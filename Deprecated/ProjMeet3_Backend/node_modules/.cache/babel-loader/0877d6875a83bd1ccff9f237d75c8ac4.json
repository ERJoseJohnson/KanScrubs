{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util = require(\"util\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst Conversation_1 = require(\"../common/models/Conversation\");\n\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\n\nconst iqEventHandler_1 = require(\"./XMPPServiceHandler/iqEventHandler\");\n\nconst packageVersion = require(\"../../package\");\n\nconst url = require('url'); // Until web proxy on websocket solved, patch existing configuration to offer the proxy options\n\n\nlet ws_options = null; // @ts-ignore\n\nlet isInTest = typeof global.it === \"function\";\nlet WS;\n\nif (isInTest) {\n  WS = require(\"mock-socket\").WebSocket;\n} else {\n  WS = require(\"ws\");\n}\n\nclass XmppWebSocket extends WS {\n  constructor(address, protocols) {\n    super(address, protocols, ws_options);\n  }\n\n} // @ts-ignore\n\n\nglobal.WebSocket = XmppWebSocket;\n\nconst Client = require(\"../common/XmppQueue/XmppClient\").XmppClient;\n\nconst xml = require(\"@xmpp/xml\");\n\nlet backoff = require(\"backoff\"); //const setTimeout = require(\"timers\").setTimeout;\n\n\nconst HttpsProxyAgent = require(\"https-proxy-agent\"); // import {URL} from \"url\";\n\n\nconst LOG_ID = \"XMPP - \";\nconst ONLINE_EVENT = \"online\";\nconst OFFLINE_EVENT = \"offline\";\nconst CONNECT_EVENT = \"connect\";\nconst RECONNECT_EVENT = \"reconnect\";\nconst RECONNECTED_EVENT = \"reconnected\";\nconst RECONNECTING_EVENT = \"reconnecting\";\nconst DISCONNECT_EVENT = \"disconnect\";\nconst CLOSE_EVENT = \"close\";\nconst END_EVENT = \"end\";\nconst ERROR_EVENT = \"error\";\nconst STANZA_EVENT = \"stanza\";\nconst STATUS_EVENT = \"status\";\nconst BIND_EVENT = \"bind\";\nconst AUTHENTICATE_EVENT = \"authenticate\";\nconst TYPE_CHAT = \"chat\";\nconst TYPE_GROUPCHAT = \"groupchat\";\nconst RECONNECT_INITIAL_DELAY = 5000;\nconst RECONNECT_MAX_DELAY = 60000;\nconst MAX_IDLE_TIMER = 70000;\nconst MAX_PING_ANSWER_TIMER = 5000;\nconst NameSpacesLabels = {\n  \"ChatstatesNS\": \"http://jabber.org/protocol/chatstates\",\n  \"ReceiptNS\": \"urn:xmpp:receipts\",\n  \"CallLogNamespace\": \"jabber:iq:telephony:call_log\",\n  \"CallLogAckNamespace\": \"urn:xmpp:telephony:call_log:receipts\",\n  \"CallLogNotificationsNamespace\": \"jabber:iq:notification:telephony:call_log\",\n  \"RsmNameSpace\": \"http://jabber.org/protocol/rsm\",\n  \"Carbon2NameSpace\": \"urn:xmpp:carbons:2\",\n  \"ApplicationNameSpace\": \"jabber:iq:application\",\n  \"RosterNameSpace\": \"jabber:iq:roster\",\n  \"ClientNameSpace\": \"jabber:client\",\n  \"PingNameSpace\": \"urn:xmpp:ping\",\n  \"DataNameSpace\": \"jabber:x:data\",\n  \"MucNameSpace\": \"http://jabber.org/protocol/muc\",\n  \"ReceiptsNameSpace\": \"urn:xmpp:receipts\",\n  \"ChatestatesNameSpace\": \"http://jabber.org/protocol/chatstates\",\n  \"ContentNameSpace\": \"urn:xmpp:content\",\n  \"MessageCorrectNameSpace\": \"urn:xmpp:message-correct:0\",\n  \"HintsNameSpace\": \"urn:xmpp:hints\",\n  \"OobNameSpace\": \"jabber:x:oob\",\n  \"Monitoring1NameSpace\": \"urn:xmpp:pbxagent:monitoring:1\",\n  \"CallService1NameSpace\": \"urn:xmpp:pbxagent:callservice:1\",\n  \"MamNameSpace\": \"urn:xmpp:mam:1\",\n  \"MamNameSpaceTmp\": \"urn:xmpp:mam:tmp\",\n  \"AttentionNS\": \"urn:xmpp:attention:0\"\n};\nexports.NameSpacesLabels = NameSpacesLabels;\nlet XMPPService = class XMPPService {\n  constructor(_xmpp, _im, _application, _eventEmitter, _logger, _proxy) {\n    this.ready = false;\n    this.serverURL = _xmpp.protocol + \"://\" + _xmpp.host + \":\" + _xmpp.port + \"/websocket\";\n    this.host = _xmpp.host;\n    this.eventEmitter = _eventEmitter;\n    this.version = \"0.1\";\n    this.jid_im = \"\";\n    this.jid_tel = \"\";\n    this.jid_password = \"\";\n    this.fullJid = \"\";\n    this.jid = \"\";\n    this.userId = \"\";\n    this.initialPresence = true;\n    this.xmppClient = null;\n    this.logger = _logger;\n    this.proxy = _proxy;\n    this.shouldSendReadReceipt = _im.sendReadReceipt;\n    this.shouldSendMessageToConnectedUser = _im.sendMessageToConnectedUser;\n    this.storeMessages = _im.storeMessages;\n    this.copyMessage = _im.copyMessage;\n    this.rateLimitPerHour = _im.rateLimitPerHour;\n    this.messagesDataStore = _im.messagesDataStore;\n    this.useXMPP = true;\n    this.timeBetweenXmppRequests = _xmpp.timeBetweenXmppRequests;\n    this.isReconnecting = false;\n    this.maxAttempts = 1;\n    this.idleTimer = null;\n    this.pingTimer = null;\n    this.forceClose = false;\n    this.applicationId = _application.appID;\n    this._startConfig = {\n      start_up: true,\n      optional: false\n    };\n    this.xmppUtils = XMPPUtils_1.XMPPUTils.getXMPPUtils();\n    this.generatedRandomId = this.xmppUtils.generateRandomID();\n    this.hash = Utils_1.makeId(8);\n\n    this.handleXMPPConnection = headers => {\n      let that = this;\n      let domain = that.xmppUtils.getDomainFromFullJID(this.fullJid);\n      let options = {\n        agent: null\n      };\n      Object.assign(options, headers);\n      let opt = url.parse(this.proxy.proxyURL);\n\n      if (this.proxy.isProxyConfigured) {\n        if (this.proxy.secureProtocol) {\n          opt.secureProxy = true;\n        } // Until web proxy on websocket solved, patch existing configuration to offer the proxy options\n\n\n        options.agent = new HttpsProxyAgent(opt); //options.agent = new HttpsProxyAgent(this.proxy.proxyURL);\n\n        ws_options = options;\n      }\n      /*\r\n      this.xmppClient = new Client({\r\n          \"jid\": this.fullJid,\r\n          \"password\": this.jid_password,\r\n          \"host\": this.host,\r\n          \"websocket\": {\r\n              \"url\": this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\r\n              \"options\": options\r\n          }\r\n      }); // */\n      //\"domain\": {enter(node) {\n      //}, exit(node){}},\n\n\n      this.xmppClient = new Client({\n        \"service\": this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\n        \"domain\": domain,\n        //   \"resource\": \"nodesdk\",\n        \"username\": this.fullJid,\n        \"password\": this.jid_password,\n        \"options\": options,\n        \"mechanism\": \"PLAIN\"\n      }); //\"domain\": domain,\n      // */\n\n      this.xmppClient.init(this.logger, this.timeBetweenXmppRequests, this.storeMessages, this.rateLimitPerHour, this.messagesDataStore); //this.reconnect = this.xmppClient.plugin(require(\"@xmpp/plugins/reconnect\"));\n\n      this.reconnect = this.xmppClient.reconnect;\n      this.reconnect.delay = RECONNECT_INITIAL_DELAY;\n      this.fibonacciStrategy = new backoff.FibonacciStrategy({\n        randomisationFactor: 0.4,\n        initialDelay: RECONNECT_INITIAL_DELAY,\n        maxDelay: RECONNECT_MAX_DELAY\n      }); //const sasl = this.xmppClient.plugins.sasl;\n\n      /*const sasl = this.xmppClient.sasl;\r\n      sasl.getMechanism = mechs => {\r\n          return \"PLAIN\"; // Force plain sasl\r\n      }; // */\n\n      this.xmppClient.setgetMechanism(mechs => {\n        return \"PLAIN\"; // Force plain sasl\n      });\n      /*\r\n      this.xmppClient.handle(AUTHENTICATE_EVENT, authenticate => {\r\n          return authenticate(this.fullJid, this.jid_password);\r\n      });\r\n        this.xmppClient.handle(BIND_EVENT, (bind) => {\r\n          return bind(that.xmppUtils.getResourceFromFullJID(this.fullJid));\r\n      }); // */\n\n      this.xmppClient.on(\"input\", packet => {\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) \", that.logger.colors.cyan(\" raw in - ⮈ stanza : \") + that.logger.colors.cyan(packet));\n        that.startOrResetIdleTimer(true);\n      });\n      this.xmppClient.on(\"output\", packet => {\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) \", that.logger.colors.yellow(\" raw out - ⮊ stanza : \") + that.logger.colors.yellow(packet));\n        that.startOrResetIdleTimer(false);\n      });\n      this.xmppClient.on(ONLINE_EVENT, msg => {\n        that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) event - ONLINE_EVENT : \" + ONLINE_EVENT + \" |\", msg);\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) connected as \", msg);\n\n        if (!that.isReconnecting) {\n          that.eventEmitter.emit(\"xmppconnected\");\n        }\n      });\n      this.xmppClient.on(STATUS_EVENT, msg => {\n        that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) event - STATUS_EVENT : \" + STATUS_EVENT + \" |\", msg);\n        /* if (msg === \"closing\") {\r\n             that.xmppClient.restartConnect().then((res) => {\r\n                 that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) restartConnect result : \", res);\r\n             }).catch((err) => {\r\n                 that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) restartConnect error : \", err);\r\n             }).then(() => {\r\n                 that.logger.log(\"debug\", LOG_ID + \"on STATUS_EVENT \");\r\n             });\r\n         } // */\n      });\n      this.xmppClient.on(STANZA_EVENT, stanza => {\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : \" + STANZA_EVENT + \" |\", stanza.toString());\n        let eventId = that.hash + \".\" + stanza.getNS() + \".\" + stanza.getName() + (stanza.attrs.type ? \".\" + stanza.attrs.type : \"\");\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : eventId \", eventId);\n        let delivered = PubSub.publish(eventId, stanza);\n        stanza.children.forEach(child => {\n          delivered |= PubSub.publish(that.hash + \".\" + child.getNS() + \".\" + child.getName() + (child.attrs.type ? \".\" + child.attrs.type : \"\"), stanza);\n        });\n\n        if (!delivered) {\n          that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : \" + STANZA_EVENT + \" not managed |\", stanza.getNS() + \".\" + stanza.getName() + (stanza.attrs.type ? \".\" + stanza.attrs.type : \"\"));\n        }\n\n        switch (stanza.getName()) {\n          case \"iq\":\n            // let children = stanza.children;\n            // children.forEach((node) => {\n            //     switch (node.getName()) {\n            //         case \"ping\":\n            //             let stanzaResponse = xml(\"iq\", {\n            //                 \"to\": stanza.attrs.from,\n            //                 \"id\": stanza.attrs.id,\n            //                 \"xmlns\": stanza.getNS(),\n            //                 \"type\": \"result\"\n            //             });\n            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - 'stanza'\", stanzaResponse.toString());\n            //             that.xmppClient.send(stanzaResponse);\n            //             break;\n            //         case \"query\":\n            //             if (stanza.attrs.type === \"result\" || stanza.attrs.type === \"set\") {\n            //                 if (node.attrs.xmlns === NameSpacesLabels.RosterNameSpace) {\n            //                     let contacts = [];\n            //                     let subchildren = node.children;\n            //                     subchildren.forEach(function(item) {\n            //                         if (item.attrs.jid.substr(0, 3) !== \"tel\") {\n            //                             contacts.push({\n            //                                 jid: item.attrs.jid,\n            //                                 subscription: item.attrs.subscription,\n            //                                 ask: item.attrs.ask || \"\"\n            //                             });\n            //                         }\n            //                     });\n            //                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) XMPP Rosters received\", contacts.length);\n            //                     that.eventEmitter.emit(\"evt_internal_onrosters\", contacts);\n            //                 }\n            //             }\n            //             break;\n            //         case \"default\":\n            //             that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) not managed - 'stanza'\", node.getName());\n            //             break;\n            //         default:\n            //             that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) child not managed for iq - 'stanza'\", node.getName());\n            //             break;\n            //     }\n            // });\n            // if (stanza.attrs.type && stanza.attrs.type === \"result\") {\n            //     if (stanza.attrs.id === \"enable_xmpp_carbon\") {\n            //         that.eventEmitter.emit(\"rainbow_oncarbonactivated\");\n            //     }\n            // }\n            break;\n\n          case \"message\":\n            let content = \"\";\n            let lang = \"\";\n            let alternativeContent = [];\n            let subject = \"\";\n            let event = \"\";\n            let eventJid = \"\";\n            let hasATextMessage = false;\n            let oob = null;\n            let messageType = stanza.attrs.type;\n\n            if (messageType === TYPE_CHAT || messageType === TYPE_GROUPCHAT) {// let fromJid = that.xmppUtils.getBareJIDFromFullJID(stanza.attrs.from);\n              // let resource = that.xmppUtils.getResourceFromFullJID(stanza.attrs.from);\n              // let toJid = stanza.attrs.to;\n              // let id = stanza.attrs.id;\n              // let children = stanza.children;\n              // children.forEach((node) => {\n              //     switch (node.getName()) {\n              //         case \"sent\":\n              //             if (node.attrs.xmlns === NameSpacesLabels.Carbon2NameSpace) {\n              //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' received\");\n              //                 let forwarded = node.children[0];\n              //                 if (forwarded && forwarded.getName() === \"forwarded\") {\n              //                     let message = forwarded.children[0];\n              //                     if (message && message.getName() === \"message\") {\n              //                         fromJid = that.xmppUtils.getBareJIDFromFullJID(message.attrs.from);\n              //                         resource = that.xmppUtils.getResourceFromFullJID(message.attrs.from);\n              //                         toJid = message.attrs.to;\n              //                         id = message.attrs.id;\n              //                         let childs = message.children;\n              //                         if (childs) {\n              //                             childs.forEach((nodeChild) => {\n              //                                 if (nodeChild.getName() === \"body\") {\n              //                                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' of type chat received \");\n              //                                     let data = {\n              //                                         \"fromJid\": fromJid,\n              //                                         \"resource\": resource,\n              //                                         \"toJid\": toJid,\n              //                                         \"type\": messageType,\n              //                                         \"content\": nodeChild.getText(),\n              //                                         \"id\": id,\n              //                                         \"lang\": nodeChild.attrs[\"xml:lang\"],\n              //                                         \"cc\": true,\n              //                                         \"cctype\": \"sent\",\n              //                                         \"isEvent\": false\n              //                                     };\n              //                                     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\n              //                                 }\n              //                             });\n              //                         }\n              //                     }\n              //                 }\n              //             }\n              //             break;\n              //         case \"received\":\n              //             if (node.attrs.xmlns === NameSpacesLabels.Carbon2NameSpace) {\n              //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' received\");\n              //                 let forwarded = node.children[0];\n              //                 if (forwarded && forwarded.getName() === \"forwarded\") {\n              //                     let message = forwarded.children[0];\n              //                     if (message && message.getName() === \"message\") {\n              //                         fromJid = that.xmppUtils.getBareJIDFromFullJID(message.attrs.from);\n              //                         resource = that.xmppUtils.getResourceFromFullJID(message.attrs.from);\n              //                         toJid = message.attrs.to;\n              //                         id = message.attrs.id;\n              //                         let childs = message.children;\n              //                         if (childs) {\n              //                             childs.forEach(function (nodeChild) {\n              //                                 if (nodeChild.getName() === \"body\") {\n              //                                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' of type chat received \");\n              //                                     let data = {\n              //                                         \"fromJid\": fromJid,\n              //                                         \"resource\": resource,\n              //                                         \"toJid\": toJid,\n              //                                         \"type\": messageType,\n              //                                         \"content\": nodeChild.getText(),\n              //                                         \"id\": id,\n              //                                         \"lang\": nodeChild.attrs[\"xml:lang\"],\n              //                                         \"cc\": true,\n              //                                         \"cctype\": \"sent\",\n              //                                         \"isEvent\": false\n              //                                     };\n              //                                     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\n              //                                 }\n              //                             });\n              //                         }\n              //                     }\n              //                 }\n              //             }\n              //             else {\n              //                 let receipt = {\n              //                     event: node.attrs.event,\n              //                     entity: node.attrs.entity,\n              //                     type: messageType,\n              //                     id: node.attrs.id,\n              //                     fromJid: fromJid,\n              //                     resource: resource\n              //                 };\n              //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - receipt received\");\n              //                 that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\n              //             }\n              //             break;\n              //         case \"active\":\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is active\");\n              //             break;\n              //         case \"inactive\":\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is inactive\");\n              //             break;\n              //         case \"composing\":\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is writing\");\n              //             break;\n              //         case \"archived\":\n              //             break;\n              //         case \"stanza-id\":\n              //             break;\n              //         case \"subject\":\n              //             subject = node.getText();\n              //             break;\n              //         case \"event\":\n              //             event = node.attrs.name;\n              //             eventJid = node.attrs.jid;\n              //             break;\n              //         case \"body\":\n              //             content = node.getText();\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - content\", \"***\");\n              //             if (node.attrs[\"xml:lang\"]) { // in <body>\n              //                 lang = node.attrs[\"xml:lang\"];\n              //             } else if (node.parent.attrs[\"xml:lang\"]) { // in <message>\n              //                 lang = node.parent.attrs[\"xml:lang\"];\n              //             } else {\n              //                 lang = \"en\";\n              //             }\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - lang\", lang);\n              //             hasATextMessage = true;\n              //             break;\n              //         case \"content\":\n              //             alternativeContent.push( {\n              //                 \"message\": node.getText(),\n              //                 \"type\": node.getAttr(\"type\")\n              //             });\n              //             break;\n              //         case \"request\":\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - asked for receipt\");\n              //             // Acknowledge 'received'\n              //             let stanzaReceived = xml(\"message\", {\n              //                 \"to\": fromJid,\n              //                 \"from\": toJid,\n              //                 \"type\": messageType\n              //             }, xml(\"received\", {\n              //                 \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\n              //                 \"event\": \"received\",\n              //                 \"entity\": \"client\",\n              //                 \"id\": stanza.attrs.id\n              //                 })\n              //             );\n              //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - send receipt 'received'\", stanzaReceived.root().toString());\n              //             that.xmppClient.send(stanzaReceived);\n              //             //Acknowledge 'read'\n              //             if (that.shouldSendReadReceipt || (messageType === TYPE_GROUPCHAT && that.xmppUtils.getResourceFromFullJID(stanza.attrs.from) === that.fullJid)) {\n              //                 let stanzaRead = xml(\"message\", {\n              //                     \"to\": fromJid,\n              //                     \"from\": toJid,\n              //                     \"type\": messageType\n              //                 }, xml(\"received\", {\n              //                         \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\n              //                         \"event\": \"read\",\n              //                         \"entity\": \"client\",\n              //                         \"id\": stanza.attrs.id\n              //                     })\n              //                 );\n              //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - send receipt 'read'\", stanzaRead.root().toString());\n              //                 that.xmppClient.send(stanzaRead);\n              //             }\n              //             break;\n              //         case \"x\":\n              //             {\n              //                 let xmlns = node.attrs.xmlns;\n              //                 switch ( xmlns) {\n              //                    case \"jabber:x:conference\": {\n              //                         let invitation = {\n              //                             event: \"invitation\",\n              //                             bubbleId: node.attrs.thread,\n              //                             bubbleJid: node.attrs.jid,\n              //                             fromJid: fromJid,\n              //                             resource: resource\n              //                         };\n              //                         that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) invitation received\");\n              //                         that.eventEmitter.emit(\"evt_internal_invitationreceived\", invitation);\n              //                     }\n              //                     break;\n              //                     case NameSpacesLabels.OobNameSpace : {\n              //                         oob = {\n              //                             url: node.getChild(\"url\").getText(),\n              //                             mime: node.getChild(\"mime\").getText(),\n              //                             filename: node.getChild(\"filename\").getText(),\n              //                             filesize: node.getChild(\"size\").getText()\n              //                         };\n              //                         that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) oob received\");\n              //                         break;\n              //                     }\n              //                     default:\n              //                         break;\n              //                 }\n              //                 break;\n              //             }\n              //         default:\n              //             break;\n              //     }\n              // });\n              // let fromBubbleJid = \"\";\n              // let fromBubbleUserJid = \"\";\n              // if (stanza.attrs.type === TYPE_GROUPCHAT) {\n              //     fromBubbleJid = that.xmppUtils.getBareJIDFromFullJID(stanza.attrs.from);\n              //     fromBubbleUserJid = that.xmppUtils.getResourceFromFullJID(stanza.attrs.from);\n              //     resource = that.xmppUtils.getResourceFromFullJID(fromBubbleUserJid);\n              // }\n              // if (hasATextMessage && ((messageType === TYPE_GROUPCHAT && fromBubbleUserJid !== that.fullJid) || (messageType === TYPE_CHAT && fromJid !== that.fullJid))) {\n              //     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - chat message received\");\n              //     let data = {\n              //         \"fromJid\": fromJid,\n              //         \"resource\": resource,\n              //         \"toJid\": toJid,\n              //         \"type\": messageType,\n              //         \"content\": content,\n              //         \"alternativeContent\": alternativeContent,\n              //         \"id\": stanza.attrs.id,\n              //         \"lang\": lang,\n              //         \"cc\": false,\n              //         \"cctype\": \"\",\n              //         \"isEvent\": false,\n              //         \"oob\": oob\n              //     };\n              //     if (stanza.attrs.type === TYPE_GROUPCHAT) {\n              //         data.fromBubbleJid = fromBubbleJid;\n              //         data.fromBubbleUserJid = fromBubbleUserJid;\n              //         data.fromJid = that.xmppUtils.getRoomJIDFromFullJID(stanza.attrs.from);\n              //         if(event) {\n              //             data.event = event;\n              //             data.eventJid = eventJid;\n              //             data.isEvent = true;\n              //         }\n              //     }\n              //     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\n              // }\n            } else if (stanza.attrs.type === \"management\") {// let children = stanza.children;\n              // children.forEach(function (node) {\n              //     switch (node.getName()) {\n              //         case \"room\":\n              //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n              //                 // Affiliation changed (my own or for a member)\n              //                 if (node.attrs.status) {\n              //                     if (node.attrs.userjid === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\n              //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble management received for own.\");\n              //                         that.eventEmitter.emit(\"evt_internal_ownaffiliationchanged\", {\n              //                             \"bubbleId\": node.attrs.roomid,\n              //                             \"bubbleJid\": node.attrs.roomjid,\n              //                             \"userJid\": node.attrs.userjid,\n              //                             \"status\": node.attrs.status,\n              //                         });\n              //                     } else {\n              //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble affiliation received\");\n              //                         that.eventEmitter.emit(\"evt_internal_affiliationchanged\", {\n              //                             \"bubbleId\": node.attrs.roomid,\n              //                             \"bubbleJid\": node.attrs.roomjid,\n              //                             \"userJid\": node.attrs.userjid,\n              //                             \"status\": node.attrs.status,\n              //                         });\n              //                     }\n              //                 }\n              //                 // Custom data changed\n              //                 else if (node.attrs.customData) {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble custom-data changed\");\n              //                     that.eventEmitter.emit(\"evt_internal_customdatachanged\", {\n              //                         \"bubbleId\": node.attrs.roomid,\n              //                         \"bubbleJid\": node.attrs.roomjid,\n              //                         \"customData\": node.attrs.customData\n              //                     });\n              //                 }\n              //                 // Topic changed\n              //                 else if (node.attrs.topic) {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble topic changed\");\n              //                     that.eventEmitter.emit(\"evt_internal_topicchanged\", {\n              //                         \"bubbleId\": node.attrs.roomid,\n              //                         \"bubbleJid\": node.attrs.roomjid,\n              //                         \"topic\": node.attrs.topic\n              //                     });\n              //                 }\n              //                 // Name changed\n              //                 else if (node.attrs.name) {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble name changed\");\n              //                     that.eventEmitter.emit(\"evt_internal_namechanged\", {\n              //                         \"bubbleId\": node.attrs.roomid,\n              //                         \"bubbleJid\": node.attrs.roomjid,\n              //                         \"name\": node.attrs.name\n              //                     });\n              //                 }\n              //             }\n              //             break;\n              //         case \"usersettings\":\n              //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n              //                 switch (node.attrs.action) {\n              //                     case \"update\":\n              //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) usersettings updated\");\n              //                         that.eventEmitter.emit(\"evt_internal_usersettingschanged\");\n              //                         break;\n              //                     default:\n              //                         break;\n              //                 }\n              //             }\n              //             break;\n              //         case \"userinvite\":\n              //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n              //                 switch (node.attrs.action) {\n              //                     case \"create\":\n              //                         if (node.attrs.type === \"received\" && node.attrs.status === \"pending\") {\n              //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite received\");\n              //                             that.eventEmitter.emit(\"evt_internal_userinvitereceived\", {\n              //                                 invitationId: node.attrs.id\n              //                             });\n              //                         }\n              //                     case \"update\":\n              //                         if( node.attrs.type === \"sent\" && node.attrs.status === \"canceled\" ) {\n              //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite canceled\");\n              //                             that.eventEmitter.emit(\"evt_internal_userinvitecanceled\", {\n              //                                 invitationId: node.attrs.id\n              //                             });\n              //                         } else if( node.attrs.type === \"sent\" && node.attrs.status === \"accepted\" ) {\n              //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite accepted\");\n              //                             that.eventEmitter.emit(\"evt_internal_userinviteaccepted\", {\n              //                                 invitationId: node.attrs.id\n              //                             });\n              //                         }\n              //                         break;\n              //                     default:\n              //                         break;\n              //                 }\n              //             }\n              //         case \"group\":\n              //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n              //                 let action = node.attrs.action;\n              //                 let scope = node.attrs.scope;\n              //                 if (action === \"create\" && scope === \"group\") {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group created\");\n              //                     that.eventEmitter.emit(\"evt_internal_groupcreated\", {\n              //                         \"groupId\": node.attrs.id\n              //                     });\n              //                 } else if (action === \"create\" && scope === \"user\" && node.attrs.userId) {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user added in group\");\n              //                     that.eventEmitter.emit(\"evt_internal_useraddedingroup\", {\n              //                         \"groupId\": node.attrs.id,\n              //                         \"userId\": node.attrs.userId\n              //                     });\n              //                 } else if (action === \"delete\" && scope === \"group\") {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group deleted\");\n              //                     that.eventEmitter.emit(\"evt_internal_groupdeleted\", {\n              //                         \"groupId\": node.attrs.id\n              //                     });\n              //                 } else if (action === \"delete\" && scope === \"user\" && node.attrs.userId) {\n              //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user removed from group\");\n              //                     that.eventEmitter.emit(\"evt_internal_userremovedfromgroup\", {\n              //                         \"groupId\": node.attrs.id,\n              //                         \"userId\": node.attrs.userId\n              //                     });\n              //                 } else if (action === \"update\" && scope === \"group\") {\n              //                     if (node.attrs.name || node.attrs.comment || node.attrs.isFavorite) {\n              //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group updated\");\n              //                         that.eventEmitter.emit(\"evt_internal_groupupdated\", {\n              //                             \"groupId\": node.attrs.id\n              //                         });\n              //                     }\n              //                 }\n              //             }\n              //             break;\n              //         default:\n              //             break;\n              //     }\n              // });\n            } else if (stanza.attrs.type === \"error\") {//that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) something goes wrong...\");\n            } else if (stanza.attrs.type === \"headline\") {// that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) channel message received\");\n              // let eventNode = stanza.children[0];\n              // let items = eventNode.children[0];\n              // let item = items.children[0];\n              // let entry = item.children[0];\n              // let message = {\n              //     \"messageId\": item.attrs.id,\n              //     \"channelId\": entry.attrs.channelId,\n              //     \"fromJid\": entry.attrs.from,\n              //     \"message\": entry.getChild(\"message\").getText() || \"\",\n              //     \"title\": entry.getChild(\"title\").getText() ||  \"\",\n              //     \"url\": entry.getChild(\"url\").getText() ||  \"\",\n              //     \"date\": new Date(entry.attrs.timestamp)\n              // };\n              // that.eventEmitter.emit(\"rainbow_onchannelmessagereceived\", message);\n            } else {\n              let children = stanza.children;\n              children.forEach(function (node) {\n                switch (node.getName()) {\n                  case \"received\":\n                    let receipt = {\n                      event: node.attrs.event,\n                      entity: node.attrs.entity,\n                      type: null,\n                      id: node.attrs.id\n                    }; //that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) server receipt received\");\n\n                    that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\n                    break;\n\n                  default:\n                    break;\n                }\n              });\n            }\n\n            break;\n\n          case \"presence\":\n            // let from = stanza.attrs.from;\n            // if (from === that.fullJid || that.xmppUtils.getBareJIDFromFullJID(from) === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\n            //     // My presence changes (coming from me or another resource)\n            //     that\n            //         .eventEmitter\n            //         .emit(\"evt_internal_presencechanged\", {\n            //             fulljid: from,\n            //             jid: that.xmppUtils.getBareJIDFromFullJID(from),\n            //             resource: that.xmppUtils.getResourceFromFullJID(from),\n            //             show: stanza.attrs.show || \"online\",\n            //             status: stanza.attrs.status || \"\",\n            //             type: that.xmppUtils.isFromTelJid(from)\n            //                 ? \"phone\"\n            //                 : that.xmppUtils.isFromMobile(from)\n            //                     ? \"mobile\"\n            //                     : that.xmppUtils.isFromNode(from)\n            //                         ? \"node\"\n            //                         : \"desktopOrWeb\"\n            //         });\n            // } else if (from.includes(\"room_\")) {\n            //     let children = stanza.children;\n            //     children.forEach(function (node) {\n            //         switch (node.getName()) {\n            //             case \"x\":\n            //                 let items = node.children;\n            //                 items.forEach(function (item) {\n            //                     switch (item.getName()) {\n            //                         case \"item\":\n            //                             break;\n            //                         case \"status\":\n            //                             break;\n            //                         default:\n            //                             break;\n            //                     }\n            //                 });\n            //                 break;\n            //             default:\n            //                 break;\n            //         }\n            //     });\n            //     // A presence in a room changes\n            //     let fullJid = that.xmppUtils.getResourceFromFullJID(from);\n            //     if (that.xmppUtils.getBareJIDFromFullJID(fullJid) === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\n            //         // My presence (node or other resources) in the room changes\n            //         that\n            //             .eventEmitter\n            //             .emit(\"evt_internal_bubblepresencechanged\", {\n            //                 fulljid: from,\n            //                 jid: that.xmppUtils.getBareJIDFromFullJID(from),\n            //                 resource: that.xmppUtils.getResourceFromFullJID(from)\n            //             });\n            //     } else {\n            //         // Presence of a participants of the room changes\n            //         that\n            //             .eventEmitter\n            //             .emit(\"rainbow_onbubblerosterpresencechanged\", {\n            //                 fulljid: from,\n            //                 jid: that.xmppUtils.getBareJIDFromFullJID(from),\n            //                 resource: that.xmppUtils.getResourceFromFullJID(from)\n            //             });\n            //     }\n            // } else {\n            //     // Presence of a contact changes\n            //     let priority = 5;\n            //     let show = \"\";\n            //     let delay = \"\";\n            //     let status = \"\";\n            //     if (stanza.attrs.type === \"unavailable\") {\n            //         show = \"unavailable\";\n            //     } else {\n            //         let children = stanza.children;\n            //         children.forEach(function (node) {\n            //             if (node && typeof node !== \"string\") {\n            //                 switch (node.getName()) {\n            //                     case \"priority\":\n            //                         priority = node.getText() || 5;\n            //                         break;\n            //                     case \"show\":\n            //                         show = node.getText() || \"online\";\n            //                         break;\n            //                     case \"delay\":\n            //                         delay = node.attrs.stamp || \"\";\n            //                         break;\n            //                     case \"status\":\n            //                         status = node.getText() || \"\";\n            //                         break;\n            //                     default:\n            //                         break;\n            //                 }\n            //             }\n            //         });\n            //     }\n            //     that.eventEmitter.emit(\"evt_internal_onrosterpresence\", {\n            //         fulljid: from,\n            //         jid: that.xmppUtils.getBareJIDFromFullJID(from),\n            //         resource: that.xmppUtils.getResourceFromFullJID(from),\n            //         value: {\n            //             priority: priority,\n            //             show: show || \"\",\n            //             delay: delay,\n            //             status: status || \"\",\n            //             type: that.xmppUtils.isFromTelJid(from) ? \"phone\" : that.xmppUtils.isFromMobile(from) ? \"mobile\" : that.xmppUtils.isFromNode(from) ? \"node\" : \"desktopOrWeb\"\n            //         }\n            //     });\n            // }\n            break;\n\n          case \"close\":\n            break;\n\n          default:\n            that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) not managed - 'stanza'\", stanza.getName());\n            break;\n        }\n      });\n      this.xmppClient.on(ERROR_EVENT, err => __awaiter(this, void 0, void 0, function* () {\n        if (err.code === \"HPE_INVALID_CONSTANT\") {\n          return;\n        }\n\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : \" + ERROR_EVENT + \" |\", util.inspect(err.condition || err));\n        that.stopIdleTimer();\n\n        if (that.reconnect && err) {\n          // Condition treatments for XEP Errors : https://xmpp.org/rfcs/rfc6120.html#streams-error\n          switch (err.condition) {\n            // Conditions which need a reconnection\n            case \"remote-connection-failed\":\n            case \"reset\":\n            case \"resource-constraint\":\n            case \"connection-timeout\":\n            case \"system-shutdown\":\n              let waitime = 21 + Math.floor(Math.random() * Math.floor(15));\n              that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT :  wait \", waitime, \" seconds before try to reconnect\");\n              yield Utils_1.setTimeoutPromised(waitime);\n\n              if (!that.isReconnecting) {\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : try to reconnect...\");\n                yield that.reconnect.reconnect();\n              } else {\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : Do nothing, already trying to reconnect...\");\n              }\n\n              break;\n            // Conditions which need to only raise an event to inform up layer.\n\n            case \"bad-format\":\n            case \"bad-namespace-prefix\":\n            case \"host-gone\":\n            case \"host-unknown\":\n            case \"improper-addressing\":\n            case \"internal-server-error\":\n            case \"invalid-from\":\n            case \"invalid-namespace\":\n            case \"invalid-xml\":\n            case \"not-authorized\":\n            case \"not-well-formed\":\n            case \"policy-violation\":\n            case \"restricted-xml\":\n            case \"undefined-condition\":\n            case \"unsupported-encoding\":\n            case \"unsupported-feature\":\n            case \"unsupported-stanza-type\":\n              that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : for condition : \", err.condition, \", error : \", err);\n              that.eventEmitter.emit(\"evt_internal_xmpperror\", err);\n              break;\n            // Conditions which are fatal errors and then need to stop the SDK.\n\n            case \"see-other-host\":\n              that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : condition : \", err.condition, \" is not supported the SDK\");\n\n            case \"conflict\":\n            case \"unsupported-version\":\n            default:\n              that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : no reconnection for condition : \", err.condition);\n              that.eventEmitter.emit(\"evt_internal_xmppfatalerror\", err);\n              break;\n          }\n        } else {\n          that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : reconnection disabled so no reconnect\");\n        }\n      }));\n      this.xmppClient.on(OFFLINE_EVENT, msg => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - OFFLINE_EVENT : \" + OFFLINE_EVENT + \" |\" + msg);\n      });\n      this.xmppClient.on(CONNECT_EVENT, () => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - CONNECT_EVENT : \" + CONNECT_EVENT);\n      });\n      this.xmppClient.on(RECONNECT_EVENT, msg => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - RECONNECT_EVENT : \" + RECONNECT_EVENT + \" |\" + msg);\n      });\n      this.xmppClient.on(DISCONNECT_EVENT, () => __awaiter(this, void 0, void 0, function* () {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : \" + DISCONNECT_EVENT + \" |\", {\n          'reconnect': that.reconnect\n        });\n        that.eventEmitter.emit(\"rainbow_xmppdisconnect\", {\n          'reconnect': that.reconnect\n        });\n        let waitime = 11 + Math.floor(Math.random() * Math.floor(15));\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : wait \" + waitime + \" seconds before try to reconnect\");\n        yield Utils_1.setTimeoutPromised(waitime);\n\n        if (that.reconnect) {\n          if (!that.isReconnecting) {\n            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : try to reconnect...\");\n            yield that.reconnect.reconnect();\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection)  event - DISCONNECT_EVENT : Do nothing, already trying to reconnect...\");\n          }\n        } else {\n          that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : reconnection disabled so no reconnect\");\n        }\n      }));\n      this.xmppClient.on(CLOSE_EVENT, msg => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - CLOSE_EVENT : \" + CLOSE_EVENT + \" |\" + msg);\n      });\n      this.xmppClient.on(END_EVENT, msg => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - END_EVENT : \" + END_EVENT + \" |\" + msg);\n      });\n      this.reconnect.on(RECONNECTING_EVENT, () => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) plugin event - RECONNECTING_EVENT : \" + RECONNECTING_EVENT);\n\n        if (that.reconnect) {\n          that.logger.log(\"debug\", `${LOG_ID} (handleXMPPConnection) RECONNECTING_EVENT that.reconnect - `, that.reconnect);\n\n          if (!that.isReconnecting) {\n            that.reconnect.delay = that.fibonacciStrategy.next();\n            that.logger.log(\"debug\", `${LOG_ID} (handleXMPPConnection) RECONNECTING_EVENT update reconnect delay - ${that.reconnect.delay} ms`);\n            that.eventEmitter.emit(\"rainbow_xmppreconnectingattempt\");\n            this.isReconnecting = true;\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection)  event - RECONNECTING_EVENT : Do nothing, already trying to reconnect...\");\n          }\n        } else {\n          that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - RECONNECTING_EVENT : reconnection disabled so no reconnect\");\n          this.isReconnecting = false;\n        }\n      });\n      this.reconnect.on(RECONNECTED_EVENT, () => {\n        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) plugin event - RECONNECTED_EVENT : \" + RECONNECTED_EVENT);\n        that.fibonacciStrategy.reset();\n        that.reconnect.delay = that.fibonacciStrategy.getInitialDelay();\n        that.isReconnecting = false;\n        that.initialPresence = true;\n        that.eventEmitter.emit(\"rainbow_xmppreconnected\");\n      });\n      this.xmppClient.start({\n        uri: this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\n        domain: domain\n      }).then(jid => {\n        /* <iq type='get'\r\n            from='romeo@montague.net/orchard'\r\n            to='plays.shakespeare.lit'\r\n            id='info1'>\r\n                <query xmlns='http://jabber.org/protocol/disco#info'/>\r\n                </iq> // */\n\n        /*\r\n        // Iq to discover the services provided by rainbow xmpp server\r\n        let stanza = xml(\"iq\", {\r\n            //to: that.jid_im + \"/\" + that.fullJid,\r\n            \"type\": \"get\",\r\n            \"to\": domain,\r\n            \"id\": that.xmppUtils.getUniqueMessageId()\r\n        }, xml(\"query\", {\"xmlns\": \"http://jabber.org/protocol/disco#info\"}));\r\n          that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) send IQ discover : \", stanza.root().toString());\r\n        return that.xmppClient.send(stanza);\r\n        // */\n        //                if (that.messagesDataStore === DataStoreType.NoStoreBotSide) {\n\n        /*<iq type='set' id='juliet2'>\r\n        <prefs xmlns='urn:xmpp:mam:tmp' default='roster'>\r\n            <always>\r\n                <jid>romeo@montague.lit</jid>\r\n        </always>\r\n        <never>\r\n        <jid>montague@montague.lit</jid>\r\n        </never>\r\n        </prefs>\r\n        </iq> // */\n        // Iq to discover the services provided by rainbow xmpp server\n        //                     let stanzaPrefs = xml(\"iq\", {\n        //                             //to: that.jid_im + \"/\" + that.fullJid,\n        //                             \"id\": that.xmppUtils.getUniqueMessageId(),\n        //                             \"type\": \"set\"\n        //                         },\n        //                         xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace , \"default\": 'always' },\n        //                         //xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace, \"default\": 'always'},\n        //                             /* xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace, \"default\": 'always'},\n        //                               xml(\"never\", {},\n        //                                xml(\"jid\", {}, that.jid_im)\n        //                                )\n        //                                )\n        //                                //*/\n        //\n        //                               xml(\"auto\", {\"save\" : false}, undefined)\n        //                             , undefined)\n        //                             // */\n        // /*\n        //                             undefined\n        //                         )\n        //                         , undefined\n        //                         // */\n        //                     );\n        //                    that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) send IQ prefs : \", stanzaPrefs.root().toString());\n        //                    return that.xmppClient.send(stanzaPrefs);\n        //                }\n        // */\n      }) // */\n\n      /*\r\n      this.xmppClient.start().then((jid) => {\r\n          that.logger.log(\"info\", \"started\", jid.toString());\r\n      })// */\n      .catch(err => {\n        // rejects for any error before online\n        if (err.code === \"HPE_INVALID_CONSTANT\") {\n          that.logger.log(\"error\", LOG_ID + \"start reconnect \", err);\n          that.reconnect.reconnect();\n          return;\n        }\n\n        that.logger.log(\"error\", LOG_ID + \"start failed\", err);\n      });\n    };\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(withXMPP) {\n    let that = this;\n    this.forceClose = false;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (withXMPP) {\n          that.logger.log(\"debug\", LOG_ID + \"(start) host used : \", that.host);\n          that.logger.log(\"info\", LOG_ID + \"(start) XMPP URL : \", that.serverUR);\n        } else {\n          that.logger.log(\"info\", LOG_ID + \"(start) XMPP connection blocked by configuration\");\n        }\n\n        that.isReconnecting = false;\n        that.useXMPP = withXMPP;\n        that.ready = that.useXMPP; // Put not ready state when the XMPP is disabled in SDK config options, then methods become unavailable with @isStarted decorator.\n\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  signin(account, headers) {\n    let that = this;\n    return new Promise(function (resolve) {\n      that.IQEventHandlerToken = [];\n      that.eventEmitter.once(\"xmppconnected\", function fn_xmppconnected() {\n        that.eventEmitter.removeListener(\"xmppconnected\", fn_xmppconnected);\n        resolve();\n      });\n\n      if (that.useXMPP) {\n        that.jid_im = account.jid_im;\n        that.jid_tel = account.jid_tel;\n        that.jid_password = account.jid_password;\n        that.userId = account.id;\n        that.fullJid = that.xmppUtils.generateRandomFullJidForNode(that.jid_im, that.generatedRandomId);\n        that.jid = account.jid_im;\n        that.logger.log(\"internal\", LOG_ID + \"(signin) account used, jid_im : \", that.jid_im, \", fullJid : \", that.fullJid);\n        that.IQEventHandler = new iqEventHandler_1.IQEventHandler(that);\n        that.IQEventHandlerToken = [PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_GET, that.IQEventHandler.onIqGetReceived), PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_SET, that.IQEventHandler.onIqGetReceived), PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_RESULT, that.IQEventHandler.onIqResultReceived)];\n        that.handleXMPPConnection(headers);\n        that.IQEventHandlerToken.push(PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_RESULT, that.xmppClient.onIqResultReceived));\n        that.IQEventHandlerToken.push(PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_ERROR, that.xmppClient.onIqErrorReceived));\n        that.startOrResetIdleTimer(); //resolve();\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  stop(forceStop) {\n    let that = this;\n    return new Promise(function (resolve) {\n      try {\n        that.jid_im = \"\";\n        that.jid_tel = \"\";\n        that.jid_password = \"\";\n        that.fullJid = \"\";\n        that.userId = \"\";\n        that.initialPresence = true;\n\n        if (that.useXMPP && forceStop) {\n          that.stopIdleTimer();\n          delete that.IQEventHandler;\n          that.IQEventHandler = null;\n\n          if (that.IQEventHandlerToken) {\n            that.IQEventHandlerToken.forEach(token => PubSub.unsubscribe(token));\n          }\n\n          that.IQEventHandlerToken = [];\n          that.forceClose = true; // Disconnect the auto-reconnect mode\n\n          if (that.reconnect) {\n            that.logger.log(\"debug\", LOG_ID + \"(stop) stop XMPP auto-reconnect mode\");\n            that.reconnect.stop();\n            that.reconnect = null;\n          } // Disconnect the xmpp connection\n\n\n          if (that.xmppClient) {\n            let stanza = xml(\"presence\", {\n              //to: that.jid_im + \"/\" + that.fullJid,\n              type: \"unavailable\"\n            }, xml(\"x\", {\n              \"xmlns\": NameSpacesLabels.MucNameSpace\n            }));\n            stanza.append(xml(\"show\", {}, \"away\"));\n            stanza.append(xml(\"status\", {}, \"away\"));\n            that.logger.log(\"internal\", LOG_ID + \"(stop) send Unavailable Presence- send - 'message'\", stanza.root().toString());\n            that.xmppClient.send(stanza);\n            that.xmppClient.stop().then(() => {\n              that.logger.log(\"debug\", LOG_ID + \"(stop) stop XMPP connection\");\n              that.xmppClient = null;\n              resolve();\n            }).catch(err => {\n              that.logger.log(\"debug\", LOG_ID + \"(stop) error received\");\n              that.logger.log(\"internalerror\", LOG_ID + \"(stop) error received : \", err);\n              resolve();\n            });\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(stop) nothing to stop\");\n            resolve();\n          }\n        } else {\n          that.logger.log(\"debug\", LOG_ID + \"(stop) nothing to stop\");\n          resolve();\n        }\n      } catch (err) {\n        that.logger.log(\"debug\", LOG_ID + \"(stop) error received\");\n        that.logger.log(\"internalerror\", LOG_ID + \"(stop) error received : \", err);\n        resolve();\n      }\n    });\n  }\n\n  startOrResetIdleTimer(incomingStanza = false) {\n    if (this.pingTimer && !incomingStanza || this.reconnect && this.reconnect.isReconnecting) {\n      return;\n    }\n\n    this.stopIdleTimer();\n\n    if (!this.forceClose) {\n      this.idleTimer = setTimeout(() => {\n        this.logger.log(\"warn\", LOG_ID + \"(startOrResetIdleTimer) No message received since \" + MAX_IDLE_TIMER / 1000 + \" seconds.\"); // Start waiting an answer from server else reset the connection\n\n        this.pingTimer = setTimeout(() => {\n          this.pingTimer = null;\n          this.xmppClient.socket && this.xmppClient.socket.end();\n        }, MAX_PING_ANSWER_TIMER);\n        this.sendPing();\n      }, MAX_IDLE_TIMER);\n    }\n  }\n\n  stopIdleTimer() {\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n      this.idleTimer = null;\n    }\n\n    if (this.pingTimer) {\n      clearTimeout(this.pingTimer);\n      this.pingTimer = null;\n    }\n  }\n\n  setPresence(show, status) {\n    let that = this;\n\n    if (this.useXMPP) {\n      let stanza = xml(\"presence\", {\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      });\n\n      if (this.initialPresence) {\n        this.initialPresence = false;\n        stanza.append(xml(\"application\", {\n          xmlns: NameSpacesLabels.ApplicationNameSpace\n        }, xml(\"appid\", {}, this.applicationId), xml(\"userid\", {}, this.userId)));\n      }\n\n      stanza.append(xml(\"priority\", {}, \"5\"));\n\n      if (show && show !== \"online\") {\n        stanza.append(xml(\"show\", {}, show));\n      }\n\n      if (status && (!show || show === \"online\")) {\n        stanza.append(xml(\"status\", {}, status));\n      } else if (status) {\n        stanza.append(xml(\"status\", {}, status));\n      }\n\n      this.logger.log(\"info\", LOG_ID + \"(setPresence) send - 'stanza'\");\n      this.logger.log(\"internal\", LOG_ID + \"(setPresence) send - 'stanza'\", stanza.toString());\n      return this.xmppClient.send(stanza);\n    } else {\n      this.logger.log(\"warn\", LOG_ID + \"(setPresence) No XMPP connection...\");\n      return Promise.resolve();\n    }\n  } //Message Carbon XEP-0280\n\n\n  enableCarbon() {\n    let that = this;\n\n    if (this.useXMPP) {\n      let stanza = xml(\"iq\", {\n        \"type\": \"set\",\n        id: \"enable_xmpp_carbon\"\n      }, xml(\"enable\", {\n        xmlns: NameSpacesLabels.Carbon2NameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(enableCarbon) send - 'stanza'\", stanza.toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanza).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(enableCarbon) sent\");\n          resolve();\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(enableCarbon) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  sendChatMessage(message, jid, lang, content, subject, answeredMsg) {\n    let that = this;\n\n    if (that.useXMPP) {\n      let id = that.xmppUtils.getUniqueMessageId();\n\n      if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\n        return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\n      } // Remove resource if exists\n\n\n      jid = that.xmppUtils.getBareJIDFromFullJID(jid);\n      let stanza = xml(\"message\", {\n        //\"from\": this.fullJid,\n        //\"from\": this.jid_im,\n        \"to\": jid,\n        \"xmlns\": NameSpacesLabels.ClientNameSpace,\n        \"type\": TYPE_CHAT,\n        \"id\": id\n      }, xml(\"body\", {\n        \"xml:lang\": lang\n      }, message), xml(\"request\", {\n        \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\n      }, xml(\"active\", {\n        \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\n      })));\n      let answeredMsgId = null;\n      let answeredMsgDate = null;\n\n      if (answeredMsg) {\n        stanza.append(xml(\"answeredMsg\", {\n          \"stamp\": answeredMsg.date.getTime()\n        }, answeredMsg.id));\n        answeredMsgId = answeredMsg.id;\n        answeredMsgDate = answeredMsg.date;\n        that.logger.log(\"internal\", LOG_ID + \"(sendChatMessage) answeredMsg : \", stanza);\n      }\n\n      if (subject) {\n        stanza.append(xml(\"subject\", {\n          \"xml:lang\": lang\n        }, subject));\n      }\n\n      if (content && content.message) {\n        let contentType = content.type || \"text/markdown\";\n        stanza.append(xml(\"content\", {\n          \"type\": contentType,\n          \"xmlns\": NameSpacesLabels.ContentNameSpace\n        }, content.message));\n      }\n\n      that.logger.log(\"internal\", LOG_ID + \"(sendChatMessage) send - 'message'\", stanza.toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanza).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(sendChatMessage) sent\");\n          resolve({\n            from: this.jid_im,\n            to: jid,\n            type: \"chat\",\n            id: id,\n            date: new Date(),\n            content: message\n          });\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(sendChatMessage) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  sendChatMessageToBubble(message, jid, lang, content, subject, answeredMsg, attention) {\n    let that = this;\n\n    if (that.useXMPP) {\n      if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\n        return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\n      }\n\n      let id = that.xmppUtils.getUniqueMessageId(); // from=\"room_85a525f559a14b1d88de9c79d866233f@muc.vberder-all-in-one-dev-1.opentouch.cloud/2c1e9ac0f2254b94bb2d977be498423d@vberder-all-in-one-dev-1.opentouch.cloud/web_win_1.56.8_S28ZBemj\"\n      // from=\"room_17b2b86803b24bcd9ac70973bb311b9b@muc.vberder-all-in-one-dev-1.opentouch.cloud/2c1e9ac0f2254b94bb2d977be498423d@vberder-all-in-one-dev-1.opentouch.cloud/node_NWGWQN6V\"\n\n      let stanza = xml(\"message\", {\n        'xmlns': 'jabber:client',\n        'xml:lang': lang,\n        'to': jid,\n        // 'from': jid + \"/\" + that.fullJid,\n        'type': TYPE_GROUPCHAT,\n        'id': id\n      }, xml(\"body\", {\n        \"xml:lang\": lang\n      }, message), xml(\"request\", {\n        \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\n      }, xml(\"active\", {\n        \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\n      })));\n\n      if (subject) {\n        stanza.append(xml(\"subject\", {\n          \"xml:lang\": lang\n        }, subject));\n      }\n\n      let answeredMsgId = null;\n      let answeredMsgDate = null;\n\n      if (answeredMsg) {\n        stanza.append(xml(\"answeredMsg\", {\n          \"stamp\": answeredMsg.date.getTime()\n        }, answeredMsg.id), undefined);\n        answeredMsgId = answeredMsg.id;\n        answeredMsgDate = answeredMsg.date;\n        that.logger.log(\"internal\", LOG_ID + \"(sendChatMessageToBubble) answeredMsg : \", stanza);\n      }\n\n      if (content && content.message) {\n        let contentType = content.type || \"text/markdown\";\n        stanza.append(xml(\"content\", {\n          \"type\": contentType,\n          \"xmlns\": NameSpacesLabels.ContentNameSpace\n        }, content.message));\n      }\n\n      if (attention) {\n        if (Array.isArray(attention) && attention.length > 0) {\n          let mentions = xml(\"mention\", {\n            \"xmlns\": NameSpacesLabels.AttentionNS\n          }, undefined);\n          attention.forEach(function (jidMentioned) {\n            mentions.append(xml(\"jid\", {}, jidMentioned), undefined);\n          });\n          stanza.append(mentions, undefined);\n        } else if (typeof attention === 'string' || attention instanceof String) {\n          let mentions = xml(\"mention\", {\n            \"xmlns\": NameSpacesLabels.AttentionNS\n          }, undefined);\n          mentions.append(xml(\"jid\", {}, attention), undefined);\n          stanza.append(mentions, undefined);\n        }\n      }\n\n      that.logger.log(\"internal\", LOG_ID + \"(sendChatMessageToBubble) send - 'message'\", stanza.toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanza).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(sendChatMessageToBubble) sent\");\n          resolve({\n            from: this.jid_im,\n            to: jid,\n            type: \"groupchat\",\n            id: id,\n            date: new Date(),\n            message: message,\n            content: content,\n            subject: subject,\n            lang: lang,\n            answeredMsg: answeredMsg\n          });\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(sendChatMessageToBubble) No XMPP connection...\");\n    return Promise.resolve(null); //return null;\n  }\n\n  sendCorrectedChatMessage(conversation, originalMessage, data, origMsgId, lang) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; //        $log.info(\"[Conversation] >sendCorrectedChatMessage: origMsgId=\" + origMsgId)\n\n      /* <message to='juliet@capulet.net/balcony' id='good1'>\r\n      <body>But soft, what light through yonder window breaks?</body>\r\n      <replace id='bad1' xmlns='urn:xmpp:message-correct:0'/>\r\n      <store xmlns='urn:xmpp:hints'/>\r\n      </message> */\n      // this.sendAckReadMessages();\n\n      let xmppMessage = null; // Build the message ID\n\n      let messageToSendID = that.xmppUtils.getUniqueMessageId();\n      that.logger.log(\"debug\", LOG_ID + \"(sendCorrectedChatMessage) : messageToSendID : \" + messageToSendID); // Handle One to one conversation message\n\n      if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\n        let to = conversation.id; //this.contact.jid;\n\n        xmppMessage = xml(\"message\", {\n          to: to,\n          type: \"chat\",\n          id: messageToSendID,\n          \"xml:lang\": lang\n        }, xml(\"body\", {\n          \"xml:lang\": lang\n        }, data), xml(\"replace\", {\n          id: origMsgId,\n          \"xmlns\": NameSpacesLabels.MessageCorrectNameSpace\n        }), xml(\"store\", {\n          \"xmlns\": NameSpacesLabels.HintsNameSpace\n        }), xml(\"request\", {\n          \"xmlns\": NameSpacesLabels.ReceiptNS\n        }), xml(\"active\", {\n          \"xmlns\": NameSpacesLabels.ChatstatesNS\n        }));\n      } // Handle Room conversation message\n      else {\n          xmppMessage = xml(\"message\", {\n            to: conversation.bubble.jid,\n            type: \"groupchat\",\n            id: messageToSendID\n          }, xml(\"body\", {\n            \"xml:lang\": lang\n          }, data), xml(\"replace\", {\n            id: origMsgId,\n            \"xmlns\": NameSpacesLabels.MessageCorrectNameSpace\n          }), xml(\"store\", {\n            \"xmlns\": NameSpacesLabels.HintsNameSpace\n          }), xml(\"request\", {\n            \"xmlns\": NameSpacesLabels.ReceiptNS\n          }), xml(\"active\", {\n            \"xmlns\": NameSpacesLabels.ChatstatesNS\n          }));\n        } // message = this.addChatReplaceMessage(contactService.userContact, new Date(), unicodeData, messageToSendID, true);\n\n\n      if (!originalMessage) {\n        return null;\n      }\n      /* WEB SDK :\r\n      originalMessage.serverAckTimer = $interval(function() {\r\n          originalMessage.receiptStatus = Message.ReceiptStatus.ERROR;\r\n          that.updateMessage(originalMessage);\r\n      }, 10000);\r\n            // Add message in messages array\r\n      originalMessage.addReplaceMsg(messageToSendID, data);\r\n      //*/\n      // Create and send message\n\n\n      that.xmppClient.send(xmppMessage);\n      return messageToSendID;\n    });\n  }\n\n  markMessageAsRead(message) {\n    let that = this;\n\n    if (this.useXMPP) {\n      let stanzaRead = xml(\"message\", {\n        \"to\": message.fromJid,\n        //\"from\": message.toJid + \"ERROR\",\n        \"type\": TYPE_CHAT\n      }, xml(\"received\", {\n        \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\n        \"event\": \"read\",\n        \"entity\": \"client\",\n        \"id\": message.id\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(markMessageAsRead) send - 'message'\", stanzaRead.root().toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanzaRead).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(markMessageAsRead) sent\");\n          resolve();\n        }).catch(err => {\n          that.logger.log(\"error\", LOG_ID + \"(markMessageAsRead) error \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(markMessageAsRead) error : \", err);\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  sendChatExistingFSMessage(message, jid, lang, fileDescriptor) {\n    let that = this;\n\n    if (that.useXMPP) {\n      if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\n        return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\n      }\n\n      let id = that.xmppUtils.getUniqueMessageId(); // Remove resource if exists\n\n      jid = that.xmppUtils.getBareJIDFromFullJID(jid); //let url = this.host + \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\n\n      let url = \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\n      let stanza = xml(\"message\", {\n        // \"from\": this.fullJid,\n        \"to\": jid,\n        \"xmlns\": NameSpacesLabels.ClientNameSpace,\n        \"type\": TYPE_CHAT,\n        \"id\": id\n      }, xml(\"body\", {\n        \"xml:lang\": lang\n      }, message), xml(\"request\", {\n        \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\n      }, xml(\"active\", {\n        \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\n      })), xml(\"x\", {\n        \"xmlns\": NameSpacesLabels.OobNameSpace\n      }, xml(\"url\", {}, url), xml(\"mime\", {}, fileDescriptor.typeMIME), xml(\"filename\", {}, fileDescriptor.fileName), xml(\"size\", {}, fileDescriptor.size)), xml(\"store\", {\n        \"xmlns\": NameSpacesLabels.HintsNameSpace\n      }));\n      that.logger.log(\"internal\", LOG_ID + \"(sendChatExistingFSMessage) send - 'message'\", stanza.toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanza).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(sendChatExistingFSMessage) sent\");\n          resolve({\n            from: this.jid_im,\n            to: jid,\n            type: \"chat\",\n            id: id,\n            date: new Date(),\n            content: message\n          });\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(sendChatExistingFSMessage) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  sendChatExistingFSMessageToBubble(message, jid, lang, fileDescriptor) {\n    let that = this;\n\n    if (that.useXMPP) {\n      if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\n        return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\n      }\n\n      let id = that.xmppUtils.getUniqueMessageId(); // Remove resource if exists\n\n      jid = that.xmppUtils.getBareJIDFromFullJID(jid); //let url = this.host  + \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\n\n      let url = \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\n      let stanza = xml(\"message\", {\n        //\"from\": this.fullJid,\n        \"to\": jid,\n        \"xmlns\": NameSpacesLabels.ClientNameSpace,\n        \"type\": TYPE_GROUPCHAT,\n        \"id\": id\n      }, xml(\"body\", {\n        \"xml:lang\": lang\n      }, message), xml(\"request\", {\n        \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\n      }, xml(\"active\", {\n        \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\n      })), xml(\"x\", {\n        \"xmlns\": NameSpacesLabels.OobNameSpace\n      }, xml(\"url\", {}, url), xml(\"mime\", {}, fileDescriptor.typeMIME), xml(\"filename\", {}, fileDescriptor.fileName), xml(\"size\", {}, fileDescriptor.size)), xml(\"store\", {\n        \"xmlns\": NameSpacesLabels.HintsNameSpace\n      }));\n      that.logger.log(\"internal\", LOG_ID + \"(sendChatExistingFSMessageToBubble) send - 'message'\", stanza.toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanza).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(sendChatExistingFSMessageToBubble) sent\");\n          resolve({\n            from: this.jid_im,\n            to: jid,\n            type: \"chat\",\n            id: id,\n            date: new Date(),\n            content: message\n          });\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(sendChatExistingFSMessageToBubble) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  sendIsTypingState(conversation, isTypingState) {\n    let that = this;\n    let state = isTypingState ? \"composing\" : \"active\";\n\n    if (this.useXMPP) {\n      let jid = conversation.id;\n      let type = \"chat\"; // Handle One to one conversation message\n\n      if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\n        //jid = this.contact.jid;\n        type = \"chat\";\n      } // Handle Room conversation message\n      else {\n          type = \"groupchat\";\n        }\n\n      let stanzaRead = xml(\"message\", {\n        \"to\": jid,\n        \"type\": type,\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      }, xml(state, {\n        \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(sendIsTypingState) send - 'message'\", stanzaRead.root().toString());\n      return new Promise((resolve, reject) => {\n        that.xmppClient.send(stanzaRead).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(sendIsTypingState) sent\");\n          resolve();\n        }).catch(err => {\n          return reject(err);\n        });\n      });\n    }\n\n    that.logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No XMPP connection...\");\n    return Promise.resolve(null);\n  }\n\n  getRosters() {\n    let that = this; //this.logger.log(\"debug\", LOG_ID + \"(start) getRosters\");\n\n    if (this.useXMPP) {\n      let stanza = xml(\"iq\", {\n        \"id\": that.xmppUtils.getUniqueMessageId(),\n        \"type\": \"get\"\n      }, xml(\"query\", {\n        xmlns: NameSpacesLabels.RosterNameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(getRosters) send - 'iq/rosters'\", stanza.toString());\n      this.xmppClient.send(stanza);\n    } else {\n      this.logger.log(\"warn\", LOG_ID + \"(getRosters) No XMPP connection...\");\n    }\n  }\n  /****************************************************/\n\n  /**            XMPP ROSTER MANAGEMENT              **/\n\n  /****************************************************/\n\n\n  sendSubscription(contact) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; // Return immediately if already subscribed\n\n      if (contact.subscribe === \"to\" || contact.subscribe === \"both\") {\n        return;\n      } // Send subscriptions for im and telephony presences\n\n\n      yield that.sendSubscribeInvitation(contact.jid);\n      yield that.sendSubscribeInvitation(contact.jidtel);\n      return;\n    });\n  }\n\n  sendSubscribeInvitation(jid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      this.logger.log(\"debug\", LOG_ID + \"(sendSubscribeInvitation) Send subscribe invitation to \", jid);\n      let stanza = xml(\"iq\", {\n        type: \"get\",\n        to: that.jid_tel + \"/phone\",\n        xmlns: NameSpacesLabels.ClientNameSpace,\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      }, xml(\"pbxagentstatus\", {\n        \"xmlns\": NameSpacesLabels.Monitoring1NameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(getAgentStatus) send - 'iq get'\", stanza.root().toString());\n      return this.xmppClient.sendIq(stanza);\n    });\n  }\n\n  sendInitialBubblePresence(jid) {\n    let that = this;\n    let id = that.xmppUtils.getUniqueMessageId();\n\n    if (this.useXMPP) {\n      let stanza = xml(\"presence\", {\n        \"id\": id,\n        to: jid + \"/\" + this.fullJid\n      }, xml(\"x\", {\n        \"xmlns\": NameSpacesLabels.MucNameSpace\n      }).append(xml(\"history\", {\n        maxchars: \"0\"\n      })));\n\n      if (this.initialPresence) {\n        this.initialPresence = false;\n        stanza.append(xml(\"application\", {\n          xmlns: NameSpacesLabels.ApplicationNameSpace\n        }, xml(\"appid\", {}, this.applicationId), xml(\"userid\", {}, this.userId)));\n        stanza.append(xml(\"priority\", {}, \"5\"));\n      }\n\n      this.logger.log(\"internal\", LOG_ID + \"(sendInitialBubblePresence) send - 'message'\", stanza.root().toString());\n      return this.xmppClient.send(stanza);\n    } else {\n      this.logger.log(\"warn\", LOG_ID + \"(sendInitialBubblePresence) No XMPP connection...\");\n      return Promise.resolve();\n    }\n  }\n\n  sendUnavailableBubblePresence(jid) {\n    let that = this;\n\n    if (this.useXMPP) {\n      let id = that.xmppUtils.getUniqueMessageId();\n      let stanza = xml(\"presence\", {\n        \"id\": id,\n        to: jid + \"/\" + this.fullJid,\n        type: \"unavailable\"\n      }, xml(\"x\", {\n        \"xmlns\": NameSpacesLabels.MucNameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(sendUnavailableBubblePresence) send - 'message'\", stanza.root().toString());\n      this.xmppClient.send(stanza);\n    } else {\n      this.logger.log(\"warn\", LOG_ID + \"(sendUnavailableBubblePresence) No XMPP connection...\");\n    }\n  }\n\n  getAgentStatus() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (this.useXMPP) {\n        let stanza = xml(\"iq\", {\n          type: \"get\",\n          to: that.jid_tel + \"/phone\",\n          xmlns: NameSpacesLabels.ClientNameSpace,\n          \"id\": that.xmppUtils.getUniqueMessageId()\n        }, xml(\"pbxagentstatus\", {\n          \"xmlns\": NameSpacesLabels.Monitoring1NameSpace\n        }));\n        this.logger.log(\"internal\", LOG_ID + \"(getAgentStatus) send - 'iq get'\", stanza.root().toString());\n        this.xmppClient.sendIq(stanza).then(data => {\n          let pbxagentstatus = {\n            \"phoneapi\": \"\",\n            \"xmppagent\": \"\",\n            \"version\": \"\"\n          };\n          let agentStatus = {\n            \"phoneApi\": \"\",\n            \"xmppAgent\": \"\",\n            \"agentVersion\": \"\"\n          };\n          let subchildren = data.children[0].children;\n          subchildren.forEach(item => {\n            if (typeof item === \"object\") {\n              let itemName = item.getName();\n\n              if (itemName) {\n                pbxagentstatus[itemName] = item.text();\n              }\n            }\n          });\n\n          if (pbxagentstatus.version) {\n            let phoneApi = pbxagentstatus.phoneapi;\n            let xmppAgent = pbxagentstatus.xmppagent;\n            let agentVersion = pbxagentstatus.version;\n            agentStatus = {\n              \"phoneApi\": phoneApi,\n              \"xmppAgent\": xmppAgent,\n              \"agentVersion\": agentVersion\n            };\n          }\n\n          resolve(agentStatus);\n        });\n      } else {\n        resolve({});\n      }\n    });\n  }\n  /**\r\n   *\r\n    * @param useAfter\r\n   * @returns {Promise<void>}\r\n   */\n\n\n  sendGetCallLogHistoryPage(useAfter) {\n    return __awaiter(this, void 0, void 0, function* () {\n      /*\r\n      <iq from=\"38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud\" id=\"c08a506f-83d9-48a8-8628-10d69a44c340:sendIQ\" type=\"set\" xmlns=\"jabber:client\">\r\n          <query xmlns=\"jabber:iq:telephony:call_log\">\r\n              <set xmlns=\"http://jabber.org/protocol/rsm\">\r\n                  <max>75</max>\r\n                  <before></before>\r\n              </set>\r\n          </query>\r\n      </iq>\r\n       */\n      let that = this; // Get the user contact\n\n      let useMax = 75;\n      let useBefore = \"\"; //add empty before in order to get the most recent messages\n      //let useAfter;\n\n      let stanza = xml(\"iq\", {\n        \"from\": this.jid_im,\n        \"type\": \"set\",\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      });\n      let queryEmt = xml(\"query\", {\n        xmlns: NameSpacesLabels.CallLogNamespace\n      });\n\n      if (useMax || useBefore || useAfter) {\n        let rsmSet = xml(\"set\", {\n          xmlns: NameSpacesLabels.RsmNameSpace\n        });\n\n        if (useMax) {\n          rsmSet.append(xml(\"max\", {}, useMax));\n        }\n\n        if (useAfter) {\n          rsmSet.append(xml(\"after\", {}, useAfter));\n        } else {\n          rsmSet.append(xml(\"before\", {}, useBefore));\n        }\n\n        queryEmt.append(rsmSet);\n      }\n\n      stanza.append(queryEmt);\n      return yield this.xmppClient.sendIq(stanza);\n    });\n  }\n\n  deleteOneCallLog(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[deleteOneCallLog] deleteOneCallLog : \" + id); // Get the user contact\n      //let userContact = contactService.userContact;\n\n      let message = xml(\"iq\", {\n        \"from\": this.jid_im,\n        \"to\": this.jid_im,\n        \"type\": \"set\",\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      });\n      let msg = message.append(xml(\"delete\", {\n        xmlns: NameSpacesLabels.CallLogNamespace,\n        call_id: id\n      }));\n      return yield this.xmppClient.sendIq(msg);\n    });\n  }\n\n  deleteCallLogsForContact(jid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[deleteCallLogsForContact] deleteCallLogsForContact : \" + jid); // Get the user contact\n      //let userContact = contactService.userContact;\n\n      let message = xml(\"iq\", {\n        \"from\": that.jid_im,\n        \"to\": that.jid_im,\n        \"type\": \"set\",\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      });\n      let msg = message.append(xml(\"delete\", {\n        xmlns: NameSpacesLabels.CallLogNamespace,\n        peer: jid\n      }));\n      return yield this.xmppClient.sendIq(msg); //xmppService.sendIQ(msg);\n    });\n  }\n\n  deleteAllCallLogs() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; // Get the user contact\n      //let userContact = contactService.userContact;\n\n      if (this.useXMPP) {\n        let message = xml(\"iq\", {\n          \"from\": that.jid_im,\n          \"to\": that.jid_im,\n          \"type\": \"set\",\n          \"id\": that.xmppUtils.getUniqueMessageId()\n        });\n        let msg = message.append(xml(\"delete\", {\n          xmlns: NameSpacesLabels.CallLogNamespace\n        }));\n        return yield this.xmppClient.sendIq(msg); //xmppService.sendIQ(msg);\n      } else {\n        this.logger.log(\"warn\", LOG_ID + \"(deleteAllCallLogs) No XMPP connection...\");\n        return Promise.resolve();\n      }\n    });\n  }\n\n  markCallLogAsRead(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[markCallLogAsRead] markCallLogAsRead : \" + id); // Get the user contact\n      //let userContact = contactService.userContact;\n\n      let message = xml(\"message\", {\n        \"from\": that.jid_im,\n        \"to\": that.jid_im,\n        \"id\": that.xmppUtils.getUniqueMessageId()\n      });\n      let msg = message.append(xml(\"read\", {\n        xmlns: NameSpacesLabels.CallLogAckNamespace,\n        call_id: id\n      }));\n      return yield this.xmppClient.sendIq(msg); //xmppService.sendIQ(msg);\n    });\n  }\n\n  markAllCallsLogsAsRead(callLogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; //let userContact = contactService.userContact;\n\n      let promSend = [];\n\n      for (let i = 0; i < callLogs.length; i++) {\n        if (!callLogs[i].read) {\n          let message = xml(\"message\", {\n            \"from\": that.jid_im,\n            \"to\": that.jid_im,\n            \"id\": that.xmppUtils.getUniqueMessageId()\n          });\n          let msg = message.append(xml(\"read\", {\n            \"xmlns\": NameSpacesLabels.CallLogAckNamespace,\n            \"call_id\": callLogs[i].id\n          }));\n          promSend.push(that.xmppClient.sendIq(msg)); //xmppService.sendIQ(msg);\n        }\n      }\n\n      return yield Promise.all(promSend);\n    });\n  }\n\n  deleteAllMessageInOneToOneConversation(conversationId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      /*\r\n      <iq id=\"3b718ea6-5dae-4e29-b54c-b843156df93d\" type=\"set\" xmlns=\"jabber:client\">\r\n      <delete queryid=\"dd008366-ad0f-4197-a61c-0c34fbc0e75a\" xmlns=\"urn:xmpp:mam:1\">\r\n      <x type=\"submit\" xmlns=\"jabber:x:data\">\r\n      <field type=\"hidden\" var=\"FORM_TYPE\">\r\n      <value>urn:xmpp:mam:1\r\n      </value>\r\n      </field>\r\n      <field var=\"with\">\r\n      <value>7ebaaacfa0634f46a903bcdd83ae793b@openrainbow.net\r\n      </value>\r\n      </field>\r\n      </x>\r\n      <set xmlns=\"http://jabber.org/protocol/rsm\"/>\r\n      </delete>\r\n      </iq>\r\n       */\n      // Get the user contact\n      //let userContact = contactService.userContact;\n\n      let uniqMessageId = that.xmppUtils.getUniqueMessageId();\n      let uniqId = that.xmppUtils.getUniqueId(undefined);\n      let message = xml(\"iq\", {\n        //\"from\": that.jid_im,\n        //\"to\": that.jid_im,\n        \"type\": \"set\",\n        \"id\": uniqMessageId\n      });\n      let rsmDelete = xml(\"delete\", {\n        xmlns: NameSpacesLabels.MamNameSpace,\n        queryid: uniqId\n      });\n      let rsmx = xml(\"x\", {\n        xmlns: NameSpacesLabels.DataNameSpace,\n        type: \"submit\"\n      });\n      let rsmField1 = xml(\"field\", {\n        var: \"FORM_TYPE\",\n        type: \"hidden\"\n      });\n      let rsmvalue1 = xml(\"value\", {}, NameSpacesLabels.MamNameSpace);\n      let rsmField2 = xml(\"field\", {\n        var: \"with\"\n      });\n      let rsmvalue2 = xml(\"value\", {}, conversationId);\n      let rsmset = xml(\"set\", {\n        xmlns: NameSpacesLabels.RsmNameSpace\n      });\n      rsmField1.append(rsmvalue1, undefined);\n      rsmField2.append(rsmvalue2, undefined);\n      rsmx.append(rsmField1, undefined);\n      rsmx.append(rsmField2, undefined);\n      rsmDelete.append(rsmx, undefined);\n      rsmDelete.append(rsmset, undefined);\n      let msg = message.append(rsmDelete, undefined); //return Promise.resolve(message);\n\n      return yield this.xmppClient.sendIq(msg); //xmppService.sendIQ(msg);\n    });\n  }\n\n  getErrorMessage(data, actionLabel) {\n    let errorMessage = actionLabel + \" failure : \";\n\n    if (data.attr(\"type\") === \"error\") {\n      //let errorMsg = stanza.getChild(\"error\")?stanza.getChild(\"error\").getChild(\"text\").getText() ||  \"\" : \"\";\n      let error = data.getChild(\"error\");\n\n      if (error) {\n        let errorType = error.attr(\"type\");\n        let errorCode = error.attr(\"code\");\n\n        if (errorType) {\n          errorMessage += errorType + \" : \";\n\n          if (errorType === \"modify\") {\n            errorMessage += error.getChild(\"text\").getText() || \"\";\n          }\n        }\n\n        if (errorCode) {\n          if (errorCode === \"503\") {\n            errorMessage += \"Agent error : service unavailable\";\n          }\n        }\n\n        this.logger.log(\"error\", LOG_ID + \"[getErrorMessage] \");\n        this.logger.log(\"internalerror\", LOG_ID + \"[getErrorMessage] : \" + errorMessage);\n      } else {\n        errorMessage += \"Unknown error\";\n      }\n\n      return errorMessage;\n    }\n\n    return null;\n  }\n\n  getTelephonyState(secondary) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      let stanza; // <iq type='get' to='tel_38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/phone' xmlns='jabber:client' id='11b8b163-f317-42fd-9962-f1943d5adb21:sendIQ'>\n      // <callservice xmlns='urn:xmpp:pbxagent:callservice:1'>\n      // <connections/>\n      // </callservice>\n      // </iq>\n\n      if (!secondary) {\n        //iq = $iq({type: \"get\", to: service.userJidTel + \"/phone\"})\n        //.c(\"callservice\", {xmlns: CALLSERVICE_NS})\n        //.c(\"connections\");\n        stanza = xml(\"iq\", {\n          type: \"get\",\n          to: that.jid_tel + \"/phone\",\n          xmlns: NameSpacesLabels.ClientNameSpace,\n          \"id\": that.xmppUtils.getUniqueMessageId()\n        }, xml(\"callservice\", {\n          \"xmlns\": NameSpacesLabels.CallService1NameSpace\n        }, xml(\"connections\")));\n      } else {\n        stanza = xml(\"iq\", {\n          type: \"get\",\n          to: that.jid_tel + \"/phone\",\n          //xmlns: NameSpacesLabels.ClientNameSpace,\n          \"id\": that.xmppUtils.getUniqueMessageId()\n        }, xml(\"callservice\", {\n          \"xmlns\": NameSpacesLabels.CallService1NameSpace\n        }, xml(\"connections\", {\n          deviceType: \"SECONDARY\"\n        })));\n      }\n\n      this.logger.log(\"internal\", LOG_ID + \"(getTelephonyState) send - 'iq get'\", stanza.root().toString());\n      this.xmppClient.sendIq(stanza).then(data => {\n        this.logger.log(\"info\", LOG_ID + \"(getTelephonyState) received - 'iq result'\");\n        this.logger.log(\"internal\", LOG_ID + \"(getTelephonyState) received - 'iq result'\", data); // Handle eventual error message\n\n        let errorMessage = that.getErrorMessage(data, \"getTelephonyState\");\n\n        if (errorMessage) {\n          this.logger.log(\"error\", LOG_ID + \"getTelephonyState -- failure -- \");\n          this.logger.log(\"internalerror\", LOG_ID + \"getTelephonyState -- failure -- : \", errorMessage);\n          return reject(new Error(errorMessage));\n        } // Handle existing calls\n\n\n        let existingCalls = that.xmppUtils.findChild(data, \"connections\");\n        let children = {};\n\n        if (existingCalls.children.length === 0) {\n          this.logger.log(\"debug\", LOG_ID + \"getTelephonyState -- success -- no existing call\");\n        } else {\n          children = existingCalls.children;\n        }\n\n        resolve(children);\n      });\n    });\n  }\n\n  sendPing() {\n    let that = this;\n\n    if (this.useXMPP) {\n      let id = that.xmppUtils.getUniqueMessageId();\n      let stanza = xml(\"iq\", {\n        \"type\": \"get\",\n        \"id\": id\n      }, xml(\"ping\", {\n        xmlns: NameSpacesLabels.PingNameSpace\n      }));\n      this.logger.log(\"internal\", LOG_ID + \"(sendPing) send - 'message'\", stanza.root().toString(), \" for Rainbow Node SDK version : \", packageVersion.version);\n      this.xmppClient.send(stanza).catch(error => {\n        this.logger.log(\"error\", LOG_ID + \"(sendPing) error \");\n        this.logger.log(\"internalerror\", LOG_ID + \"(sendPing) error : \", error);\n      });\n    } else {\n      this.logger.log(\"warn\", LOG_ID + \"(sendPing) No XMPP connection...\");\n    }\n  } // Mam\n\n\n  mamQuery(jid, options) {\n    let that = this;\n    const MAM = \"urn:xmpp:mam:1\";\n    const _p = [\"with\", \"start\", \"end\"];\n    let mamAttr = {\n      xmlns: MAM,\n      queryid: null\n    };\n\n    if (!!options.queryid) {\n      mamAttr.queryid = options.queryid;\n      delete options.queryid;\n    }\n\n    let onMessage = options.onMessage;\n    delete options.onMessage;\n    let onComplete = options.onComplete;\n    delete options.onComplete;\n    let stanza = xml(\"iq\", {\n      \"type\": \"set\",\n      id: jid,\n      xmlns: NameSpacesLabels.ClientNameSpace\n    }, xml(\"query\", mamAttr, xml(\"x\", {\n      xmlns: NameSpacesLabels.DataNameSpace,\n      type: \"submit\"\n    }, xml(\"field\", {\n      \"var\": \"FORM_TYPE\",\n      \"type\": \"hidden\"\n    }, xml(\"value\", {}, MAM)), _p.filter(key => options[key]).map(key => {\n      let value = xml(\"field\", {\n        \"var\": key\n      }, xml(\"value\", {}, options[key]));\n      delete options[key];\n      return value;\n    })), xml(\"set\", {\n      xmlns: NameSpacesLabels.RsmNameSpace\n    }, Object.keys(options).map(key => xml(key, {}, options[key]\n    /*? options[key] : null*/\n    )))));\n    that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamQuery - 'stanza'\");\n    that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamQuery - 'stanza'\", stanza.toString());\n    that.xmppClient.send(stanza).then(() => {\n      if (typeof onComplete === \"function\") {\n        onComplete();\n      }\n    });\n  }\n\n  mamQueryMuc(jid, to, options) {\n    let that = this;\n    const MAM = \"urn:xmpp:mam:1\";\n    const _p = [\"with\", \"start\", \"end\"];\n    let mamAttr = {\n      xmlns: MAM,\n      queryid: null\n    };\n\n    if (Boolean(options.queryid)) {\n      mamAttr.queryid = options.queryid;\n      delete options.queryid;\n    }\n\n    let onMessage = options.onMessage;\n    delete options.onMessage;\n    let onComplete = options.onComplete;\n    delete options.onComplete;\n    let stanza = xml(\"iq\", {\n      \"type\": \"set\",\n      id: jid,\n      to: to,\n      xmlns: NameSpacesLabels.ClientNameSpace\n    }, xml(\"query\", mamAttr, xml(\"x\", {\n      xmlns: NameSpacesLabels.DataNameSpace,\n      type: \"submit\"\n    }, xml(\"field\", {\n      \"var\": \"FORM_TYPE\",\n      \"type\": \"hidden\"\n    }, xml(\"value\", {}, MAM)), _p.filter(key => options[key]).map(key => {\n      let value = xml(\"field\", {\n        \"var\": key\n      }, xml(\"value\", {}, options[key]));\n      delete options[key];\n      return value;\n    })), xml(\"set\", {\n      xmlns: NameSpacesLabels.RsmNameSpace\n    }, Object.keys(options).map(key => xml(key, {}, options[key] ? options[key] : null)))));\n    that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamQueryMuc - 'stanza'\");\n    that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamQueryMuc - 'stanza'\", stanza.toString());\n    that.xmppClient.send(stanza).then(() => {\n      if (typeof onComplete === \"function\") {\n        onComplete();\n      }\n    });\n  }\n\n  mamDelete(options) {\n    let that = this;\n    const MAM = \"urn:xmpp:mam:1\";\n    const _p = [\"with\", \"start\", \"end\"];\n    let mamAttr = {\n      xmlns: MAM,\n      deleteid: null\n    };\n\n    if (Boolean(options.deleteid)) {\n      mamAttr.deleteid = options.deleteid;\n      delete options.deleteid;\n    }\n\n    let onMessage = options.onMessage;\n    delete options.onMessage;\n    let onComplete = options.onComplete;\n    delete options.onComplete;\n    options.queryid = that.xmppUtils.getUniqueMessageId();\n    let id = that.xmppUtils.getUniqueMessageId();\n    let stanza = xml(\"iq\", {\n      \"type\": \"set\",\n      id: id,\n      xmlns: NameSpacesLabels.ClientNameSpace\n    }, xml(\"delete\", mamAttr, xml(\"x\", {\n      xmlns: NameSpacesLabels.DataNameSpace,\n      type: \"submit\"\n    }, xml(\"field\", {\n      \"var\": \"FORM_TYPE\",\n      \"type\": \"hidden\"\n    }, xml(\"value\", {}, MAM)), _p.filter(key => options[key]).map(key => {\n      let value = xml(\"field\", {\n        \"var\": key\n      }, xml(\"value\", {}, options[key]));\n      delete options[key];\n      return value;\n    })), xml(\"set\", {\n      xmlns: NameSpacesLabels.RsmNameSpace\n    }, Object.keys(options).map(key => xml(key, {}, options[key] ? options[key] : null)))));\n    that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamDelete - 'stanza'\");\n    that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamDelete - 'stanza'\", stanza.toString());\n    that.xmppClient.send(stanza).then(result => {\n      if (typeof onComplete === \"function\") {\n        onComplete(result);\n      }\n    });\n  } // Voice Messages\n\n\n  voiceMessageQuery(jid) {\n    let that = this;\n    /*\r\n                // Create the iq request\r\n        let iq = $iq({type: \"get\", to: that.userJidTel + \"/phone\"})\r\n            .c(\"callservice\", {xmlns: NameSpacesLabels.CallService1NameSpace})\r\n            .c(\"messaging\");\r\n     */\n\n    let nsAttr = {\n      xmlns: NameSpacesLabels.CallService1NameSpace\n    };\n    let stanza = xml(\"iq\", {\n      \"type\": \"set\",\n      \"to\": jid + \"/phone\"\n    }, xml(\"callservice\", nsAttr, xml(\"messaging\")));\n    return new Promise((resolve, reject) => {\n      that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) voiceMessageQuery - 'stanza'\");\n      that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) voiceMessageQuery - 'stanza'\", stanza.toString());\n      that.xmppClient.send(stanza).then(data => {\n        resolve(data);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n\n};\nXMPPService = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_1.isStarted([\"start\", \"stop\"])], XMPPService);\nexports.XMPPService = XMPPService;\nmodule.exports.XMPPService = XMPPService;\nmodule.exports.NameSpacesLabels = NameSpacesLabels;","map":{"version":3,"sources":["../../src/lib/connection/XMPPService.ts"],"names":[],"mappings":"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AAG,EAAzB;AACA,gBAAI,OAAO,GAAG,EAAd;AACA,gBAAI,KAAK,GAAG,EAAZ;AACA,gBAAI,QAAQ,GAAG,EAAf;AACA,gBAAI,eAAe,GAAG,KAAtB;AACA,gBAAI,GAAG,GAAG,IAAV;AACA,gBAAI,WAAW,GAAG,MAAM,CAAC,KAAP,CAAa,IAA/B;;AACA,gBAAI,WAAW,KAAK,SAAhB,IAA6B,WAAW,KAAK,cAAjD,EAAiE,CAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH,aA1PD,MA0PO,IAAI,MAAM,CAAC,KAAP,CAAa,IAAb,KAAsB,YAA1B,EAAwC,CAC3C;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,aAxIM,MAwIA,IAAI,MAAM,CAAC,KAAP,CAAa,IAAb,KAAsB,OAA1B,EAAmC,CACtC;AACH,aAFM,MAEA,IAAI,MAAM,CAAC,KAAP,CAAa,IAAb,KAAsB,UAA1B,EAAsC,CAEzC;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEH,aArBM,MAqBA;AACH,kBAAI,QAAQ,GAAG,MAAM,CAAC,QAAtB;AAEA,cAAA,QAAQ,CAAC,OAAT,CAAiB,UAAU,IAAV,EAAc;AAC3B,wBAAQ,IAAI,CAAC,OAAL,EAAR;AACI,uBAAK,UAAL;AACI,wBAAI,OAAO,GAAG;AACV,sBAAA,KAAK,EAAE,IAAI,CAAC,KAAL,CAAW,KADR;AAEV,sBAAA,MAAM,EAAE,IAAI,CAAC,KAAL,CAAW,MAFT;AAGV,sBAAA,IAAI,EAAE,IAHI;AAIV,sBAAA,EAAE,EAAE,IAAI,CAAC,KAAL,CAAW;AAJL,qBAAd,CADJ,CAOI;;AACA,oBAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,wBAAvB,EAAiD,OAAjD;AACA;;AACJ;AACI;AAZR;AAcH,eAfD;AAgBH;;AACD;;AACJ,eAAK,UAAL;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACJ,eAAK,OAAL;AACI;;AACJ;AACI,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,+CAAjC,EAAkF,MAAM,CAAC,OAAP,EAAlF;AACA;AA3lBR;AA6lBH,OA5mBD;AA8mBA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,WAAnB,EAAuC,GAAP,IAAc,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC1C,YAAI,GAAG,CAAC,IAAJ,KAAa,sBAAjB,EAAyC;AACrC;AACH;;AACD,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,+CAAT,GAA2D,WAA3D,GAAyE,IAAlG,EAAwG,IAAI,CAAC,OAAL,CAAa,GAAG,CAAC,SAAJ,IAAiB,GAA9B,CAAxG;AACA,QAAA,IAAI,CAAC,aAAL;;AACA,YAAI,IAAI,CAAC,SAAL,IAAkB,GAAtB,EAA2B;AACvB;AACA,kBAAQ,GAAG,CAAC,SAAZ;AACI;AACA,iBAAK,0BAAL;AACA,iBAAK,OAAL;AACA,iBAAK,qBAAL;AACA,iBAAK,oBAAL;AACA,iBAAK,iBAAL;AACI,kBAAI,OAAO,GAAG,KAAK,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,KAAgB,IAAI,CAAC,KAAL,CAAW,EAAX,CAA3B,CAAnB;AACA,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,qDAAlC,EAAyF,OAAzF,EAAiG,kCAAjG;AACA,oBAAM,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAAN;;AACA,kBAAI,CAAC,IAAI,CAAC,cAAV,EAA0B;AACtB,gBAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kEAAlC;AACA,sBAAM,IAAI,CAAC,SAAL,CAAe,SAAf,EAAN;AACH,eAHD,MAGO;AACH,gBAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,yFAAlC;AACH;;AACD;AACJ;;AACA,iBAAK,YAAL;AACA,iBAAK,sBAAL;AACA,iBAAK,WAAL;AACA,iBAAK,cAAL;AACA,iBAAK,qBAAL;AACA,iBAAK,uBAAL;AACA,iBAAK,cAAL;AACA,iBAAK,mBAAL;AACA,iBAAK,aAAL;AACA,iBAAK,gBAAL;AACA,iBAAK,iBAAL;AACA,iBAAK,kBAAL;AACA,iBAAK,gBAAL;AACA,iBAAK,qBAAL;AACA,iBAAK,sBAAL;AACA,iBAAK,qBAAL;AACA,iBAAK,yBAAL;AACI,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,+DAAlC,EAAmG,GAAG,CAAC,SAAvG,EAAkH,YAAlH,EAAgI,GAAhI;AACA,cAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,wBAAvB,EAAiD,GAAjD;AACA;AACJ;;AACA,iBAAK,gBAAL;AACI,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,2DAAlC,EAA+F,GAAG,CAAC,SAAnG,EAA8G,2BAA9G;;AACJ,iBAAK,UAAL;AACA,iBAAK,qBAAL;AACA;AACI,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,+EAAlC,EAAmH,GAAG,CAAC,SAAvH;AACA,cAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,6BAAvB,EAAsD,GAAtD;AACA;AA9CR;AAgDH,SAlDD,MAkDO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,oFAAlC;AACH;AACJ,OA3D6C,CAA9C;AA6DA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,aAAnB,EAAmC,GAAD,IAAQ;AACtC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,iDAAT,GAA6D,aAA7D,GAA6E,IAA7E,GAAoF,GAA7G;AACH,OAFD;AAIA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,aAAnB,EAAkC,MAAK;AACnC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,iDAAT,GAA6D,aAAtF;AACH,OAFD;AAIA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,eAAnB,EAAqC,GAAD,IAAQ;AACxC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mDAAT,GAA+D,eAA/D,GAAiF,IAAjF,GAAwF,GAAjH;AACH,OAFD;AAIA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,gBAAnB,EAAqC,MAAW,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC5C,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,oDAAT,GAAgE,gBAAhE,GAAmF,IAA5G,EAAkH;AAAC,uBAAa,IAAI,CAAC;AAAnB,SAAlH;AACA,QAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,wBAAvB,EAAiD;AAAC,uBAAa,IAAI,CAAC;AAAnB,SAAjD;AACA,YAAI,OAAO,GAAG,KAAK,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,KAAgB,IAAI,CAAC,KAAL,CAAW,EAAX,CAA3B,CAAnB;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,yDAAT,GAAqE,OAArE,GAA+E,kCAAxG;AACA,cAAM,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAAN;;AACA,YAAI,IAAI,CAAC,SAAT,EAAoB;AAChB,cAAI,CAAC,IAAI,CAAC,cAAV,EAA0B;AACtB,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,uEAAlC;AACA,kBAAM,IAAI,CAAC,SAAL,CAAe,SAAf,EAAN;AACH,WAHD,MAGO;AACH,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,+FAAlC;AACH;AACJ,SAPD,MAOO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,yFAAlC;AACH;AACJ,OAhB+C,CAAhD;AAkBA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,WAAnB,EAAiC,GAAD,IAAQ;AACpC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,+CAAT,GAA2D,WAA3D,GAAyE,IAAzE,GAAgF,GAAzG;AACH,OAFD;AAIA,WAAK,UAAL,CAAgB,EAAhB,CAAmB,SAAnB,EAA+B,GAAD,IAAQ;AAClC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,6CAAT,GAAyD,SAAzD,GAAqE,IAArE,GAA4E,GAArG;AACH,OAFD;AAIA,WAAK,SAAL,CAAe,EAAf,CAAkB,kBAAlB,EAAsC,MAAK;AACvC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,6DAAT,GAAyE,kBAAlG;;AACA,YAAI,IAAI,CAAC,SAAT,EAAoB;AAChB,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,GAAG,MAAM,8DAAlC,EAAkG,IAAI,CAAC,SAAvG;;AACA,cAAI,CAAC,IAAI,CAAC,cAAV,EAA0B;AACtB,YAAA,IAAI,CAAC,SAAL,CAAe,KAAf,GAAuB,IAAI,CAAC,iBAAL,CAAuB,IAAvB,EAAvB;AACA,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,GAAG,MAAM,uEAAuE,IAAI,CAAC,SAAL,CAAe,KAAK,KAA7H;AAEA,YAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,iCAAvB;AACA,iBAAK,cAAL,GAAsB,IAAtB;AACH,WAND,MAMO;AACH,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,iGAAlC;AACH;AACJ,SAXD,MAWO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,2FAAlC;AACA,eAAK,cAAL,GAAsB,KAAtB;AACH;AACJ,OAjBD;AAmBA,WAAK,SAAL,CAAe,EAAf,CAAkB,iBAAlB,EAAqC,MAAK;AACtC,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,4DAAT,GAAwE,iBAAjG;AACA,QAAA,IAAI,CAAC,iBAAL,CAAuB,KAAvB;AACA,QAAA,IAAI,CAAC,SAAL,CAAe,KAAf,GAAuB,IAAI,CAAC,iBAAL,CAAuB,eAAvB,EAAvB;AACA,QAAA,IAAI,CAAC,cAAL,GAAsB,KAAtB;AACA,QAAA,IAAI,CAAC,eAAL,GAAuB,IAAvB;AACA,QAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,yBAAvB;AACH,OAPD;AAUA,WAAK,UAAL,CAAgB,KAAhB,CAAsB;AAClB,QAAA,GAAG,EAAE,KAAK,SAAL,GAAiB,sBAAjB,GAA0C,MAD7B;AAElB,QAAA,MAAM,EAAE;AAFU,OAAtB,EAGG,IAHH,CAGS,GAAD,IAAQ;AACZ;;;;;;;AAOA;;;;;;;;;;;AAahB;;AACoB;;;;;;;;;;AAUA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACgB;AACH,OAhED,EAgEG;;AACH;;;;AAjEA,OAqEK,KArEL,CAqEW,GAAG,IAAG;AACT;AACA,YAAI,GAAG,CAAC,IAAJ,KAAa,sBAAjB,EAAyC;AACrC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kBAAlC,EAAsD,GAAtD;AACA,UAAA,IAAI,CAAC,SAAL,CAAe,SAAf;AACA;AACH;;AAED,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,cAAlC,EAAkD,GAAlD;AACH,OA9EL;AA+EH,KAz6BD;AA06BH;;AAx9BD,MAAI,WAAJ,GAAe;AACX,WAAO,KAAK,YAAZ;AACH;;AAw9BD,EAAA,KAAK,CAAC,QAAD,EAAS;AACV,QAAI,IAAI,GAAG,IAAX;AACA,SAAK,UAAL,GAAkB,KAAlB;AAEA,WAAO,IAAI,OAAJ,CAAY,UAAU,OAAV,EAAmB,MAAnB,EAAyB;AACxC,UAAI;AACA,YAAI,QAAJ,EAAc;AACV,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,sBAAlC,EAA0D,IAAI,CAAC,IAA/D;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,qBAAjC,EAAwD,IAAI,CAAC,QAA7D;AACH,SAHD,MAGO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,kDAAjC;AACH;;AACD,QAAA,IAAI,CAAC,cAAL,GAAsB,KAAtB;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,QAAf;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,OAAlB,CATA,CAS2B;;AAC3B,QAAA,OAAO;AACV,OAXD,CAWE,OAAO,GAAP,EAAY;AACV,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAfM,CAAP;AAgBH;;AAED,EAAA,MAAM,CAAC,OAAD,EAAU,OAAV,EAAiB;AACnB,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,UAAU,OAAV,EAAiB;AAChC,MAAA,IAAI,CAAC,mBAAL,GAA2B,EAA3B;AACA,MAAA,IAAI,CAAC,YAAL,CAAkB,IAAlB,CAAuB,eAAvB,EAAwC,SAAS,gBAAT,GAAyB;AAC7D,QAAA,IAAI,CAAC,YAAL,CAAkB,cAAlB,CAAiC,eAAjC,EAAkD,gBAAlD;AACA,QAAA,OAAO;AACV,OAHD;;AAIA,UAAI,IAAI,CAAC,OAAT,EAAkB;AACd,QAAA,IAAI,CAAC,MAAL,GAAc,OAAO,CAAC,MAAtB;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,OAAO,CAAC,OAAvB;AACA,QAAA,IAAI,CAAC,YAAL,GAAoB,OAAO,CAAC,YAA5B;AACA,QAAA,IAAI,CAAC,MAAL,GAAc,OAAO,CAAC,EAAtB;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,IAAI,CAAC,SAAL,CAAe,4BAAf,CAA4C,IAAI,CAAC,MAAjD,EAAyD,IAAI,CAAC,iBAA9D,CAAf;AACA,QAAA,IAAI,CAAC,GAAL,GAAW,OAAO,CAAC,MAAnB;AAEA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kCAArC,EAAyE,IAAI,CAAC,MAA9E,EAAsF,cAAtF,EAAsG,IAAI,CAAC,OAA3G;AAEA,QAAA,IAAI,CAAC,cAAL,GAAsB,IAAI,gBAAA,CAAA,cAAJ,CAAmB,IAAnB,CAAtB;AAEA,QAAA,IAAI,CAAC,mBAAL,GAA2B,CACvB,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,IAAL,GAAY,GAAZ,GAAkB,IAAI,CAAC,cAAL,CAAoB,MAAvD,EAA+D,IAAI,CAAC,cAAL,CAAoB,eAAnF,CADuB,EAEvB,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,IAAL,GAAY,GAAZ,GAAkB,IAAI,CAAC,cAAL,CAAoB,MAAvD,EAA+D,IAAI,CAAC,cAAL,CAAoB,eAAnF,CAFuB,EAGvB,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,IAAL,GAAY,GAAZ,GAAkB,IAAI,CAAC,cAAL,CAAoB,SAAvD,EAAkE,IAAI,CAAC,cAAL,CAAoB,kBAAtF,CAHuB,CAA3B;AAMA,QAAA,IAAI,CAAC,oBAAL,CAA0B,OAA1B;AACA,QAAA,IAAI,CAAC,mBAAL,CAAyB,IAAzB,CAA8B,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,IAAL,GAAY,GAAZ,GAAkB,IAAI,CAAC,cAAL,CAAoB,SAAvD,EAAkE,IAAI,CAAC,UAAL,CAAgB,kBAAlF,CAA9B;AACA,QAAA,IAAI,CAAC,mBAAL,CAAyB,IAAzB,CAA8B,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,IAAL,GAAY,GAAZ,GAAkB,IAAI,CAAC,cAAL,CAAoB,QAAvD,EAAiE,IAAI,CAAC,UAAL,CAAgB,iBAAjF,CAA9B;AAEA,QAAA,IAAI,CAAC,qBAAL,GAtBc,CAuBd;AACH,OAxBD,MAwBO;AACH,QAAA,OAAO;AACV;AACJ,KAjCM,CAAP;AAkCH;;AAED,EAAA,IAAI,CAAC,SAAD,EAAU;AACV,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,UAAU,OAAV,EAAiB;AAChC,UAAI;AACA,QAAA,IAAI,CAAC,MAAL,GAAc,EAAd;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,EAAf;AACA,QAAA,IAAI,CAAC,YAAL,GAAoB,EAApB;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,EAAf;AACA,QAAA,IAAI,CAAC,MAAL,GAAc,EAAd;AACA,QAAA,IAAI,CAAC,eAAL,GAAuB,IAAvB;;AACA,YAAI,IAAI,CAAC,OAAL,IAAgB,SAApB,EAA+B;AAC3B,UAAA,IAAI,CAAC,aAAL;AAEA,iBAAO,IAAI,CAAC,cAAZ;AACA,UAAA,IAAI,CAAC,cAAL,GAAsB,IAAtB;;AAEA,cAAI,IAAI,CAAC,mBAAT,EAA8B;AAC1B,YAAA,IAAI,CAAC,mBAAL,CAAyB,OAAzB,CAAkC,KAAD,IAAW,MAAM,CAAC,WAAP,CAAmB,KAAnB,CAA5C;AACH;;AACD,UAAA,IAAI,CAAC,mBAAL,GAA2B,EAA3B;AAEA,UAAA,IAAI,CAAC,UAAL,GAAkB,IAAlB,CAX2B,CAa3B;;AACA,cAAI,IAAI,CAAC,SAAT,EAAoB;AAChB,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,sCAAlC;AACA,YAAA,IAAI,CAAC,SAAL,CAAe,IAAf;AACA,YAAA,IAAI,CAAC,SAAL,GAAiB,IAAjB;AACH,WAlB0B,CAoB3B;;;AACA,cAAI,IAAI,CAAC,UAAT,EAAqB;AACjB,gBAAI,MAAM,GAAG,GAAG,CAAC,UAAD,EAAa;AACzB;AACA,cAAA,IAAI,EAAE;AAFmB,aAAb,EAGb,GAAG,CAAC,GAAD,EAAM;AAAC,uBAAS,gBAAgB,CAAC;AAA3B,aAAN,CAHU,CAAhB;AAIA,YAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,MAAb,CAAjB;AACA,YAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,MAAf,CAAjB;AAEA,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,oDAArC,EAA2F,MAAM,CAAC,IAAP,GAAc,QAAd,EAA3F;AACA,YAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB;AAEA,YAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,GAAuB,IAAvB,CAA4B,MAAK;AAC7B,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,6BAAlC;AACA,cAAA,IAAI,CAAC,UAAL,GAAkB,IAAlB;AACA,cAAA,OAAO;AACV,aAJD,EAIG,KAJH,CAIU,GAAD,IAAQ;AACb,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,uBAAlC;AACA,cAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,0BAA1C,EAAsE,GAAtE;AACA,cAAA,OAAO;AACV,aARD;AASH,WApBD,MAoBO;AACH,YAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,wBAAlC;AACA,YAAA,OAAO;AACV;AACJ,SA7CD,MA6CO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,wBAAlC;AACA,UAAA,OAAO;AACV;AACJ,OAxDD,CAwDE,OAAO,GAAP,EAAY;AACV,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,uBAAlC;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,0BAA1C,EAAsE,GAAtE;AACA,QAAA,OAAO;AACV;AACJ,KA9DM,CAAP;AA+DH;;AAED,EAAA,qBAAqB,CAAC,cAAc,GAAG,KAAlB,EAAuB;AACxC,QAAK,KAAK,SAAL,IAAkB,CAAC,cAApB,IAAwC,KAAK,SAAL,IAAkB,KAAK,SAAL,CAAe,cAA7E,EAA8F;AAC1F;AACH;;AACD,SAAK,aAAL;;AACA,QAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,WAAK,SAAL,GAAiB,UAAU,CAAC,MAAK;AAC7B,aAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,oDAAT,GAAgE,cAAc,GAAG,IAAjF,GAAwF,WAAhH,EAD6B,CAE7B;;AACA,aAAK,SAAL,GAAiB,UAAU,CAAC,MAAK;AAC7B,eAAK,SAAL,GAAiB,IAAjB;AACA,eAAK,UAAL,CAAgB,MAAhB,IAA0B,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,EAA1B;AACH,SAH0B,EAGxB,qBAHwB,CAA3B;AAIA,aAAK,QAAL;AACH,OAR0B,EAQxB,cARwB,CAA3B;AASH;AACJ;;AAED,EAAA,aAAa,GAAA;AACT,QAAI,KAAK,SAAT,EAAoB;AAChB,MAAA,YAAY,CAAC,KAAK,SAAN,CAAZ;AACA,WAAK,SAAL,GAAiB,IAAjB;AACH;;AACD,QAAI,KAAK,SAAT,EAAoB;AAChB,MAAA,YAAY,CAAC,KAAK,SAAN,CAAZ;AACA,WAAK,SAAL,GAAiB,IAAjB;AACH;AACJ;;AAED,EAAA,WAAW,CAAC,IAAD,EAAO,MAAP,EAAa;AACpB,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,MAAM,GAAG,GAAG,CAAC,UAAD,EAAa;AAAC,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAAP,OAAb,CAAhB;;AAEA,UAAI,KAAK,eAAT,EAA0B;AACtB,aAAK,eAAL,GAAuB,KAAvB;AACA,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,aAAD,EACb;AAAC,UAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,SADa,EAEb,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,KAAK,aAAnB,CAFU,EAGb,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,KAAK,MAApB,CAHU,CAAjB;AAIH;;AAED,MAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,UAAD,EAAa,EAAb,EAAiB,GAAjB,CAAjB;;AAEA,UAAI,IAAI,IAAI,IAAI,KAAK,QAArB,EAA+B;AAC3B,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,IAAb,CAAjB;AACH;;AAED,UAAI,MAAM,KAAK,CAAC,IAAD,IAAS,IAAI,KAAK,QAAvB,CAAV,EAA4C;AACxC,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,MAAf,CAAjB;AACH,OAFD,MAEO,IAAI,MAAJ,EAAY;AACf,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,MAAf,CAAjB;AACH;;AACD,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,+BAAjC;AACA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,+BAArC,EAAsE,MAAM,CAAC,QAAP,EAAtE;AACA,aAAO,KAAK,UAAL,CAAgB,IAAhB,CAAqB,MAArB,CAAP;AACH,KAzBD,MAyBO;AACH,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,qCAAjC;AACA,aAAO,OAAO,CAAC,OAAR,EAAP;AACH;AACJ,GAhsCY,CAksCb;;;AACA,EAAA,YAAY,GAAA;AACR,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,gBAAQ,KADW;AAEnB,QAAA,EAAE,EAAE;AAFe,OAAP,EAGb,GAAG,CAAC,QAAD,EAAW;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,OAAX,CAHU,CAAhB;AAIA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,gCAArC,EAAuE,MAAM,CAAC,QAAP,EAAvE;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,qBAAlC;AACA,UAAA,OAAO;AACV,SAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SALD;AAMH,OAPM,CAAP;AAQH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,sCAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,eAAe,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,WAAvC,EAAkD;AAC7D,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,IAAI,CAAC,OAAT,EAAkB;AACd,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT;;AAEA,UAAI,CAAC,IAAI,CAAC,gCAAN,IAA0C,IAAI,CAAC,MAAL,IAAe,GAA7D,EAAkE;AAC9D,eAAO,OAAO,CAAC,MAAR,CAAe,oDAAoD,IAAI,CAAC,MAAxE,CAAP;AACH,OALa,CAOd;;;AACA,MAAA,GAAG,GAAG,IAAI,CAAC,SAAL,CAAe,qBAAf,CAAqC,GAArC,CAAN;AAEA,UAAI,MAAM,GAAG,GAAG,CAAC,SAAD,EAAY;AACxB;AACA;AACA,cAAM,GAHkB;AAIxB,iBAAS,gBAAgB,CAAC,eAJF;AAKxB,gBAAQ,SALgB;AAMxB,cAAM;AANkB,OAAZ,EAOb,GAAG,CAAC,MAAD,EAAS;AACX,oBAAY;AADD,OAAT,EAEH,OAFG,CAPU,EASH,GAAG,CAAC,SAAD,EAAY;AACpB,iBAAS,gBAAgB,CAAC;AADN,OAAZ,EAET,GAAG,CAAC,QAAD,EAAW;AACb,iBAAS,gBAAgB,CAAC;AADb,OAAX,CAFM,CATA,CAAhB;AAgBA,UAAI,aAAa,GAAG,IAApB;AACA,UAAI,eAAe,GAAG,IAAtB;;AACA,UAAK,WAAL,EAAmB;AACf,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,aAAD,EAAgB;AAAE,mBAAS,WAAW,CAAC,IAAZ,CAAiB,OAAjB;AAAX,SAAhB,EAAyD,WAAW,CAAC,EAArE,CAAjB;AACA,QAAA,aAAa,GAAG,WAAW,CAAC,EAA5B;AACA,QAAA,eAAe,GAAG,WAAW,CAAC,IAA9B;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kCAArC,EAAyE,MAAzE;AACH;;AAGD,UAAI,OAAJ,EAAa;AACT,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,SAAD,EAAY;AACzB,sBAAY;AADa,SAAZ,EAEd,OAFc,CAAjB;AAGH;;AAED,UAAI,OAAO,IAAI,OAAO,CAAC,OAAvB,EAAgC;AAC5B,YAAI,WAAW,GAAG,OAAO,CAAC,IAAR,IAAgB,eAAlC;AACA,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,SAAD,EAAY;AACzB,kBAAQ,WADiB;AAEzB,mBAAS,gBAAgB,CAAC;AAFD,SAAZ,EAGd,OAAO,CAAC,OAHM,CAAjB;AAIH;;AAED,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,oCAArC,EAA2E,MAAM,CAAC,QAAP,EAA3E;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,wBAAlC;AACA,UAAA,OAAO,CAAC;AAAC,YAAA,IAAI,EAAE,KAAK,MAAZ;AAAoB,YAAA,EAAE,EAAE,GAAxB;AAA6B,YAAA,IAAI,EAAE,MAAnC;AAA2C,YAAA,EAAE,EAAE,EAA/C;AAAmD,YAAA,IAAI,EAAE,IAAI,IAAJ,EAAzD;AAAqE,YAAA,OAAO,EAAE;AAA9E,WAAD,CAAP;AACH,SAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SALD;AAMH,OAPM,CAAP;AAQH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,yCAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,uBAAuB,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,WAAvC,EAAoD,SAApD,EAA6D;AAChF,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,IAAI,CAAC,OAAT,EAAkB;AAEd,UAAI,CAAC,IAAI,CAAC,gCAAN,IAA0C,IAAI,CAAC,MAAL,IAAe,GAA7D,EAAkE;AAC9D,eAAO,OAAO,CAAC,MAAR,CAAe,oDAAoD,IAAI,CAAC,MAAxE,CAAP;AACH;;AAED,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT,CANc,CAO1B;AACA;;AACY,UAAI,MAAM,GAAG,GAAG,CAAC,SAAD,EAAY;AACxB,iBAAS,eADe;AAExB,oBAAY,IAFY;AAGxB,cAAM,GAHkB;AAIzB;AACC,gBAAQ,cALgB;AAMxB,cAAM;AANkB,OAAZ,EAOb,GAAG,CAAC,MAAD,EAAS;AACX,oBAAY;AADD,OAAT,EAEH,OAFG,CAPU,EASH,GAAG,CAAC,SAAD,EAAY;AACpB,iBAAS,gBAAgB,CAAC;AADN,OAAZ,EAET,GAAG,CAAC,QAAD,EAAW;AACb,iBAAS,gBAAgB,CAAC;AADb,OAAX,CAFM,CATA,CAAhB;;AAgBA,UAAI,OAAJ,EAAa;AACT,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,SAAD,EAAY;AACzB,sBAAY;AADa,SAAZ,EAEd,OAFc,CAAjB;AAGH;;AAED,UAAI,aAAa,GAAG,IAApB;AACA,UAAI,eAAe,GAAG,IAAtB;;AACA,UAAK,WAAL,EAAmB;AACf,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,aAAD,EAAgB;AAAE,mBAAS,WAAW,CAAC,IAAZ,CAAiB,OAAjB;AAAX,SAAhB,EAAyD,WAAW,CAAC,EAArE,CAAjB,EAA2F,SAA3F;AACA,QAAA,aAAa,GAAG,WAAW,CAAC,EAA5B;AACA,QAAA,eAAe,GAAG,WAAW,CAAC,IAA9B;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,0CAArC,EAAiF,MAAjF;AACH;;AAED,UAAI,OAAO,IAAI,OAAO,CAAC,OAAvB,EAAgC;AAC5B,YAAI,WAAW,GAAG,OAAO,CAAC,IAAR,IAAgB,eAAlC;AACA,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,SAAD,EAAY;AACzB,kBAAQ,WADiB;AAEzB,mBAAS,gBAAgB,CAAC;AAFD,SAAZ,EAGd,OAAO,CAAC,OAHM,CAAjB;AAIH;;AAED,UAAI,SAAJ,EAAe;AACX,YAAI,KAAK,CAAC,OAAN,CAAc,SAAd,KAA4B,SAAS,CAAC,MAAV,GAAmB,CAAnD,EAAsD;AAClD,cAAI,QAAQ,GAAG,GAAG,CAAC,SAAD,EAAY;AAAC,qBAAS,gBAAgB,CAAC;AAA3B,WAAZ,EAAqD,SAArD,CAAlB;AACA,UAAA,SAAS,CAAC,OAAV,CAAkB,UAAU,YAAV,EAAsB;AACpC,YAAA,QAAQ,CAAC,MAAT,CAAgB,GAAG,CAAC,KAAD,EAAQ,EAAR,EAAY,YAAZ,CAAnB,EAA8C,SAA9C;AACH,WAFD;AAGA,UAAA,MAAM,CAAC,MAAP,CAAc,QAAd,EAAwB,SAAxB;AACH,SAND,MAMO,IAAI,OAAO,SAAP,KAAqB,QAArB,IAAiC,SAAS,YAAY,MAA1D,EAAkE;AACrE,cAAI,QAAQ,GAAG,GAAG,CAAC,SAAD,EAAY;AAAC,qBAAS,gBAAgB,CAAC;AAA3B,WAAZ,EAAqD,SAArD,CAAlB;AACA,UAAA,QAAQ,CAAC,MAAT,CAAgB,GAAG,CAAC,KAAD,EAAQ,EAAR,EAAY,SAAZ,CAAnB,EAA2C,SAA3C;AACA,UAAA,MAAM,CAAC,MAAP,CAAc,QAAd,EAAwB,SAAxB;AACH;AACJ;;AAED,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,4CAArC,EAAmF,MAAM,CAAC,QAAP,EAAnF;AAEA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,gCAAlC;AACA,UAAA,OAAO,CAAC;AACJ,YAAA,IAAI,EAAE,KAAK,MADP;AAEJ,YAAA,EAAE,EAAE,GAFA;AAGJ,YAAA,IAAI,EAAE,WAHF;AAIJ,YAAA,EAAE,EAAE,EAJA;AAKJ,YAAA,IAAI,EAAE,IAAI,IAAJ,EALF;AAMJ,YAAA,OAAO,EAAE,OANL;AAOJ,YAAA,OAAO,EAAE,OAPL;AAQJ,YAAA,OAAO,EAAE,OARL;AASJ,YAAA,IAAI,EAAE,IATF;AAUJ,YAAA,WAAW,EAAE;AAVT,WAAD,CAAP;AAYH,SAdD,EAcG,KAdH,CAcU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAhBD;AAiBH,OAlBM,CAAP;AAmBH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,iDAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP,CAxFgF,CA0FhF;AAEH;;AAEK,EAAA,wBAAwB,CAAC,YAAD,EAAe,eAAf,EAAgC,IAAhC,EAAsC,SAAtC,EAAiD,IAAjD,EAAqD;;AAC/E,UAAI,IAAI,GAAG,IAAX,C,CACR;;AAEQ;;;;;AAMA;;AAEA,UAAI,WAAW,GAAG,IAAlB,C,CACA;;AACA,UAAI,eAAe,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAtB;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,iDAAT,GAA6D,eAAtF,E,CAEA;;AACA,UAAI,YAAY,CAAC,IAAb,KAAsB,cAAA,CAAA,YAAA,CAAa,IAAb,CAAkB,UAA5C,EAAwD;AACpD,YAAI,EAAE,GAAG,YAAY,CAAC,EAAtB,CADoD,CAC1B;;AAC1B,QAAA,WAAW,GAAG,GAAG,CAAC,SAAD,EAAY;AAAC,UAAA,EAAE,EAAE,EAAL;AAAS,UAAA,IAAI,EAAE,MAAf;AAAuB,UAAA,EAAE,EAAE,eAA3B;AAA4C,sBAAY;AAAxD,SAAZ,EACb,GAAG,CAAC,MAAD,EAAS;AAAC,sBAAY;AAAb,SAAT,EAA6B,IAA7B,CADU,EAEb,GAAG,CAAC,SAAD,EAAY;AAAC,UAAA,EAAE,EAAE,SAAL;AAAgB,mBAAS,gBAAgB,CAAC;AAA1C,SAAZ,CAFU,EAGb,GAAG,CAAC,OAAD,EAAU;AAAC,mBAAS,gBAAgB,CAAC;AAA3B,SAAV,CAHU,EAIb,GAAG,CAAC,SAAD,EAAY;AAAC,mBAAS,gBAAgB,CAAC;AAA3B,SAAZ,CAJU,EAKb,GAAG,CAAC,QAAD,EAAW;AAAC,mBAAS,gBAAgB,CAAC;AAA3B,SAAX,CALU,CAAjB;AAOH,OATD,CAUA;AAVA,WAWK;AACD,UAAA,WAAW,GAAG,GAAG,CAAC,SAAD,EAAY;AAAC,YAAA,EAAE,EAAE,YAAY,CAAC,MAAb,CAAoB,GAAzB;AAA8B,YAAA,IAAI,EAAE,WAApC;AAAiD,YAAA,EAAE,EAAE;AAArD,WAAZ,EACb,GAAG,CAAC,MAAD,EAAS;AAAC,wBAAY;AAAb,WAAT,EAA6B,IAA7B,CADU,EAEb,GAAG,CAAC,SAAD,EAAY;AAAC,YAAA,EAAE,EAAE,SAAL;AAAgB,qBAAS,gBAAgB,CAAC;AAA1C,WAAZ,CAFU,EAGb,GAAG,CAAC,OAAD,EAAU;AAAC,qBAAS,gBAAgB,CAAC;AAA3B,WAAV,CAHU,EAIb,GAAG,CAAC,SAAD,EAAY;AAAC,qBAAS,gBAAgB,CAAC;AAA3B,WAAZ,CAJU,EAKb,GAAG,CAAC,QAAD,EAAW;AAAC,qBAAS,gBAAgB,CAAC;AAA3B,WAAX,CALU,CAAjB;AAOH,S,CAED;;;AACA,UAAI,CAAC,eAAL,EAAsB;AAClB,eAAO,IAAP;AACH;AACD;;;;;;;;AAUA;;;AACA,MAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,WAArB;AAEA,aAAO,eAAP;AACH,K;AAAA;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAQ;AACrB,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,UAAU,GAAG,GAAG,CAAC,SAAD,EAAY;AAC5B,cAAM,OAAO,CAAC,OADc;AAE5B;AACA,gBAAQ;AAHoB,OAAZ,EAIjB,GAAG,CAAC,UAAD,EAAa;AACf,iBAAS,gBAAgB,CAAC,iBADX;AAEf,iBAAS,MAFM;AAGf,kBAAU,QAHK;AAIf,cAAM,OAAO,CAAC;AAJC,OAAb,CAJc,CAApB;AAWA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,sCAArC,EAA6E,UAAU,CAAC,IAAX,GAAkB,QAAlB,EAA7E;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,UAArB,EAAiC,IAAjC,CAAsC,MAAK;AACvC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,0BAAlC;AACA,UAAA,OAAO;AACV,SAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,4BAAlC;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,8BAA1C,EAA0E,GAA1E;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAPD;AAQH,OATM,CAAP;AAUH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,2CAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,yBAAyB,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,cAArB,EAAmC;AACxD,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,IAAI,CAAC,OAAT,EAAkB;AACd,UAAI,CAAC,IAAI,CAAC,gCAAN,IAA0C,IAAI,CAAC,MAAL,IAAe,GAA7D,EAAkE;AAC9D,eAAO,OAAO,CAAC,MAAR,CAAe,oDAAoD,IAAI,CAAC,MAAxE,CAAP;AACH;;AAED,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT,CALc,CAOd;;AACA,MAAA,GAAG,GAAG,IAAI,CAAC,SAAL,CAAe,qBAAf,CAAqC,GAArC,CAAN,CARc,CAUd;;AACA,UAAI,GAAG,GAAG,wCAAwC,cAAc,CAAC,EAAjE;AAEA,UAAI,MAAM,GAAG,GAAG,CAAC,SAAD,EAAY;AACrB;AACC,cAAM,GAFc;AAGpB,iBAAS,gBAAgB,CAAC,eAHN;AAIpB,gBAAQ,SAJY;AAKpB,cAAM;AALc,OAAZ,EAMT,GAAG,CAAC,MAAD,EAAS;AACX,oBAAY;AADD,OAAT,EAEH,OAFG,CANM,EAQC,GAAG,CAAC,SAAD,EAAY;AACxB,iBAAS,gBAAgB,CAAC;AADF,OAAZ,EAEb,GAAG,CAAC,QAAD,EAAW;AACb,iBAAS,gBAAgB,CAAC;AADb,OAAX,CAFU,CARJ,EAaT,GAAG,CAAC,GAAD,EAAM;AACR,iBAAS,gBAAgB,CAAC;AADlB,OAAN,EAEH,GAAG,CAAC,KAAD,EAAQ,EAAR,EAAY,GAAZ,CAFA,EAGJ,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,cAAc,CAAC,QAA5B,CAHC,EAIJ,GAAG,CAAC,UAAD,EAAa,EAAb,EAAiB,cAAc,CAAC,QAAhC,CAJC,EAKJ,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,cAAc,CAAC,IAA5B,CALC,CAbM,EAoBV,GAAG,CAAC,OAAD,EAAU;AACX,iBAAS,gBAAgB,CAAC;AADf,OAAV,CApBO,CAAhB;AAyBA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,8CAArC,EAAqF,MAAM,CAAC,QAAP,EAArF;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CACC,UADL,CAEK,IAFL,CAEU,MAFV,EAEkB,IAFlB,CAEuB,MAAK;AACxB,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kCAAlC;AACA,UAAA,OAAO,CAAC;AAAC,YAAA,IAAI,EAAE,KAAK,MAAZ;AAAoB,YAAA,EAAE,EAAE,GAAxB;AAA6B,YAAA,IAAI,EAAE,MAAnC;AAA2C,YAAA,EAAE,EAAE,EAA/C;AAAmD,YAAA,IAAI,EAAE,IAAI,IAAJ,EAAzD;AAAqE,YAAA,OAAO,EAAE;AAA9E,WAAD,CAAP;AACH,SALD,EAKG,KALH,CAKU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAPD;AAQH,OATM,CAAP;AAUH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,mDAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,iCAAiC,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,cAArB,EAAmC;AAChE,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,IAAI,CAAC,OAAT,EAAkB;AAEd,UAAI,CAAC,IAAI,CAAC,gCAAN,IAA0C,IAAI,CAAC,MAAL,IAAe,GAA7D,EAAkE;AAC9D,eAAO,OAAO,CAAC,MAAR,CAAe,oDAAoD,IAAI,CAAC,MAAxE,CAAP;AACH;;AAED,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT,CANc,CAQd;;AACA,MAAA,GAAG,GAAG,IAAI,CAAC,SAAL,CAAe,qBAAf,CAAqC,GAArC,CAAN,CATc,CAWd;;AACA,UAAI,GAAG,GAAG,wCAAwC,cAAc,CAAC,EAAjE;AAEA,UAAI,MAAM,GAAG,GAAG,CAAC,SAAD,EAAY;AACpB;AACA,cAAM,GAFc;AAGpB,iBAAS,gBAAgB,CAAC,eAHN;AAIpB,gBAAQ,cAJY;AAKpB,cAAM;AALc,OAAZ,EAMT,GAAG,CAAC,MAAD,EAAS;AACX,oBAAY;AADD,OAAT,EAEH,OAFG,CANM,EAQC,GAAG,CAAC,SAAD,EAAY;AACxB,iBAAS,gBAAgB,CAAC;AADF,OAAZ,EAEb,GAAG,CAAC,QAAD,EAAW;AACb,iBAAS,gBAAgB,CAAC;AADb,OAAX,CAFU,CARJ,EAaT,GAAG,CAAC,GAAD,EAAM;AACR,iBAAS,gBAAgB,CAAC;AADlB,OAAN,EAEH,GAAG,CAAC,KAAD,EAAQ,EAAR,EAAY,GAAZ,CAFA,EAGJ,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,cAAc,CAAC,QAA5B,CAHC,EAIJ,GAAG,CAAC,UAAD,EAAa,EAAb,EAAiB,cAAc,CAAC,QAAhC,CAJC,EAKJ,GAAG,CAAC,MAAD,EAAS,EAAT,EAAa,cAAc,CAAC,IAA5B,CALC,CAbM,EAoBV,GAAG,CAAC,OAAD,EAAU;AACX,iBAAS,gBAAgB,CAAC;AADf,OAAV,CApBO,CAAhB;AAyBA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,sDAArC,EAA6F,MAAM,CAAC,QAAP,EAA7F;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,0CAAlC;AACA,UAAA,OAAO,CAAC;AAAC,YAAA,IAAI,EAAE,KAAK,MAAZ;AAAoB,YAAA,EAAE,EAAE,GAAxB;AAA6B,YAAA,IAAI,EAAE,MAAnC;AAA2C,YAAA,EAAE,EAAE,EAA/C;AAAmD,YAAA,IAAI,EAAE,IAAI,IAAJ,EAAzD;AAAqE,YAAA,OAAO,EAAE;AAA9E,WAAD,CAAP;AACH,SAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SALD;AAMH,OAPM,CAAP;AAQH;;AAED,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,2DAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,iBAAiB,CAAC,YAAD,EAAe,aAAf,EAA4B;AACzC,QAAI,IAAI,GAAG,IAAX;AACA,QAAI,KAAK,GAAI,aAAD,GAAkB,WAAlB,GAAgC,QAA5C;;AACA,QAAI,KAAK,OAAT,EAAkB;AAEd,UAAI,GAAG,GAAG,YAAY,CAAC,EAAvB;AACA,UAAI,IAAI,GAAG,MAAX,CAHc,CAKd;;AACA,UAAI,YAAY,CAAC,IAAb,KAAsB,cAAA,CAAA,YAAA,CAAa,IAAb,CAAkB,UAA5C,EAAwD;AACpD;AACA,QAAA,IAAI,GAAG,MAAP;AACH,OAHD,CAIA;AAJA,WAKK;AACD,UAAA,IAAI,GAAG,WAAP;AACH;;AAED,UAAI,UAAU,GAAG,GAAG,CAAC,SAAD,EAAY;AAC5B,cAAM,GADsB;AAE5B,gBAAQ,IAFoB;AAG5B,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAHsB,OAAZ,EAIjB,GAAG,CAAC,KAAD,EAAQ;AACV,iBAAS,gBAAgB,CAAC;AADhB,OAAR,CAJc,CAApB;AAQA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,sCAArC,EAA6E,UAAU,CAAC,IAAX,GAAkB,QAAlB,EAA7E;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,UAArB,EAAiC,IAAjC,CAAsC,MAAK;AACvC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,0BAAlC;AACA,UAAA,OAAO;AACV,SAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SALD;AAMH,OAPM,CAAP;AAQH;;AACD,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,2CAAjC;AACA,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACH;;AAED,EAAA,UAAU,GAAA;AACN,QAAI,IAAI,GAAG,IAAX,CADM,CAEN;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf,EADa;AAEnB,gBAAQ;AAFW,OAAP,EAGb,GAAG,CAAC,OAAD,EAAU;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,OAAV,CAHU,CAAhB;AAKA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kCAArC,EAAyE,MAAM,CAAC,QAAP,EAAzE;AACA,WAAK,UAAL,CAAgB,IAAhB,CAAqB,MAArB;AACH,KARD,MAQO;AACH,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,oCAAjC;AACH;AACJ;AAED;;AACA;;AACA;;;AACM,EAAA,gBAAgB,CAAE,OAAF,EAAS;;AAC3B,UAAI,IAAI,GAAG,IAAX,C,CACA;;AACA,UAAI,OAAO,CAAC,SAAR,KAAsB,IAAtB,IAA8B,OAAO,CAAC,SAAR,KAAsB,MAAxD,EAAgE;AAC5D;AACH,O,CAED;;;AACA,YAAM,IAAI,CAAC,uBAAL,CAA6B,OAAO,CAAC,GAArC,CAAN;AACA,YAAM,IAAI,CAAC,uBAAL,CAA6B,OAAO,CAAC,MAArC,CAAN;AAEA;AACH,K;AAAA;;AAEK,EAAA,uBAAuB,CAAE,GAAF,EAAK;;AAC9B,UAAI,IAAI,GAAG,IAAX;AACA,WAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,yDAAlC,EAA6F,GAA7F;AACA,UAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,QAAA,IAAI,EAAE,KADa;AAEnB,QAAA,EAAE,EAAE,IAAI,CAAC,OAAL,GAAe,QAFA;AAGnB,QAAA,KAAK,EAAE,gBAAgB,CAAC,eAHL;AAInB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJa,OAAP,EAKb,GAAG,CAAC,gBAAD,EAAmB;AAAC,iBAAS,gBAAgB,CAAC;AAA3B,OAAnB,CALU,CAAhB;AAOA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kCAArC,EAAyE,MAAM,CAAC,IAAP,GAAc,QAAd,EAAzE;AACA,aAAO,KAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,CAAP;AACH,K;AAAA;;AAED,EAAA,yBAAyB,CAAC,GAAD,EAAI;AACzB,QAAI,IAAI,GAAG,IAAX;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT;;AAEA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,MAAM,GAAG,GAAG,CAAC,UAAD,EAAa;AACzB,cAAM,EADmB;AAEzB,QAAA,EAAE,EAAE,GAAG,GAAG,GAAN,GAAY,KAAK;AAFI,OAAb,EAGb,GAAG,CAAC,GAAD,EAAM;AAAC,iBAAS,gBAAgB,CAAC;AAA3B,OAAN,CAAH,CAAmD,MAAnD,CAA0D,GAAG,CAAC,SAAD,EAAY;AAAC,QAAA,QAAQ,EAAE;AAAX,OAAZ,CAA7D,CAHa,CAAhB;;AAKA,UAAI,KAAK,eAAT,EAA0B;AACtB,aAAK,eAAL,GAAuB,KAAvB;AACA,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,aAAD,EACb;AAAC,UAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,SADa,EAEb,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,KAAK,aAAnB,CAFU,EAGb,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,KAAK,MAApB,CAHU,CAAjB;AAIA,QAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,UAAD,EAAa,EAAb,EAAiB,GAAjB,CAAjB;AACH;;AAED,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,8CAArC,EAAqF,MAAM,CAAC,IAAP,GAAc,QAAd,EAArF;AACA,aAAO,KAAK,UAAL,CAAgB,IAAhB,CAAqB,MAArB,CAAP;AACH,KAjBD,MAiBO;AACH,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,mDAAjC;AACA,aAAO,OAAO,CAAC,OAAR,EAAP;AACH;AACJ;;AAED,EAAA,6BAA6B,CAAC,GAAD,EAAI;AAC7B,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT;AAEA,UAAI,MAAM,GAAG,GAAG,CAAC,UAAD,EAAa;AACzB,cAAM,EADmB;AAEzB,QAAA,EAAE,EAAE,GAAG,GAAG,GAAN,GAAY,KAAK,OAFI;AAGzB,QAAA,IAAI,EAAE;AAHmB,OAAb,EAIb,GAAG,CAAC,GAAD,EAAM;AAAC,iBAAS,gBAAgB,CAAC;AAA3B,OAAN,CAJU,CAAhB;AAMA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kDAArC,EAAyF,MAAM,CAAC,IAAP,GAAc,QAAd,EAAzF;AACA,WAAK,UAAL,CAAgB,IAAhB,CAAqB,MAArB;AACH,KAXD,MAWO;AACH,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,uDAAjC;AACH;AACJ;;AAED,EAAA,cAAc,GAAA;AACV,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI,KAAK,OAAT,EAAkB;AACd,YAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,UAAA,IAAI,EAAE,KADa;AAEnB,UAAA,EAAE,EAAE,IAAI,CAAC,OAAL,GAAe,QAFA;AAGnB,UAAA,KAAK,EAAE,gBAAgB,CAAC,eAHL;AAInB,gBAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJa,SAAP,EAKb,GAAG,CAAC,gBAAD,EAAmB;AAAC,mBAAS,gBAAgB,CAAC;AAA3B,SAAnB,CALU,CAAhB;AAQA,aAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,kCAArC,EAAyE,MAAM,CAAC,IAAP,GAAc,QAAd,EAAzE;AACA,aAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,EAA+B,IAA/B,CAAqC,IAAD,IAAS;AACzC,cAAI,cAAc,GAAG;AACjB,wBAAY,EADK;AAEjB,yBAAa,EAFI;AAGjB,uBAAW;AAHM,WAArB;AAKA,cAAI,WAAW,GAAG;AAAC,wBAAY,EAAb;AAAiB,yBAAa,EAA9B;AAAkC,4BAAgB;AAAlD,WAAlB;AAEA,cAAI,WAAW,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,EAAiB,QAAnC;AACA,UAAA,WAAW,CAAC,OAAZ,CAAqB,IAAD,IAAS;AACzB,gBAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,kBAAI,QAAQ,GAAG,IAAI,CAAC,OAAL,EAAf;;AACA,kBAAI,QAAJ,EAAc;AACV,gBAAA,cAAc,CAAC,QAAD,CAAd,GAA2B,IAAI,CAAC,IAAL,EAA3B;AACH;AACJ;AACJ,WAPD;;AASA,cAAI,cAAc,CAAC,OAAnB,EAA4B;AACxB,gBAAI,QAAQ,GAAG,cAAc,CAAC,QAA9B;AACA,gBAAI,SAAS,GAAG,cAAc,CAAC,SAA/B;AACA,gBAAI,YAAY,GAAG,cAAc,CAAC,OAAlC;AACA,YAAA,WAAW,GAAG;AAAC,0BAAY,QAAb;AAAuB,2BAAa,SAApC;AAA+C,8BAAgB;AAA/D,aAAd;AACH;;AACD,UAAA,OAAO,CAAC,WAAD,CAAP;AACH,SAzBD;AA0BH,OApCD,MAoCO;AACH,QAAA,OAAO,CAAC,EAAD,CAAP;AACH;AACJ,KAxCM,CAAP;AAyCH;AAED;;;;;;;AAKM,EAAA,yBAAyB,CAAC,QAAD,EAAS;;AACpC;;;;;;;;;;AAUA,UAAI,IAAI,GAAG,IAAX,C,CACA;;AACA,UAAI,MAAM,GAAG,EAAb;AACA,UAAI,SAAS,GAAG,EAAhB,C,CAAoB;AACpB;;AAEA,UAAI,MAAM,GAAI,GAAG,CAAC,IAAD,EAAO;AACpB,gBAAQ,KAAK,MADO;AAEpB,gBAAQ,KAFY;AAGpB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAHc,OAAP,CAAjB;AAKA,UAAI,QAAQ,GAAG,GAAG,CAAC,OAAD,EAAU;AACxB,QAAA,KAAK,EAAE,gBAAgB,CAAC;AADA,OAAV,CAAlB;;AAIA,UAAI,MAAM,IAAI,SAAV,IAAuB,QAA3B,EAAqC;AACjC,YAAI,MAAM,GAAG,GAAG,CAAC,KAAD,EAAQ;AAAC,UAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,SAAR,CAAhB;;AACA,YAAI,MAAJ,EAAY;AACR,UAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,KAAD,EAAQ,EAAR,EAAY,MAAZ,CAAjB;AACH;;AAED,YAAI,QAAJ,EAAc;AACV,UAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,QAAd,CAAjB;AACH,SAFD,MAEO;AACH,UAAA,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,QAAD,EAAW,EAAX,EAAe,SAAf,CAAjB;AACH;;AACD,QAAA,QAAQ,CAAC,MAAT,CAAgB,MAAhB;AACH;;AACD,MAAA,MAAM,CAAC,MAAP,CAAc,QAAd;AAEA,aAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,CAAb;AACH,K;AAAA;;AAEK,EAAA,gBAAgB,CAAC,EAAD,EAAG;;AACrB,UAAI,IAAI,GAAG,IAAX;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,wCAAT,GAAoD,EAA5E,E,CACA;AACA;;AAEA,UAAI,OAAO,GAAG,GAAG,CAAC,IAAD,EAAO;AACpB,gBAAQ,KAAK,MADO;AAEpB,cAAM,KAAK,MAFS;AAGpB,gBAAQ,KAHY;AAIpB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJc,OAAP,CAAjB;AAOA,UAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,GAAG,CAAC,QAAD,EAAW;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC,gBAAzB;AAA2C,QAAA,OAAO,EAAE;AAApD,OAAX,CAAlB,CAAV;AAEA,aAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAb;AACH,K;AAAA;;AAEK,EAAA,wBAAwB,CAAC,GAAD,EAAI;;AAC9B,UAAI,IAAI,GAAG,IAAX;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,wDAAT,GAAoE,GAA5F,E,CACA;AACA;;AAEA,UAAI,OAAO,GAAG,GAAG,CAAC,IAAD,EAAO;AACpB,gBAAQ,IAAI,CAAC,MADO;AAEpB,cAAM,IAAI,CAAC,MAFS;AAGpB,gBAAQ,KAHY;AAIpB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJc,OAAP,CAAjB;AAOA,UAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,GAAG,CAAC,QAAD,EAAW;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC,gBAAzB;AAA2C,QAAA,IAAI,EAAE;AAAjD,OAAX,CAAlB,CAAV;AACA,aAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAb,C,CACA;AACH,K;AAAA;;AAEK,EAAA,iBAAiB,GAAA;;AACnB,UAAI,IAAI,GAAG,IAAX,C,CACA;AACA;;AACA,UAAI,KAAK,OAAT,EAAkB;AACd,YAAI,OAAO,GAAG,GAAG,CAAC,IAAD,EAAO;AACpB,kBAAQ,IAAI,CAAC,MADO;AAEpB,gBAAM,IAAI,CAAC,MAFS;AAGpB,kBAAQ,KAHY;AAIpB,gBAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJc,SAAP,CAAjB;AAOA,YAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,GAAG,CAAC,QAAD,EAAW;AAAC,UAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,SAAX,CAAlB,CAAV;AACA,eAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAb,CATc,CAUd;AACH,OAXD,MAWO;AACH,aAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,2CAAjC;AACA,eAAO,OAAO,CAAC,OAAR,EAAP;AACH;AACJ,K;AAAA;;AAEK,EAAA,iBAAiB,CAAC,EAAD,EAAG;;AACtB,UAAI,IAAI,GAAG,IAAX;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,0CAAT,GAAsD,EAA9E,E,CACA;AACA;;AAEA,UAAI,OAAO,GAAG,GAAG,CAAC,SAAD,EAAY;AACzB,gBAAQ,IAAI,CAAC,MADY;AAEzB,cAAM,IAAI,CAAC,MAFc;AAGzB,cAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAHmB,OAAZ,CAAjB;AAMA,UAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,GAAG,CAAC,MAAD,EAAS;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC,mBAAzB;AAA8C,QAAA,OAAO,EAAE;AAAvD,OAAT,CAAlB,CAAV;AAEA,aAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAb,C,CACA;AACH,K;AAAA;;AAEK,EAAA,sBAAsB,CAAC,QAAD,EAAS;;AACjC,UAAI,IAAI,GAAG,IAAX,C,CAEA;;AACA,UAAI,QAAQ,GAAG,EAAf;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACtC,YAAI,CAAC,QAAQ,CAAC,CAAD,CAAR,CAAY,IAAjB,EAAuB;AAEnB,cAAI,OAAO,GAAG,GAAG,CAAC,SAAD,EAAY;AACzB,oBAAQ,IAAI,CAAC,MADY;AAEzB,kBAAM,IAAI,CAAC,MAFc;AAGzB,kBAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAHmB,WAAZ,CAAjB;AAMA,cAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,GAAG,CAAC,MAAD,EAAS;AACjC,qBAAS,gBAAgB,CAAC,mBADO;AAEjC,uBAAW,QAAQ,CAAC,CAAD,CAAR,CAAY;AAFU,WAAT,CAAlB,CAAV;AAKA,UAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAd,EAbmB,CAcnB;AACH;AACJ;;AACD,aAAO,MAAM,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAb;AACH,K;AAAA;;AAEK,EAAA,sCAAsC,CAAC,cAAD,EAAe;;AACvD,UAAI,IAAI,GAAG,IAAX;AACA;;;;;;;;;;;;;;;;;AAmBA;AACA;;AAEA,UAAI,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAApB;AACA,UAAI,MAAM,GAAG,IAAI,CAAC,SAAL,CAAe,WAAf,CAA2B,SAA3B,CAAb;AAEA,UAAI,OAAO,GAAG,GAAG,CAAC,IAAD,EAAO;AACpB;AACA;AACA,gBAAQ,KAHY;AAIpB,cAAM;AAJc,OAAP,CAAjB;AAOA,UAAI,SAAS,GAAG,GAAG,CAAC,QAAD,EAAW;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC,YAAzB;AAAuC,QAAA,OAAO,EAAE;AAAhD,OAAX,CAAnB;AACA,UAAI,IAAI,GAAG,GAAG,CAAC,GAAD,EAAK;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC,aAAzB;AAAwC,QAAA,IAAI,EAAE;AAA9C,OAAL,CAAd;AACA,UAAI,SAAS,GAAG,GAAG,CAAC,OAAD,EAAS;AAAC,QAAA,GAAG,EAAE,WAAN;AAAmB,QAAA,IAAI,EAAE;AAAzB,OAAT,CAAnB;AACA,UAAI,SAAS,GAAG,GAAG,CAAC,OAAD,EAAS,EAAT,EAAa,gBAAgB,CAAC,YAA9B,CAAnB;AACA,UAAI,SAAS,GAAG,GAAG,CAAC,OAAD,EAAS;AAAC,QAAA,GAAG,EAAE;AAAN,OAAT,CAAnB;AACA,UAAI,SAAS,GAAG,GAAG,CAAC,OAAD,EAAS,EAAT,EAAa,cAAb,CAAnB;AACA,UAAI,MAAM,GAAG,GAAG,CAAC,KAAD,EAAQ;AAAC,QAAA,KAAK,EAAC,gBAAgB,CAAC;AAAxB,OAAR,CAAhB;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,SAAjB,EAA4B,SAA5B;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,SAAjB,EAA4B,SAA5B;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,SAAZ,EAAwB,SAAxB;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,SAAZ,EAAwB,SAAxB;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,IAAjB,EAAwB,SAAxB;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,MAAjB,EAA0B,SAA1B;AACA,UAAI,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,SAAf,EAA0B,SAA1B,CAAV,C,CACA;;AACA,aAAO,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,GAAvB,CAAb,C,CACA;AACH,K;AAAA;;AAED,EAAA,eAAe,CAAE,IAAF,EAAQ,WAAR,EAAmB;AAC9B,QAAI,YAAY,GAAG,WAAW,GAAG,aAAjC;;AAEA,QAAI,IAAI,CAAC,IAAL,CAAU,MAAV,MAAsB,OAA1B,EAAmC;AAC/B;AAEA,UAAI,KAAK,GAAG,IAAI,CAAC,QAAL,CAAc,OAAd,CAAZ;;AACA,UAAI,KAAJ,EAAW;AACP,YAAI,SAAS,GAAG,KAAK,CAAC,IAAN,CAAW,MAAX,CAAhB;AACA,YAAI,SAAS,GAAG,KAAK,CAAC,IAAN,CAAW,MAAX,CAAhB;;AACA,YAAI,SAAJ,EAAe;AACX,UAAA,YAAY,IAAK,SAAS,GAAG,KAA7B;;AAEA,cAAI,SAAS,KAAK,QAAlB,EAA4B;AACxB,YAAA,YAAY,IAAI,KAAK,CAAC,QAAN,CAAe,MAAf,EAAuB,OAAvB,MAAqC,EAArD;AACH;AACJ;;AACD,YAAI,SAAJ,EAAe;AACX,cAAI,SAAS,KAAK,KAAlB,EAAyB;AACrB,YAAA,YAAY,IAAI,mCAAhB;AACH;AACJ;;AAED,aAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,oBAAlC;AACA,aAAK,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,sBAAT,GAAkC,YAAnE;AAEH,OAnBD,MAoBK;AACD,QAAA,YAAY,IAAI,eAAhB;AACH;;AAED,aAAO,YAAP;AACH;;AACD,WAAO,IAAP;AACH;;AAED,EAAA,iBAAiB,CAAE,SAAF,EAAW;AACxB,QAAI,IAAI,GAAE,IAAV;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI,MAAJ,CADmC,CAE/C;AACA;AACA;AACA;AACA;;AACY,UAAI,CAAC,SAAL,EAAgB;AACZ;AACI;AACA;AAEJ,QAAA,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACf,UAAA,IAAI,EAAE,KADS;AAEf,UAAA,EAAE,EAAE,IAAI,CAAC,OAAL,GAAe,QAFJ;AAGf,UAAA,KAAK,EAAE,gBAAgB,CAAC,eAHT;AAIf,gBAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJS,SAAP,EAKT,GAAG,CAAC,aAAD,EAAgB;AAAC,mBAAU,gBAAgB,CAAC;AAA5B,SAAhB,EAAoE,GAAG,CAAC,aAAD,CAAvE,CALM,CAAZ;AAOH,OAZD,MAYO;AACH,QAAA,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACf,UAAA,IAAI,EAAE,KADS;AAEf,UAAA,EAAE,EAAE,IAAI,CAAC,OAAL,GAAe,QAFJ;AAGf;AACA,gBAAM,IAAI,CAAC,SAAL,CAAe,kBAAf;AAJS,SAAP,EAKT,GAAG,CAAC,aAAD,EAAgB;AAAC,mBAAU,gBAAgB,CAAC;AAA5B,SAAhB,EAAoE,GAAG,CAAC,aAAD,EAAgB;AAAC,UAAA,UAAU,EAAE;AAAb,SAAhB,CAAvE,CALM,CAAZ;AAMH;;AAEG,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,qCAArC,EAA4E,MAAM,CAAC,IAAP,GAAc,QAAd,EAA5E;AACJ,WAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,EAA+B,IAA/B,CAAqC,IAAD,IAAQ;AACxC,aAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,4CAAjC;AACA,aAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,4CAArC,EAAmF,IAAnF,EAFwC,CAKxC;;AACA,YAAI,YAAY,GAAG,IAAI,CAAC,eAAL,CAAqB,IAArB,EAA2B,mBAA3B,CAAnB;;AACA,YAAI,YAAJ,EAAkB;AACd,eAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kCAAlC;AACA,eAAK,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,oCAA1C,EAAgF,YAAhF;AACA,iBAAO,MAAM,CAAC,IAAI,KAAJ,CAAU,YAAV,CAAD,CAAb;AACH,SAXuC,CAaxC;;;AACA,YAAI,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,IAAzB,EAA+B,aAA/B,CAApB;AACA,YAAI,QAAQ,GAAG,EAAf;;AACA,YAAI,aAAa,CAAC,QAAd,CAAuB,MAAvB,KAAkC,CAAtC,EAAyC;AACrC,eAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kDAAlC;AACH,SAFD,MAEO;AACH,UAAA,QAAQ,GAAG,aAAa,CAAC,QAAzB;AACH;;AACD,QAAA,OAAO,CAAC,QAAD,CAAP;AAEH,OAvBD;AAwBH,KArDM,CAAP;AAsDH;;AAED,EAAA,QAAQ,GAAA;AACJ,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT;AACA,UAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,gBAAQ,KADW;AAEnB,cAAM;AAFa,OAAP,EAGb,GAAG,CAAC,MAAD,EAAS;AAAC,QAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,OAAT,CAHU,CAAhB;AAKA,WAAK,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,6BAArC,EAAoE,MAAM,CAAC,IAAP,GAAc,QAAd,EAApE,EAA8F,kCAA9F,EAAkI,cAAc,CAAC,OAAjJ;AACA,WAAK,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,KAA7B,CAAoC,KAAD,IAAU;AACzC,aAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mBAAlC;AACA,aAAK,MAAL,CAAY,GAAZ,CAAgB,eAAhB,EAAiC,MAAM,GAAG,qBAA1C,EAAiE,KAAjE;AACH,OAHD;AAIH,KAZD,MAYO;AACH,WAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,kCAAjC;AACH;AACJ,GAjjEY,CAmjEb;;;AACA,EAAA,QAAQ,CAAE,GAAF,EAAO,OAAP,EAAc;AAClB,QAAI,IAAI,GAAG,IAAX;AAEA,UAAM,GAAG,GAAG,gBAAZ;AACA,UAAM,EAAE,GAAI,CAAE,MAAF,EAAU,OAAV,EAAmB,KAAnB,CAAZ;AAEA,QAAI,OAAO,GAAG;AAAC,MAAA,KAAK,EAAE,GAAR;AAAa,MAAA,OAAO,EAAE;AAAtB,KAAd;;AACA,QAAI,CAAC,CAAC,OAAO,CAAC,OAAd,EAAuB;AACnB,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACA,aAAO,OAAO,CAAC,OAAf;AACH;;AAED,QAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;AACA,WAAO,OAAO,CAAC,SAAf;AACA,QAAI,UAAU,GAAG,OAAO,CAAC,UAAzB;AACA,WAAO,OAAO,CAAC,UAAf;AAEA,QAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,cAAQ,KADW;AAEnB,MAAA,EAAE,EAAE,GAFe;AAGnB,MAAA,KAAK,EAAE,gBAAgB,CAAC;AAHL,KAAP,EAIb,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,GAAG,CAAC,GAAD,EAAM;AAC9B,MAAA,KAAK,EAAE,gBAAgB,CAAC,aADM;AAE9B,MAAA,IAAI,EAAE;AAFwB,KAAN,EAGzB,GAAG,CAAC,OAAD,EAAU;AACR,aAAO,WADC;AAER,cAAQ;AAFA,KAAV,EAGC,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,GAAd,CAHJ,CAHsB,EAMG,EAAE,CAAC,MAAH,CAAY,GAAD,IAAS,OAAO,CAAC,GAAD,CAA3B,EAAkC,GAAlC,CAAuC,GAAD,IAAQ;AACjE,UAAI,KAAK,GAAG,GAAG,CAAC,OAAD,EAAU;AACrB,eAAO;AADc,OAAV,EAEZ,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,OAAO,CAAC,GAAD,CAArB,CAFS,CAAf;AAGA,aAAO,OAAO,CAAC,GAAD,CAAd;AACA,aAAO,KAAP;AACP,KAN0B,CANH,CAAtB,EAaF,GAAG,CAAC,KAAD,EAAQ;AAAE,MAAA,KAAK,EAAC,gBAAgB,CAAC;AAAzB,KAAR,EAAiD,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB,CAA0B,GAAD,IAAQ,GAAG,CAAE,GAAF,EAAO,EAAP,EAAW,OAAO,CAAC,GAAD;AAAM;AAAxB,KAApC,CAAjD,CAbD,CAJU,CAAhB;AAoBA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,4CAAjC;AACA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,4CAArC,EAAmF,MAAM,CAAC,QAAP,EAAnF;AACA,IAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAK,OAAO,UAAP,KAAsB,UAA3B,EAAwC;AACpC,QAAA,UAAU;AACb;AACL,KAJA;AAKH;;AAED,EAAA,WAAW,CAAC,GAAD,EAAM,EAAN,EAAU,OAAV,EAAiB;AACxB,QAAI,IAAI,GAAG,IAAX;AACA,UAAM,GAAG,GAAG,gBAAZ;AACA,UAAM,EAAE,GAAI,CAAE,MAAF,EAAU,OAAV,EAAmB,KAAnB,CAAZ;AAEA,QAAI,OAAO,GAAG;AAAC,MAAA,KAAK,EAAE,GAAR;AAAa,MAAA,OAAO,EAAE;AAAtB,KAAd;;AACA,QAAI,OAAO,CAAC,OAAO,CAAC,OAAT,CAAX,EAA8B;AAC1B,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACA,aAAO,OAAO,CAAC,OAAf;AACH;;AAED,QAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;AACA,WAAO,OAAO,CAAC,SAAf;AACA,QAAI,UAAU,GAAG,OAAO,CAAC,UAAzB;AACA,WAAO,OAAO,CAAC,UAAf;AAEA,QAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,cAAQ,KADW;AAEnB,MAAA,EAAE,EAAE,GAFe;AAGnB,MAAA,EAAE,EAAE,EAHe;AAInB,MAAA,KAAK,EAAE,gBAAgB,CAAC;AAJL,KAAP,EAKb,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,GAAG,CAAC,GAAD,EAAM;AAC9B,MAAA,KAAK,EAAE,gBAAgB,CAAC,aADM;AAE9B,MAAA,IAAI,EAAE;AAFwB,KAAN,EAGzB,GAAG,CAAC,OAAD,EAAU;AACR,aAAO,WADC;AAER,cAAQ;AAFA,KAAV,EAGC,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,GAAd,CAHJ,CAHsB,EAMG,EAAE,CAAC,MAAH,CAAY,GAAD,IAAS,OAAO,CAAC,GAAD,CAA3B,EAAkC,GAAlC,CAAuC,GAAD,IAAQ;AACjE,UAAI,KAAK,GAAG,GAAG,CAAC,OAAD,EAAU;AACrB,eAAO;AADc,OAAV,EAEZ,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,OAAO,CAAC,GAAD,CAArB,CAFS,CAAf;AAGA,aAAO,OAAO,CAAC,GAAD,CAAd;AACA,aAAO,KAAP;AACP,KAN0B,CANH,CAAtB,EAaF,GAAG,CAAC,KAAD,EAAQ;AAAE,MAAA,KAAK,EAAC,gBAAgB,CAAC;AAAzB,KAAR,EAAiD,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB,CAA0B,GAAD,IAAQ,GAAG,CAAE,GAAF,EAAO,EAAP,EAAW,OAAO,CAAC,GAAD,CAAP,GAAe,OAAO,CAAC,GAAD,CAAtB,GAA8B,IAAzC,CAApC,CAAjD,CAbD,CALU,CAAhB;AAqBA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,+CAAjC;AACA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,+CAArC,EAAsF,MAAM,CAAC,QAAP,EAAtF;AACA,IAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAkC,MAAK;AACnC,UAAK,OAAO,UAAP,KAAsB,UAA3B,EAAwC;AACpC,QAAA,UAAU;AACb;AACJ,KAJD;AAKH;;AAED,EAAA,SAAS,CAAC,OAAD,EAAQ;AAEb,QAAI,IAAI,GAAG,IAAX;AACA,UAAM,GAAG,GAAG,gBAAZ;AACA,UAAM,EAAE,GAAI,CAAE,MAAF,EAAU,OAAV,EAAmB,KAAnB,CAAZ;AAEA,QAAI,OAAO,GAAG;AAAC,MAAA,KAAK,EAAE,GAAR;AAAa,MAAA,QAAQ,EAAE;AAAvB,KAAd;;AACA,QAAI,OAAO,CAAC,OAAO,CAAC,QAAT,CAAX,EAA+B;AAC3B,MAAA,OAAO,CAAC,QAAR,GAAmB,OAAO,CAAC,QAA3B;AACA,aAAO,OAAO,CAAC,QAAf;AACH;;AAED,QAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;AACA,WAAO,OAAO,CAAC,SAAf;AACA,QAAI,UAAU,GAAG,OAAO,CAAC,UAAzB;AACA,WAAO,OAAO,CAAC,UAAf;AAEA,IAAA,OAAO,CAAC,OAAR,GAAkB,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAlB;AAEA,QAAI,EAAE,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,EAAT;AAEA,QAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,cAAQ,KADW;AAEnB,MAAA,EAAE,EAAE,EAFe;AAGnB,MAAA,KAAK,EAAE,gBAAgB,CAAC;AAHL,KAAP,EAIb,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,GAAG,CAAC,GAAD,EAAM;AAC/B,MAAA,KAAK,EAAE,gBAAgB,CAAC,aADO;AAE/B,MAAA,IAAI,EAAE;AAFyB,KAAN,EAG1B,GAAG,CAAC,OAAD,EAAU;AACZ,aAAO,WADK;AAEZ,cAAQ;AAFI,KAAV,EAGH,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,GAAd,CAHA,CAHuB,EAMF,EAAE,CAAC,MAAH,CAAY,GAAD,IAAS,OAAO,CAAC,GAAD,CAA3B,EAAkC,GAAlC,CAAuC,GAAD,IAAQ;AACrE,UAAI,KAAK,GAAG,GAAG,CAAC,OAAD,EAAU;AACrB,eAAO;AADc,OAAV,EAEZ,GAAG,CAAC,OAAD,EAAU,EAAV,EAAc,OAAO,CAAC,GAAD,CAArB,CAFS,CAAf;AAGA,aAAO,OAAO,CAAC,GAAD,CAAd;AACA,aAAO,KAAP;AACC,KANsB,CANE,CAAvB,EAaF,GAAG,CAAC,KAAD,EAAQ;AAAE,MAAA,KAAK,EAAC,gBAAgB,CAAC;AAAzB,KAAR,EAAiD,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB,CAA0B,GAAD,IAAQ,GAAG,CAAE,GAAF,EAAO,EAAP,EAAW,OAAO,CAAC,GAAD,CAAP,GAAe,OAAO,CAAC,GAAD,CAAtB,GAA8B,IAAzC,CAApC,CAAjD,CAbD,CAJU,CAAhB;AAoBA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,6CAAjC;AACA,IAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,6CAArC,EAAoF,MAAM,CAAC,QAAP,EAApF;AACA,IAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAmC,MAAD,IAAW;AACxC,UAAK,OAAO,UAAP,KAAsB,UAA3B,EAAwC;AACpC,QAAA,UAAU,CAAC,MAAD,CAAV;AACH;AACL,KAJD;AAKH,GAhsEY,CAksEb;;;AACA,EAAA,iBAAiB,CAAC,GAAD,EAAI;AACjB,QAAI,IAAI,GAAG,IAAX;AAEA;;;;;;;AAOA,QAAI,MAAM,GAAG;AAAC,MAAA,KAAK,EAAE,gBAAgB,CAAC;AAAzB,KAAb;AAEA,QAAI,MAAM,GAAG,GAAG,CAAC,IAAD,EAAO;AACnB,cAAQ,KADW;AAEnB,YAAM,GAAG,GAAG;AAFO,KAAP,EAGb,GAAG,CAAC,aAAD,EAAgB,MAAhB,EACF,GAAG,CAAC,WAAD,CADD,CAHU,CAAhB;AAOA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAS,MAAT,KAAmB;AAClC,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,qDAAjC;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,UAAhB,EAA4B,MAAM,GAAG,qDAArC,EAA4F,MAAM,CAAC,QAAP,EAA5F;AACA,MAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,MAArB,EAA6B,IAA7B,CAAmC,IAAD,IAAS;AACvC,QAAA,OAAO,CAAC,IAAD,CAAP;AACH,OAFD,EAEG,KAFH,CAEU,GAAD,IAAQ;AACb,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAJD;AAKH,KARM,CAAP;AASH;;AA/tEY,CAAjB;AAAM,WAAW,GAAA,UAAA,CAAA,CAFhB,OAAA,CAAA,YAAA,CAAa,MAAb,CAEgB,EADhB,OAAA,CAAA,SAAA,CAAU,CAAC,OAAD,EAAU,MAAV,CAAV,CACgB,CAAA,EAAX,WAAW,CAAX;AAouEG,OAAA,CAAA,WAAA,GAAA,WAAA;AACT,MAAM,CAAC,OAAP,CAAe,WAAf,GAA6B,WAA7B;AACA,MAAM,CAAC,OAAP,CAAe,gBAAf,GAAkC,gBAAlC","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst util = require(\"util\");\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst PubSub = require(\"pubsub-js\");\r\nconst Conversation_1 = require(\"../common/models/Conversation\");\r\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\r\nconst iqEventHandler_1 = require(\"./XMPPServiceHandler/iqEventHandler\");\r\nconst packageVersion = require(\"../../package\");\r\nconst url = require('url');\r\n// Until web proxy on websocket solved, patch existing configuration to offer the proxy options\r\nlet ws_options = null;\r\n// @ts-ignore\r\nlet isInTest = typeof global.it === \"function\";\r\nlet WS;\r\nif (isInTest) {\r\n    WS = require(\"mock-socket\").WebSocket;\r\n}\r\nelse {\r\n    WS = require(\"ws\");\r\n}\r\nclass XmppWebSocket extends WS {\r\n    constructor(address, protocols) {\r\n        super(address, protocols, ws_options);\r\n    }\r\n}\r\n// @ts-ignore\r\nglobal.WebSocket = XmppWebSocket;\r\nconst Client = require(\"../common/XmppQueue/XmppClient\").XmppClient;\r\nconst xml = require(\"@xmpp/xml\");\r\nlet backoff = require(\"backoff\");\r\n//const setTimeout = require(\"timers\").setTimeout;\r\nconst HttpsProxyAgent = require(\"https-proxy-agent\");\r\n// import {URL} from \"url\";\r\nconst LOG_ID = \"XMPP - \";\r\nconst ONLINE_EVENT = \"online\";\r\nconst OFFLINE_EVENT = \"offline\";\r\nconst CONNECT_EVENT = \"connect\";\r\nconst RECONNECT_EVENT = \"reconnect\";\r\nconst RECONNECTED_EVENT = \"reconnected\";\r\nconst RECONNECTING_EVENT = \"reconnecting\";\r\nconst DISCONNECT_EVENT = \"disconnect\";\r\nconst CLOSE_EVENT = \"close\";\r\nconst END_EVENT = \"end\";\r\nconst ERROR_EVENT = \"error\";\r\nconst STANZA_EVENT = \"stanza\";\r\nconst STATUS_EVENT = \"status\";\r\nconst BIND_EVENT = \"bind\";\r\nconst AUTHENTICATE_EVENT = \"authenticate\";\r\nconst TYPE_CHAT = \"chat\";\r\nconst TYPE_GROUPCHAT = \"groupchat\";\r\nconst RECONNECT_INITIAL_DELAY = 5000;\r\nconst RECONNECT_MAX_DELAY = 60000;\r\nconst MAX_IDLE_TIMER = 70000;\r\nconst MAX_PING_ANSWER_TIMER = 5000;\r\nconst NameSpacesLabels = {\r\n    \"ChatstatesNS\": \"http://jabber.org/protocol/chatstates\",\r\n    \"ReceiptNS\": \"urn:xmpp:receipts\",\r\n    \"CallLogNamespace\": \"jabber:iq:telephony:call_log\",\r\n    \"CallLogAckNamespace\": \"urn:xmpp:telephony:call_log:receipts\",\r\n    \"CallLogNotificationsNamespace\": \"jabber:iq:notification:telephony:call_log\",\r\n    \"RsmNameSpace\": \"http://jabber.org/protocol/rsm\",\r\n    \"Carbon2NameSpace\": \"urn:xmpp:carbons:2\",\r\n    \"ApplicationNameSpace\": \"jabber:iq:application\",\r\n    \"RosterNameSpace\": \"jabber:iq:roster\",\r\n    \"ClientNameSpace\": \"jabber:client\",\r\n    \"PingNameSpace\": \"urn:xmpp:ping\",\r\n    \"DataNameSpace\": \"jabber:x:data\",\r\n    \"MucNameSpace\": \"http://jabber.org/protocol/muc\",\r\n    \"ReceiptsNameSpace\": \"urn:xmpp:receipts\",\r\n    \"ChatestatesNameSpace\": \"http://jabber.org/protocol/chatstates\",\r\n    \"ContentNameSpace\": \"urn:xmpp:content\",\r\n    \"MessageCorrectNameSpace\": \"urn:xmpp:message-correct:0\",\r\n    \"HintsNameSpace\": \"urn:xmpp:hints\",\r\n    \"OobNameSpace\": \"jabber:x:oob\",\r\n    \"Monitoring1NameSpace\": \"urn:xmpp:pbxagent:monitoring:1\",\r\n    \"CallService1NameSpace\": \"urn:xmpp:pbxagent:callservice:1\",\r\n    \"MamNameSpace\": \"urn:xmpp:mam:1\",\r\n    \"MamNameSpaceTmp\": \"urn:xmpp:mam:tmp\",\r\n    \"AttentionNS\": \"urn:xmpp:attention:0\"\r\n};\r\nexports.NameSpacesLabels = NameSpacesLabels;\r\nlet XMPPService = class XMPPService {\r\n    constructor(_xmpp, _im, _application, _eventEmitter, _logger, _proxy) {\r\n        this.ready = false;\r\n        this.serverURL = _xmpp.protocol + \"://\" + _xmpp.host + \":\" + _xmpp.port + \"/websocket\";\r\n        this.host = _xmpp.host;\r\n        this.eventEmitter = _eventEmitter;\r\n        this.version = \"0.1\";\r\n        this.jid_im = \"\";\r\n        this.jid_tel = \"\";\r\n        this.jid_password = \"\";\r\n        this.fullJid = \"\";\r\n        this.jid = \"\";\r\n        this.userId = \"\";\r\n        this.initialPresence = true;\r\n        this.xmppClient = null;\r\n        this.logger = _logger;\r\n        this.proxy = _proxy;\r\n        this.shouldSendReadReceipt = _im.sendReadReceipt;\r\n        this.shouldSendMessageToConnectedUser = _im.sendMessageToConnectedUser;\r\n        this.storeMessages = _im.storeMessages;\r\n        this.copyMessage = _im.copyMessage;\r\n        this.rateLimitPerHour = _im.rateLimitPerHour;\r\n        this.messagesDataStore = _im.messagesDataStore;\r\n        this.useXMPP = true;\r\n        this.timeBetweenXmppRequests = _xmpp.timeBetweenXmppRequests;\r\n        this.isReconnecting = false;\r\n        this.maxAttempts = 1;\r\n        this.idleTimer = null;\r\n        this.pingTimer = null;\r\n        this.forceClose = false;\r\n        this.applicationId = _application.appID;\r\n        this._startConfig = {\r\n            start_up: true,\r\n            optional: false\r\n        };\r\n        this.xmppUtils = XMPPUtils_1.XMPPUTils.getXMPPUtils();\r\n        this.generatedRandomId = this.xmppUtils.generateRandomID();\r\n        this.hash = Utils_1.makeId(8);\r\n        this.handleXMPPConnection = (headers) => {\r\n            let that = this;\r\n            let domain = that.xmppUtils.getDomainFromFullJID(this.fullJid);\r\n            let options = { agent: null };\r\n            Object.assign(options, headers);\r\n            let opt = url.parse(this.proxy.proxyURL);\r\n            if (this.proxy.isProxyConfigured) {\r\n                if (this.proxy.secureProtocol) {\r\n                    opt.secureProxy = true;\r\n                }\r\n                // Until web proxy on websocket solved, patch existing configuration to offer the proxy options\r\n                options.agent = new HttpsProxyAgent(opt);\r\n                //options.agent = new HttpsProxyAgent(this.proxy.proxyURL);\r\n                ws_options = options;\r\n            }\r\n            /*\r\n            this.xmppClient = new Client({\r\n                \"jid\": this.fullJid,\r\n                \"password\": this.jid_password,\r\n                \"host\": this.host,\r\n                \"websocket\": {\r\n                    \"url\": this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\r\n                    \"options\": options\r\n                }\r\n            }); // */\r\n            //\"domain\": {enter(node) {\r\n            //}, exit(node){}},\r\n            this.xmppClient = new Client({\r\n                \"service\": this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\r\n                \"domain\": domain,\r\n                //   \"resource\": \"nodesdk\",\r\n                \"username\": this.fullJid,\r\n                \"password\": this.jid_password,\r\n                \"options\": options,\r\n                \"mechanism\": \"PLAIN\"\r\n            }); //\"domain\": domain,\r\n            // */\r\n            this.xmppClient.init(this.logger, this.timeBetweenXmppRequests, this.storeMessages, this.rateLimitPerHour, this.messagesDataStore);\r\n            //this.reconnect = this.xmppClient.plugin(require(\"@xmpp/plugins/reconnect\"));\r\n            this.reconnect = this.xmppClient.reconnect;\r\n            this.reconnect.delay = RECONNECT_INITIAL_DELAY;\r\n            this.fibonacciStrategy = new backoff.FibonacciStrategy({\r\n                randomisationFactor: 0.4,\r\n                initialDelay: RECONNECT_INITIAL_DELAY,\r\n                maxDelay: RECONNECT_MAX_DELAY\r\n            });\r\n            //const sasl = this.xmppClient.plugins.sasl;\r\n            /*const sasl = this.xmppClient.sasl;\r\n            sasl.getMechanism = mechs => {\r\n                return \"PLAIN\"; // Force plain sasl\r\n            }; // */\r\n            this.xmppClient.setgetMechanism((mechs) => {\r\n                return \"PLAIN\"; // Force plain sasl\r\n            });\r\n            /*\r\n            this.xmppClient.handle(AUTHENTICATE_EVENT, authenticate => {\r\n                return authenticate(this.fullJid, this.jid_password);\r\n            });\r\n\r\n            this.xmppClient.handle(BIND_EVENT, (bind) => {\r\n                return bind(that.xmppUtils.getResourceFromFullJID(this.fullJid));\r\n            }); // */\r\n            this.xmppClient.on(\"input\", (packet) => {\r\n                that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) \", that.logger.colors.cyan(\" raw in - ⮈ stanza : \") + that.logger.colors.cyan(packet));\r\n                that.startOrResetIdleTimer(true);\r\n            });\r\n            this.xmppClient.on(\"output\", (packet) => {\r\n                that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) \", that.logger.colors.yellow(\" raw out - ⮊ stanza : \") + that.logger.colors.yellow(packet));\r\n                that.startOrResetIdleTimer(false);\r\n            });\r\n            this.xmppClient.on(ONLINE_EVENT, (msg) => {\r\n                that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) event - ONLINE_EVENT : \" + ONLINE_EVENT + \" |\", msg);\r\n                that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) connected as \", msg);\r\n                if (!that.isReconnecting) {\r\n                    that.eventEmitter.emit(\"xmppconnected\");\r\n                }\r\n            });\r\n            this.xmppClient.on(STATUS_EVENT, msg => {\r\n                that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) event - STATUS_EVENT : \" + STATUS_EVENT + \" |\", msg);\r\n                /* if (msg === \"closing\") {\r\n                     that.xmppClient.restartConnect().then((res) => {\r\n                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) restartConnect result : \", res);\r\n                     }).catch((err) => {\r\n                         that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) restartConnect error : \", err);\r\n                     }).then(() => {\r\n                         that.logger.log(\"debug\", LOG_ID + \"on STATUS_EVENT \");\r\n                     });\r\n                 } // */\r\n            });\r\n            this.xmppClient.on(STANZA_EVENT, (stanza) => {\r\n                that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : \" + STANZA_EVENT + \" |\", stanza.toString());\r\n                let eventId = that.hash + \".\" + stanza.getNS() + \".\" + stanza.getName() + (stanza.attrs.type ? \".\" + stanza.attrs.type : \"\");\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : eventId \", eventId);\r\n                let delivered = PubSub.publish(eventId, stanza);\r\n                stanza.children.forEach((child) => {\r\n                    delivered |= PubSub.publish(that.hash + \".\" + child.getNS() + \".\" + child.getName() + (child.attrs.type ? \".\" + child.attrs.type : \"\"), stanza);\r\n                });\r\n                if (!delivered) {\r\n                    that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) event - STANZA_EVENT : \" + STANZA_EVENT + \" not managed |\", stanza.getNS() + \".\" + stanza.getName() + (stanza.attrs.type ? \".\" + stanza.attrs.type : \"\"));\r\n                }\r\n                switch (stanza.getName()) {\r\n                    case \"iq\":\r\n                        // let children = stanza.children;\r\n                        // children.forEach((node) => {\r\n                        //     switch (node.getName()) {\r\n                        //         case \"ping\":\r\n                        //             let stanzaResponse = xml(\"iq\", {\r\n                        //                 \"to\": stanza.attrs.from,\r\n                        //                 \"id\": stanza.attrs.id,\r\n                        //                 \"xmlns\": stanza.getNS(),\r\n                        //                 \"type\": \"result\"\r\n                        //             });\r\n                        //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - 'stanza'\", stanzaResponse.toString());\r\n                        //             that.xmppClient.send(stanzaResponse);\r\n                        //             break;\r\n                        //         case \"query\":\r\n                        //             if (stanza.attrs.type === \"result\" || stanza.attrs.type === \"set\") {\r\n                        //                 if (node.attrs.xmlns === NameSpacesLabels.RosterNameSpace) {\r\n                        //                     let contacts = [];\r\n                        //                     let subchildren = node.children;\r\n                        //                     subchildren.forEach(function(item) {\r\n                        //                         if (item.attrs.jid.substr(0, 3) !== \"tel\") {\r\n                        //                             contacts.push({\r\n                        //                                 jid: item.attrs.jid,\r\n                        //                                 subscription: item.attrs.subscription,\r\n                        //                                 ask: item.attrs.ask || \"\"\r\n                        //                             });\r\n                        //                         }\r\n                        //                     });\r\n                        //                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) XMPP Rosters received\", contacts.length);\r\n                        //                     that.eventEmitter.emit(\"evt_internal_onrosters\", contacts);\r\n                        //                 }\r\n                        //             }\r\n                        //             break;\r\n                        //         case \"default\":\r\n                        //             that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) not managed - 'stanza'\", node.getName());\r\n                        //             break;\r\n                        //         default:\r\n                        //             that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) child not managed for iq - 'stanza'\", node.getName());\r\n                        //             break;\r\n                        //     }\r\n                        // });\r\n                        // if (stanza.attrs.type && stanza.attrs.type === \"result\") {\r\n                        //     if (stanza.attrs.id === \"enable_xmpp_carbon\") {\r\n                        //         that.eventEmitter.emit(\"rainbow_oncarbonactivated\");\r\n                        //     }\r\n                        // }\r\n                        break;\r\n                    case \"message\":\r\n                        let content = \"\";\r\n                        let lang = \"\";\r\n                        let alternativeContent = [];\r\n                        let subject = \"\";\r\n                        let event = \"\";\r\n                        let eventJid = \"\";\r\n                        let hasATextMessage = false;\r\n                        let oob = null;\r\n                        let messageType = stanza.attrs.type;\r\n                        if (messageType === TYPE_CHAT || messageType === TYPE_GROUPCHAT) {\r\n                            // let fromJid = that.xmppUtils.getBareJIDFromFullJID(stanza.attrs.from);\r\n                            // let resource = that.xmppUtils.getResourceFromFullJID(stanza.attrs.from);\r\n                            // let toJid = stanza.attrs.to;\r\n                            // let id = stanza.attrs.id;\r\n                            // let children = stanza.children;\r\n                            // children.forEach((node) => {\r\n                            //     switch (node.getName()) {\r\n                            //         case \"sent\":\r\n                            //             if (node.attrs.xmlns === NameSpacesLabels.Carbon2NameSpace) {\r\n                            //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' received\");\r\n                            //                 let forwarded = node.children[0];\r\n                            //                 if (forwarded && forwarded.getName() === \"forwarded\") {\r\n                            //                     let message = forwarded.children[0];\r\n                            //                     if (message && message.getName() === \"message\") {\r\n                            //                         fromJid = that.xmppUtils.getBareJIDFromFullJID(message.attrs.from);\r\n                            //                         resource = that.xmppUtils.getResourceFromFullJID(message.attrs.from);\r\n                            //                         toJid = message.attrs.to;\r\n                            //                         id = message.attrs.id;\r\n                            //                         let childs = message.children;\r\n                            //                         if (childs) {\r\n                            //                             childs.forEach((nodeChild) => {\r\n                            //                                 if (nodeChild.getName() === \"body\") {\r\n                            //                                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' of type chat received \");\r\n                            //                                     let data = {\r\n                            //                                         \"fromJid\": fromJid,\r\n                            //                                         \"resource\": resource,\r\n                            //                                         \"toJid\": toJid,\r\n                            //                                         \"type\": messageType,\r\n                            //                                         \"content\": nodeChild.getText(),\r\n                            //                                         \"id\": id,\r\n                            //                                         \"lang\": nodeChild.attrs[\"xml:lang\"],\r\n                            //                                         \"cc\": true,\r\n                            //                                         \"cctype\": \"sent\",\r\n                            //                                         \"isEvent\": false\r\n                            //                                     };\r\n                            //                                     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\r\n                            //                                 }\r\n                            //                             });\r\n                            //                         }\r\n                            //                     }\r\n                            //                 }\r\n                            //             }\r\n                            //             break;\r\n                            //         case \"received\":\r\n                            //             if (node.attrs.xmlns === NameSpacesLabels.Carbon2NameSpace) {\r\n                            //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' received\");\r\n                            //                 let forwarded = node.children[0];\r\n                            //                 if (forwarded && forwarded.getName() === \"forwarded\") {\r\n                            //                     let message = forwarded.children[0];\r\n                            //                     if (message && message.getName() === \"message\") {\r\n                            //                         fromJid = that.xmppUtils.getBareJIDFromFullJID(message.attrs.from);\r\n                            //                         resource = that.xmppUtils.getResourceFromFullJID(message.attrs.from);\r\n                            //                         toJid = message.attrs.to;\r\n                            //                         id = message.attrs.id;\r\n                            //                         let childs = message.children;\r\n                            //                         if (childs) {\r\n                            //                             childs.forEach(function (nodeChild) {\r\n                            //                                 if (nodeChild.getName() === \"body\") {\r\n                            //                                     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - CC message 'sent' of type chat received \");\r\n                            //                                     let data = {\r\n                            //                                         \"fromJid\": fromJid,\r\n                            //                                         \"resource\": resource,\r\n                            //                                         \"toJid\": toJid,\r\n                            //                                         \"type\": messageType,\r\n                            //                                         \"content\": nodeChild.getText(),\r\n                            //                                         \"id\": id,\r\n                            //                                         \"lang\": nodeChild.attrs[\"xml:lang\"],\r\n                            //                                         \"cc\": true,\r\n                            //                                         \"cctype\": \"sent\",\r\n                            //                                         \"isEvent\": false\r\n                            //                                     };\r\n                            //                                     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\r\n                            //                                 }\r\n                            //                             });\r\n                            //                         }\r\n                            //                     }\r\n                            //                 }\r\n                            //             }\r\n                            //             else {\r\n                            //                 let receipt = {\r\n                            //                     event: node.attrs.event,\r\n                            //                     entity: node.attrs.entity,\r\n                            //                     type: messageType,\r\n                            //                     id: node.attrs.id,\r\n                            //                     fromJid: fromJid,\r\n                            //                     resource: resource\r\n                            //                 };\r\n                            //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - receipt received\");\r\n                            //                 that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\r\n                            //             }\r\n                            //             break;\r\n                            //         case \"active\":\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is active\");\r\n                            //             break;\r\n                            //         case \"inactive\":\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is inactive\");\r\n                            //             break;\r\n                            //         case \"composing\":\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - someone is writing\");\r\n                            //             break;\r\n                            //         case \"archived\":\r\n                            //             break;\r\n                            //         case \"stanza-id\":\r\n                            //             break;\r\n                            //         case \"subject\":\r\n                            //             subject = node.getText();\r\n                            //             break;\r\n                            //         case \"event\":\r\n                            //             event = node.attrs.name;\r\n                            //             eventJid = node.attrs.jid;\r\n                            //             break;\r\n                            //         case \"body\":\r\n                            //             content = node.getText();\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - content\", \"***\");\r\n                            //             if (node.attrs[\"xml:lang\"]) { // in <body>\r\n                            //                 lang = node.attrs[\"xml:lang\"];\r\n                            //             } else if (node.parent.attrs[\"xml:lang\"]) { // in <message>\r\n                            //                 lang = node.parent.attrs[\"xml:lang\"];\r\n                            //             } else {\r\n                            //                 lang = \"en\";\r\n                            //             }\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - lang\", lang);\r\n                            //             hasATextMessage = true;\r\n                            //             break;\r\n                            //         case \"content\":\r\n                            //             alternativeContent.push( {\r\n                            //                 \"message\": node.getText(),\r\n                            //                 \"type\": node.getAttr(\"type\")\r\n                            //             });\r\n                            //             break;\r\n                            //         case \"request\":\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - asked for receipt\");\r\n                            //             // Acknowledge 'received'\r\n                            //             let stanzaReceived = xml(\"message\", {\r\n                            //                 \"to\": fromJid,\r\n                            //                 \"from\": toJid,\r\n                            //                 \"type\": messageType\r\n                            //             }, xml(\"received\", {\r\n                            //                 \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\r\n                            //                 \"event\": \"received\",\r\n                            //                 \"entity\": \"client\",\r\n                            //                 \"id\": stanza.attrs.id\r\n                            //                 })\r\n                            //             );\r\n                            //             that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - send receipt 'received'\", stanzaReceived.root().toString());\r\n                            //             that.xmppClient.send(stanzaReceived);\r\n                            //             //Acknowledge 'read'\r\n                            //             if (that.shouldSendReadReceipt || (messageType === TYPE_GROUPCHAT && that.xmppUtils.getResourceFromFullJID(stanza.attrs.from) === that.fullJid)) {\r\n                            //                 let stanzaRead = xml(\"message\", {\r\n                            //                     \"to\": fromJid,\r\n                            //                     \"from\": toJid,\r\n                            //                     \"type\": messageType\r\n                            //                 }, xml(\"received\", {\r\n                            //                         \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\r\n                            //                         \"event\": \"read\",\r\n                            //                         \"entity\": \"client\",\r\n                            //                         \"id\": stanza.attrs.id\r\n                            //                     })\r\n                            //                 );\r\n                            //                 that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) answered - send receipt 'read'\", stanzaRead.root().toString());\r\n                            //                 that.xmppClient.send(stanzaRead);\r\n                            //             }\r\n                            //             break;\r\n                            //         case \"x\":\r\n                            //             {\r\n                            //                 let xmlns = node.attrs.xmlns;\r\n                            //                 switch ( xmlns) {\r\n                            //                    case \"jabber:x:conference\": {\r\n                            //                         let invitation = {\r\n                            //                             event: \"invitation\",\r\n                            //                             bubbleId: node.attrs.thread,\r\n                            //                             bubbleJid: node.attrs.jid,\r\n                            //                             fromJid: fromJid,\r\n                            //                             resource: resource\r\n                            //                         };\r\n                            //                         that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) invitation received\");\r\n                            //                         that.eventEmitter.emit(\"evt_internal_invitationreceived\", invitation);\r\n                            //                     }\r\n                            //                     break;\r\n                            //                     case NameSpacesLabels.OobNameSpace : {\r\n                            //                         oob = {\r\n                            //                             url: node.getChild(\"url\").getText(),\r\n                            //                             mime: node.getChild(\"mime\").getText(),\r\n                            //                             filename: node.getChild(\"filename\").getText(),\r\n                            //                             filesize: node.getChild(\"size\").getText()\r\n                            //                         };\r\n                            //                         that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) oob received\");\r\n                            //                         break;\r\n                            //                     }\r\n                            //                     default:\r\n                            //                         break;\r\n                            //                 }\r\n                            //                 break;\r\n                            //             }\r\n                            //         default:\r\n                            //             break;\r\n                            //     }\r\n                            // });\r\n                            // let fromBubbleJid = \"\";\r\n                            // let fromBubbleUserJid = \"\";\r\n                            // if (stanza.attrs.type === TYPE_GROUPCHAT) {\r\n                            //     fromBubbleJid = that.xmppUtils.getBareJIDFromFullJID(stanza.attrs.from);\r\n                            //     fromBubbleUserJid = that.xmppUtils.getResourceFromFullJID(stanza.attrs.from);\r\n                            //     resource = that.xmppUtils.getResourceFromFullJID(fromBubbleUserJid);\r\n                            // }\r\n                            // if (hasATextMessage && ((messageType === TYPE_GROUPCHAT && fromBubbleUserJid !== that.fullJid) || (messageType === TYPE_CHAT && fromJid !== that.fullJid))) {\r\n                            //     that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) message - chat message received\");\r\n                            //     let data = {\r\n                            //         \"fromJid\": fromJid,\r\n                            //         \"resource\": resource,\r\n                            //         \"toJid\": toJid,\r\n                            //         \"type\": messageType,\r\n                            //         \"content\": content,\r\n                            //         \"alternativeContent\": alternativeContent,\r\n                            //         \"id\": stanza.attrs.id,\r\n                            //         \"lang\": lang,\r\n                            //         \"cc\": false,\r\n                            //         \"cctype\": \"\",\r\n                            //         \"isEvent\": false,\r\n                            //         \"oob\": oob\r\n                            //     };\r\n                            //     if (stanza.attrs.type === TYPE_GROUPCHAT) {\r\n                            //         data.fromBubbleJid = fromBubbleJid;\r\n                            //         data.fromBubbleUserJid = fromBubbleUserJid;\r\n                            //         data.fromJid = that.xmppUtils.getRoomJIDFromFullJID(stanza.attrs.from);\r\n                            //         if(event) {\r\n                            //             data.event = event;\r\n                            //             data.eventJid = eventJid;\r\n                            //             data.isEvent = true;\r\n                            //         }\r\n                            //     }\r\n                            //     that.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\r\n                            // }\r\n                        }\r\n                        else if (stanza.attrs.type === \"management\") {\r\n                            // let children = stanza.children;\r\n                            // children.forEach(function (node) {\r\n                            //     switch (node.getName()) {\r\n                            //         case \"room\":\r\n                            //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                            //                 // Affiliation changed (my own or for a member)\r\n                            //                 if (node.attrs.status) {\r\n                            //                     if (node.attrs.userjid === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\r\n                            //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble management received for own.\");\r\n                            //                         that.eventEmitter.emit(\"evt_internal_ownaffiliationchanged\", {\r\n                            //                             \"bubbleId\": node.attrs.roomid,\r\n                            //                             \"bubbleJid\": node.attrs.roomjid,\r\n                            //                             \"userJid\": node.attrs.userjid,\r\n                            //                             \"status\": node.attrs.status,\r\n                            //                         });\r\n                            //                     } else {\r\n                            //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble affiliation received\");\r\n                            //                         that.eventEmitter.emit(\"evt_internal_affiliationchanged\", {\r\n                            //                             \"bubbleId\": node.attrs.roomid,\r\n                            //                             \"bubbleJid\": node.attrs.roomjid,\r\n                            //                             \"userJid\": node.attrs.userjid,\r\n                            //                             \"status\": node.attrs.status,\r\n                            //                         });\r\n                            //                     }\r\n                            //                 }\r\n                            //                 // Custom data changed\r\n                            //                 else if (node.attrs.customData) {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble custom-data changed\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_customdatachanged\", {\r\n                            //                         \"bubbleId\": node.attrs.roomid,\r\n                            //                         \"bubbleJid\": node.attrs.roomjid,\r\n                            //                         \"customData\": node.attrs.customData\r\n                            //                     });\r\n                            //                 }\r\n                            //                 // Topic changed\r\n                            //                 else if (node.attrs.topic) {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble topic changed\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_topicchanged\", {\r\n                            //                         \"bubbleId\": node.attrs.roomid,\r\n                            //                         \"bubbleJid\": node.attrs.roomjid,\r\n                            //                         \"topic\": node.attrs.topic\r\n                            //                     });\r\n                            //                 }\r\n                            //                 // Name changed\r\n                            //                 else if (node.attrs.name) {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) bubble name changed\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_namechanged\", {\r\n                            //                         \"bubbleId\": node.attrs.roomid,\r\n                            //                         \"bubbleJid\": node.attrs.roomjid,\r\n                            //                         \"name\": node.attrs.name\r\n                            //                     });\r\n                            //                 }\r\n                            //             }\r\n                            //             break;\r\n                            //         case \"usersettings\":\r\n                            //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                            //                 switch (node.attrs.action) {\r\n                            //                     case \"update\":\r\n                            //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) usersettings updated\");\r\n                            //                         that.eventEmitter.emit(\"evt_internal_usersettingschanged\");\r\n                            //                         break;\r\n                            //                     default:\r\n                            //                         break;\r\n                            //                 }\r\n                            //             }\r\n                            //             break;\r\n                            //         case \"userinvite\":\r\n                            //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                            //                 switch (node.attrs.action) {\r\n                            //                     case \"create\":\r\n                            //                         if (node.attrs.type === \"received\" && node.attrs.status === \"pending\") {\r\n                            //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite received\");\r\n                            //                             that.eventEmitter.emit(\"evt_internal_userinvitereceived\", {\r\n                            //                                 invitationId: node.attrs.id\r\n                            //                             });\r\n                            //                         }\r\n                            //                     case \"update\":\r\n                            //                         if( node.attrs.type === \"sent\" && node.attrs.status === \"canceled\" ) {\r\n                            //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite canceled\");\r\n                            //                             that.eventEmitter.emit(\"evt_internal_userinvitecanceled\", {\r\n                            //                                 invitationId: node.attrs.id\r\n                            //                             });\r\n                            //                         } else if( node.attrs.type === \"sent\" && node.attrs.status === \"accepted\" ) {\r\n                            //                             that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user invite accepted\");\r\n                            //                             that.eventEmitter.emit(\"evt_internal_userinviteaccepted\", {\r\n                            //                                 invitationId: node.attrs.id\r\n                            //                             });\r\n                            //                         }\r\n                            //                         break;\r\n                            //                     default:\r\n                            //                         break;\r\n                            //                 }\r\n                            //             }\r\n                            //         case \"group\":\r\n                            //             if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                            //                 let action = node.attrs.action;\r\n                            //                 let scope = node.attrs.scope;\r\n                            //                 if (action === \"create\" && scope === \"group\") {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group created\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_groupcreated\", {\r\n                            //                         \"groupId\": node.attrs.id\r\n                            //                     });\r\n                            //                 } else if (action === \"create\" && scope === \"user\" && node.attrs.userId) {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user added in group\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_useraddedingroup\", {\r\n                            //                         \"groupId\": node.attrs.id,\r\n                            //                         \"userId\": node.attrs.userId\r\n                            //                     });\r\n                            //                 } else if (action === \"delete\" && scope === \"group\") {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group deleted\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_groupdeleted\", {\r\n                            //                         \"groupId\": node.attrs.id\r\n                            //                     });\r\n                            //                 } else if (action === \"delete\" && scope === \"user\" && node.attrs.userId) {\r\n                            //                     that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) user removed from group\");\r\n                            //                     that.eventEmitter.emit(\"evt_internal_userremovedfromgroup\", {\r\n                            //                         \"groupId\": node.attrs.id,\r\n                            //                         \"userId\": node.attrs.userId\r\n                            //                     });\r\n                            //                 } else if (action === \"update\" && scope === \"group\") {\r\n                            //                     if (node.attrs.name || node.attrs.comment || node.attrs.isFavorite) {\r\n                            //                         that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) group updated\");\r\n                            //                         that.eventEmitter.emit(\"evt_internal_groupupdated\", {\r\n                            //                             \"groupId\": node.attrs.id\r\n                            //                         });\r\n                            //                     }\r\n                            //                 }\r\n                            //             }\r\n                            //             break;\r\n                            //         default:\r\n                            //             break;\r\n                            //     }\r\n                            // });\r\n                        }\r\n                        else if (stanza.attrs.type === \"error\") {\r\n                            //that.logger.log(\"error\", LOG_ID + \"(handleXMPPConnection) something goes wrong...\");\r\n                        }\r\n                        else if (stanza.attrs.type === \"headline\") {\r\n                            // that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) channel message received\");\r\n                            // let eventNode = stanza.children[0];\r\n                            // let items = eventNode.children[0];\r\n                            // let item = items.children[0];\r\n                            // let entry = item.children[0];\r\n                            // let message = {\r\n                            //     \"messageId\": item.attrs.id,\r\n                            //     \"channelId\": entry.attrs.channelId,\r\n                            //     \"fromJid\": entry.attrs.from,\r\n                            //     \"message\": entry.getChild(\"message\").getText() || \"\",\r\n                            //     \"title\": entry.getChild(\"title\").getText() ||  \"\",\r\n                            //     \"url\": entry.getChild(\"url\").getText() ||  \"\",\r\n                            //     \"date\": new Date(entry.attrs.timestamp)\r\n                            // };\r\n                            // that.eventEmitter.emit(\"rainbow_onchannelmessagereceived\", message);\r\n                        }\r\n                        else {\r\n                            let children = stanza.children;\r\n                            children.forEach(function (node) {\r\n                                switch (node.getName()) {\r\n                                    case \"received\":\r\n                                        let receipt = {\r\n                                            event: node.attrs.event,\r\n                                            entity: node.attrs.entity,\r\n                                            type: null,\r\n                                            id: node.attrs.id\r\n                                        };\r\n                                        //that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) server receipt received\");\r\n                                        that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\r\n                                        break;\r\n                                    default:\r\n                                        break;\r\n                                }\r\n                            });\r\n                        }\r\n                        break;\r\n                    case \"presence\":\r\n                        // let from = stanza.attrs.from;\r\n                        // if (from === that.fullJid || that.xmppUtils.getBareJIDFromFullJID(from) === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\r\n                        //     // My presence changes (coming from me or another resource)\r\n                        //     that\r\n                        //         .eventEmitter\r\n                        //         .emit(\"evt_internal_presencechanged\", {\r\n                        //             fulljid: from,\r\n                        //             jid: that.xmppUtils.getBareJIDFromFullJID(from),\r\n                        //             resource: that.xmppUtils.getResourceFromFullJID(from),\r\n                        //             show: stanza.attrs.show || \"online\",\r\n                        //             status: stanza.attrs.status || \"\",\r\n                        //             type: that.xmppUtils.isFromTelJid(from)\r\n                        //                 ? \"phone\"\r\n                        //                 : that.xmppUtils.isFromMobile(from)\r\n                        //                     ? \"mobile\"\r\n                        //                     : that.xmppUtils.isFromNode(from)\r\n                        //                         ? \"node\"\r\n                        //                         : \"desktopOrWeb\"\r\n                        //         });\r\n                        // } else if (from.includes(\"room_\")) {\r\n                        //     let children = stanza.children;\r\n                        //     children.forEach(function (node) {\r\n                        //         switch (node.getName()) {\r\n                        //             case \"x\":\r\n                        //                 let items = node.children;\r\n                        //                 items.forEach(function (item) {\r\n                        //                     switch (item.getName()) {\r\n                        //                         case \"item\":\r\n                        //                             break;\r\n                        //                         case \"status\":\r\n                        //                             break;\r\n                        //                         default:\r\n                        //                             break;\r\n                        //                     }\r\n                        //                 });\r\n                        //                 break;\r\n                        //             default:\r\n                        //                 break;\r\n                        //         }\r\n                        //     });\r\n                        //     // A presence in a room changes\r\n                        //     let fullJid = that.xmppUtils.getResourceFromFullJID(from);\r\n                        //     if (that.xmppUtils.getBareJIDFromFullJID(fullJid) === that.xmppUtils.getBareJIDFromFullJID(that.fullJid)) {\r\n                        //         // My presence (node or other resources) in the room changes\r\n                        //         that\r\n                        //             .eventEmitter\r\n                        //             .emit(\"evt_internal_bubblepresencechanged\", {\r\n                        //                 fulljid: from,\r\n                        //                 jid: that.xmppUtils.getBareJIDFromFullJID(from),\r\n                        //                 resource: that.xmppUtils.getResourceFromFullJID(from)\r\n                        //             });\r\n                        //     } else {\r\n                        //         // Presence of a participants of the room changes\r\n                        //         that\r\n                        //             .eventEmitter\r\n                        //             .emit(\"rainbow_onbubblerosterpresencechanged\", {\r\n                        //                 fulljid: from,\r\n                        //                 jid: that.xmppUtils.getBareJIDFromFullJID(from),\r\n                        //                 resource: that.xmppUtils.getResourceFromFullJID(from)\r\n                        //             });\r\n                        //     }\r\n                        // } else {\r\n                        //     // Presence of a contact changes\r\n                        //     let priority = 5;\r\n                        //     let show = \"\";\r\n                        //     let delay = \"\";\r\n                        //     let status = \"\";\r\n                        //     if (stanza.attrs.type === \"unavailable\") {\r\n                        //         show = \"unavailable\";\r\n                        //     } else {\r\n                        //         let children = stanza.children;\r\n                        //         children.forEach(function (node) {\r\n                        //             if (node && typeof node !== \"string\") {\r\n                        //                 switch (node.getName()) {\r\n                        //                     case \"priority\":\r\n                        //                         priority = node.getText() || 5;\r\n                        //                         break;\r\n                        //                     case \"show\":\r\n                        //                         show = node.getText() || \"online\";\r\n                        //                         break;\r\n                        //                     case \"delay\":\r\n                        //                         delay = node.attrs.stamp || \"\";\r\n                        //                         break;\r\n                        //                     case \"status\":\r\n                        //                         status = node.getText() || \"\";\r\n                        //                         break;\r\n                        //                     default:\r\n                        //                         break;\r\n                        //                 }\r\n                        //             }\r\n                        //         });\r\n                        //     }\r\n                        //     that.eventEmitter.emit(\"evt_internal_onrosterpresence\", {\r\n                        //         fulljid: from,\r\n                        //         jid: that.xmppUtils.getBareJIDFromFullJID(from),\r\n                        //         resource: that.xmppUtils.getResourceFromFullJID(from),\r\n                        //         value: {\r\n                        //             priority: priority,\r\n                        //             show: show || \"\",\r\n                        //             delay: delay,\r\n                        //             status: status || \"\",\r\n                        //             type: that.xmppUtils.isFromTelJid(from) ? \"phone\" : that.xmppUtils.isFromMobile(from) ? \"mobile\" : that.xmppUtils.isFromNode(from) ? \"node\" : \"desktopOrWeb\"\r\n                        //         }\r\n                        //     });\r\n                        // }\r\n                        break;\r\n                    case \"close\":\r\n                        break;\r\n                    default:\r\n                        that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection) not managed - 'stanza'\", stanza.getName());\r\n                        break;\r\n                }\r\n            });\r\n            this.xmppClient.on(ERROR_EVENT, (err) => __awaiter(this, void 0, void 0, function* () {\r\n                if (err.code === \"HPE_INVALID_CONSTANT\") {\r\n                    return;\r\n                }\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : \" + ERROR_EVENT + \" |\", util.inspect(err.condition || err));\r\n                that.stopIdleTimer();\r\n                if (that.reconnect && err) {\r\n                    // Condition treatments for XEP Errors : https://xmpp.org/rfcs/rfc6120.html#streams-error\r\n                    switch (err.condition) {\r\n                        // Conditions which need a reconnection\r\n                        case \"remote-connection-failed\":\r\n                        case \"reset\":\r\n                        case \"resource-constraint\":\r\n                        case \"connection-timeout\":\r\n                        case \"system-shutdown\":\r\n                            let waitime = 21 + Math.floor(Math.random() * Math.floor(15));\r\n                            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT :  wait \", waitime, \" seconds before try to reconnect\");\r\n                            yield Utils_1.setTimeoutPromised(waitime);\r\n                            if (!that.isReconnecting) {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : try to reconnect...\");\r\n                                yield that.reconnect.reconnect();\r\n                            }\r\n                            else {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : Do nothing, already trying to reconnect...\");\r\n                            }\r\n                            break;\r\n                        // Conditions which need to only raise an event to inform up layer.\r\n                        case \"bad-format\":\r\n                        case \"bad-namespace-prefix\":\r\n                        case \"host-gone\":\r\n                        case \"host-unknown\":\r\n                        case \"improper-addressing\":\r\n                        case \"internal-server-error\":\r\n                        case \"invalid-from\":\r\n                        case \"invalid-namespace\":\r\n                        case \"invalid-xml\":\r\n                        case \"not-authorized\":\r\n                        case \"not-well-formed\":\r\n                        case \"policy-violation\":\r\n                        case \"restricted-xml\":\r\n                        case \"undefined-condition\":\r\n                        case \"unsupported-encoding\":\r\n                        case \"unsupported-feature\":\r\n                        case \"unsupported-stanza-type\":\r\n                            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : for condition : \", err.condition, \", error : \", err);\r\n                            that.eventEmitter.emit(\"evt_internal_xmpperror\", err);\r\n                            break;\r\n                        // Conditions which are fatal errors and then need to stop the SDK.\r\n                        case \"see-other-host\":\r\n                            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : condition : \", err.condition, \" is not supported the SDK\");\r\n                        case \"conflict\":\r\n                        case \"unsupported-version\":\r\n                        default:\r\n                            that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : no reconnection for condition : \", err.condition);\r\n                            that.eventEmitter.emit(\"evt_internal_xmppfatalerror\", err);\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - ERROR_EVENT : reconnection disabled so no reconnect\");\r\n                }\r\n            }));\r\n            this.xmppClient.on(OFFLINE_EVENT, (msg) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - OFFLINE_EVENT : \" + OFFLINE_EVENT + \" |\" + msg);\r\n            });\r\n            this.xmppClient.on(CONNECT_EVENT, () => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - CONNECT_EVENT : \" + CONNECT_EVENT);\r\n            });\r\n            this.xmppClient.on(RECONNECT_EVENT, (msg) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - RECONNECT_EVENT : \" + RECONNECT_EVENT + \" |\" + msg);\r\n            });\r\n            this.xmppClient.on(DISCONNECT_EVENT, () => __awaiter(this, void 0, void 0, function* () {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : \" + DISCONNECT_EVENT + \" |\", { 'reconnect': that.reconnect });\r\n                that.eventEmitter.emit(\"rainbow_xmppdisconnect\", { 'reconnect': that.reconnect });\r\n                let waitime = 11 + Math.floor(Math.random() * Math.floor(15));\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : wait \" + waitime + \" seconds before try to reconnect\");\r\n                yield Utils_1.setTimeoutPromised(waitime);\r\n                if (that.reconnect) {\r\n                    if (!that.isReconnecting) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : try to reconnect...\");\r\n                        yield that.reconnect.reconnect();\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection)  event - DISCONNECT_EVENT : Do nothing, already trying to reconnect...\");\r\n                    }\r\n                }\r\n                else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - DISCONNECT_EVENT : reconnection disabled so no reconnect\");\r\n                }\r\n            }));\r\n            this.xmppClient.on(CLOSE_EVENT, (msg) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - CLOSE_EVENT : \" + CLOSE_EVENT + \" |\" + msg);\r\n            });\r\n            this.xmppClient.on(END_EVENT, (msg) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - END_EVENT : \" + END_EVENT + \" |\" + msg);\r\n            });\r\n            this.reconnect.on(RECONNECTING_EVENT, () => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) plugin event - RECONNECTING_EVENT : \" + RECONNECTING_EVENT);\r\n                if (that.reconnect) {\r\n                    that.logger.log(\"debug\", `${LOG_ID} (handleXMPPConnection) RECONNECTING_EVENT that.reconnect - `, that.reconnect);\r\n                    if (!that.isReconnecting) {\r\n                        that.reconnect.delay = that.fibonacciStrategy.next();\r\n                        that.logger.log(\"debug\", `${LOG_ID} (handleXMPPConnection) RECONNECTING_EVENT update reconnect delay - ${that.reconnect.delay} ms`);\r\n                        that.eventEmitter.emit(\"rainbow_xmppreconnectingattempt\");\r\n                        this.isReconnecting = true;\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection)  event - RECONNECTING_EVENT : Do nothing, already trying to reconnect...\");\r\n                    }\r\n                }\r\n                else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) event - RECONNECTING_EVENT : reconnection disabled so no reconnect\");\r\n                    this.isReconnecting = false;\r\n                }\r\n            });\r\n            this.reconnect.on(RECONNECTED_EVENT, () => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(handleXMPPConnection) plugin event - RECONNECTED_EVENT : \" + RECONNECTED_EVENT);\r\n                that.fibonacciStrategy.reset();\r\n                that.reconnect.delay = that.fibonacciStrategy.getInitialDelay();\r\n                that.isReconnecting = false;\r\n                that.initialPresence = true;\r\n                that.eventEmitter.emit(\"rainbow_xmppreconnected\");\r\n            });\r\n            this.xmppClient.start({\r\n                uri: this.serverURL + \"?x-rainbow-xmpp-dom=\" + domain,\r\n                domain: domain\r\n            }).then((jid) => {\r\n                /* <iq type='get'\r\n                    from='romeo@montague.net/orchard'\r\n                    to='plays.shakespeare.lit'\r\n                    id='info1'>\r\n                        <query xmlns='http://jabber.org/protocol/disco#info'/>\r\n                        </iq> // */\r\n                /*\r\n                // Iq to discover the services provided by rainbow xmpp server\r\n                let stanza = xml(\"iq\", {\r\n                    //to: that.jid_im + \"/\" + that.fullJid,\r\n                    \"type\": \"get\",\r\n                    \"to\": domain,\r\n                    \"id\": that.xmppUtils.getUniqueMessageId()\r\n                }, xml(\"query\", {\"xmlns\": \"http://jabber.org/protocol/disco#info\"}));\r\n\r\n                that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) send IQ discover : \", stanza.root().toString());\r\n                return that.xmppClient.send(stanza);\r\n                // */\r\n                //                if (that.messagesDataStore === DataStoreType.NoStoreBotSide) {\r\n                /*<iq type='set' id='juliet2'>\r\n                <prefs xmlns='urn:xmpp:mam:tmp' default='roster'>\r\n                    <always>\r\n                        <jid>romeo@montague.lit</jid>\r\n                </always>\r\n                <never>\r\n                <jid>montague@montague.lit</jid>\r\n                </never>\r\n                </prefs>\r\n                </iq> // */\r\n                // Iq to discover the services provided by rainbow xmpp server\r\n                //                     let stanzaPrefs = xml(\"iq\", {\r\n                //                             //to: that.jid_im + \"/\" + that.fullJid,\r\n                //                             \"id\": that.xmppUtils.getUniqueMessageId(),\r\n                //                             \"type\": \"set\"\r\n                //                         },\r\n                //                         xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace , \"default\": 'always' },\r\n                //                         //xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace, \"default\": 'always'},\r\n                //                             /* xml(\"prefs\", {\"xmlns\": NameSpacesLabels.MamNameSpace, \"default\": 'always'},\r\n                //                               xml(\"never\", {},\r\n                //                                xml(\"jid\", {}, that.jid_im)\r\n                //                                )\r\n                //                                )\r\n                //                                //*/\r\n                //\r\n                //                               xml(\"auto\", {\"save\" : false}, undefined)\r\n                //                             , undefined)\r\n                //                             // */\r\n                // /*\r\n                //                             undefined\r\n                //                         )\r\n                //                         , undefined\r\n                //                         // */\r\n                //                     );\r\n                //                    that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) send IQ prefs : \", stanzaPrefs.root().toString());\r\n                //                    return that.xmppClient.send(stanzaPrefs);\r\n                //                }\r\n                // */\r\n            }) // */\r\n                /*\r\n                this.xmppClient.start().then((jid) => {\r\n                    that.logger.log(\"info\", \"started\", jid.toString());\r\n                })// */\r\n                .catch(err => {\r\n                // rejects for any error before online\r\n                if (err.code === \"HPE_INVALID_CONSTANT\") {\r\n                    that.logger.log(\"error\", LOG_ID + \"start reconnect \", err);\r\n                    that.reconnect.reconnect();\r\n                    return;\r\n                }\r\n                that.logger.log(\"error\", LOG_ID + \"start failed\", err);\r\n            });\r\n        };\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(withXMPP) {\r\n        let that = this;\r\n        this.forceClose = false;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                if (withXMPP) {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(start) host used : \", that.host);\r\n                    that.logger.log(\"info\", LOG_ID + \"(start) XMPP URL : \", that.serverUR);\r\n                }\r\n                else {\r\n                    that.logger.log(\"info\", LOG_ID + \"(start) XMPP connection blocked by configuration\");\r\n                }\r\n                that.isReconnecting = false;\r\n                that.useXMPP = withXMPP;\r\n                that.ready = that.useXMPP; // Put not ready state when the XMPP is disabled in SDK config options, then methods become unavailable with @isStarted decorator.\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    signin(account, headers) {\r\n        let that = this;\r\n        return new Promise(function (resolve) {\r\n            that.IQEventHandlerToken = [];\r\n            that.eventEmitter.once(\"xmppconnected\", function fn_xmppconnected() {\r\n                that.eventEmitter.removeListener(\"xmppconnected\", fn_xmppconnected);\r\n                resolve();\r\n            });\r\n            if (that.useXMPP) {\r\n                that.jid_im = account.jid_im;\r\n                that.jid_tel = account.jid_tel;\r\n                that.jid_password = account.jid_password;\r\n                that.userId = account.id;\r\n                that.fullJid = that.xmppUtils.generateRandomFullJidForNode(that.jid_im, that.generatedRandomId);\r\n                that.jid = account.jid_im;\r\n                that.logger.log(\"internal\", LOG_ID + \"(signin) account used, jid_im : \", that.jid_im, \", fullJid : \", that.fullJid);\r\n                that.IQEventHandler = new iqEventHandler_1.IQEventHandler(that);\r\n                that.IQEventHandlerToken = [\r\n                    PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_GET, that.IQEventHandler.onIqGetReceived),\r\n                    PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_SET, that.IQEventHandler.onIqGetReceived),\r\n                    PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_RESULT, that.IQEventHandler.onIqResultReceived)\r\n                ];\r\n                that.handleXMPPConnection(headers);\r\n                that.IQEventHandlerToken.push(PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_RESULT, that.xmppClient.onIqResultReceived));\r\n                that.IQEventHandlerToken.push(PubSub.subscribe(that.hash + \".\" + that.IQEventHandler.IQ_ERROR, that.xmppClient.onIqErrorReceived));\r\n                that.startOrResetIdleTimer();\r\n                //resolve();\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    stop(forceStop) {\r\n        let that = this;\r\n        return new Promise(function (resolve) {\r\n            try {\r\n                that.jid_im = \"\";\r\n                that.jid_tel = \"\";\r\n                that.jid_password = \"\";\r\n                that.fullJid = \"\";\r\n                that.userId = \"\";\r\n                that.initialPresence = true;\r\n                if (that.useXMPP && forceStop) {\r\n                    that.stopIdleTimer();\r\n                    delete that.IQEventHandler;\r\n                    that.IQEventHandler = null;\r\n                    if (that.IQEventHandlerToken) {\r\n                        that.IQEventHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n                    }\r\n                    that.IQEventHandlerToken = [];\r\n                    that.forceClose = true;\r\n                    // Disconnect the auto-reconnect mode\r\n                    if (that.reconnect) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(stop) stop XMPP auto-reconnect mode\");\r\n                        that.reconnect.stop();\r\n                        that.reconnect = null;\r\n                    }\r\n                    // Disconnect the xmpp connection\r\n                    if (that.xmppClient) {\r\n                        let stanza = xml(\"presence\", {\r\n                            //to: that.jid_im + \"/\" + that.fullJid,\r\n                            type: \"unavailable\"\r\n                        }, xml(\"x\", { \"xmlns\": NameSpacesLabels.MucNameSpace }));\r\n                        stanza.append(xml(\"show\", {}, \"away\"));\r\n                        stanza.append(xml(\"status\", {}, \"away\"));\r\n                        that.logger.log(\"internal\", LOG_ID + \"(stop) send Unavailable Presence- send - 'message'\", stanza.root().toString());\r\n                        that.xmppClient.send(stanza);\r\n                        that.xmppClient.stop().then(() => {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(stop) stop XMPP connection\");\r\n                            that.xmppClient = null;\r\n                            resolve();\r\n                        }).catch((err) => {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(stop) error received\");\r\n                            that.logger.log(\"internalerror\", LOG_ID + \"(stop) error received : \", err);\r\n                            resolve();\r\n                        });\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(stop) nothing to stop\");\r\n                        resolve();\r\n                    }\r\n                }\r\n                else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(stop) nothing to stop\");\r\n                    resolve();\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"debug\", LOG_ID + \"(stop) error received\");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(stop) error received : \", err);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    startOrResetIdleTimer(incomingStanza = false) {\r\n        if ((this.pingTimer && !incomingStanza) || (this.reconnect && this.reconnect.isReconnecting)) {\r\n            return;\r\n        }\r\n        this.stopIdleTimer();\r\n        if (!this.forceClose) {\r\n            this.idleTimer = setTimeout(() => {\r\n                this.logger.log(\"warn\", LOG_ID + \"(startOrResetIdleTimer) No message received since \" + MAX_IDLE_TIMER / 1000 + \" seconds.\");\r\n                // Start waiting an answer from server else reset the connection\r\n                this.pingTimer = setTimeout(() => {\r\n                    this.pingTimer = null;\r\n                    this.xmppClient.socket && this.xmppClient.socket.end();\r\n                }, MAX_PING_ANSWER_TIMER);\r\n                this.sendPing();\r\n            }, MAX_IDLE_TIMER);\r\n        }\r\n    }\r\n    stopIdleTimer() {\r\n        if (this.idleTimer) {\r\n            clearTimeout(this.idleTimer);\r\n            this.idleTimer = null;\r\n        }\r\n        if (this.pingTimer) {\r\n            clearTimeout(this.pingTimer);\r\n            this.pingTimer = null;\r\n        }\r\n    }\r\n    setPresence(show, status) {\r\n        let that = this;\r\n        if (this.useXMPP) {\r\n            let stanza = xml(\"presence\", { \"id\": that.xmppUtils.getUniqueMessageId() });\r\n            if (this.initialPresence) {\r\n                this.initialPresence = false;\r\n                stanza.append(xml(\"application\", { xmlns: NameSpacesLabels.ApplicationNameSpace }, xml(\"appid\", {}, this.applicationId), xml(\"userid\", {}, this.userId)));\r\n            }\r\n            stanza.append(xml(\"priority\", {}, \"5\"));\r\n            if (show && show !== \"online\") {\r\n                stanza.append(xml(\"show\", {}, show));\r\n            }\r\n            if (status && (!show || show === \"online\")) {\r\n                stanza.append(xml(\"status\", {}, status));\r\n            }\r\n            else if (status) {\r\n                stanza.append(xml(\"status\", {}, status));\r\n            }\r\n            this.logger.log(\"info\", LOG_ID + \"(setPresence) send - 'stanza'\");\r\n            this.logger.log(\"internal\", LOG_ID + \"(setPresence) send - 'stanza'\", stanza.toString());\r\n            return this.xmppClient.send(stanza);\r\n        }\r\n        else {\r\n            this.logger.log(\"warn\", LOG_ID + \"(setPresence) No XMPP connection...\");\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    //Message Carbon XEP-0280\r\n    enableCarbon() {\r\n        let that = this;\r\n        if (this.useXMPP) {\r\n            let stanza = xml(\"iq\", {\r\n                \"type\": \"set\",\r\n                id: \"enable_xmpp_carbon\"\r\n            }, xml(\"enable\", { xmlns: NameSpacesLabels.Carbon2NameSpace }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(enableCarbon) send - 'stanza'\", stanza.toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanza).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(enableCarbon) sent\");\r\n                    resolve();\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(enableCarbon) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    sendChatMessage(message, jid, lang, content, subject, answeredMsg) {\r\n        let that = this;\r\n        if (that.useXMPP) {\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\r\n                return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\r\n            }\r\n            // Remove resource if exists\r\n            jid = that.xmppUtils.getBareJIDFromFullJID(jid);\r\n            let stanza = xml(\"message\", {\r\n                //\"from\": this.fullJid,\r\n                //\"from\": this.jid_im,\r\n                \"to\": jid,\r\n                \"xmlns\": NameSpacesLabels.ClientNameSpace,\r\n                \"type\": TYPE_CHAT,\r\n                \"id\": id\r\n            }, xml(\"body\", {\r\n                \"xml:lang\": lang\r\n            }, message), xml(\"request\", {\r\n                \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\r\n            }, xml(\"active\", {\r\n                \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\r\n            })));\r\n            let answeredMsgId = null;\r\n            let answeredMsgDate = null;\r\n            if (answeredMsg) {\r\n                stanza.append(xml(\"answeredMsg\", { \"stamp\": answeredMsg.date.getTime() }, answeredMsg.id));\r\n                answeredMsgId = answeredMsg.id;\r\n                answeredMsgDate = answeredMsg.date;\r\n                that.logger.log(\"internal\", LOG_ID + \"(sendChatMessage) answeredMsg : \", stanza);\r\n            }\r\n            if (subject) {\r\n                stanza.append(xml(\"subject\", {\r\n                    \"xml:lang\": lang\r\n                }, subject));\r\n            }\r\n            if (content && content.message) {\r\n                let contentType = content.type || \"text/markdown\";\r\n                stanza.append(xml(\"content\", {\r\n                    \"type\": contentType,\r\n                    \"xmlns\": NameSpacesLabels.ContentNameSpace\r\n                }, content.message));\r\n            }\r\n            that.logger.log(\"internal\", LOG_ID + \"(sendChatMessage) send - 'message'\", stanza.toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanza).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(sendChatMessage) sent\");\r\n                    resolve({ from: this.jid_im, to: jid, type: \"chat\", id: id, date: new Date(), content: message });\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(sendChatMessage) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    sendChatMessageToBubble(message, jid, lang, content, subject, answeredMsg, attention) {\r\n        let that = this;\r\n        if (that.useXMPP) {\r\n            if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\r\n                return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\r\n            }\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            // from=\"room_85a525f559a14b1d88de9c79d866233f@muc.vberder-all-in-one-dev-1.opentouch.cloud/2c1e9ac0f2254b94bb2d977be498423d@vberder-all-in-one-dev-1.opentouch.cloud/web_win_1.56.8_S28ZBemj\"\r\n            // from=\"room_17b2b86803b24bcd9ac70973bb311b9b@muc.vberder-all-in-one-dev-1.opentouch.cloud/2c1e9ac0f2254b94bb2d977be498423d@vberder-all-in-one-dev-1.opentouch.cloud/node_NWGWQN6V\"\r\n            let stanza = xml(\"message\", {\r\n                'xmlns': 'jabber:client',\r\n                'xml:lang': lang,\r\n                'to': jid,\r\n                // 'from': jid + \"/\" + that.fullJid,\r\n                'type': TYPE_GROUPCHAT,\r\n                'id': id\r\n            }, xml(\"body\", {\r\n                \"xml:lang\": lang\r\n            }, message), xml(\"request\", {\r\n                \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\r\n            }, xml(\"active\", {\r\n                \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\r\n            })));\r\n            if (subject) {\r\n                stanza.append(xml(\"subject\", {\r\n                    \"xml:lang\": lang\r\n                }, subject));\r\n            }\r\n            let answeredMsgId = null;\r\n            let answeredMsgDate = null;\r\n            if (answeredMsg) {\r\n                stanza.append(xml(\"answeredMsg\", { \"stamp\": answeredMsg.date.getTime() }, answeredMsg.id), undefined);\r\n                answeredMsgId = answeredMsg.id;\r\n                answeredMsgDate = answeredMsg.date;\r\n                that.logger.log(\"internal\", LOG_ID + \"(sendChatMessageToBubble) answeredMsg : \", stanza);\r\n            }\r\n            if (content && content.message) {\r\n                let contentType = content.type || \"text/markdown\";\r\n                stanza.append(xml(\"content\", {\r\n                    \"type\": contentType,\r\n                    \"xmlns\": NameSpacesLabels.ContentNameSpace\r\n                }, content.message));\r\n            }\r\n            if (attention) {\r\n                if (Array.isArray(attention) && attention.length > 0) {\r\n                    let mentions = xml(\"mention\", { \"xmlns\": NameSpacesLabels.AttentionNS }, undefined);\r\n                    attention.forEach(function (jidMentioned) {\r\n                        mentions.append(xml(\"jid\", {}, jidMentioned), undefined);\r\n                    });\r\n                    stanza.append(mentions, undefined);\r\n                }\r\n                else if (typeof attention === 'string' || attention instanceof String) {\r\n                    let mentions = xml(\"mention\", { \"xmlns\": NameSpacesLabels.AttentionNS }, undefined);\r\n                    mentions.append(xml(\"jid\", {}, attention), undefined);\r\n                    stanza.append(mentions, undefined);\r\n                }\r\n            }\r\n            that.logger.log(\"internal\", LOG_ID + \"(sendChatMessageToBubble) send - 'message'\", stanza.toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanza).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(sendChatMessageToBubble) sent\");\r\n                    resolve({\r\n                        from: this.jid_im,\r\n                        to: jid,\r\n                        type: \"groupchat\",\r\n                        id: id,\r\n                        date: new Date(),\r\n                        message: message,\r\n                        content: content,\r\n                        subject: subject,\r\n                        lang: lang,\r\n                        answeredMsg: answeredMsg\r\n                    });\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(sendChatMessageToBubble) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n        //return null;\r\n    }\r\n    sendCorrectedChatMessage(conversation, originalMessage, data, origMsgId, lang) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            //        $log.info(\"[Conversation] >sendCorrectedChatMessage: origMsgId=\" + origMsgId)\r\n            /* <message to='juliet@capulet.net/balcony' id='good1'>\r\n            <body>But soft, what light through yonder window breaks?</body>\r\n            <replace id='bad1' xmlns='urn:xmpp:message-correct:0'/>\r\n            <store xmlns='urn:xmpp:hints'/>\r\n            </message> */\r\n            // this.sendAckReadMessages();\r\n            let xmppMessage = null;\r\n            // Build the message ID\r\n            let messageToSendID = that.xmppUtils.getUniqueMessageId();\r\n            that.logger.log(\"debug\", LOG_ID + \"(sendCorrectedChatMessage) : messageToSendID : \" + messageToSendID);\r\n            // Handle One to one conversation message\r\n            if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n                let to = conversation.id; //this.contact.jid;\r\n                xmppMessage = xml(\"message\", { to: to, type: \"chat\", id: messageToSendID, \"xml:lang\": lang }, xml(\"body\", { \"xml:lang\": lang }, data), xml(\"replace\", { id: origMsgId, \"xmlns\": NameSpacesLabels.MessageCorrectNameSpace }), xml(\"store\", { \"xmlns\": NameSpacesLabels.HintsNameSpace }), xml(\"request\", { \"xmlns\": NameSpacesLabels.ReceiptNS }), xml(\"active\", { \"xmlns\": NameSpacesLabels.ChatstatesNS }));\r\n            }\r\n            // Handle Room conversation message\r\n            else {\r\n                xmppMessage = xml(\"message\", { to: conversation.bubble.jid, type: \"groupchat\", id: messageToSendID }, xml(\"body\", { \"xml:lang\": lang }, data), xml(\"replace\", { id: origMsgId, \"xmlns\": NameSpacesLabels.MessageCorrectNameSpace }), xml(\"store\", { \"xmlns\": NameSpacesLabels.HintsNameSpace }), xml(\"request\", { \"xmlns\": NameSpacesLabels.ReceiptNS }), xml(\"active\", { \"xmlns\": NameSpacesLabels.ChatstatesNS }));\r\n            }\r\n            // message = this.addChatReplaceMessage(contactService.userContact, new Date(), unicodeData, messageToSendID, true);\r\n            if (!originalMessage) {\r\n                return null;\r\n            }\r\n            /* WEB SDK :\r\n            originalMessage.serverAckTimer = $interval(function() {\r\n                originalMessage.receiptStatus = Message.ReceiptStatus.ERROR;\r\n                that.updateMessage(originalMessage);\r\n            }, 10000);\r\n    \r\n            // Add message in messages array\r\n            originalMessage.addReplaceMsg(messageToSendID, data);\r\n            //*/\r\n            // Create and send message\r\n            that.xmppClient.send(xmppMessage);\r\n            return messageToSendID;\r\n        });\r\n    }\r\n    markMessageAsRead(message) {\r\n        let that = this;\r\n        if (this.useXMPP) {\r\n            let stanzaRead = xml(\"message\", {\r\n                \"to\": message.fromJid,\r\n                //\"from\": message.toJid + \"ERROR\",\r\n                \"type\": TYPE_CHAT\r\n            }, xml(\"received\", {\r\n                \"xmlns\": NameSpacesLabels.ReceiptsNameSpace,\r\n                \"event\": \"read\",\r\n                \"entity\": \"client\",\r\n                \"id\": message.id\r\n            }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(markMessageAsRead) send - 'message'\", stanzaRead.root().toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanzaRead).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(markMessageAsRead) sent\");\r\n                    resolve();\r\n                }).catch((err) => {\r\n                    that.logger.log(\"error\", LOG_ID + \"(markMessageAsRead) error \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(markMessageAsRead) error : \", err);\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    sendChatExistingFSMessage(message, jid, lang, fileDescriptor) {\r\n        let that = this;\r\n        if (that.useXMPP) {\r\n            if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\r\n                return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\r\n            }\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            // Remove resource if exists\r\n            jid = that.xmppUtils.getBareJIDFromFullJID(jid);\r\n            //let url = this.host + \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\r\n            let url = \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\r\n            let stanza = xml(\"message\", {\r\n                // \"from\": this.fullJid,\r\n                \"to\": jid,\r\n                \"xmlns\": NameSpacesLabels.ClientNameSpace,\r\n                \"type\": TYPE_CHAT,\r\n                \"id\": id\r\n            }, xml(\"body\", {\r\n                \"xml:lang\": lang\r\n            }, message), xml(\"request\", {\r\n                \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\r\n            }, xml(\"active\", {\r\n                \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\r\n            })), xml(\"x\", {\r\n                \"xmlns\": NameSpacesLabels.OobNameSpace\r\n            }, xml(\"url\", {}, url), xml(\"mime\", {}, fileDescriptor.typeMIME), xml(\"filename\", {}, fileDescriptor.fileName), xml(\"size\", {}, fileDescriptor.size)), xml(\"store\", {\r\n                \"xmlns\": NameSpacesLabels.HintsNameSpace\r\n            }));\r\n            that.logger.log(\"internal\", LOG_ID + \"(sendChatExistingFSMessage) send - 'message'\", stanza.toString());\r\n            return new Promise((resolve, reject) => {\r\n                that\r\n                    .xmppClient\r\n                    .send(stanza).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(sendChatExistingFSMessage) sent\");\r\n                    resolve({ from: this.jid_im, to: jid, type: \"chat\", id: id, date: new Date(), content: message });\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(sendChatExistingFSMessage) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    sendChatExistingFSMessageToBubble(message, jid, lang, fileDescriptor) {\r\n        let that = this;\r\n        if (that.useXMPP) {\r\n            if (!that.shouldSendMessageToConnectedUser && that.jid_im == jid) {\r\n                return Promise.reject(\"Can not send a message to the connected user : \" + that.jid_im);\r\n            }\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            // Remove resource if exists\r\n            jid = that.xmppUtils.getBareJIDFromFullJID(jid);\r\n            //let url = this.host  + \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\r\n            let url = \"/api/rainbow/fileserver/v1.0/files/\" + fileDescriptor.id;\r\n            let stanza = xml(\"message\", {\r\n                //\"from\": this.fullJid,\r\n                \"to\": jid,\r\n                \"xmlns\": NameSpacesLabels.ClientNameSpace,\r\n                \"type\": TYPE_GROUPCHAT,\r\n                \"id\": id\r\n            }, xml(\"body\", {\r\n                \"xml:lang\": lang\r\n            }, message), xml(\"request\", {\r\n                \"xmlns\": NameSpacesLabels.ReceiptsNameSpace\r\n            }, xml(\"active\", {\r\n                \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\r\n            })), xml(\"x\", {\r\n                \"xmlns\": NameSpacesLabels.OobNameSpace\r\n            }, xml(\"url\", {}, url), xml(\"mime\", {}, fileDescriptor.typeMIME), xml(\"filename\", {}, fileDescriptor.fileName), xml(\"size\", {}, fileDescriptor.size)), xml(\"store\", {\r\n                \"xmlns\": NameSpacesLabels.HintsNameSpace\r\n            }));\r\n            that.logger.log(\"internal\", LOG_ID + \"(sendChatExistingFSMessageToBubble) send - 'message'\", stanza.toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanza).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(sendChatExistingFSMessageToBubble) sent\");\r\n                    resolve({ from: this.jid_im, to: jid, type: \"chat\", id: id, date: new Date(), content: message });\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(sendChatExistingFSMessageToBubble) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    sendIsTypingState(conversation, isTypingState) {\r\n        let that = this;\r\n        let state = (isTypingState) ? \"composing\" : \"active\";\r\n        if (this.useXMPP) {\r\n            let jid = conversation.id;\r\n            let type = \"chat\";\r\n            // Handle One to one conversation message\r\n            if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n                //jid = this.contact.jid;\r\n                type = \"chat\";\r\n            }\r\n            // Handle Room conversation message\r\n            else {\r\n                type = \"groupchat\";\r\n            }\r\n            let stanzaRead = xml(\"message\", {\r\n                \"to\": jid,\r\n                \"type\": type,\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            }, xml(state, {\r\n                \"xmlns\": NameSpacesLabels.ChatestatesNameSpace\r\n            }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(sendIsTypingState) send - 'message'\", stanzaRead.root().toString());\r\n            return new Promise((resolve, reject) => {\r\n                that.xmppClient.send(stanzaRead).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(sendIsTypingState) sent\");\r\n                    resolve();\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            });\r\n        }\r\n        that.logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No XMPP connection...\");\r\n        return Promise.resolve(null);\r\n    }\r\n    getRosters() {\r\n        let that = this;\r\n        //this.logger.log(\"debug\", LOG_ID + \"(start) getRosters\");\r\n        if (this.useXMPP) {\r\n            let stanza = xml(\"iq\", {\r\n                \"id\": that.xmppUtils.getUniqueMessageId(),\r\n                \"type\": \"get\"\r\n            }, xml(\"query\", { xmlns: NameSpacesLabels.RosterNameSpace }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(getRosters) send - 'iq/rosters'\", stanza.toString());\r\n            this.xmppClient.send(stanza);\r\n        }\r\n        else {\r\n            this.logger.log(\"warn\", LOG_ID + \"(getRosters) No XMPP connection...\");\r\n        }\r\n    }\r\n    /****************************************************/\r\n    /**            XMPP ROSTER MANAGEMENT              **/\r\n    /****************************************************/\r\n    sendSubscription(contact) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            // Return immediately if already subscribed\r\n            if (contact.subscribe === \"to\" || contact.subscribe === \"both\") {\r\n                return;\r\n            }\r\n            // Send subscriptions for im and telephony presences\r\n            yield that.sendSubscribeInvitation(contact.jid);\r\n            yield that.sendSubscribeInvitation(contact.jidtel);\r\n            return;\r\n        });\r\n    }\r\n    ;\r\n    sendSubscribeInvitation(jid) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            this.logger.log(\"debug\", LOG_ID + \"(sendSubscribeInvitation) Send subscribe invitation to \", jid);\r\n            let stanza = xml(\"iq\", {\r\n                type: \"get\",\r\n                to: that.jid_tel + \"/phone\",\r\n                xmlns: NameSpacesLabels.ClientNameSpace,\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            }, xml(\"pbxagentstatus\", { \"xmlns\": NameSpacesLabels.Monitoring1NameSpace }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(getAgentStatus) send - 'iq get'\", stanza.root().toString());\r\n            return this.xmppClient.sendIq(stanza);\r\n        });\r\n    }\r\n    ;\r\n    sendInitialBubblePresence(jid) {\r\n        let that = this;\r\n        let id = that.xmppUtils.getUniqueMessageId();\r\n        if (this.useXMPP) {\r\n            let stanza = xml(\"presence\", {\r\n                \"id\": id,\r\n                to: jid + \"/\" + this.fullJid\r\n            }, xml(\"x\", { \"xmlns\": NameSpacesLabels.MucNameSpace }).append(xml(\"history\", { maxchars: \"0\" })));\r\n            if (this.initialPresence) {\r\n                this.initialPresence = false;\r\n                stanza.append(xml(\"application\", { xmlns: NameSpacesLabels.ApplicationNameSpace }, xml(\"appid\", {}, this.applicationId), xml(\"userid\", {}, this.userId)));\r\n                stanza.append(xml(\"priority\", {}, \"5\"));\r\n            }\r\n            this.logger.log(\"internal\", LOG_ID + \"(sendInitialBubblePresence) send - 'message'\", stanza.root().toString());\r\n            return this.xmppClient.send(stanza);\r\n        }\r\n        else {\r\n            this.logger.log(\"warn\", LOG_ID + \"(sendInitialBubblePresence) No XMPP connection...\");\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    sendUnavailableBubblePresence(jid) {\r\n        let that = this;\r\n        if (this.useXMPP) {\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            let stanza = xml(\"presence\", {\r\n                \"id\": id,\r\n                to: jid + \"/\" + this.fullJid,\r\n                type: \"unavailable\"\r\n            }, xml(\"x\", { \"xmlns\": NameSpacesLabels.MucNameSpace }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(sendUnavailableBubblePresence) send - 'message'\", stanza.root().toString());\r\n            this.xmppClient.send(stanza);\r\n        }\r\n        else {\r\n            this.logger.log(\"warn\", LOG_ID + \"(sendUnavailableBubblePresence) No XMPP connection...\");\r\n        }\r\n    }\r\n    getAgentStatus() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (this.useXMPP) {\r\n                let stanza = xml(\"iq\", {\r\n                    type: \"get\",\r\n                    to: that.jid_tel + \"/phone\",\r\n                    xmlns: NameSpacesLabels.ClientNameSpace,\r\n                    \"id\": that.xmppUtils.getUniqueMessageId()\r\n                }, xml(\"pbxagentstatus\", { \"xmlns\": NameSpacesLabels.Monitoring1NameSpace }));\r\n                this.logger.log(\"internal\", LOG_ID + \"(getAgentStatus) send - 'iq get'\", stanza.root().toString());\r\n                this.xmppClient.sendIq(stanza).then((data) => {\r\n                    let pbxagentstatus = {\r\n                        \"phoneapi\": \"\",\r\n                        \"xmppagent\": \"\",\r\n                        \"version\": \"\"\r\n                    };\r\n                    let agentStatus = { \"phoneApi\": \"\", \"xmppAgent\": \"\", \"agentVersion\": \"\" };\r\n                    let subchildren = data.children[0].children;\r\n                    subchildren.forEach((item) => {\r\n                        if (typeof item === \"object\") {\r\n                            let itemName = item.getName();\r\n                            if (itemName) {\r\n                                pbxagentstatus[itemName] = item.text();\r\n                            }\r\n                        }\r\n                    });\r\n                    if (pbxagentstatus.version) {\r\n                        let phoneApi = pbxagentstatus.phoneapi;\r\n                        let xmppAgent = pbxagentstatus.xmppagent;\r\n                        let agentVersion = pbxagentstatus.version;\r\n                        agentStatus = { \"phoneApi\": phoneApi, \"xmppAgent\": xmppAgent, \"agentVersion\": agentVersion };\r\n                    }\r\n                    resolve(agentStatus);\r\n                });\r\n            }\r\n            else {\r\n                resolve({});\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n      * @param useAfter\r\n     * @returns {Promise<void>}\r\n     */\r\n    sendGetCallLogHistoryPage(useAfter) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            /*\r\n            <iq from=\"38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud\" id=\"c08a506f-83d9-48a8-8628-10d69a44c340:sendIQ\" type=\"set\" xmlns=\"jabber:client\">\r\n                <query xmlns=\"jabber:iq:telephony:call_log\">\r\n                    <set xmlns=\"http://jabber.org/protocol/rsm\">\r\n                        <max>75</max>\r\n                        <before></before>\r\n                    </set>\r\n                </query>\r\n            </iq>\r\n             */\r\n            let that = this;\r\n            // Get the user contact\r\n            let useMax = 75;\r\n            let useBefore = \"\"; //add empty before in order to get the most recent messages\r\n            //let useAfter;\r\n            let stanza = xml(\"iq\", {\r\n                \"from\": this.jid_im,\r\n                \"type\": \"set\",\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            });\r\n            let queryEmt = xml(\"query\", {\r\n                xmlns: NameSpacesLabels.CallLogNamespace\r\n            });\r\n            if (useMax || useBefore || useAfter) {\r\n                let rsmSet = xml(\"set\", { xmlns: NameSpacesLabels.RsmNameSpace });\r\n                if (useMax) {\r\n                    rsmSet.append(xml(\"max\", {}, useMax));\r\n                }\r\n                if (useAfter) {\r\n                    rsmSet.append(xml(\"after\", {}, useAfter));\r\n                }\r\n                else {\r\n                    rsmSet.append(xml(\"before\", {}, useBefore));\r\n                }\r\n                queryEmt.append(rsmSet);\r\n            }\r\n            stanza.append(queryEmt);\r\n            return yield this.xmppClient.sendIq(stanza);\r\n        });\r\n    }\r\n    deleteOneCallLog(id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[deleteOneCallLog] deleteOneCallLog : \" + id);\r\n            // Get the user contact\r\n            //let userContact = contactService.userContact;\r\n            let message = xml(\"iq\", {\r\n                \"from\": this.jid_im,\r\n                \"to\": this.jid_im,\r\n                \"type\": \"set\",\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            });\r\n            let msg = message.append(xml(\"delete\", { xmlns: NameSpacesLabels.CallLogNamespace, call_id: id }));\r\n            return yield this.xmppClient.sendIq(msg);\r\n        });\r\n    }\r\n    deleteCallLogsForContact(jid) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[deleteCallLogsForContact] deleteCallLogsForContact : \" + jid);\r\n            // Get the user contact\r\n            //let userContact = contactService.userContact;\r\n            let message = xml(\"iq\", {\r\n                \"from\": that.jid_im,\r\n                \"to\": that.jid_im,\r\n                \"type\": \"set\",\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            });\r\n            let msg = message.append(xml(\"delete\", { xmlns: NameSpacesLabels.CallLogNamespace, peer: jid }));\r\n            return yield this.xmppClient.sendIq(msg);\r\n            //xmppService.sendIQ(msg);\r\n        });\r\n    }\r\n    deleteAllCallLogs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            // Get the user contact\r\n            //let userContact = contactService.userContact;\r\n            if (this.useXMPP) {\r\n                let message = xml(\"iq\", {\r\n                    \"from\": that.jid_im,\r\n                    \"to\": that.jid_im,\r\n                    \"type\": \"set\",\r\n                    \"id\": that.xmppUtils.getUniqueMessageId()\r\n                });\r\n                let msg = message.append(xml(\"delete\", { xmlns: NameSpacesLabels.CallLogNamespace }));\r\n                return yield this.xmppClient.sendIq(msg);\r\n                //xmppService.sendIQ(msg);\r\n            }\r\n            else {\r\n                this.logger.log(\"warn\", LOG_ID + \"(deleteAllCallLogs) No XMPP connection...\");\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    markCallLogAsRead(id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[markCallLogAsRead] markCallLogAsRead : \" + id);\r\n            // Get the user contact\r\n            //let userContact = contactService.userContact;\r\n            let message = xml(\"message\", {\r\n                \"from\": that.jid_im,\r\n                \"to\": that.jid_im,\r\n                \"id\": that.xmppUtils.getUniqueMessageId()\r\n            });\r\n            let msg = message.append(xml(\"read\", { xmlns: NameSpacesLabels.CallLogAckNamespace, call_id: id }));\r\n            return yield this.xmppClient.sendIq(msg);\r\n            //xmppService.sendIQ(msg);\r\n        });\r\n    }\r\n    markAllCallsLogsAsRead(callLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            //let userContact = contactService.userContact;\r\n            let promSend = [];\r\n            for (let i = 0; i < callLogs.length; i++) {\r\n                if (!callLogs[i].read) {\r\n                    let message = xml(\"message\", {\r\n                        \"from\": that.jid_im,\r\n                        \"to\": that.jid_im,\r\n                        \"id\": that.xmppUtils.getUniqueMessageId()\r\n                    });\r\n                    let msg = message.append(xml(\"read\", {\r\n                        \"xmlns\": NameSpacesLabels.CallLogAckNamespace,\r\n                        \"call_id\": callLogs[i].id\r\n                    }));\r\n                    promSend.push(that.xmppClient.sendIq(msg));\r\n                    //xmppService.sendIQ(msg);\r\n                }\r\n            }\r\n            return yield Promise.all(promSend);\r\n        });\r\n    }\r\n    deleteAllMessageInOneToOneConversation(conversationId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            /*\r\n            <iq id=\"3b718ea6-5dae-4e29-b54c-b843156df93d\" type=\"set\" xmlns=\"jabber:client\">\r\n      <delete queryid=\"dd008366-ad0f-4197-a61c-0c34fbc0e75a\" xmlns=\"urn:xmpp:mam:1\">\r\n        <x type=\"submit\" xmlns=\"jabber:x:data\">\r\n          <field type=\"hidden\" var=\"FORM_TYPE\">\r\n            <value>urn:xmpp:mam:1\r\n            </value>\r\n          </field>\r\n          <field var=\"with\">\r\n            <value>7ebaaacfa0634f46a903bcdd83ae793b@openrainbow.net\r\n            </value>\r\n          </field>\r\n        </x>\r\n        <set xmlns=\"http://jabber.org/protocol/rsm\"/>\r\n      </delete>\r\n    </iq>\r\n             */\r\n            // Get the user contact\r\n            //let userContact = contactService.userContact;\r\n            let uniqMessageId = that.xmppUtils.getUniqueMessageId();\r\n            let uniqId = that.xmppUtils.getUniqueId(undefined);\r\n            let message = xml(\"iq\", {\r\n                //\"from\": that.jid_im,\r\n                //\"to\": that.jid_im,\r\n                \"type\": \"set\",\r\n                \"id\": uniqMessageId\r\n            });\r\n            let rsmDelete = xml(\"delete\", { xmlns: NameSpacesLabels.MamNameSpace, queryid: uniqId });\r\n            let rsmx = xml(\"x\", { xmlns: NameSpacesLabels.DataNameSpace, type: \"submit\" });\r\n            let rsmField1 = xml(\"field\", { var: \"FORM_TYPE\", type: \"hidden\" });\r\n            let rsmvalue1 = xml(\"value\", {}, NameSpacesLabels.MamNameSpace);\r\n            let rsmField2 = xml(\"field\", { var: \"with\" });\r\n            let rsmvalue2 = xml(\"value\", {}, conversationId);\r\n            let rsmset = xml(\"set\", { xmlns: NameSpacesLabels.RsmNameSpace });\r\n            rsmField1.append(rsmvalue1, undefined);\r\n            rsmField2.append(rsmvalue2, undefined);\r\n            rsmx.append(rsmField1, undefined);\r\n            rsmx.append(rsmField2, undefined);\r\n            rsmDelete.append(rsmx, undefined);\r\n            rsmDelete.append(rsmset, undefined);\r\n            let msg = message.append(rsmDelete, undefined);\r\n            //return Promise.resolve(message);\r\n            return yield this.xmppClient.sendIq(msg);\r\n            //xmppService.sendIQ(msg);\r\n        });\r\n    }\r\n    getErrorMessage(data, actionLabel) {\r\n        let errorMessage = actionLabel + \" failure : \";\r\n        if (data.attr(\"type\") === \"error\") {\r\n            //let errorMsg = stanza.getChild(\"error\")?stanza.getChild(\"error\").getChild(\"text\").getText() ||  \"\" : \"\";\r\n            let error = data.getChild(\"error\");\r\n            if (error) {\r\n                let errorType = error.attr(\"type\");\r\n                let errorCode = error.attr(\"code\");\r\n                if (errorType) {\r\n                    errorMessage += (errorType + \" : \");\r\n                    if (errorType === \"modify\") {\r\n                        errorMessage += error.getChild(\"text\").getText() || \"\";\r\n                    }\r\n                }\r\n                if (errorCode) {\r\n                    if (errorCode === \"503\") {\r\n                        errorMessage += \"Agent error : service unavailable\";\r\n                    }\r\n                }\r\n                this.logger.log(\"error\", LOG_ID + \"[getErrorMessage] \");\r\n                this.logger.log(\"internalerror\", LOG_ID + \"[getErrorMessage] : \" + errorMessage);\r\n            }\r\n            else {\r\n                errorMessage += \"Unknown error\";\r\n            }\r\n            return errorMessage;\r\n        }\r\n        return null;\r\n    }\r\n    getTelephonyState(secondary) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            let stanza;\r\n            // <iq type='get' to='tel_38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/phone' xmlns='jabber:client' id='11b8b163-f317-42fd-9962-f1943d5adb21:sendIQ'>\r\n            // <callservice xmlns='urn:xmpp:pbxagent:callservice:1'>\r\n            // <connections/>\r\n            // </callservice>\r\n            // </iq>\r\n            if (!secondary) {\r\n                //iq = $iq({type: \"get\", to: service.userJidTel + \"/phone\"})\r\n                //.c(\"callservice\", {xmlns: CALLSERVICE_NS})\r\n                //.c(\"connections\");\r\n                stanza = xml(\"iq\", {\r\n                    type: \"get\",\r\n                    to: that.jid_tel + \"/phone\",\r\n                    xmlns: NameSpacesLabels.ClientNameSpace,\r\n                    \"id\": that.xmppUtils.getUniqueMessageId()\r\n                }, xml(\"callservice\", { \"xmlns\": NameSpacesLabels.CallService1NameSpace }, xml(\"connections\")));\r\n            }\r\n            else {\r\n                stanza = xml(\"iq\", {\r\n                    type: \"get\",\r\n                    to: that.jid_tel + \"/phone\",\r\n                    //xmlns: NameSpacesLabels.ClientNameSpace,\r\n                    \"id\": that.xmppUtils.getUniqueMessageId()\r\n                }, xml(\"callservice\", { \"xmlns\": NameSpacesLabels.CallService1NameSpace }, xml(\"connections\", { deviceType: \"SECONDARY\" })));\r\n            }\r\n            this.logger.log(\"internal\", LOG_ID + \"(getTelephonyState) send - 'iq get'\", stanza.root().toString());\r\n            this.xmppClient.sendIq(stanza).then((data) => {\r\n                this.logger.log(\"info\", LOG_ID + \"(getTelephonyState) received - 'iq result'\");\r\n                this.logger.log(\"internal\", LOG_ID + \"(getTelephonyState) received - 'iq result'\", data);\r\n                // Handle eventual error message\r\n                let errorMessage = that.getErrorMessage(data, \"getTelephonyState\");\r\n                if (errorMessage) {\r\n                    this.logger.log(\"error\", LOG_ID + \"getTelephonyState -- failure -- \");\r\n                    this.logger.log(\"internalerror\", LOG_ID + \"getTelephonyState -- failure -- : \", errorMessage);\r\n                    return reject(new Error(errorMessage));\r\n                }\r\n                // Handle existing calls\r\n                let existingCalls = that.xmppUtils.findChild(data, \"connections\");\r\n                let children = {};\r\n                if (existingCalls.children.length === 0) {\r\n                    this.logger.log(\"debug\", LOG_ID + \"getTelephonyState -- success -- no existing call\");\r\n                }\r\n                else {\r\n                    children = existingCalls.children;\r\n                }\r\n                resolve(children);\r\n            });\r\n        });\r\n    }\r\n    sendPing() {\r\n        let that = this;\r\n        if (this.useXMPP) {\r\n            let id = that.xmppUtils.getUniqueMessageId();\r\n            let stanza = xml(\"iq\", {\r\n                \"type\": \"get\",\r\n                \"id\": id\r\n            }, xml(\"ping\", { xmlns: NameSpacesLabels.PingNameSpace }));\r\n            this.logger.log(\"internal\", LOG_ID + \"(sendPing) send - 'message'\", stanza.root().toString(), \" for Rainbow Node SDK version : \", packageVersion.version);\r\n            this.xmppClient.send(stanza).catch((error) => {\r\n                this.logger.log(\"error\", LOG_ID + \"(sendPing) error \");\r\n                this.logger.log(\"internalerror\", LOG_ID + \"(sendPing) error : \", error);\r\n            });\r\n        }\r\n        else {\r\n            this.logger.log(\"warn\", LOG_ID + \"(sendPing) No XMPP connection...\");\r\n        }\r\n    }\r\n    // Mam\r\n    mamQuery(jid, options) {\r\n        let that = this;\r\n        const MAM = \"urn:xmpp:mam:1\";\r\n        const _p = [\"with\", \"start\", \"end\"];\r\n        let mamAttr = { xmlns: MAM, queryid: null };\r\n        if (!!options.queryid) {\r\n            mamAttr.queryid = options.queryid;\r\n            delete options.queryid;\r\n        }\r\n        let onMessage = options.onMessage;\r\n        delete options.onMessage;\r\n        let onComplete = options.onComplete;\r\n        delete options.onComplete;\r\n        let stanza = xml(\"iq\", {\r\n            \"type\": \"set\",\r\n            id: jid,\r\n            xmlns: NameSpacesLabels.ClientNameSpace\r\n        }, xml(\"query\", mamAttr, xml(\"x\", {\r\n            xmlns: NameSpacesLabels.DataNameSpace,\r\n            type: \"submit\"\r\n        }, xml(\"field\", {\r\n            \"var\": \"FORM_TYPE\",\r\n            \"type\": \"hidden\"\r\n        }, xml(\"value\", {}, MAM)), _p.filter((key) => options[key]).map((key) => {\r\n            let value = xml(\"field\", {\r\n                \"var\": key\r\n            }, xml(\"value\", {}, options[key]));\r\n            delete options[key];\r\n            return value;\r\n        })), xml(\"set\", { xmlns: NameSpacesLabels.RsmNameSpace }, Object.keys(options).map((key) => xml(key, {}, options[key] /*? options[key] : null*/)))));\r\n        that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamQuery - 'stanza'\");\r\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamQuery - 'stanza'\", stanza.toString());\r\n        that.xmppClient.send(stanza).then(() => {\r\n            if (typeof onComplete === \"function\") {\r\n                onComplete();\r\n            }\r\n        });\r\n    }\r\n    mamQueryMuc(jid, to, options) {\r\n        let that = this;\r\n        const MAM = \"urn:xmpp:mam:1\";\r\n        const _p = [\"with\", \"start\", \"end\"];\r\n        let mamAttr = { xmlns: MAM, queryid: null };\r\n        if (Boolean(options.queryid)) {\r\n            mamAttr.queryid = options.queryid;\r\n            delete options.queryid;\r\n        }\r\n        let onMessage = options.onMessage;\r\n        delete options.onMessage;\r\n        let onComplete = options.onComplete;\r\n        delete options.onComplete;\r\n        let stanza = xml(\"iq\", {\r\n            \"type\": \"set\",\r\n            id: jid,\r\n            to: to,\r\n            xmlns: NameSpacesLabels.ClientNameSpace\r\n        }, xml(\"query\", mamAttr, xml(\"x\", {\r\n            xmlns: NameSpacesLabels.DataNameSpace,\r\n            type: \"submit\"\r\n        }, xml(\"field\", {\r\n            \"var\": \"FORM_TYPE\",\r\n            \"type\": \"hidden\"\r\n        }, xml(\"value\", {}, MAM)), _p.filter((key) => options[key]).map((key) => {\r\n            let value = xml(\"field\", {\r\n                \"var\": key\r\n            }, xml(\"value\", {}, options[key]));\r\n            delete options[key];\r\n            return value;\r\n        })), xml(\"set\", { xmlns: NameSpacesLabels.RsmNameSpace }, Object.keys(options).map((key) => xml(key, {}, options[key] ? options[key] : null)))));\r\n        that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamQueryMuc - 'stanza'\");\r\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamQueryMuc - 'stanza'\", stanza.toString());\r\n        that.xmppClient.send(stanza).then(() => {\r\n            if (typeof onComplete === \"function\") {\r\n                onComplete();\r\n            }\r\n        });\r\n    }\r\n    mamDelete(options) {\r\n        let that = this;\r\n        const MAM = \"urn:xmpp:mam:1\";\r\n        const _p = [\"with\", \"start\", \"end\"];\r\n        let mamAttr = { xmlns: MAM, deleteid: null };\r\n        if (Boolean(options.deleteid)) {\r\n            mamAttr.deleteid = options.deleteid;\r\n            delete options.deleteid;\r\n        }\r\n        let onMessage = options.onMessage;\r\n        delete options.onMessage;\r\n        let onComplete = options.onComplete;\r\n        delete options.onComplete;\r\n        options.queryid = that.xmppUtils.getUniqueMessageId();\r\n        let id = that.xmppUtils.getUniqueMessageId();\r\n        let stanza = xml(\"iq\", {\r\n            \"type\": \"set\",\r\n            id: id,\r\n            xmlns: NameSpacesLabels.ClientNameSpace\r\n        }, xml(\"delete\", mamAttr, xml(\"x\", {\r\n            xmlns: NameSpacesLabels.DataNameSpace,\r\n            type: \"submit\"\r\n        }, xml(\"field\", {\r\n            \"var\": \"FORM_TYPE\",\r\n            \"type\": \"hidden\"\r\n        }, xml(\"value\", {}, MAM)), _p.filter((key) => options[key]).map((key) => {\r\n            let value = xml(\"field\", {\r\n                \"var\": key\r\n            }, xml(\"value\", {}, options[key]));\r\n            delete options[key];\r\n            return value;\r\n        })), xml(\"set\", { xmlns: NameSpacesLabels.RsmNameSpace }, Object.keys(options).map((key) => xml(key, {}, options[key] ? options[key] : null)))));\r\n        that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) mamDelete - 'stanza'\");\r\n        that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) mamDelete - 'stanza'\", stanza.toString());\r\n        that.xmppClient.send(stanza).then((result) => {\r\n            if (typeof onComplete === \"function\") {\r\n                onComplete(result);\r\n            }\r\n        });\r\n    }\r\n    // Voice Messages\r\n    voiceMessageQuery(jid) {\r\n        let that = this;\r\n        /*\r\n                    // Create the iq request\r\n            let iq = $iq({type: \"get\", to: that.userJidTel + \"/phone\"})\r\n                .c(\"callservice\", {xmlns: NameSpacesLabels.CallService1NameSpace})\r\n                .c(\"messaging\");\r\n         */\r\n        let nsAttr = { xmlns: NameSpacesLabels.CallService1NameSpace };\r\n        let stanza = xml(\"iq\", {\r\n            \"type\": \"set\",\r\n            \"to\": jid + \"/phone\"\r\n        }, xml(\"callservice\", nsAttr, xml(\"messaging\")));\r\n        return new Promise((resolve, reject) => {\r\n            that.logger.log(\"info\", LOG_ID + \"(handleXMPPConnection) voiceMessageQuery - 'stanza'\");\r\n            that.logger.log(\"internal\", LOG_ID + \"(handleXMPPConnection) voiceMessageQuery - 'stanza'\", stanza.toString());\r\n            that.xmppClient.send(stanza).then((data) => {\r\n                resolve(data);\r\n            }).catch((err) => {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n};\r\nXMPPService = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_1.isStarted([\"start\", \"stop\"])\r\n], XMPPService);\r\nexports.XMPPService = XMPPService;\r\nmodule.exports.XMPPService = XMPPService;\r\nmodule.exports.NameSpacesLabels = NameSpacesLabels;\r\n//# sourceMappingURL=XMPPService.js.map"]},"metadata":{},"sourceType":"script"}