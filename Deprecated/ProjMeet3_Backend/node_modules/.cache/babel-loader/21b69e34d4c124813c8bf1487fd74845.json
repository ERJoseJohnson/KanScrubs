{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require(\"deep-equal\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Bubble_1 = require(\"../common/models/Bubble\");\n\nconst promiseQueue_1 = require(\"../common/promiseQueue\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst Jimp = require('jimp'); //import Jimp from \"jimp\";\n\n\nconst LOG_ID = \"BUBBLES/SVCE - \";\nlet Bubbles =\n/**\r\n * @module\r\n * @name Bubbles\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This service manages multi-party communications (aka bubbles). Bubbles allow to chat and to share files with several participants.<br><br>\r\n *      Each user can create bubbles and invite other users to be part of it.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Create a new bubble <br>\r\n *      - Invite users in a bubble or remove them <br>\r\n *      - Manage a bubble: close, delete <br>\r\n *      - Leave a bubble <br>\r\n *      - Accept or decline an invitation to join a bubble <br>\r\n *      - Change the custom data attached to a bubble\r\n */\nclass Bubbles {\n  constructor(_eventEmitter, _http, _logger, _startConfig) {\n    this.ready = false;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._bubbles = null;\n    this._eventEmitter = _eventEmitter;\n    this._logger = _logger;\n    this._startConfig = _startConfig;\n    this.avatarDomain = _http.host.split(\".\").length === 2 ? _http.protocol + \"://cdn.\" + _http.host + \":\" + _http.port : _http.protocol + \"://\" + _http.host + \":\" + _http.port;\n\n    this._eventEmitter.on(\"evt_internal_invitationreceived\", this._onInvitationReceived.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_affiliationchanged\", this._onAffiliationChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_ownaffiliationchanged\", this._onOwnAffiliationChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_customdatachanged\", this._onCustomDataChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_topicchanged\", this._onTopicChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_namechanged\", this._onNameChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_onbubblepresencechanged\", this._onbubblepresencechanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_privilegechanged\", this._onPrivilegeBubbleChanged.bind(this));\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._bubbles = [];\n        that._contacts = _core.contacts;\n        that._profileService = _core.profiles;\n        that._presence = _core.presence;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        /*\r\n                        that._eventEmitter.on(\"evt_internal_invitationreceived\", that._onInvitationReceived.bind(that));\r\n                        that._eventEmitter.on(\"evt_internal_affiliationchanged\", that._onAffiliationChanged.bind(that));\r\n                        that._eventEmitter.on(\"evt_internal_ownaffiliationchanged\", that._onOwnAffiliationChanged.bind(that));\r\n                        that._eventEmitter.on(\"evt_internal_customdatachanged\", that._onCustomDataChanged.bind(that));\r\n                        that._eventEmitter.on(\"evt_internal_topicchanged\", that._onTopicChanged.bind(that));\r\n                        that._eventEmitter.on(\"evt_internal_namechanged\", that._onNameChanged.bind(that));\r\n        */\n\n        that.ready = true;\n        resolve();\n      } catch (err) {\n        return reject();\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = null;\n        that._rest = null;\n        that._bubbles = null;\n        /*that._eventEmitter.removeListener(\"evt_internal_invitationreceived\", that._onInvitationReceived.bind(that));\r\n        that._eventEmitter.removeListener(\"evt_internal_affiliationchanged\", that._onAffiliationChanged.bind(that));\r\n        that._eventEmitter.removeListener(\"evt_internal_ownaffiliationchanged\", that._onOwnAffiliationChanged.bind(that));\r\n        that._eventEmitter.removeListener(\"evt_internal_customdatachanged\", that._onCustomDataChanged.bind(that));\r\n        that._eventEmitter.removeListener(\"evt_internal_topicchanged\", that._onTopicChanged.bind(that));\r\n        that._eventEmitter.removeListener(\"evt_internal_namechanged\", that._onNameChanged.bind(that));\r\n        that._logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\r\n        // */\n\n        that.ready = false;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method createBubble\r\n   * @instance\r\n   * @description\r\n   *  Create a new bubble\r\n   * @param {string} name  The name of the bubble to create\r\n   * @param {string} description  The description of the bubble to create\r\n   * @param {boolean} withHistory If true, a newcomer will have the complete messages history since the beginning of the bubble. False if omitted\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - Bubble object, else an ErrorManager object\r\n   * @category async\r\n   */\n\n\n  createBubble(name, description, withHistory) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (typeof withHistory === \"undefined\") {\n          withHistory = false;\n        }\n\n        if (!name) {\n          that._logger.log(\"warn\", LOG_ID + \"(createBubble) bad or empty 'name' parameter\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(createBubble) bad or empty 'name' parameter\", name);\n\n          reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n          return;\n        } else if (!description) {\n          that._logger.log(\"warn\", LOG_ID + \"(createBubble) bad or empty 'description' parameter\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(createBubble) bad or empty 'description' parameter\", description);\n\n          reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n          return;\n        }\n\n        that._rest.createBubble(name, description, withHistory).then(bubble => {\n          that._logger.log(\"debug\", LOG_ID + \"(createBubble) creation successfull\");\n\n          that._logger.log(\"internal\", LOG_ID + \"(createBubble) creation successfull, bubble\", bubble);\n          /*that._eventEmitter.once(\"evt_internal_bubblepresencechanged\", function fn_onbubblepresencechanged() {\r\n              that._logger.log(\"debug\", LOG_ID + \"(createBubble) bubble presence successfull\");\r\n              that._logger.log(\"debug\", LOG_ID + \"(createBubble) _exiting_\");\r\n              that._bubbles.push(Object.assign( new Bubble(), bubble));\r\n              that._eventEmitter.removeListener(\"evt_internal_bubblepresencechanged\", fn_onbubblepresencechanged);\r\n              resolve(bubble);\r\n          }); // */\n\n\n          that._presence.sendInitialBubblePresence(bubble).then(() => __awaiter(this, void 0, void 0, function* () {\n            // Wait for the bubble to be added in service list with the treatment of the sendInitialPresence result event (_onbubblepresencechanged)\n            yield Utils_1.until(() => {\n              return that._bubbles.find(bubbleIter => {\n                return bubbleIter.jid === bubble.jid;\n              }) !== undefined;\n            }, \"Waiting for the initial presence of a creation of bubble : \" + bubble.jid); //that._bubbles.push(Object.assign( new Bubble(), bubble));\n\n            that._logger.log(\"debug\", LOG_ID + \"(createBubble) bubble successfully created and presence sent : \", bubble.jid);\n\n            resolve(bubble);\n          }));\n        }).catch(err => {\n          that._logger.log(\"error\", LOG_ID + \"(createBubble) error\");\n\n          return reject(err);\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method isBubbleClosed\r\n   * @instance\r\n   * @param {Bubble} bubble  The bubble to check\r\n   * @return {boolean} True if the bubble is closed\r\n   * @description\r\n   *  Check if the bubble is closed or not.\r\n   */\n\n\n  isBubbleClosed(bubble) {\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(isBubbleClosed) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(isBubbleClosed) bad or empty 'bubble' parameter : \", bubble);\n\n      throw ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n    } else {\n      let activeUser = bubble.users.find(user => {\n        return user.status === \"invited\" || user.status === \"accepted\";\n      });\n\n      if (activeUser) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n  /**\r\n   * @public\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Delete all existing owned bubbles <br/>\r\n   *    Return a promise\r\n   * @return {Object} Nothing or an error object depending on the result\r\n   */\n\n\n  deleteAllBubbles() {\n    let that = this;\n    let deleteallBubblePromiseQueue = promiseQueue_1.createPromiseQueue(that._logger);\n    let bubbles = that.getAll();\n    bubbles.forEach(function (bubble) {\n      let deleteBubblePromise = function () {\n        return that.deleteBubble(bubble);\n      };\n\n      deleteallBubblePromiseQueue.add(deleteBubblePromise);\n    });\n    return deleteallBubblePromiseQueue.execute();\n  }\n\n  /**\r\n   * @public\r\n   * @method deleteBubble\r\n   * @instance\r\n   * @param {Bubble} bubble  The bubble to delete\r\n   * @description\r\n   *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble removed, else an ErrorManager object\r\n   * @category async\r\n   */\n  deleteBubble(bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.deleteBubble(bubble.id).then(resultDelete => {\n        //let bubbleRemoved = await that.removeBubbleFromCache(updatedBubble.id);\n\n        /*let bubbleRemovedList = that._bubbles.splice(that._bubbles.findIndex(function(el) {\r\n            return el.id === updatedBubble.id;\r\n        }), 1); // */\n        that._logger.log(\"debug\", LOG_ID + \"(deleteBubble) delete bubble with id : \", bubble.id, \" successfull\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(deleteBubble) delete bubble : \", bubble, \", resultDelete : \", resultDelete, \" bubble successfull\"); //let bubbleRemoved = bubbleRemoved.length > 0 ? bubbleRemoved[0] : null;\n        //resolve( Object.assign(bubble, bubbleRemoved));\n\n\n        resolve(bubble);\n      }).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(deleteBubble) error\");\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method closeAndDeleteBubble\r\n   * @instance\r\n   * @param {Bubble} bubble  The bubble to close + delete\r\n   * @description\r\n   *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble removed, else an ErrorManager object\r\n   * @category async\r\n   */\n\n\n  closeAndDeleteBubble(bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter \");\n\n        that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that.closeBubble(bubble).then(updatedBubble => {\n        that._rest.deleteBubble(updatedBubble.id).then(() => {\n          //let bubbleRemoved = await that.removeBubbleFromCache(updatedBubble.id);\n\n          /*let bubbleRemovedList = that._bubbles.splice(that._bubbles.findIndex(function(el) {\r\n              return el.id === updatedBubble.id;\r\n          }), 1); // */\n          that._logger.log(\"debug\", LOG_ID + \"(deleteBubble) delete with id : \", updatedBubble.id, \" bubble successfull\");\n\n          that._logger.log(\"internal\", LOG_ID + \"(deleteBubble) delete \", updatedBubble, \" bubble successfull\"); //let bubbleRemoved = bubbleRemoved.length > 0 ? bubbleRemoved[0] : null;\n          //resolve( Object.assign(bubble, bubbleRemoved));\n\n\n          resolve(updatedBubble);\n        }).catch(function (err) {\n          that._logger.log(\"error\", LOG_ID + \"(deleteBubble) error\");\n\n          return reject(err);\n        });\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method closeBubble\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble to close\r\n   * @description\r\n   *  Close a owned bubble. When the owner closes a bubble, the bubble is archived and only accessible in read only mode for all participants.\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble closed, else an ErrorManager object\r\n   * @category async\r\n   */\n\n\n  closeBubble(bubble) {\n    let that = this;\n\n    let unsubscribeParticipants = participantsIDList => {\n      return new Promise((resolve, reject) => {\n        let participantID = participantsIDList.shift();\n\n        if (participantID) {\n          return that.removeContactFromBubble({\n            id: participantID\n          }, bubble).then(() => {\n            that._logger.log(\"debug\", LOG_ID + \"(closeBubble) Participant \" + participantID + \" unsubscribed\");\n\n            return unsubscribeParticipants(participantsIDList).then(() => {\n              resolve();\n            }).catch(err => {\n              return reject(err);\n            });\n          }).catch(err => {\n            return reject(err);\n          });\n        }\n\n        resolve();\n      });\n    };\n\n    return new Promise(function (resolve, reject) {\n      if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(closeBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(closeBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (that.isBubbleClosed(bubble)) {\n        that._logger.log(\"internal\", LOG_ID + \"(closeBubble) bubble is already closed : \", bubble);\n\n        resolve(bubble);\n      } else {\n        let queue = [];\n        bubble.users.forEach(function (user) {\n          if (user.userId !== that._rest.userId && user.status !== Bubble_1.Bubble.RoomUserStatus.DELETED && user.status !== Bubble_1.Bubble.RoomUserStatus.REJECTED) {\n            // if (user.userId !== that._rest.userId) {\n            // unsubscribe everyone except the connected user\n            queue.push(user.userId); //}\n          }\n        }); // unsubscribe the connected user\n        // queue.push(that._rest.userId);\n\n        unsubscribeParticipants(queue).then(() => {\n          that._logger.log(\"info\", LOG_ID + \"(closeBubble) all users have been unsubscribed from bubble. Bubble is closed\");\n\n          that.removeContactFromBubble({\n            id: that._rest.userId\n          }, bubble).then(() => {\n            that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n              //\n              // Update the existing local bubble stored\n              let bubbleReturned = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n              /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n              if ( foundIndex > -1) {\r\n                  bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                  that._bubbles[foundIndex] = bubbleUpdated;\r\n              } else {\r\n                  that._logger.log(\"warn\", LOG_ID + \"(closeBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n              }\r\n              // */\n\n              resolve(bubbleReturned);\n            }));\n          });\n        }).catch(err => {\n          return reject(err);\n        });\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method archiveBubble\r\n   * @instance\r\n   * @param {Bubble} bubble  The bubble to archive\r\n   * @description\r\n   *  Archive  a bubble.\r\n   *  This API allows to close the room in one step. The other alternative is to change the status for each room users not deactivated yet.\r\n   *  All users currently having the status 'invited' or 'accepted' will receive a message/stanza .\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The operation result\r\n   * @category async\r\n   */\n\n\n  archiveBubble(bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      let otherModerator = null;\n\n      if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(archiveBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(archiveBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.archiveBubble(bubble.id).then(function (json) {\n        that._logger.log(\"info\", LOG_ID + \"(archiveBubble) leave successfull\");\n\n        that._xmpp.sendUnavailableBubblePresence(bubble.jid);\n\n        resolve(json);\n      }).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(archiveBubble) error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(archiveBubble) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method leaveBubble\r\n   * @instance\r\n   * @param {Bubble} bubble  The bubble to leave\r\n   * @description\r\n   *  Leave a bubble. If the connected user is a moderator, an other moderator should be still present in order to leave this bubble.\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The operation result\r\n   * @category async\r\n   */\n\n\n  leaveBubble(bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      let otherModerator = null;\n      let userStatus = \"none\";\n\n      if (bubble) {\n        otherModerator = bubble.users.find(user => {\n          return user.privilege === \"moderator\" && user.status === \"accepted\" && user.userId !== that._rest.userId;\n        });\n        userStatus = bubble.getStatusForUser(that._rest.userId);\n      }\n\n      if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(leaveBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(leaveBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (!otherModerator) {\n        that._logger.log(\"warn\", LOG_ID + \"(leaveBubble) can't leave a bubble if no other active moderator\");\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().FORBIDDEN);\n        return;\n      }\n\n      that._rest.leaveBubble(bubble.id, userStatus).then(function (json) {\n        that._logger.log(\"info\", LOG_ID + \"(leaveBubble) leave successfull\");\n\n        that._xmpp.sendUnavailableBubblePresence(bubble.jid);\n\n        resolve(json);\n      }).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(leaveBubble) error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(leaveBubble) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getUsersFromBubble\r\n   * @instance\r\n   * @param {Bubble} bubble           The bubble\r\n   * @param {Object} options          The criterias to select the users to retrieve\r\n   * format : Allows to retrieve more or less user details in response, besides specifics data about room users like (privilege, status and additionDate)\r\n   * - small: userId loginEmail displayName jid_im\r\n   * - medium: userId loginEmail displayName jid_im status additionDate privilege firstName lastName companyId companyName\r\n   * - full: userId loginEmail displayName jid_im status additionDate privilege firstName lastName nickName title jobTitle emails country language timezone companyId companyName roles adminType\r\n   * sortField : Sort items list based on the given field\r\n   * privilege : Allows to filter users list on the privilege type provided in this option.\r\n   * limit : Allow to specify the number of items to retrieve.\r\n   * offset : Allow to specify the position of first item to retrieve (first item if not specified). Warning: if offset > total, no results are returned.\r\n   * sortOrder : Specify order when sorting items list. Available values -1, 1 (default)\r\n   * @description\r\n   *  Get a list of users in a bubble filtered by criterias.\r\n   * @async\r\n   * @return {Promise<Array, ErrorManager>}\r\n   */\n\n\n  getUsersFromBubble(bubble, options = {}) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      /*let filterToApply = \"format=medium\";\r\n      if (_options.format) {\r\n          filterToApply = \"format=\" + _options.format;\r\n      }\r\n        if (_options.page > 0) {\r\n          filterToApply += \"&offset=\";\r\n          if (_options.page > 1) {\r\n              filterToApply += (_options.limit * (_options.page - 1));\r\n          } else {\r\n              filterToApply += 0;\r\n          }\r\n      }\r\n        filterToApply += \"&limit=\" + Math.min(_options.limit, 1000);\r\n        if (_options.type) {\r\n          filterToApply += \"&types=\" + _options.type;\r\n      }\r\n        // */\n      that._rest.getRoomUsers(bubble.id, options).then(function (json) {\n        that._logger.log(\"info\", LOG_ID + \"(getRoomUsers) retrieve successfull\");\n\n        resolve(json);\n      }).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(getRoomUsers) error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getRoomUsers) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n  * @public\r\n  * @method getStatusForConnectedUserInBubble\r\n  * @instance\r\n  * @param {Bubble} bubble           The bubble\r\n  * @description\r\n  *  Get the status of the connected user in a bubble\r\n  * @async\r\n  * @return {Promise<Bubble, ErrorManager>}\r\n  */\n\n\n  getStatusForConnectedUserInBubble(bubble) {\n    let that = this;\n\n    if (!bubble) {\n      that._logger.log(\"warn\", LOG_ID + \"(getStatusForConnectedUserInBubble) bad or empty 'bubble' parameter\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(getStatusForConnectedUserInBubble) bad or empty 'bubble' parameter : \", bubble); //reject(ErrorManager.getErrorManager().BAD_REQUEST);\n\n\n      return \"none\";\n    }\n\n    let user = bubble.users.find(user => {\n      return user.userId === that._rest.userId;\n    });\n    return user ? user.status : \"none\";\n  }\n  /**\r\n   * @public\r\n   * @method inviteContactToBubble\r\n   * @instance\r\n   * @param {Contact} contact         The contact to invite\r\n   * @param {Bubble} bubble           The bubble\r\n   * @param {boolean} isModerator     True to add a contact as a moderator of the bubble\r\n   * @param {boolean} withInvitation  If true, the contact will receive an invitation and will have to accept it before entering the bubble. False to force the contact directly in the bubble without sending an invitation.\r\n   * @param {string} reason        The reason of the invitation (optional)\r\n   * @description\r\n   *  Invite a contact in a bubble\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated with the new invitation\r\n   * @category async\r\n   */\n\n\n  inviteContactToBubble(contact, bubble, isModerator, withInvitation, reason) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._logger.log(\"internal\", LOG_ID + \"(inviteContactToBubble) arguments : \", ...arguments);\n\n      if (!contact) {\n        that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bad or empty 'contact' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactToBubble) bad or empty 'contact' parameter : \", contact);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactToBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      let isActive = false;\n      let isInvited = false;\n      bubble.users.forEach(function (user) {\n        if (user.userId === contact.id) {\n          switch (user.status) {\n            case \"invited\":\n              isInvited = true;\n              break;\n\n            case \"accepted\":\n              isActive = true;\n              break;\n\n            default:\n              break;\n          }\n        }\n      });\n\n      if (isActive || isInvited) {\n        that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) Contact has been already invited or is already a member of the bubble\");\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that.removeContactFromBubble(contact, bubble).then(bubbleUpdated => {\n        return that._rest.inviteContactToBubble(contact.id, bubbleUpdated.id, isModerator, withInvitation, reason);\n      }).then(function () {\n        that._logger.log(\"info\", LOG_ID + \"(inviteContactToBubble) invitation successfully sent\");\n\n        return that._rest.getBubble(bubble.id);\n      }).then(bubbleReUpdated => __awaiter(this, void 0, void 0, function* () {\n        let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\n        /*\r\n        // Update the existing local bubble stored\r\n        let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleReUpdated.id);\r\n        if ( foundIndex > -1) {\r\n            bubbleReUpdated = Object.assign(that._bubbles[foundIndex], bubbleReUpdated);\r\n            that._bubbles[foundIndex] = bubbleReUpdated;\r\n        } else {\r\n            that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bubble with id:\" + bubbleReUpdated.id + \" is no more available\");\r\n        }\r\n         */\n\n        resolve(bubble);\n      })).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(inviteContactToBubble) error\");\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method inviteContactsByEmailsToBubble\r\n   * @instance\r\n   * @param {Contact} contactsEmails         The contacts email tab to invite\r\n   * @param {Bubble} bubble           The bubble\r\n   * @description\r\n   *  Invite a list of contacts by emails in a bubble\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated with the new invitation\r\n   * @category async\r\n   */\n\n\n  inviteContactsByEmailsToBubble(contactsEmails, bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._logger.log(\"internal\", LOG_ID + \"(inviteContactsByEmailToBubble) arguments : \", ...arguments);\n\n      if (!contactsEmails || !Array.isArray(contactsEmails)) {\n        that._logger.log(\"warn\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'contact' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'contact' parameter : \", contactsEmails);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      return that._rest.inviteContactsByEmailsToBubble(contactsEmails, bubble.id).then(function () {\n        that._logger.log(\"info\", LOG_ID + \"(inviteContactsByEmailsToBubble) invitation successfully sent\");\n\n        return that._rest.getBubble(bubble.id);\n      }).then(bubbleReUpdated => __awaiter(this, void 0, void 0, function* () {\n        let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\n        resolve(bubble);\n      })).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(inviteContactsByEmailsToBubble) error\");\n\n        return reject(err);\n      });\n    });\n  } // @private for ale rainbow team's tests only\n\n\n  joinConference(bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(this, arguments, void 0, function* () {\n        that._logger.log(\"internal\", LOG_ID + \"(joinConference) arguments : \", ...arguments);\n\n        if (!bubble || !bubble.id) {\n          that._logger.log(\"warn\", LOG_ID + \"(joinConference) bad or empty 'bubble' parameter\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(joinConference) bad or empty 'bubble' parameter : \", bubble);\n\n          reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n          return;\n        }\n        /*let isActive = false;\r\n        let isInvited = false;\r\n        bubble.users.forEach(function(user) {\r\n            if (user.userId === contact.id) {\r\n                switch (user.status) {\r\n                    case \"invited\":\r\n                        isInvited = true;\r\n                        break;\r\n                    case \"accepted\":\r\n                        isActive = true;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n        getAllActiveBubbles\r\n        if (isActive || isInvited) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(joinConference) Contact has been already invited or is already a member of the bubble\");\r\n            reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n            return;\r\n        } // */\n\n\n        if (!bubble || !bubble.confEndpoints) {\n          that._logger.log(\"warn\", LOG_ID + \"(joinConference) bad or empty 'bubble.confEndpoints' parameter\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(joinConference) bad or empty 'bubble.confEndpoints' parameter : \", bubble);\n\n          reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n          return;\n        }\n\n        let mediaType = bubble.mediaType;\n\n        if (!that._profileService.isFeatureEnabled(that._profileService.getFeaturesEnum().WEBRTC_CONFERENCE_ALLOWED) && mediaType !== that._rest.MEDIATYPE.WEBRTCSHARINGONLY) {\n          that._logger.log(\"warn\", LOG_ID + \"(WebConferenceService) retrieveWebConferences - user is not allowed\");\n\n          reject(new Error(\"notAllowed\"));\n          return;\n        }\n\n        let endpoint = yield that._rest.retrieveWebConferences(mediaType);\n        let confEndPoints = null;\n        confEndPoints = endpoint;\n        let confEndPointId = null;\n\n        if (confEndPoints.length === 1 && confEndPoints[0].mediaType === that._rest.MEDIATYPE.WEBRTC) {\n          confEndPointId = confEndPoints[0].id;\n        }\n\n        that._rest.joinConference(confEndPointId, \"moderator\").then(function (joinResult) {\n          resolve(joinResult);\n        }).catch(function (err) {\n          that._logger.log(\"error\", LOG_ID + \"(joinConference) error\");\n\n          return reject(err);\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method promoteContactInBubble\r\n   * @instance\r\n   * @param {Contact} contact         The contact to promote or downgraded\r\n   * @param {Bubble} bubble           The bubble\r\n   * @param {boolean} isModerator     True to promote a contact as a moderator of the bubble, and false to downgrade\r\n   * @description\r\n   *  Promote or not a contact in a bubble\r\n   *  The logged in user can't update himself. As a result, a 'moderator' can't be downgraded to 'user'.\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated with the modifications\r\n   * @category async\r\n   */\n\n\n  promoteContactInBubble(contact, bubble, isModerator) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (!contact) {\n        that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bad or empty 'contact' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) bad or empty 'contact' parameter : \", contact);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      let isActive = false;\n      let isInvited = false;\n      bubble.users.forEach(function (user) {\n        if (user.userId === contact.id) {\n          switch (user.status) {\n            case \"invited\":\n              isInvited = true;\n              break;\n\n            case \"accepted\":\n              isActive = true;\n              break;\n\n            default:\n              break;\n          }\n        }\n      });\n\n      if (!isActive && !isInvited) {\n        that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) Contact is not invited or is not already a member of the bubble\");\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.promoteContactInBubble(contact.id, bubble.id, isModerator).then(function () {\n        that._logger.log(\"info\", LOG_ID + \"(promoteContactInBubble) user privilege successfully sent\");\n\n        return that._rest.getBubble(bubble.id);\n      }).then(bubbleReUpdated => __awaiter(this, void 0, void 0, function* () {\n        // Update the existing local bubble stored\n        let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\n        /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleReUpdated.id);\r\n        if ( foundIndex > -1) {\r\n            bubbleReUpdated = Object.assign(that._bubbles[foundIndex], bubbleReUpdated);\r\n            that._bubbles[foundIndex] = bubbleReUpdated;\r\n        } else {\r\n            that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bubble with id:\" + bubbleReUpdated.id + \" is no more available\");\r\n        }\r\n         */\n\n        resolve(bubble);\n      })).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(promoteContactInBubble) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) error : \", err);\n\n        reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method promoteContactToModerator\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Promote a contact to moderator in a bubble <br/>\r\n   *    Return a promise.\r\n   * @param {Contact} contact The contact to promote\r\n   * @param {Bubble} bubble   The destination bubble\r\n   * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result\r\n   */\n\n\n  promoteContactToModerator(contact, bubble) {\n    let that = this;\n\n    if (!contact) {\n      that._logger.log(\"warn\", LOG_ID + \"(promoteContactToModerator) bad or empty 'contact' parameter\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactToModerator) bad or empty 'contact' parameter : \", contact);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else if (!bubble) {\n      that._logger.log(\"warn\", LOG_ID + \"(promoteContactToModerator) bad or empty 'bubble' parameter\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactToModerator) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return this.promoteContactInBubble(contact, bubble, true);\n  }\n  /**\r\n   * @public\r\n   * @method demoteContactFromModerator\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Demote a contact to user in a bubble <br/>\r\n   *    Return a promise.\r\n   * @param {Contact} contact The contact to promote\r\n   * @param {Bubble} bubble   The destination bubble\r\n   * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result\r\n   */\n\n\n  demoteContactFromModerator(contact, bubble) {\n    let that = this;\n\n    if (!contact) {\n      that._logger.log(\"warn\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'contact' parameter\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'contact' parameter : \", contact);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else if (!bubble) {\n      that._logger.log(\"warn\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'bubble' parameter\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return this.promoteContactInBubble(contact, bubble, false);\n  }\n  /**\r\n   * @public\r\n   * @method changeBubbleOwner\r\n   * @instance\r\n   * @param {Contact} contact         The contact to set a new bubble owner\r\n   * @param {Bubble} bubble           The bubble\r\n   * @description\r\n   *  Set a moderator contact as owner of a bubble\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated with the modifications\r\n   * @category async\r\n   */\n\n\n  changeBubbleOwner(bubble, contact) {\n    let that = this;\n\n    if (!contact) {\n      that._logger.log(\"warn\", LOG_ID + \"(changeBubbleOwner) bad or empty 'contact' parameter \");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) bad or empty 'contact' parameter : \", contact);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(changeBubbleOwner) bad or empty 'bubble' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.changeBubbleOwner(bubble.id, contact.id).then(bubbleData => __awaiter(this, void 0, void 0, function* () {\n        bubbleData = yield that.addOrUpdateBubbleToCache(bubbleData);\n\n        that._logger.log(\"info\", LOG_ID + \"(changeBubbleOwner) owner setted : \", bubbleData.owner);\n\n        bubble.owner = bubbleData.owner;\n        resolve(bubbleData);\n      })).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(changeBubbleOwner) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n  * @public\r\n  * @method removeContactFromBubble\r\n  * @instance\r\n  * @param {Contact} contact The contact to remove\r\n  * @param {Bubble} bubble   The destination bubble\r\n  * @description\r\n  *    Remove a contact from a bubble\r\n  * @async\r\n  * @return {Promise<Bubble, ErrorManager>}\r\n  * @fulfil {Bubble} - The bubble object or an error object depending on the result\r\n  * @category async\r\n  */\n\n\n  removeContactFromBubble(contact, bubble) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (!contact) {\n        that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bad or empty 'contact' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) bad or empty 'contact' parameter : \", contact);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      } else if (!bubble) {\n        that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bad or empty 'bubble' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      let contactStatus = \"\";\n      bubble.users.forEach(function (user) {\n        if (user.userId === contact.id) {\n          contactStatus = user.status;\n        }\n      });\n\n      that._logger.log(\"info\", LOG_ID + \"(removeContactFromBubble) remove contact with status\", contactStatus);\n\n      switch (contactStatus) {\n        case \"rejected\":\n        case \"invited\":\n        case \"unsubscribed\":\n          that._rest.removeInvitationOfContactToBubble(contact.id, bubble.id).then(function () {\n            that._logger.log(\"info\", LOG_ID + \"(removeContactFromBubble) removed successfully\");\n\n            that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n              // Update the existing local bubble stored\n              let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n              /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n              if ( foundIndex > -1) {\r\n                  bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                  that._bubbles[foundIndex] = bubbleUpdated;\r\n              } else {\r\n                  that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n              }\r\n               */\n\n              resolve(bubble);\n            }));\n          }).catch(function (err) {\n            that._logger.log(\"error\", LOG_ID + \"(removeContactFromBubble) error\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) error : \", err);\n\n            return reject(err);\n          });\n\n          break;\n\n        case \"accepted\":\n          that._rest.unsubscribeContactFromBubble(contact.id, bubble.id).then(function () {\n            that._logger.log(\"debug\", LOG_ID + \"(removeContactFromBubble) removed successfully\");\n\n            that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n              // Update the existing local bubble stored\n              let bubbleProm = that.addOrUpdateBubbleToCache(bubbleUpdated);\n              let bubble = yield bubbleProm;\n              /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n              if ( foundIndex > -1) {\r\n                  bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                  that._bubbles[foundIndex] = bubbleUpdated;\r\n              } else {\r\n                  that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n              }\r\n               */\n              // We send the result here, because sometimes the xmpp server does not send us the resulting event.\n              // So this event change will be sent twice time.\n\n              that._eventEmitter.emit(\"evt_internal_affiliationdetailschanged\", bubble);\n\n              resolve(bubble);\n            }));\n          }).catch(function (err) {\n            that._logger.log(\"error\", LOG_ID + \"(removeContactFromBubble) error\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) error : \", err);\n\n            return reject(err);\n          });\n\n          break;\n\n        default:\n          that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) contact not found in that bubble\");\n\n          resolve(bubble);\n          break;\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @description\r\n   *      Internal method\r\n   */\n\n\n  getBubbles() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._rest.getBubbles().then(function (listOfBubbles = []) {\n        that._logger.log(\"debug\", LOG_ID + \"(getBubbles)  listOfBubbles.length : \", listOfBubbles.length); //that._bubbles = listOfBubbles.map( (bubble) => Object.assign( new Bubble(), bubble));\n\n\n        that._bubbles = [];\n        listOfBubbles.map(bubble => __awaiter(this, void 0, void 0, function* () {\n          yield that.addOrUpdateBubbleToCache(bubble);\n        }));\n\n        that._logger.log(\"info\", LOG_ID + \"(getBubbles) get successfully\");\n\n        let prom = [];\n        listOfBubbles.forEach(function (bubble) {\n          let users = bubble.users;\n          users.forEach(function (user) {\n            if (user.userId === that._rest.userId && user.status === \"accepted\") {\n              if (bubble.isActive) {\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbles) send initial presence to room : \", bubble.jid);\n\n                prom.push(that._presence.sendInitialBubblePresence(bubble));\n              } else {\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbles) bubble not active, so do not send initial presence to room : \", bubble.jid);\n              }\n            }\n          });\n        });\n        Promise.all(prom).then(() => {\n          resolve();\n        }).catch(function (err) {\n          that._logger.log(\"error\", LOG_ID + \"(getBubbles) error\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(getBubbles) error : \", err);\n\n          return reject(err);\n        }); // */\n      }).catch(function (err) {\n        that._logger.log(\"error\", LOG_ID + \"(getBubbles) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getBubbles) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getAll\r\n   * @instance\r\n   * @return {Bubble[]} The list of existing bubbles\r\n   * @description\r\n   *  Return the list of existing bubbles\r\n   */\n\n\n  getAll() {\n    return this._bubbles;\n  }\n  /**\r\n   * @public\r\n   * @method getAllBubbles\r\n   * @instance\r\n   * @return {Bubble[]} The list of existing bubbles\r\n   * @description\r\n   *  Return the list of existing bubbles\r\n   */\n\n\n  getAllBubbles() {\n    return this.getAll();\n  }\n  /**\r\n   * @public\r\n   * @method getAllOwnedBubbles\r\n   * @instance\r\n   * @description\r\n   *    Get the list of bubbles created by the user <br/>\r\n   * @return {Bubble[]} An array of bubbles restricted to the ones owned by the user\r\n   */\n\n\n  getAllOwnedBubbles() {\n    let that = this; //        return new Promise(function (resolve, reject) {\n\n    that._logger.log(\"debug\", LOG_ID + \"(getAllOwnedBubbles) \"); //resolve(that._bubbles.filter(function (room) {\n\n\n    return that._bubbles.filter(function (room) {\n      return room.creator === that._rest.userId;\n    }); //      });\n  }\n\n  getBubbleFromCache(bubbleId) {\n    let bubbleFound = null;\n\n    this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) search id : \", bubbleId);\n\n    if (this._bubbles) {\n      let channelFoundindex = this._bubbles.findIndex(channel => {\n        return channel.id === bubbleId;\n      });\n\n      if (channelFoundindex != -1) {\n        this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) bubble found : \", this._bubbles[channelFoundindex], \" with id : \", bubbleId);\n\n        return this._bubbles[channelFoundindex];\n      }\n    }\n\n    this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) channel found : \", bubbleFound, \" with id : \", bubbleId);\n\n    return bubbleFound;\n  }\n\n  addOrUpdateBubbleToCache(bubble) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let bubbleObj = yield Bubble_1.Bubble.BubbleFactory(that.avatarDomain, that._contacts)(bubble);\n\n      let bubbleFoundindex = this._bubbles.findIndex(channelIter => {\n        return channelIter.id === bubble.id;\n      });\n\n      if (bubbleFoundindex != -1) {\n        this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) update in cache with bubble : \", bubble, \", at bubbleFoundindex : \", bubbleFoundindex); //this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) update in cache with bubble : \", bubble, \", at bubbleFoundindex : \", bubbleFoundindex);\n\n\n        this._bubbles[bubbleFoundindex].updateBubble(bubble, that._contacts); //this._bubbles.splice(bubbleFoundindex,1,bubbleObj);\n\n\n        this.refreshMemberAndOrganizerLists(this._bubbles[bubbleFoundindex]); //this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) in update this._bubbles : \", this._bubbles);\n\n        bubbleObj = this._bubbles[bubbleFoundindex];\n      } else {\n        this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) add in cache bubbleObj : \", bubbleObj);\n\n        this.refreshMemberAndOrganizerLists(bubbleObj);\n\n        this._bubbles.push(bubbleObj);\n      } //this.updateChannelsList();\n\n\n      return bubbleObj;\n    });\n  }\n\n  removeBubbleFromCache(bubbleId) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Get the channel to remove\n      let bubbleToRemove = this.getBubbleFromCache(bubbleId);\n\n      if (bubbleToRemove) {\n        // Remove from channels\n        let bubbleIdToRemove = bubbleToRemove.id;\n\n        that._logger.log(\"internal\", LOG_ID + \"(removeBubbleFromCache) remove from cache bubbleId : \", bubbleIdToRemove);\n\n        that._bubbles = this._bubbles.filter(function (chnl) {\n          return !(chnl.id === bubbleIdToRemove);\n        });\n        resolve(bubbleToRemove);\n      } else {\n        resolve(null);\n      }\n    });\n  }\n  /**\r\n   * @method getAvatarFromBubble\r\n   * @public\r\n   * @instance\r\n   * @param {Bubble} bubble   The destination bubble\r\n   * @async\r\n   * @return {Promise<{}>}  return a promise with {Object} A Blob object with data about the avatar picture.\r\n   * @description\r\n   *  Get A Blob object with data about the avatar picture of the bubble.\r\n   */\n\n\n  getAvatarFromBubble(bubble) {\n    /*\r\n    Nom : 5da72aa7e6ca5a023da44eff\r\n    Dimensions : 512  512\r\n    Type MIME : image/jpeg\r\n     */\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubble : \", bubble);\n\n      if (!bubble) {\n        that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty 'bubble' parameter.\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(getAvatarFromBubble) bad or empty 'bubble' parameter : \", bubble);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      if (!bubble.avatar) {\n        that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty avatar of 'bubble' parameter.\");\n\n        that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty avatar of 'bubble' parameter : \", bubble);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      return that._rest.getBlobFromUrl(bubble.avatar).then(avatarBuffer => {\n        that._logger.log(\"internal\", LOG_ID + \"(getAvatarFromBubble) bubble from server : \", avatarBuffer);\n\n        let blob = {\n          buffer: avatarBuffer,\n          type: \"image/jpeg\",\n          fileSize: avatarBuffer.length,\n          fileName: bubble.id\n        }; // */\n\n        /*let blob = new Blob([response.data],\r\n            { type: mime }); // */\n\n        that._logger.log(\"debug\", LOG_ID + \"getAvatarFromBubble success\");\n\n        resolve(blob);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @method refreshMemberAndOrganizerLists\r\n   * @instance\r\n   * @param {Bubble} bubble the bubble to refresh\r\n   * @async\r\n   * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n   * @description\r\n   *  Refresh members and organizers of the bubble.\r\n   */\n\n\n  refreshMemberAndOrganizerLists(bubble) {\n    let that = this;\n\n    if (!bubble) {\n      that._logger.log(\"debug\", LOG_ID + \"(refreshMemberAndOrganizerLists) bad or empty 'bubble' parameter.\");\n\n      that._logger.log(\"internal\", LOG_ID + \"(refreshMemberAndOrganizerLists) bad or empty 'bubble' parameter : \", bubble);\n\n      return ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n    } //Clear both lists :\n\n\n    bubble.organizers = [];\n    bubble.members = [];\n    bubble.users.forEach(function (user) {\n      if (user.status === Bubble_1.Bubble.RoomUserStatus.ACCEPTED || user.status === Bubble_1.Bubble.RoomUserStatus.INVITED || user.jid_im === bubble.ownerContact.jid) {\n        if (user.privilege === Bubble_1.Bubble.Privilege.MODERATOR) {\n          bubble.organizers.push(user);\n        } else {\n          bubble.members.push(user);\n        }\n      }\n    });\n  }\n\n  /**\r\n   * @public\r\n   * @method getBubbleById\r\n   * @instance\r\n   * @param {string} id the id of the bubble\r\n   * @async\r\n   * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n   * @description\r\n   *  Get a bubble by its ID in memory and if it is not found in server.\r\n   */\n  getBubbleById(id) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble id  \" + id);\n\n      if (!id) {\n        that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bad or empty 'id' parameter\", id);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      let bubbleFound = that._bubbles.find(bubble => {\n        return bubble.id === id;\n      });\n\n      if (bubbleFound) {\n        that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubbleFound in memory : \", bubbleFound.jid);\n      } else {\n        that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble not found in memory, search in server id : \", id);\n\n        return that._rest.getBubble(id).then(bubbleFromServer => __awaiter(this, void 0, void 0, function* () {\n          that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubble from server : \", bubbleFromServer);\n\n          if (bubbleFromServer) {\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleFromServer); //let bubble = Object.assign(new Bubble(), bubbleFromServer);\n            //that._bubbles.push(bubble);\n\n            if (bubble.isActive) {\n              that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) send initial presence to room : \", bubble.jid);\n\n              yield that._presence.sendInitialBubblePresence(bubble);\n            } else {\n              that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble not active, so do not send initial presence to room : \", bubble.jid);\n            }\n\n            resolve(bubble);\n          } else {\n            resolve(null);\n          }\n        })).catch(err => {\n          return reject(err);\n        });\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubbleFound in memory : \", bubbleFound);\n\n      resolve(bubbleFound);\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getBubbleByJid\r\n   * @instance\r\n   * @param {string} jid the JID of the bubble\r\n   * @async\r\n   * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n   * @description\r\n   *  Get a bubble by its JID in memory and if it is not found in server.\r\n   */\n\n\n  getBubbleByJid(jid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bubble jid  \", jid);\n\n        if (!jid) {\n          that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bad or empty 'jid' parameter\", jid);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        let bubbleFound = that._bubbles.find(bubble => {\n          return bubble.jid === jid;\n        });\n\n        if (bubbleFound) {\n          that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJId) bubbleFound in memory : \", bubbleFound.jid);\n        } else {\n          that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJId) bubble not found in memory, search in server jid : \", jid);\n\n          return that._rest.getBubbleByJid(jid).then(bubbleFromServer => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"internal\", LOG_ID + \"(getBubbleByJId) bubble from server : \", bubbleFromServer);\n\n            if (bubbleFromServer) {\n              let bubble = yield that.addOrUpdateBubbleToCache(bubbleFromServer); //let bubble = Object.assign(new Bubble(), bubbleFromServer);\n              //that._bubbles.push(bubble);\n\n              if (bubble.isActive) {\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) send initial presence to room : \", bubble.jid);\n\n                yield that._presence.sendInitialBubblePresence(bubble);\n              } else {\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bubble not active, so do not send initial presence to room : \", bubble.jid);\n              }\n\n              resolve(bubble);\n            } else {\n              resolve(null);\n            }\n          })).catch(err => {\n            return reject(err);\n          });\n        }\n\n        resolve(bubbleFound);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getAllPendingBubbles\r\n   * @instance\r\n   * @return {Bubble[]} An array of Bubbles not accepted or declined\r\n   * @description\r\n   *  Get the list of Bubbles that have a pending invitation not yet accepted of declined\r\n   */\n\n\n  getAllPendingBubbles() {\n    let that = this;\n\n    let pendingBubbles = this._bubbles.filter(bubble => {\n      let invitation = bubble.users.filter(user => {\n        return user.userId === that._rest.userId && user.status === \"invited\";\n      });\n      return invitation.length > 0;\n    });\n\n    return pendingBubbles;\n  }\n  /**\r\n   * @public\r\n   * @method getAllActiveBubbles\r\n   * @since 1.30\r\n   * @instance\r\n   * @return {Bubble[]} An array of Bubbles that are \"active\" for the connected user\r\n   * @description\r\n   *  Get the list of Bubbles where the connected user can chat\r\n   */\n\n\n  getAllActiveBubbles() {\n    let that = this;\n\n    let activeBubbles = this._bubbles.filter(bubble => {\n      let amIActive = bubble.users.find(user => {\n        return user.userId === that._rest.userId && user.status === \"accepted\";\n      });\n      return amIActive;\n    });\n\n    return activeBubbles;\n  }\n  /**\r\n   * @public\r\n   * @method getAllClosedBubbles\r\n   * @since 1.30\r\n   * @instance\r\n   * @return {Bubble[]} An array of Bubbles that are closed for the connected user\r\n   * @description\r\n   *  Get the list of Bubbles where the connected user can only read messages\r\n   */\n\n\n  getAllClosedBubbles() {\n    let that = this;\n\n    let closedBubbles = this._bubbles.filter(bubble => {\n      let amIAway = bubble.users.find(user => {\n        return user.userId === that._rest.userId && user.status === \"unsubscribed\";\n      });\n      return amIAway;\n    });\n\n    return closedBubbles;\n  }\n  /**\r\n   * @public\r\n   * @method acceptInvitationToJoinBubble\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble to join\r\n   * @description\r\n   *  Accept an invitation to join a bubble\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  acceptInvitationToJoinBubble(bubble) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(acceptInvitationToJoinBubble) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(acceptInvitationToJoinBubble) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.acceptInvitationToJoinBubble(bubble.id).then(invitationStatus => {\n        that._logger.log(\"info\", LOG_ID + \"(acceptInvitationToJoinBubble) invitation accepted\", invitationStatus);\n\n        that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n          // Update the existing local bubble stored\n          let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n          /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n          if ( foundIndex > -1) {\r\n              bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n              that._bubbles[foundIndex] = bubbleUpdated;\r\n          } else {\r\n              that._logger.log(\"warn\", LOG_ID + \"(acceptInvitationToJoinBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n          }\r\n           */\n\n          resolve(bubble);\n        }));\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(acceptInvitationToJoinBubble) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(acceptInvitationToJoinBubble) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method declineInvitationToJoinBubble\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble to decline\r\n   * @description\r\n   *  Decline an invitation to join a bubble\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  declineInvitationToJoinBubble(bubble) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(declineInvitationToJoinBubble) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(declineInvitationToJoinBubble) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.declineInvitationToJoinBubble(bubble.id).then(invitationStatus => {\n        that._logger.log(\"info\", LOG_ID + \"(declineInvitationToJoinBubble) invitation declined : \", invitationStatus);\n\n        that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n          // Update the existing local bubble stored\n          let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n          /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n          if ( foundIndex > -1) {\r\n              bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n              that._bubbles[foundIndex] = bubbleUpdated;\r\n          } else {\r\n              that._logger.log(\"warn\", LOG_ID + \"(declineInvitationToJoinBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n          }\r\n           */\n\n          resolve(bubble);\n        }));\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(declineInvitationToJoinBubble) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(declineInvitationToJoinBubble) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method setBubbleCustomData\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble\r\n   * @param {Object} customData Bubble's custom data area. key/value format. Maximum and size are server dependent\r\n   * @description\r\n   *  Modify all custom data at once in a bubble\r\n   *  To erase all custom data, put {} in customData\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The bubble updated with the custom data set or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  setBubbleCustomData(bubble, customData) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setBubbleCustomData) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleCustomData) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let bubbleId = bubble.id;\n    let custom = {\n      \"customData\": customData || {}\n    };\n    return new Promise((resolve, reject) => {\n      that._rest.setBubbleCustomData(bubbleId, custom).then(json => __awaiter(this, void 0, void 0, function* () {\n        that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) customData set\", json.customData);\n\n        bubble.customData = json.customData || {};\n\n        try {\n          yield Utils_1.until(() => {\n            let bubbleInMemory = that._bubbles.find(bubbleIter => {\n              return bubbleIter.id === bubbleId;\n            });\n\n            if (bubbleInMemory) {\n              that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) bubbleInMemory : \", bubbleInMemory, \", \\nbubble : \", bubble);\n\n              return deepEqual(bubbleInMemory.customData, bubble.customData);\n            } else {\n              return false;\n            }\n          }, \"wait in setBubbleCustomData for the customData to be updated by the event rainbow_onbubblecustomdatachanged\", 8000);\n\n          this._logger.log(\"debug\", LOG_ID + \"(setBubbleCustomData) customData updated in bubble stored in BubblesService.\");\n        } catch (err) {\n          this._logger.log(\"debug\", LOG_ID + \"(setBubbleCustomData) customData not updated in bubble stored in BubblesService. Get infos about bubble from server.\");\n\n          this._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) customData not updated in bubble stored in BubblesService. Get infos about bubble from server.\", err);\n\n          that._rest.getBubble(bubble.id).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) Custom data in bubble retrieved from server : \", bubbleUpdated.name + \" | \" + bubbleUpdated.customData);\n\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n            /*// Update the existing local bubble stored\r\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n            if (foundIndex > -1) {\r\n                bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                that._bubbles[foundIndex] = bubbleUpdated;\r\n            } else {\r\n                bubbleUpdated = Object.assign(new Bubble(), bubbleUpdated);\r\n                that._bubbles.push(bubbleUpdated);\r\n            } // */\n\n            that._eventEmitter.emit(\"evt_internal_bubblecustomDatachanged\", bubble);\n          }));\n        }\n\n        resolve(bubble);\n      })).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(setBubbleCustomData) error\", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @method setBubbleVisibilityStatus\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble\r\n   * @param {string} status Bubble's public/private group visibility for search.  Either \"private\" (default) or \"public\"\r\n   * @description\r\n   *  Set the Bubble's visibility status\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  setBubbleVisibilityStatus(bubble, status) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setBubbleVisibilityStatus) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleVisibilityStatus) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.setBubbleVisibility(bubble.id, status).then(bubbleData => {\n        that._logger.log(\"info\", LOG_ID + \"(setBubbleVisibilityStatus) visibility set \");\n\n        that._logger.log(\"internal\", LOG_ID + \"(setBubbleVisibilityStatus) visibility set : \", bubbleData);\n\n        resolve(bubbleData);\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(setBubbleVisibilityStatus) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleVisibilityStatus) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method setBubbleTopic\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble\r\n   * @param {string} topic Bubble's topic\r\n   * @description\r\n   *  Set the Bubble's topic\r\n   * @memberof Bubbles\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  setBubbleTopic(bubble, topic) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setBubbleTopic) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleTopic) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.setBubbleTopic(bubble.id, topic).then(bubbleData => {\n        that._logger.log(\"internal\", LOG_ID + \"(setBubbleTopic) topic set\", bubbleData.topic);\n\n        bubble.topic = bubbleData.topic;\n        resolve(bubble);\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(setBubbleTopic) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleTopic) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method setBubbleName\r\n   * @instance\r\n   * @param {Bubble} bubble The Bubble\r\n   * @param {string} topic Bubble's name\r\n   * @description\r\n   *  Set the Bubble's name\r\n   * @async\r\n   * @return {Promise<Bubble, ErrorManager>}\r\n   * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n   * @category async\r\n   */\n\n\n  setBubbleName(bubble, name) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setBubbleName) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleName) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.setBubbleName(bubble.id, name).then(bubbleData => {\n        that._logger.log(\"debug\", LOG_ID + \"(setBubbleName) name set : \", bubbleData.name);\n\n        bubble.name = bubbleData.name;\n        resolve(bubble);\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(setBubbleName) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleName) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  randomString(length = 10) {\n    let string = \"\";\n    let rnd;\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n    while (length > 0) {\n      rnd = Math.floor(Math.random() * chars.length);\n      string += chars.charAt(rnd);\n      length--;\n    }\n\n    return string;\n  }\n\n  /**\r\n   * @public\r\n   * @method updateAvatarForBubble\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Update the bubble avatar (from given URL) <br/>\r\n   *    The image will be automaticalle resized <br/>\r\n   *    /!\\ if URL isn't valid or given image isn't loadable, it'll fail <br/>\r\n   *    Return a promise.\r\n   * @param {string} urlAvatar  The avatarUrl\r\n   * @param {Bubble} bubble  The bubble to update\r\n   * @return {Bubble} A bubble object of null if not found\r\n   */\n  updateAvatarForBubble(urlAvatar, bubble) {\n    return this.setAvatarBubble(bubble, urlAvatar);\n  }\n  /**\r\n   * @private\r\n   * @method setAvatarBubble\r\n   * @param bubble\r\n   * @param roomAvatarPath\r\n   */\n\n\n  setAvatarBubble(bubble, roomAvatarPath) {\n    let that = this;\n\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!roomAvatarPath) {\n      this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'roomAvatarPath' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'roomAvatarPath' parameter : \", roomAvatarPath);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      Utils_1.resizeImage(roomAvatarPath, 512, 512).then(function (resizedImage) {\n        that._logger.log(\"debug\", LOG_ID + \"(setAvatarBubble) resizedImage : \", resizedImage);\n\n        let binaryData = Utils_1.getBinaryData(resizedImage);\n\n        that._rest.setAvatarRoom(bubble.id, binaryData).then(function success(result) {\n          that._logger.log(\"debug\", LOG_ID + \"(setAvatarBubble) setAvatarRoom success : \" + result);\n          /*\r\n          let url = that.avatarDomain;\r\n          if ($rootScope.cdn) {\r\n              url = $rootScope.cdnServer;\r\n          }\r\n          bubble.avatar = url + \"/api/room-avatar/\" + bubble.id + \"?size=512&rand=\" + that.randomString();\r\n          // */\n\n\n          resolve(bubble);\n        }, function failure(err) {\n          that._logger.log(\"error\", LOG_ID + \"(setAvatarBubble) error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) error : \", err);\n\n          return reject(err);\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method deleteAvatarFromBubble\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Delete the bubble avatar <br/>\r\n     *    Return a promise.\r\n   * @param {Bubble} bubble  The bubble to update\r\n   * @return {Bubble} A bubble object of null if not found\r\n   */\n\n\n  deleteAvatarFromBubble(bubble) {\n    if (!bubble) {\n      this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return this.deleteAvatarBubble(bubble.id);\n  }\n  /**\r\n   * @private\r\n   * @method deleteAvatarBubble\r\n   * @param bubbleId\r\n   */\n\n\n  deleteAvatarBubble(bubbleId) {\n    let that = this;\n\n    if (!bubbleId) {\n      this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubbleId);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      that._rest.deleteAvatarRoom(bubbleId).then(res => {\n        resolve(res);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n    /* return $q(function(resolve, reject) {\r\n        $http({\r\n            method: \"DELETE\",\r\n            url: service.portalURL + \"rooms/\" + roomId + \"/avatar\",\r\n            headers: authService.getRequestHeader()\r\n        }).then(function success() {\r\n            $log.info(\"[roomService] avatar room sucessfully deleted\");\r\n            resolve();\r\n        }).catch(function(err) {\r\n            reject(err);\r\n        });\r\n    });\r\n    // */\n  }\n\n  /**\r\n   * @public\r\n   * @method updateCustomDataForBubble\r\n   * @since 1.64\r\n   * @instance\r\n   * @description\r\n   *    Update the customData of the bubble  <br/>\r\n   *    Return a promise.\r\n   * @param {Object} customData\r\n   *    The customData to put to the bubble <br />\r\n   *    Example: { \"key1\" : 123, \"key2\" : \"a string\" }\r\n   * @param {Bubble} bubble   The bubble to update\r\n   * @return {Promise<Bubble>} The updated Bubble\r\n   */\n  updateCustomDataForBubble(customData, bubble) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateCustomDataForBubble) customData : \", customData);\n\n      return yield this.setBubbleCustomData(bubble, customData).then(bubbleUpdated => {\n        return bubbleUpdated;\n      });\n      /*\r\n      let that = this;\r\n       // update bubble with internal copy to avoid user/moderator/owner side effects\r\n       let bubblefound : any = bubble && bubble.id ? await that.getBubbleById(bubble.id) : null;\r\n              if (!customData) {\r\n           this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'customData' parameter\");\r\n           this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'customData' parameter : \", customData);\r\n           return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n       } else if (!bubblefound) {\r\n           this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\r\n           this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\r\n           return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n       } else {\r\n           return new Promise((resolve, reject) => {\r\n               bubblefound.customData = customData;\r\n               this._rest.ownerUpdateRoomCustomData(bubblefound).then(function (updatedCustomData) {\r\n                   bubblefound.customData = updatedCustomData;\r\n                       resolve(bubblefound);\r\n                   })\r\n                   .catch(function (err) {\r\n                       reject(err);\r\n                   });\r\n           });\r\n       }\r\n       // */\n    });\n  }\n  /**\r\n   * @public\r\n   * @method deleteCustomDataForBubble\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Delete the customData of the bubble  <br/>\r\n   *    Return a promise.\r\n   * @param {Bubble} bubble   The bubble to update\r\n   * @return {Promise<Bubble>} The updated Bubble\r\n   */\n\n\n  deleteCustomDataForBubble(bubble) {\n    return this.updateCustomDataForBubble(\"\", bubble);\n  }\n  /**\r\n   * @public\r\n   * @method updateDescriptionForBubble\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Update the description of the bubble  <br/>\r\n   *    Return a promise.\r\n   * @param {string} strDescription   The description of the bubble (is is the topic on server side, and result event)\r\n   * @param {Bubble} bubble   The bubble to update\r\n   * @return {Bubble} A bubble object of null if not found\r\n   */\n\n\n  updateDescriptionForBubble(bubble, strDescription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.setBubbleTopic(bubble, strDescription);\n      /*let that = this;\r\n      // update bubble with internal copy to avoid user/moderator/owner side effects\r\n      let bubblefound : any = bubble && bubble.id ? await that.getBubbleById(bubble.id) : null;\r\n            if (!strDescription) {\r\n          this._logger.log(\"warn\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'strDescription' parameter\");\r\n          this._logger.log(\"internalerror\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'strDescription' parameter : \", strDescription);\r\n          return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n      } else if (!bubblefound) {\r\n          this._logger.log(\"warn\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'bubble' parameter\");\r\n          this._logger.log(\"internalerror\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'bubble' parameter : \", bubble);\r\n          return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n      } else {\r\n          return new Promise((resolve, reject) => {\r\n              bubblefound.desc = strDescription;\r\n              this._rest.ownerUpdateRoom(bubblefound).then(function (updatedCustomData) {\r\n                  resolve(updatedCustomData);\r\n              }).catch(function (err) {\r\n                  reject(err);\r\n              });\r\n          });\r\n      } // */\n    });\n  }\n  /**\r\n   * @private\r\n   * @method _onInvitationReceived\r\n   * @instance\r\n   * @param {Object} invitation contains informations about bubble and user's jid\r\n   * @description\r\n   *      Method called when receiving an invitation to join a bubble\r\n   */\n\n\n  _onInvitationReceived(invitation) {\n    let that = this;\n\n    that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) invitation : \", invitation);\n\n    this._rest.getBubble(invitation.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n      that._logger.log(\"debug\", LOG_ID + \"(_onInvitationReceived) invitation received from bubble.\");\n\n      that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) invitation received from bubble : \", bubbleUpdated);\n\n      let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n      /*// Store the new bubble\r\n      let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n      if (foundIndex > -1) {\r\n          bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n          that._bubbles[foundIndex] = bubbleUpdated;\r\n      }\r\n      else {\r\n          bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n          that._bubbles.push(bubbleUpdated);\r\n      } // */\n\n      that._eventEmitter.emit(\"evt_internal_invitationdetailsreceived\", bubble);\n    })).catch(err => {\n      that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) get bubble failed for invitation : \", invitation);\n    });\n\n    ;\n  }\n  /**\r\n   * @private\r\n   * @method _onAffiliationChanged\r\n   * @instance\r\n   * @param {Object} affiliation contains information about bubble and user's jid\r\n   * @description\r\n   *      Method called when affilitation to a bubble changed\r\n   */\n\n\n  _onAffiliationChanged(affiliation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) affiliation : \", affiliation);\n\n      yield this._rest.getBubble(affiliation.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n        that._logger.log(\"debug\", LOG_ID + \"(_onAffiliationChanged) user affiliation changed for bubble.\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) user affiliation changed for bubble : \", bubbleUpdated, \", affiliation : \", affiliation);\n\n        let bubbleProm = that.addOrUpdateBubbleToCache(bubbleUpdated);\n        let bubble = yield bubbleProm;\n        /*// Update the existing local bubble stored\r\n        let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n        if (foundIndex > -1) {\r\n            bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n            that._bubbles[foundIndex] = bubbleUpdated;\r\n        }\r\n        else {\r\n            bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n            that._bubbles.push(bubbleUpdated);\r\n        } // */\n\n        that._eventEmitter.emit(\"evt_internal_affiliationdetailschanged\", bubble);\n      })).catch(err => {\n        that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) get bubble failed for affiliation : \", affiliation);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @method _onOwnAffiliationChanged\r\n   * @instance\r\n   * @param {Object} affiliation contains information about bubble and user's jid\r\n   * @description\r\n   *      Method called when the user affilitation to a bubble changed\r\n   */\n\n\n  _onOwnAffiliationChanged(affiliation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) parameters : affiliation : \", affiliation);\n\n      if (affiliation.status !== \"deleted\") {\n        if (affiliation.status === \"available\") {\n          that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) available state received. Nothing to do.\");\n        } else {\n          yield this._rest.getBubble(affiliation.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) own affiliation changed for bubble : \", bubbleUpdated.name + \" | \" + affiliation.status); // Update the existing local bubble stored\n\n\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\n\n            if (foundIndex > -1) {\n              let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated); //bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\n              //that._bubbles[foundIndex] = bubbleUpdated;\n\n              if (affiliation.status === \"accepted\") {\n                if (bubble.isActive) {\n                  that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) send initial presence to room : \", bubble.jid);\n\n                  that._presence.sendInitialBubblePresence(bubble);\n                } else {\n                  that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) bubble not active, so do not send initial presence to room : \", bubble.jid);\n                }\n              } else if (affiliation.status === \"unsubscribed\") {\n                that._xmpp.sendUnavailableBubblePresence(bubble.jid);\n              }\n            } else {\n              let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n              /*bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n              that._bubbles.push(bubbleUpdated); // */\n              // New bubble, send initial presence\n\n              if (bubble.isActive) {\n                that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) send initial presence to room : \", bubble.jid);\n\n                that._presence.sendInitialBubblePresence(bubble);\n              } else {\n                that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) bubble not active, so do not send initial presence to room : \", bubble.jid);\n              }\n            }\n\n            that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubbleUpdated);\n          }));\n        }\n      } else {\n        // remove it\n        let bubbleToRemoved = that._bubbles.findIndex(function (el) {\n          return el.id === affiliation.bubbleId;\n        }); //*/\n\n\n        if (bubbleToRemoved != -1) {\n          let bubbleRemoved = yield that.removeBubbleFromCache(affiliation.bubbleId);\n\n          that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubbleRemoved);\n\n          that._eventEmitter.emit(\"evt_internal_bubbledeleted\", bubbleRemoved);\n        } else {\n          that._logger.log(\"warn\", LOG_ID + \"(_onOwnAffiliationChanged) deleted bubble not found in cache, so raised the deleted event with only the id of this bubble : \", affiliation.bubbleId);\n\n          let bubble = {\n            id: null\n          };\n          bubble.id = affiliation.bubbleId;\n\n          that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubble);\n\n          that._eventEmitter.emit(\"evt_internal_bubbledeleted\", bubble);\n        } // */\n\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @method _onCustomDataChanged\r\n   * @instance\r\n   * @param {Object} data contains information about bubble and new custom data received\r\n   * @description\r\n   *      Method called when custom data have changed for a bubble\r\n   */\n\n\n  _onCustomDataChanged(data) {\n    let that = this;\n\n    this._rest.getBubble(data.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n      that._logger.log(\"internal\", LOG_ID + \"(_onCustomDataChanged) Custom data changed for bubble : \", bubbleUpdated.name + \" | \" + data.customData);\n\n      let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n      /*// Update the existing local bubble stored\r\n      let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n      if (foundIndex > -1) {\r\n          bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n          that._bubbles[foundIndex] = bubbleUpdated;\r\n      }\r\n      else {\r\n          bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n          that._bubbles.push(bubbleUpdated);\r\n      } // */\n\n      that._eventEmitter.emit(\"evt_internal_bubblecustomDatachanged\", bubble);\n    }));\n  }\n  /**\r\n   * @private\r\n   * @method _onTopicChanged\r\n   * @instance\r\n   * @param {Object} data contains information about bubble new topic received\r\n   * @description\r\n   *      Method called when the topic has changed for a bubble\r\n   */\n\n\n  _onTopicChanged(data) {\n    let that = this;\n\n    this._rest.getBubble(data.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n      that._logger.log(\"internal\", LOG_ID + \"(_onTopicChanged) Topic changed for bubble : \", bubbleUpdated.name + \" | \" + data.topic);\n\n      let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n      /*// Update the existing local bubble stored\r\n      let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n      if (foundIndex > -1) {\r\n          bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n          that._bubbles[foundIndex] = bubbleUpdated;\r\n      }\r\n      else {\r\n          bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n          that._bubbles.push(bubbleUpdated);\r\n      } // */\n\n      that._eventEmitter.emit(\"evt_internal_bubbletopicchanged\", bubble);\n    }));\n  }\n  /**\r\n   * @private\r\n   * @method _onPrivilegeBubbleChanged\r\n   * @instance\r\n   * @param {Object} bubbleInfo modified bubble info\r\n   * @description\r\n   *     Method called when the owner of a bubble changed.\r\n   */\n\n\n  _onPrivilegeBubbleChanged(bubbleInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      /*\r\n      let that = this;\r\n      let ownerContact = await that.getContactById(bubbleInfo.creator, false);\r\n       */\n      let that = this;\n\n      that._logger.log(\"internal\", LOG_ID + \"(_onPrivilegeBubbleChanged) privilege changed for bubbleInfo : \", bubbleInfo);\n\n      this._rest.getBubble(bubbleInfo.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n        that._logger.log(\"internal\", LOG_ID + \"(_onPrivilegeBubbleChanged) privilege changed for bubble : \", bubbleUpdated.name);\n\n        let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n\n        that._eventEmitter.emit(\"evt_internal_bubbleprivilegechanged\", {\n          bubble,\n          \"privilege\": bubbleInfo.privilege\n        });\n      }));\n    });\n  }\n  /**\r\n   * @private\r\n   * @method _onNameChanged\r\n   * @instance\r\n   * @param {Object} data contains information about bubble new name received\r\n   * @description\r\n   *      Method called when the name has changed for a bubble\r\n   */\n\n\n  _onNameChanged(data) {\n    let that = this;\n\n    this._rest.getBubble(data.bubbleId).then(bubbleUpdated => __awaiter(this, void 0, void 0, function* () {\n      that._logger.log(\"internal\", LOG_ID + \"(_onNameChanged) Name changed for bubble : \", bubbleUpdated.name + \" | \" + data.name);\n\n      let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\n      /*// Update the existing local bubble stored\r\n      let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n      if (foundIndex > -1) {\r\n          bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n          that._bubbles[foundIndex] = bubbleUpdated;\r\n      }\r\n      else {\r\n          bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n          that._bubbles.push(bubbleUpdated);\r\n      } // */\n\n      that._eventEmitter.emit(\"evt_internal_bubblenamechanged\", bubble);\n    }));\n  }\n  /**\r\n   * @private\r\n   * @method _onbubblepresencechanged\r\n   * @instance\r\n   * @param {Object} bubbleInfo contains information about bubble\r\n   * @description\r\n   *      Method called when the name has changed for a bubble\r\n   */\n\n\n  _onbubblepresencechanged(bubbleInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"debug\", LOG_ID + \"(_onbubblepresencechanged) bubble presence received for : \", bubbleInfo.jid); //that._logger.log(\"internal\", LOG_ID + \"(_onbubblepresencechanged) bubble presence : \", bubbleInfo );\n      // Find the bubble in service list, and else retrieve it from server.\n\n\n      let bubbleInMemory;\n      bubbleInMemory = yield that.getBubbleByJid(bubbleInfo.jid); // that._bubbles.find((bubbleIter) => { return bubbleIter.jid === bubbleInfo.jid ; });\n\n      if (bubbleInMemory) {\n        that._logger.log(\"internal\", LOG_ID + \"(_onbubblepresencechanged) bubble found in memory : \", bubbleInMemory.jid);\n\n        if (bubbleInfo.statusCode === \"resumed\") {\n          that._presence.sendInitialBubblePresence(bubbleInfo).then(() => {\n            bubbleInMemory.isActive = true;\n\n            that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\n          });\n        }\n\n        if (bubbleInfo.statusCode === \"deactivated\") {\n          bubbleInMemory.isActive = false;\n\n          that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\n        }\n      } else {\n        that._logger.log(\"warn\", LOG_ID + \"(_onbubblepresencechanged) bubble not found !\"); //that._bubbles.push(Object.assign(new Bubble(), bubble));\n\n      } // that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\n\n    });\n  }\n\n};\nBubbles = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n * @module\r\n * @name Bubbles\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This service manages multi-party communications (aka bubbles). Bubbles allow to chat and to share files with several participants.<br><br>\r\n *      Each user can create bubbles and invite other users to be part of it.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Create a new bubble <br>\r\n *      - Invite users in a bubble or remove them <br>\r\n *      - Manage a bubble: close, delete <br>\r\n *      - Leave a bubble <br>\r\n *      - Accept or decline an invitation to join a bubble <br>\r\n *      - Change the custom data attached to a bubble\r\n */\n], Bubbles);\nexports.BubblesService = Bubbles;\nmodule.exports.BubblesService = Bubbles;","map":{"version":3,"sources":["../../src/lib/services/BubblesService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst deepEqual = require(\"deep-equal\");\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Bubble_1 = require(\"../common/models/Bubble\");\r\nconst promiseQueue_1 = require(\"../common/promiseQueue\");\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst Jimp = require('jimp');\r\n//import Jimp from \"jimp\";\r\nconst LOG_ID = \"BUBBLES/SVCE - \";\r\nlet Bubbles = \r\n/**\r\n * @module\r\n * @name Bubbles\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This service manages multi-party communications (aka bubbles). Bubbles allow to chat and to share files with several participants.<br><br>\r\n *      Each user can create bubbles and invite other users to be part of it.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Create a new bubble <br>\r\n *      - Invite users in a bubble or remove them <br>\r\n *      - Manage a bubble: close, delete <br>\r\n *      - Leave a bubble <br>\r\n *      - Accept or decline an invitation to join a bubble <br>\r\n *      - Change the custom data attached to a bubble\r\n */\r\nclass Bubbles {\r\n    constructor(_eventEmitter, _http, _logger, _startConfig) {\r\n        this.ready = false;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._bubbles = null;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._logger = _logger;\r\n        this._startConfig = _startConfig;\r\n        this.avatarDomain = _http.host.split(\".\").length === 2 ? _http.protocol + \"://cdn.\" + _http.host + \":\" + _http.port : _http.protocol + \"://\" + _http.host + \":\" + _http.port;\r\n        this._eventEmitter.on(\"evt_internal_invitationreceived\", this._onInvitationReceived.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_affiliationchanged\", this._onAffiliationChanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_ownaffiliationchanged\", this._onOwnAffiliationChanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_customdatachanged\", this._onCustomDataChanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_topicchanged\", this._onTopicChanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_namechanged\", this._onNameChanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_onbubblepresencechanged\", this._onbubblepresencechanged.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_privilegechanged\", this._onPrivilegeBubbleChanged.bind(this));\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = _core._xmpp;\r\n                that._rest = _core._rest;\r\n                that._bubbles = [];\r\n                that._contacts = _core.contacts;\r\n                that._profileService = _core.profiles;\r\n                that._presence = _core.presence;\r\n                that._options = _options;\r\n                that._s2s = _core._s2s;\r\n                that._useXMPP = that._options.useXMPP;\r\n                that._useS2S = that._options.useS2S;\r\n                /*\r\n                                that._eventEmitter.on(\"evt_internal_invitationreceived\", that._onInvitationReceived.bind(that));\r\n                                that._eventEmitter.on(\"evt_internal_affiliationchanged\", that._onAffiliationChanged.bind(that));\r\n                                that._eventEmitter.on(\"evt_internal_ownaffiliationchanged\", that._onOwnAffiliationChanged.bind(that));\r\n                                that._eventEmitter.on(\"evt_internal_customdatachanged\", that._onCustomDataChanged.bind(that));\r\n                                that._eventEmitter.on(\"evt_internal_topicchanged\", that._onTopicChanged.bind(that));\r\n                                that._eventEmitter.on(\"evt_internal_namechanged\", that._onNameChanged.bind(that));\r\n                */\r\n                that.ready = true;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject();\r\n            }\r\n        });\r\n    }\r\n    stop() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = null;\r\n                that._rest = null;\r\n                that._bubbles = null;\r\n                /*that._eventEmitter.removeListener(\"evt_internal_invitationreceived\", that._onInvitationReceived.bind(that));\r\n                that._eventEmitter.removeListener(\"evt_internal_affiliationchanged\", that._onAffiliationChanged.bind(that));\r\n                that._eventEmitter.removeListener(\"evt_internal_ownaffiliationchanged\", that._onOwnAffiliationChanged.bind(that));\r\n                that._eventEmitter.removeListener(\"evt_internal_customdatachanged\", that._onCustomDataChanged.bind(that));\r\n                that._eventEmitter.removeListener(\"evt_internal_topicchanged\", that._onTopicChanged.bind(that));\r\n                that._eventEmitter.removeListener(\"evt_internal_namechanged\", that._onNameChanged.bind(that));\r\n                that._logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\r\n                // */\r\n                that.ready = false;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method createBubble\r\n     * @instance\r\n     * @description\r\n     *  Create a new bubble\r\n     * @param {string} name  The name of the bubble to create\r\n     * @param {string} description  The description of the bubble to create\r\n     * @param {boolean} withHistory If true, a newcomer will have the complete messages history since the beginning of the bubble. False if omitted\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - Bubble object, else an ErrorManager object\r\n     * @category async\r\n     */\r\n    createBubble(name, description, withHistory) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                if (typeof withHistory === \"undefined\") {\r\n                    withHistory = false;\r\n                }\r\n                if (!name) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(createBubble) bad or empty 'name' parameter\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(createBubble) bad or empty 'name' parameter\", name);\r\n                    reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                    return;\r\n                }\r\n                else if (!description) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(createBubble) bad or empty 'description' parameter\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(createBubble) bad or empty 'description' parameter\", description);\r\n                    reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                    return;\r\n                }\r\n                that._rest.createBubble(name, description, withHistory).then((bubble) => {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(createBubble) creation successfull\");\r\n                    that._logger.log(\"internal\", LOG_ID + \"(createBubble) creation successfull, bubble\", bubble);\r\n                    /*that._eventEmitter.once(\"evt_internal_bubblepresencechanged\", function fn_onbubblepresencechanged() {\r\n                        that._logger.log(\"debug\", LOG_ID + \"(createBubble) bubble presence successfull\");\r\n                        that._logger.log(\"debug\", LOG_ID + \"(createBubble) _exiting_\");\r\n                        that._bubbles.push(Object.assign( new Bubble(), bubble));\r\n                        that._eventEmitter.removeListener(\"evt_internal_bubblepresencechanged\", fn_onbubblepresencechanged);\r\n                        resolve(bubble);\r\n                    }); // */\r\n                    that._presence.sendInitialBubblePresence(bubble).then(() => __awaiter(this, void 0, void 0, function* () {\r\n                        // Wait for the bubble to be added in service list with the treatment of the sendInitialPresence result event (_onbubblepresencechanged)\r\n                        yield Utils_1.until(() => {\r\n                            return (that._bubbles.find((bubbleIter) => {\r\n                                return (bubbleIter.jid === bubble.jid);\r\n                            }) !== undefined);\r\n                        }, \"Waiting for the initial presence of a creation of bubble : \" + bubble.jid);\r\n                        //that._bubbles.push(Object.assign( new Bubble(), bubble));\r\n                        that._logger.log(\"debug\", LOG_ID + \"(createBubble) bubble successfully created and presence sent : \", bubble.jid);\r\n                        resolve(bubble);\r\n                    }));\r\n                }).catch((err) => {\r\n                    that._logger.log(\"error\", LOG_ID + \"(createBubble) error\");\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method isBubbleClosed\r\n     * @instance\r\n     * @param {Bubble} bubble  The bubble to check\r\n     * @return {boolean} True if the bubble is closed\r\n     * @description\r\n     *  Check if the bubble is closed or not.\r\n     */\r\n    isBubbleClosed(bubble) {\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(isBubbleClosed) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(isBubbleClosed) bad or empty 'bubble' parameter : \", bubble);\r\n            throw (ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        else {\r\n            let activeUser = bubble.users.find((user) => {\r\n                return user.status === \"invited\" || user.status === \"accepted\";\r\n            });\r\n            if (activeUser) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * @public\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Delete all existing owned bubbles <br/>\r\n     *    Return a promise\r\n     * @return {Object} Nothing or an error object depending on the result\r\n     */\r\n    deleteAllBubbles() {\r\n        let that = this;\r\n        let deleteallBubblePromiseQueue = promiseQueue_1.createPromiseQueue(that._logger);\r\n        let bubbles = that.getAll();\r\n        bubbles.forEach(function (bubble) {\r\n            let deleteBubblePromise = function () { return that.deleteBubble(bubble); };\r\n            deleteallBubblePromiseQueue.add(deleteBubblePromise);\r\n        });\r\n        return deleteallBubblePromiseQueue.execute();\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method deleteBubble\r\n     * @instance\r\n     * @param {Bubble} bubble  The bubble to delete\r\n     * @description\r\n     *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble removed, else an ErrorManager object\r\n     * @category async\r\n     */\r\n    deleteBubble(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.deleteBubble(bubble.id).then((resultDelete) => {\r\n                //let bubbleRemoved = await that.removeBubbleFromCache(updatedBubble.id);\r\n                /*let bubbleRemovedList = that._bubbles.splice(that._bubbles.findIndex(function(el) {\r\n                    return el.id === updatedBubble.id;\r\n                }), 1); // */\r\n                that._logger.log(\"debug\", LOG_ID + \"(deleteBubble) delete bubble with id : \", bubble.id, \" successfull\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(deleteBubble) delete bubble : \", bubble, \", resultDelete : \", resultDelete, \" bubble successfull\");\r\n                //let bubbleRemoved = bubbleRemoved.length > 0 ? bubbleRemoved[0] : null;\r\n                //resolve( Object.assign(bubble, bubbleRemoved));\r\n                resolve(bubble);\r\n            }).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(deleteBubble) error\");\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method closeAndDeleteBubble\r\n     * @instance\r\n     * @param {Bubble} bubble  The bubble to close + delete\r\n     * @description\r\n     *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble removed, else an ErrorManager object\r\n     * @category async\r\n     */\r\n    closeAndDeleteBubble(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter \");\r\n                that._logger.log(\"warn\", LOG_ID + \"(deleteBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that.closeBubble(bubble).then((updatedBubble) => {\r\n                that._rest.deleteBubble(updatedBubble.id).then(() => {\r\n                    //let bubbleRemoved = await that.removeBubbleFromCache(updatedBubble.id);\r\n                    /*let bubbleRemovedList = that._bubbles.splice(that._bubbles.findIndex(function(el) {\r\n                        return el.id === updatedBubble.id;\r\n                    }), 1); // */\r\n                    that._logger.log(\"debug\", LOG_ID + \"(deleteBubble) delete with id : \", updatedBubble.id, \" bubble successfull\");\r\n                    that._logger.log(\"internal\", LOG_ID + \"(deleteBubble) delete \", updatedBubble, \" bubble successfull\");\r\n                    //let bubbleRemoved = bubbleRemoved.length > 0 ? bubbleRemoved[0] : null;\r\n                    //resolve( Object.assign(bubble, bubbleRemoved));\r\n                    resolve(updatedBubble);\r\n                }).catch(function (err) {\r\n                    that._logger.log(\"error\", LOG_ID + \"(deleteBubble) error\");\r\n                    return reject(err);\r\n                });\r\n            }).catch((err) => {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method closeBubble\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble to close\r\n     * @description\r\n     *  Close a owned bubble. When the owner closes a bubble, the bubble is archived and only accessible in read only mode for all participants.\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble closed, else an ErrorManager object\r\n     * @category async\r\n     */\r\n    closeBubble(bubble) {\r\n        let that = this;\r\n        let unsubscribeParticipants = (participantsIDList) => {\r\n            return new Promise((resolve, reject) => {\r\n                let participantID = participantsIDList.shift();\r\n                if (participantID) {\r\n                    return that.removeContactFromBubble({ id: participantID }, bubble).then(() => {\r\n                        that._logger.log(\"debug\", LOG_ID + \"(closeBubble) Participant \" + participantID + \" unsubscribed\");\r\n                        return unsubscribeParticipants(participantsIDList).then(() => {\r\n                            resolve();\r\n                        }).catch((err) => {\r\n                            return reject(err);\r\n                        });\r\n                    }).catch((err) => {\r\n                        return reject(err);\r\n                    });\r\n                }\r\n                resolve();\r\n            });\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(closeBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(closeBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (that.isBubbleClosed(bubble)) {\r\n                that._logger.log(\"internal\", LOG_ID + \"(closeBubble) bubble is already closed : \", bubble);\r\n                resolve(bubble);\r\n            }\r\n            else {\r\n                let queue = [];\r\n                bubble.users.forEach(function (user) {\r\n                    if (user.userId !== that._rest.userId && user.status !== Bubble_1.Bubble.RoomUserStatus.DELETED && user.status !== Bubble_1.Bubble.RoomUserStatus.REJECTED) {\r\n                        // if (user.userId !== that._rest.userId) {\r\n                        // unsubscribe everyone except the connected user\r\n                        queue.push(user.userId);\r\n                        //}\r\n                    }\r\n                });\r\n                // unsubscribe the connected user\r\n                // queue.push(that._rest.userId);\r\n                unsubscribeParticipants(queue).then(() => {\r\n                    that._logger.log(\"info\", LOG_ID + \"(closeBubble) all users have been unsubscribed from bubble. Bubble is closed\");\r\n                    that.removeContactFromBubble({ id: that._rest.userId }, bubble).then(() => {\r\n                        that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                            //\r\n                            // Update the existing local bubble stored\r\n                            let bubbleReturned = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                            /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                            if ( foundIndex > -1) {\r\n                                bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                                that._bubbles[foundIndex] = bubbleUpdated;\r\n                            } else {\r\n                                that._logger.log(\"warn\", LOG_ID + \"(closeBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n                            }\r\n                            // */\r\n                            resolve(bubbleReturned);\r\n                        }));\r\n                    });\r\n                }).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method archiveBubble\r\n     * @instance\r\n     * @param {Bubble} bubble  The bubble to archive\r\n     * @description\r\n     *  Archive  a bubble.\r\n     *  This API allows to close the room in one step. The other alternative is to change the status for each room users not deactivated yet.\r\n     *  All users currently having the status 'invited' or 'accepted' will receive a message/stanza .\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The operation result\r\n     * @category async\r\n     */\r\n    archiveBubble(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            let otherModerator = null;\r\n            if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(archiveBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(archiveBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.archiveBubble(bubble.id).then(function (json) {\r\n                that._logger.log(\"info\", LOG_ID + \"(archiveBubble) leave successfull\");\r\n                that._xmpp.sendUnavailableBubblePresence(bubble.jid);\r\n                resolve(json);\r\n            }).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(archiveBubble) error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(archiveBubble) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method leaveBubble\r\n     * @instance\r\n     * @param {Bubble} bubble  The bubble to leave\r\n     * @description\r\n     *  Leave a bubble. If the connected user is a moderator, an other moderator should be still present in order to leave this bubble.\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The operation result\r\n     * @category async\r\n     */\r\n    leaveBubble(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            let otherModerator = null;\r\n            let userStatus = \"none\";\r\n            if (bubble) {\r\n                otherModerator = bubble.users.find((user) => {\r\n                    return user.privilege === \"moderator\" && user.status === \"accepted\" && user.userId !== that._rest.userId;\r\n                });\r\n                userStatus = bubble.getStatusForUser(that._rest.userId);\r\n            }\r\n            if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(leaveBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(leaveBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (!otherModerator) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(leaveBubble) can't leave a bubble if no other active moderator\");\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().FORBIDDEN);\r\n                return;\r\n            }\r\n            that._rest.leaveBubble(bubble.id, userStatus).then(function (json) {\r\n                that._logger.log(\"info\", LOG_ID + \"(leaveBubble) leave successfull\");\r\n                that._xmpp.sendUnavailableBubblePresence(bubble.jid);\r\n                resolve(json);\r\n            }).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(leaveBubble) error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(leaveBubble) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getUsersFromBubble\r\n     * @instance\r\n     * @param {Bubble} bubble           The bubble\r\n     * @param {Object} options          The criterias to select the users to retrieve\r\n     * format : Allows to retrieve more or less user details in response, besides specifics data about room users like (privilege, status and additionDate)\r\n     * - small: userId loginEmail displayName jid_im\r\n     * - medium: userId loginEmail displayName jid_im status additionDate privilege firstName lastName companyId companyName\r\n     * - full: userId loginEmail displayName jid_im status additionDate privilege firstName lastName nickName title jobTitle emails country language timezone companyId companyName roles adminType\r\n     * sortField : Sort items list based on the given field\r\n     * privilege : Allows to filter users list on the privilege type provided in this option.\r\n     * limit : Allow to specify the number of items to retrieve.\r\n     * offset : Allow to specify the position of first item to retrieve (first item if not specified). Warning: if offset > total, no results are returned.\r\n     * sortOrder : Specify order when sorting items list. Available values -1, 1 (default)\r\n     * @description\r\n     *  Get a list of users in a bubble filtered by criterias.\r\n     * @async\r\n     * @return {Promise<Array, ErrorManager>}\r\n     */\r\n    getUsersFromBubble(bubble, options = {}) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            /*let filterToApply = \"format=medium\";\r\n            if (_options.format) {\r\n                filterToApply = \"format=\" + _options.format;\r\n            }\r\n\r\n            if (_options.page > 0) {\r\n                filterToApply += \"&offset=\";\r\n                if (_options.page > 1) {\r\n                    filterToApply += (_options.limit * (_options.page - 1));\r\n                } else {\r\n                    filterToApply += 0;\r\n                }\r\n            }\r\n\r\n            filterToApply += \"&limit=\" + Math.min(_options.limit, 1000);\r\n\r\n            if (_options.type) {\r\n                filterToApply += \"&types=\" + _options.type;\r\n            }\r\n\r\n            // */\r\n            that._rest.getRoomUsers(bubble.id, options).then(function (json) {\r\n                that._logger.log(\"info\", LOG_ID + \"(getRoomUsers) retrieve successfull\");\r\n                resolve(json);\r\n            }).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(getRoomUsers) error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getRoomUsers) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n    * @public\r\n    * @method getStatusForConnectedUserInBubble\r\n    * @instance\r\n    * @param {Bubble} bubble           The bubble\r\n    * @description\r\n    *  Get the status of the connected user in a bubble\r\n    * @async\r\n    * @return {Promise<Bubble, ErrorManager>}\r\n    */\r\n    getStatusForConnectedUserInBubble(bubble) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(getStatusForConnectedUserInBubble) bad or empty 'bubble' parameter\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(getStatusForConnectedUserInBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            //reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n            return \"none\";\r\n        }\r\n        let user = bubble.users.find((user) => {\r\n            return user.userId === that._rest.userId;\r\n        });\r\n        return user ? user.status : \"none\";\r\n    }\r\n    /**\r\n     * @public\r\n     * @method inviteContactToBubble\r\n     * @instance\r\n     * @param {Contact} contact         The contact to invite\r\n     * @param {Bubble} bubble           The bubble\r\n     * @param {boolean} isModerator     True to add a contact as a moderator of the bubble\r\n     * @param {boolean} withInvitation  If true, the contact will receive an invitation and will have to accept it before entering the bubble. False to force the contact directly in the bubble without sending an invitation.\r\n     * @param {string} reason        The reason of the invitation (optional)\r\n     * @description\r\n     *  Invite a contact in a bubble\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated with the new invitation\r\n     * @category async\r\n     */\r\n    inviteContactToBubble(contact, bubble, isModerator, withInvitation, reason) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._logger.log(\"internal\", LOG_ID + \"(inviteContactToBubble) arguments : \", ...arguments);\r\n            if (!contact) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bad or empty 'contact' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactToBubble) bad or empty 'contact' parameter : \", contact);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactToBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            let isActive = false;\r\n            let isInvited = false;\r\n            bubble.users.forEach(function (user) {\r\n                if (user.userId === contact.id) {\r\n                    switch (user.status) {\r\n                        case \"invited\":\r\n                            isInvited = true;\r\n                            break;\r\n                        case \"accepted\":\r\n                            isActive = true;\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            });\r\n            if (isActive || isInvited) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) Contact has been already invited or is already a member of the bubble\");\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that.removeContactFromBubble(contact, bubble).then((bubbleUpdated) => {\r\n                return that._rest.inviteContactToBubble(contact.id, bubbleUpdated.id, isModerator, withInvitation, reason);\r\n            }).then(function () {\r\n                that._logger.log(\"info\", LOG_ID + \"(inviteContactToBubble) invitation successfully sent\");\r\n                return that._rest.getBubble(bubble.id);\r\n            }).then((bubbleReUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\r\n                /*\r\n                // Update the existing local bubble stored\r\n                let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleReUpdated.id);\r\n                if ( foundIndex > -1) {\r\n                    bubbleReUpdated = Object.assign(that._bubbles[foundIndex], bubbleReUpdated);\r\n                    that._bubbles[foundIndex] = bubbleReUpdated;\r\n                } else {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(inviteContactToBubble) bubble with id:\" + bubbleReUpdated.id + \" is no more available\");\r\n                }\r\n                 */\r\n                resolve(bubble);\r\n            })).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(inviteContactToBubble) error\");\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method inviteContactsByEmailsToBubble\r\n     * @instance\r\n     * @param {Contact} contactsEmails         The contacts email tab to invite\r\n     * @param {Bubble} bubble           The bubble\r\n     * @description\r\n     *  Invite a list of contacts by emails in a bubble\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated with the new invitation\r\n     * @category async\r\n     */\r\n    inviteContactsByEmailsToBubble(contactsEmails, bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._logger.log(\"internal\", LOG_ID + \"(inviteContactsByEmailToBubble) arguments : \", ...arguments);\r\n            if (!contactsEmails || !Array.isArray(contactsEmails)) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'contact' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'contact' parameter : \", contactsEmails);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(inviteContactsByEmailToBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            return that._rest.inviteContactsByEmailsToBubble(contactsEmails, bubble.id).then(function () {\r\n                that._logger.log(\"info\", LOG_ID + \"(inviteContactsByEmailsToBubble) invitation successfully sent\");\r\n                return that._rest.getBubble(bubble.id);\r\n            }).then((bubbleReUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\r\n                resolve(bubble);\r\n            })).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(inviteContactsByEmailsToBubble) error\");\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    // @private for ale rainbow team's tests only\r\n    joinConference(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            return __awaiter(this, arguments, void 0, function* () {\r\n                that._logger.log(\"internal\", LOG_ID + \"(joinConference) arguments : \", ...arguments);\r\n                if (!bubble || !bubble.id) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(joinConference) bad or empty 'bubble' parameter\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(joinConference) bad or empty 'bubble' parameter : \", bubble);\r\n                    reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                    return;\r\n                }\r\n                /*let isActive = false;\r\n                let isInvited = false;\r\n                bubble.users.forEach(function(user) {\r\n                    if (user.userId === contact.id) {\r\n                        switch (user.status) {\r\n                            case \"invited\":\r\n                                isInvited = true;\r\n                                break;\r\n                            case \"accepted\":\r\n                                isActive = true;\r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }\r\n                });\r\n    getAllActiveBubbles\r\n                if (isActive || isInvited) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(joinConference) Contact has been already invited or is already a member of the bubble\");\r\n                    reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n                    return;\r\n                } // */\r\n                if (!bubble || !bubble.confEndpoints) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(joinConference) bad or empty 'bubble.confEndpoints' parameter\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(joinConference) bad or empty 'bubble.confEndpoints' parameter : \", bubble);\r\n                    reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                    return;\r\n                }\r\n                let mediaType = bubble.mediaType;\r\n                if (!that._profileService.isFeatureEnabled(that._profileService.getFeaturesEnum().WEBRTC_CONFERENCE_ALLOWED) && mediaType !== that._rest.MEDIATYPE.WEBRTCSHARINGONLY) {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(WebConferenceService) retrieveWebConferences - user is not allowed\");\r\n                    reject(new Error(\"notAllowed\"));\r\n                    return;\r\n                }\r\n                let endpoint = yield that._rest.retrieveWebConferences(mediaType);\r\n                let confEndPoints = null;\r\n                confEndPoints = endpoint;\r\n                let confEndPointId = null;\r\n                if (confEndPoints.length === 1 && confEndPoints[0].mediaType === that._rest.MEDIATYPE.WEBRTC) {\r\n                    confEndPointId = confEndPoints[0].id;\r\n                }\r\n                that._rest.joinConference(confEndPointId, \"moderator\").then(function (joinResult) {\r\n                    resolve(joinResult);\r\n                }).catch(function (err) {\r\n                    that._logger.log(\"error\", LOG_ID + \"(joinConference) error\");\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method promoteContactInBubble\r\n     * @instance\r\n     * @param {Contact} contact         The contact to promote or downgraded\r\n     * @param {Bubble} bubble           The bubble\r\n     * @param {boolean} isModerator     True to promote a contact as a moderator of the bubble, and false to downgrade\r\n     * @description\r\n     *  Promote or not a contact in a bubble\r\n     *  The logged in user can't update himself. As a result, a 'moderator' can't be downgraded to 'user'.\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated with the modifications\r\n     * @category async\r\n     */\r\n    promoteContactInBubble(contact, bubble, isModerator) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (!contact) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bad or empty 'contact' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) bad or empty 'contact' parameter : \", contact);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            let isActive = false;\r\n            let isInvited = false;\r\n            bubble.users.forEach(function (user) {\r\n                if (user.userId === contact.id) {\r\n                    switch (user.status) {\r\n                        case \"invited\":\r\n                            isInvited = true;\r\n                            break;\r\n                        case \"accepted\":\r\n                            isActive = true;\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            });\r\n            if (!isActive && !isInvited) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) Contact is not invited or is not already a member of the bubble\");\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.promoteContactInBubble(contact.id, bubble.id, isModerator)\r\n                .then(function () {\r\n                that._logger.log(\"info\", LOG_ID + \"(promoteContactInBubble) user privilege successfully sent\");\r\n                return that._rest.getBubble(bubble.id);\r\n            }).then((bubbleReUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                // Update the existing local bubble stored\r\n                let bubble = yield that.addOrUpdateBubbleToCache(bubbleReUpdated);\r\n                /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleReUpdated.id);\r\n                if ( foundIndex > -1) {\r\n                    bubbleReUpdated = Object.assign(that._bubbles[foundIndex], bubbleReUpdated);\r\n                    that._bubbles[foundIndex] = bubbleReUpdated;\r\n                } else {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(promoteContactInBubble) bubble with id:\" + bubbleReUpdated.id + \" is no more available\");\r\n                }\r\n                 */\r\n                resolve(bubble);\r\n            })).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(promoteContactInBubble) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactInBubble) error : \", err);\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method promoteContactToModerator\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Promote a contact to moderator in a bubble <br/>\r\n     *    Return a promise.\r\n     * @param {Contact} contact The contact to promote\r\n     * @param {Bubble} bubble   The destination bubble\r\n     * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result\r\n     */\r\n    promoteContactToModerator(contact, bubble) {\r\n        let that = this;\r\n        if (!contact) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(promoteContactToModerator) bad or empty 'contact' parameter\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactToModerator) bad or empty 'contact' parameter : \", contact);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        else if (!bubble) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(promoteContactToModerator) bad or empty 'bubble' parameter\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(promoteContactToModerator) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return this.promoteContactInBubble(contact, bubble, true);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method demoteContactFromModerator\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Demote a contact to user in a bubble <br/>\r\n     *    Return a promise.\r\n     * @param {Contact} contact The contact to promote\r\n     * @param {Bubble} bubble   The destination bubble\r\n     * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result\r\n     */\r\n    demoteContactFromModerator(contact, bubble) {\r\n        let that = this;\r\n        if (!contact) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'contact' parameter\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'contact' parameter : \", contact);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        else if (!bubble) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'bubble' parameter\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(demoteContactFromModerator) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return this.promoteContactInBubble(contact, bubble, false);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method changeBubbleOwner\r\n     * @instance\r\n     * @param {Contact} contact         The contact to set a new bubble owner\r\n     * @param {Bubble} bubble           The bubble\r\n     * @description\r\n     *  Set a moderator contact as owner of a bubble\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated with the modifications\r\n     * @category async\r\n     */\r\n    changeBubbleOwner(bubble, contact) {\r\n        let that = this;\r\n        if (!contact) {\r\n            that._logger.log(\"warn\", LOG_ID + \"(changeBubbleOwner) bad or empty 'contact' parameter \");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) bad or empty 'contact' parameter : \", contact);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        else if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(changeBubbleOwner) bad or empty 'bubble' parameter \");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.changeBubbleOwner(bubble.id, contact.id).then((bubbleData) => __awaiter(this, void 0, void 0, function* () {\r\n                bubbleData = yield that.addOrUpdateBubbleToCache(bubbleData);\r\n                that._logger.log(\"info\", LOG_ID + \"(changeBubbleOwner) owner setted : \", bubbleData.owner);\r\n                bubble.owner = bubbleData.owner;\r\n                resolve(bubbleData);\r\n            })).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(changeBubbleOwner) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(changeBubbleOwner) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n    * @public\r\n    * @method removeContactFromBubble\r\n    * @instance\r\n    * @param {Contact} contact The contact to remove\r\n    * @param {Bubble} bubble   The destination bubble\r\n    * @description\r\n    *    Remove a contact from a bubble\r\n    * @async\r\n    * @return {Promise<Bubble, ErrorManager>}\r\n    * @fulfil {Bubble} - The bubble object or an error object depending on the result\r\n    * @category async\r\n    */\r\n    removeContactFromBubble(contact, bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (!contact) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bad or empty 'contact' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) bad or empty 'contact' parameter : \", contact);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            else if (!bubble) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bad or empty 'bubble' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            let contactStatus = \"\";\r\n            bubble.users.forEach(function (user) {\r\n                if (user.userId === contact.id) {\r\n                    contactStatus = user.status;\r\n                }\r\n            });\r\n            that._logger.log(\"info\", LOG_ID + \"(removeContactFromBubble) remove contact with status\", contactStatus);\r\n            switch (contactStatus) {\r\n                case \"rejected\":\r\n                case \"invited\":\r\n                case \"unsubscribed\":\r\n                    that._rest.removeInvitationOfContactToBubble(contact.id, bubble.id).then(function () {\r\n                        that._logger.log(\"info\", LOG_ID + \"(removeContactFromBubble) removed successfully\");\r\n                        that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                            // Update the existing local bubble stored\r\n                            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                            /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                            if ( foundIndex > -1) {\r\n                                bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                                that._bubbles[foundIndex] = bubbleUpdated;\r\n                            } else {\r\n                                that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n                            }\r\n                             */\r\n                            resolve(bubble);\r\n                        }));\r\n                    }).catch(function (err) {\r\n                        that._logger.log(\"error\", LOG_ID + \"(removeContactFromBubble) error\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) error : \", err);\r\n                        return reject(err);\r\n                    });\r\n                    break;\r\n                case \"accepted\":\r\n                    that._rest.unsubscribeContactFromBubble(contact.id, bubble.id).then(function () {\r\n                        that._logger.log(\"debug\", LOG_ID + \"(removeContactFromBubble) removed successfully\");\r\n                        that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                            // Update the existing local bubble stored\r\n                            let bubbleProm = that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                            let bubble = yield bubbleProm;\r\n                            /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                            if ( foundIndex > -1) {\r\n                                bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                                that._bubbles[foundIndex] = bubbleUpdated;\r\n                            } else {\r\n                                that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n                            }\r\n                             */\r\n                            // We send the result here, because sometimes the xmpp server does not send us the resulting event.\r\n                            // So this event change will be sent twice time.\r\n                            that._eventEmitter.emit(\"evt_internal_affiliationdetailschanged\", bubble);\r\n                            resolve(bubble);\r\n                        }));\r\n                    }).catch(function (err) {\r\n                        that._logger.log(\"error\", LOG_ID + \"(removeContactFromBubble) error\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"(removeContactFromBubble) error : \", err);\r\n                        return reject(err);\r\n                    });\r\n                    break;\r\n                default:\r\n                    that._logger.log(\"warn\", LOG_ID + \"(removeContactFromBubble) contact not found in that bubble\");\r\n                    resolve(bubble);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @description\r\n     *      Internal method\r\n     */\r\n    getBubbles() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._rest.getBubbles().then(function (listOfBubbles = []) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbles)  listOfBubbles.length : \", listOfBubbles.length);\r\n                //that._bubbles = listOfBubbles.map( (bubble) => Object.assign( new Bubble(), bubble));\r\n                that._bubbles = [];\r\n                listOfBubbles.map((bubble) => __awaiter(this, void 0, void 0, function* () {\r\n                    yield that.addOrUpdateBubbleToCache(bubble);\r\n                }));\r\n                that._logger.log(\"info\", LOG_ID + \"(getBubbles) get successfully\");\r\n                let prom = [];\r\n                listOfBubbles.forEach(function (bubble) {\r\n                    let users = bubble.users;\r\n                    users.forEach(function (user) {\r\n                        if (user.userId === that._rest.userId && user.status === \"accepted\") {\r\n                            if (bubble.isActive) {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(getBubbles) send initial presence to room : \", bubble.jid);\r\n                                prom.push(that._presence.sendInitialBubblePresence(bubble));\r\n                            }\r\n                            else {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(getBubbles) bubble not active, so do not send initial presence to room : \", bubble.jid);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n                Promise.all(prom).then(() => {\r\n                    resolve();\r\n                }).catch(function (err) {\r\n                    that._logger.log(\"error\", LOG_ID + \"(getBubbles) error\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(getBubbles) error : \", err);\r\n                    return reject(err);\r\n                }); // */\r\n            }).catch(function (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(getBubbles) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getBubbles) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAll\r\n     * @instance\r\n     * @return {Bubble[]} The list of existing bubbles\r\n     * @description\r\n     *  Return the list of existing bubbles\r\n     */\r\n    getAll() {\r\n        return this._bubbles;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllBubbles\r\n     * @instance\r\n     * @return {Bubble[]} The list of existing bubbles\r\n     * @description\r\n     *  Return the list of existing bubbles\r\n     */\r\n    getAllBubbles() {\r\n        return this.getAll();\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllOwnedBubbles\r\n     * @instance\r\n     * @description\r\n     *    Get the list of bubbles created by the user <br/>\r\n     * @return {Bubble[]} An array of bubbles restricted to the ones owned by the user\r\n     */\r\n    getAllOwnedBubbles() {\r\n        let that = this;\r\n        //        return new Promise(function (resolve, reject) {\r\n        that._logger.log(\"debug\", LOG_ID + \"(getAllOwnedBubbles) \");\r\n        //resolve(that._bubbles.filter(function (room) {\r\n        return (that._bubbles.filter(function (room) {\r\n            return (room.creator === that._rest.userId);\r\n        }));\r\n        //      });\r\n    }\r\n    getBubbleFromCache(bubbleId) {\r\n        let bubbleFound = null;\r\n        this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) search id : \", bubbleId);\r\n        if (this._bubbles) {\r\n            let channelFoundindex = this._bubbles.findIndex((channel) => {\r\n                return channel.id === bubbleId;\r\n            });\r\n            if (channelFoundindex != -1) {\r\n                this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) bubble found : \", this._bubbles[channelFoundindex], \" with id : \", bubbleId);\r\n                return this._bubbles[channelFoundindex];\r\n            }\r\n        }\r\n        this._logger.log(\"internal\", LOG_ID + \"(getBubbleFromCache) channel found : \", bubbleFound, \" with id : \", bubbleId);\r\n        return bubbleFound;\r\n    }\r\n    addOrUpdateBubbleToCache(bubble) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            let bubbleObj = yield Bubble_1.Bubble.BubbleFactory(that.avatarDomain, that._contacts)(bubble);\r\n            let bubbleFoundindex = this._bubbles.findIndex((channelIter) => {\r\n                return channelIter.id === bubble.id;\r\n            });\r\n            if (bubbleFoundindex != -1) {\r\n                this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) update in cache with bubble : \", bubble, \", at bubbleFoundindex : \", bubbleFoundindex);\r\n                //this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) update in cache with bubble : \", bubble, \", at bubbleFoundindex : \", bubbleFoundindex);\r\n                this._bubbles[bubbleFoundindex].updateBubble(bubble, that._contacts);\r\n                //this._bubbles.splice(bubbleFoundindex,1,bubbleObj);\r\n                this.refreshMemberAndOrganizerLists(this._bubbles[bubbleFoundindex]);\r\n                //this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) in update this._bubbles : \", this._bubbles);\r\n                bubbleObj = this._bubbles[bubbleFoundindex];\r\n            }\r\n            else {\r\n                this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateBubbleToCache) add in cache bubbleObj : \", bubbleObj);\r\n                this.refreshMemberAndOrganizerLists(bubbleObj);\r\n                this._bubbles.push(bubbleObj);\r\n            }\r\n            //this.updateChannelsList();\r\n            return bubbleObj;\r\n        });\r\n    }\r\n    removeBubbleFromCache(bubbleId) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Get the channel to remove\r\n            let bubbleToRemove = this.getBubbleFromCache(bubbleId);\r\n            if (bubbleToRemove) {\r\n                // Remove from channels\r\n                let bubbleIdToRemove = bubbleToRemove.id;\r\n                that._logger.log(\"internal\", LOG_ID + \"(removeBubbleFromCache) remove from cache bubbleId : \", bubbleIdToRemove);\r\n                that._bubbles = this._bubbles.filter(function (chnl) {\r\n                    return !(chnl.id === bubbleIdToRemove);\r\n                });\r\n                resolve(bubbleToRemove);\r\n            }\r\n            else {\r\n                resolve(null);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @method getAvatarFromBubble\r\n     * @public\r\n     * @instance\r\n     * @param {Bubble} bubble   The destination bubble\r\n     * @async\r\n     * @return {Promise<{}>}  return a promise with {Object} A Blob object with data about the avatar picture.\r\n     * @description\r\n     *  Get A Blob object with data about the avatar picture of the bubble.\r\n     */\r\n    getAvatarFromBubble(bubble) {\r\n        /*\r\n        Nom : 5da72aa7e6ca5a023da44eff\r\n        Dimensions : 512  512\r\n        Type MIME : image/jpeg\r\n         */\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubble : \", bubble);\r\n            if (!bubble) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty 'bubble' parameter.\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(getAvatarFromBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            if (!bubble.avatar) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty avatar of 'bubble' parameter.\");\r\n                that._logger.log(\"debug\", LOG_ID + \"(getAvatarFromBubble) bad or empty avatar of 'bubble' parameter : \", bubble);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            return that._rest.getBlobFromUrl(bubble.avatar).then((avatarBuffer) => {\r\n                that._logger.log(\"internal\", LOG_ID + \"(getAvatarFromBubble) bubble from server : \", avatarBuffer);\r\n                let blob = { buffer: avatarBuffer,\r\n                    type: \"image/jpeg\",\r\n                    fileSize: avatarBuffer.length,\r\n                    fileName: bubble.id\r\n                }; // */\r\n                /*let blob = new Blob([response.data],\r\n                    { type: mime }); // */\r\n                that._logger.log(\"debug\", LOG_ID + \"getAvatarFromBubble success\");\r\n                resolve(blob);\r\n            }).catch((err) => {\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method refreshMemberAndOrganizerLists\r\n     * @instance\r\n     * @param {Bubble} bubble the bubble to refresh\r\n     * @async\r\n     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n     * @description\r\n     *  Refresh members and organizers of the bubble.\r\n     */\r\n    refreshMemberAndOrganizerLists(bubble) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            that._logger.log(\"debug\", LOG_ID + \"(refreshMemberAndOrganizerLists) bad or empty 'bubble' parameter.\");\r\n            that._logger.log(\"internal\", LOG_ID + \"(refreshMemberAndOrganizerLists) bad or empty 'bubble' parameter : \", bubble);\r\n            return ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\r\n        }\r\n        //Clear both lists :\r\n        bubble.organizers = [];\r\n        bubble.members = [];\r\n        bubble.users.forEach(function (user) {\r\n            if (user.status === Bubble_1.Bubble.RoomUserStatus.ACCEPTED || user.status === Bubble_1.Bubble.RoomUserStatus.INVITED || user.jid_im === bubble.ownerContact.jid) {\r\n                if (user.privilege === Bubble_1.Bubble.Privilege.MODERATOR) {\r\n                    bubble.organizers.push(user);\r\n                }\r\n                else {\r\n                    bubble.members.push(user);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method getBubbleById\r\n     * @instance\r\n     * @param {string} id the id of the bubble\r\n     * @async\r\n     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n     * @description\r\n     *  Get a bubble by its ID in memory and if it is not found in server.\r\n     */\r\n    getBubbleById(id) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble id  \" + id);\r\n            if (!id) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bad or empty 'id' parameter\", id);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            let bubbleFound = that._bubbles.find((bubble) => {\r\n                return (bubble.id === id);\r\n            });\r\n            if (bubbleFound) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubbleFound in memory : \", bubbleFound.jid);\r\n            }\r\n            else {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble not found in memory, search in server id : \", id);\r\n                return that._rest.getBubble(id).then((bubbleFromServer) => __awaiter(this, void 0, void 0, function* () {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubble from server : \", bubbleFromServer);\r\n                    if (bubbleFromServer) {\r\n                        let bubble = yield that.addOrUpdateBubbleToCache(bubbleFromServer);\r\n                        //let bubble = Object.assign(new Bubble(), bubbleFromServer);\r\n                        //that._bubbles.push(bubble);\r\n                        if (bubble.isActive) {\r\n                            that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) send initial presence to room : \", bubble.jid);\r\n                            yield that._presence.sendInitialBubblePresence(bubble);\r\n                        }\r\n                        else {\r\n                            that._logger.log(\"debug\", LOG_ID + \"(getBubbleById) bubble not active, so do not send initial presence to room : \", bubble.jid);\r\n                        }\r\n                        resolve(bubble);\r\n                    }\r\n                    else {\r\n                        resolve(null);\r\n                    }\r\n                })).catch((err) => {\r\n                    return reject(err);\r\n                });\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(getBubbleById) bubbleFound in memory : \", bubbleFound);\r\n            resolve(bubbleFound);\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getBubbleByJid\r\n     * @instance\r\n     * @param {string} jid the JID of the bubble\r\n     * @async\r\n     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null\r\n     * @description\r\n     *  Get a bubble by its JID in memory and if it is not found in server.\r\n     */\r\n    getBubbleByJid(jid) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bubble jid  \", jid);\r\n                if (!jid) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bad or empty 'jid' parameter\", jid);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                }\r\n                let bubbleFound = that._bubbles.find((bubble) => {\r\n                    return (bubble.jid === jid);\r\n                });\r\n                if (bubbleFound) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJId) bubbleFound in memory : \", bubbleFound.jid);\r\n                }\r\n                else {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJId) bubble not found in memory, search in server jid : \", jid);\r\n                    return that._rest.getBubbleByJid(jid).then((bubbleFromServer) => __awaiter(this, void 0, void 0, function* () {\r\n                        that._logger.log(\"internal\", LOG_ID + \"(getBubbleByJId) bubble from server : \", bubbleFromServer);\r\n                        if (bubbleFromServer) {\r\n                            let bubble = yield that.addOrUpdateBubbleToCache(bubbleFromServer);\r\n                            //let bubble = Object.assign(new Bubble(), bubbleFromServer);\r\n                            //that._bubbles.push(bubble);\r\n                            if (bubble.isActive) {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) send initial presence to room : \", bubble.jid);\r\n                                yield that._presence.sendInitialBubblePresence(bubble);\r\n                            }\r\n                            else {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(getBubbleByJid) bubble not active, so do not send initial presence to room : \", bubble.jid);\r\n                            }\r\n                            resolve(bubble);\r\n                        }\r\n                        else {\r\n                            resolve(null);\r\n                        }\r\n                    })).catch((err) => {\r\n                        return reject(err);\r\n                    });\r\n                }\r\n                resolve(bubbleFound);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllPendingBubbles\r\n     * @instance\r\n     * @return {Bubble[]} An array of Bubbles not accepted or declined\r\n     * @description\r\n     *  Get the list of Bubbles that have a pending invitation not yet accepted of declined\r\n     */\r\n    getAllPendingBubbles() {\r\n        let that = this;\r\n        let pendingBubbles = this._bubbles.filter((bubble) => {\r\n            let invitation = bubble.users.filter((user) => {\r\n                return (user.userId === that._rest.userId && user.status === \"invited\");\r\n            });\r\n            return invitation.length > 0;\r\n        });\r\n        return pendingBubbles;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllActiveBubbles\r\n     * @since 1.30\r\n     * @instance\r\n     * @return {Bubble[]} An array of Bubbles that are \"active\" for the connected user\r\n     * @description\r\n     *  Get the list of Bubbles where the connected user can chat\r\n     */\r\n    getAllActiveBubbles() {\r\n        let that = this;\r\n        let activeBubbles = this._bubbles.filter((bubble) => {\r\n            let amIActive = bubble.users.find((user) => {\r\n                return (user.userId === that._rest.userId && user.status === \"accepted\");\r\n            });\r\n            return amIActive;\r\n        });\r\n        return activeBubbles;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllClosedBubbles\r\n     * @since 1.30\r\n     * @instance\r\n     * @return {Bubble[]} An array of Bubbles that are closed for the connected user\r\n     * @description\r\n     *  Get the list of Bubbles where the connected user can only read messages\r\n     */\r\n    getAllClosedBubbles() {\r\n        let that = this;\r\n        let closedBubbles = this._bubbles.filter((bubble) => {\r\n            let amIAway = bubble.users.find((user) => {\r\n                return (user.userId === that._rest.userId && user.status === \"unsubscribed\");\r\n            });\r\n            return amIAway;\r\n        });\r\n        return closedBubbles;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method acceptInvitationToJoinBubble\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble to join\r\n     * @description\r\n     *  Accept an invitation to join a bubble\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated or an error object depending on the result\r\n     * @category async\r\n     */\r\n    acceptInvitationToJoinBubble(bubble) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(acceptInvitationToJoinBubble) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(acceptInvitationToJoinBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.acceptInvitationToJoinBubble(bubble.id).then((invitationStatus) => {\r\n                that._logger.log(\"info\", LOG_ID + \"(acceptInvitationToJoinBubble) invitation accepted\", invitationStatus);\r\n                that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                    // Update the existing local bubble stored\r\n                    let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                    /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                    if ( foundIndex > -1) {\r\n                        bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                        that._bubbles[foundIndex] = bubbleUpdated;\r\n                    } else {\r\n                        that._logger.log(\"warn\", LOG_ID + \"(acceptInvitationToJoinBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n                    }\r\n                     */\r\n                    resolve(bubble);\r\n                }));\r\n            }).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(acceptInvitationToJoinBubble) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(acceptInvitationToJoinBubble) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method declineInvitationToJoinBubble\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble to decline\r\n     * @description\r\n     *  Decline an invitation to join a bubble\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated or an error object depending on the result\r\n     * @category async\r\n     */\r\n    declineInvitationToJoinBubble(bubble) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(declineInvitationToJoinBubble) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(declineInvitationToJoinBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.declineInvitationToJoinBubble(bubble.id).then((invitationStatus) => {\r\n                that._logger.log(\"info\", LOG_ID + \"(declineInvitationToJoinBubble) invitation declined : \", invitationStatus);\r\n                that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                    // Update the existing local bubble stored\r\n                    let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                    /*let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                    if ( foundIndex > -1) {\r\n                        bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                        that._bubbles[foundIndex] = bubbleUpdated;\r\n                    } else {\r\n                        that._logger.log(\"warn\", LOG_ID + \"(declineInvitationToJoinBubble) bubble with id:\" + bubbleUpdated.id + \" is no more available\");\r\n                    }\r\n                     */\r\n                    resolve(bubble);\r\n                }));\r\n            }).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(declineInvitationToJoinBubble) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(declineInvitationToJoinBubble) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method setBubbleCustomData\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble\r\n     * @param {Object} customData Bubble's custom data area. key/value format. Maximum and size are server dependent\r\n     * @description\r\n     *  Modify all custom data at once in a bubble\r\n     *  To erase all custom data, put {} in customData\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The bubble updated with the custom data set or an error object depending on the result\r\n     * @category async\r\n     */\r\n    setBubbleCustomData(bubble, customData) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setBubbleCustomData) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleCustomData) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        let bubbleId = bubble.id;\r\n        let custom = { \"customData\": customData || {} };\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.setBubbleCustomData(bubbleId, custom).then((json) => __awaiter(this, void 0, void 0, function* () {\r\n                that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) customData set\", json.customData);\r\n                bubble.customData = json.customData || {};\r\n                try {\r\n                    yield Utils_1.until(() => {\r\n                        let bubbleInMemory = that._bubbles.find((bubbleIter) => { return bubbleIter.id === bubbleId; });\r\n                        if (bubbleInMemory) {\r\n                            that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) bubbleInMemory : \", bubbleInMemory, \", \\nbubble : \", bubble);\r\n                            return deepEqual(bubbleInMemory.customData, bubble.customData);\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }, \"wait in setBubbleCustomData for the customData to be updated by the event rainbow_onbubblecustomdatachanged\", 8000);\r\n                    this._logger.log(\"debug\", LOG_ID + \"(setBubbleCustomData) customData updated in bubble stored in BubblesService.\");\r\n                }\r\n                catch (err) {\r\n                    this._logger.log(\"debug\", LOG_ID + \"(setBubbleCustomData) customData not updated in bubble stored in BubblesService. Get infos about bubble from server.\");\r\n                    this._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) customData not updated in bubble stored in BubblesService. Get infos about bubble from server.\", err);\r\n                    that._rest.getBubble(bubble.id).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                        that._logger.log(\"internal\", LOG_ID + \"(setBubbleCustomData) Custom data in bubble retrieved from server : \", bubbleUpdated.name + \" | \" + bubbleUpdated.customData);\r\n                        let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                        /*// Update the existing local bubble stored\r\n                        let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                        if (foundIndex > -1) {\r\n                            bubbleUpdated = Object.assign(that._bubbles[foundIndex], bubbleUpdated);\r\n                            that._bubbles[foundIndex] = bubbleUpdated;\r\n                        } else {\r\n                            bubbleUpdated = Object.assign(new Bubble(), bubbleUpdated);\r\n                            that._bubbles.push(bubbleUpdated);\r\n                        } // */\r\n                        that._eventEmitter.emit(\"evt_internal_bubblecustomDatachanged\", bubble);\r\n                    }));\r\n                }\r\n                resolve(bubble);\r\n            })).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(setBubbleCustomData) error\", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method setBubbleVisibilityStatus\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble\r\n     * @param {string} status Bubble's public/private group visibility for search.  Either \"private\" (default) or \"public\"\r\n     * @description\r\n     *  Set the Bubble's visibility status\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n     * @category async\r\n     */\r\n    setBubbleVisibilityStatus(bubble, status) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setBubbleVisibilityStatus) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleVisibilityStatus) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.setBubbleVisibility(bubble.id, status).then((bubbleData) => {\r\n                that._logger.log(\"info\", LOG_ID + \"(setBubbleVisibilityStatus) visibility set \");\r\n                that._logger.log(\"internal\", LOG_ID + \"(setBubbleVisibilityStatus) visibility set : \", bubbleData);\r\n                resolve(bubbleData);\r\n            }).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(setBubbleVisibilityStatus) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleVisibilityStatus) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method setBubbleTopic\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble\r\n     * @param {string} topic Bubble's topic\r\n     * @description\r\n     *  Set the Bubble's topic\r\n     * @memberof Bubbles\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n     * @category async\r\n     */\r\n    setBubbleTopic(bubble, topic) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setBubbleTopic) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleTopic) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.setBubbleTopic(bubble.id, topic).then((bubbleData) => {\r\n                that._logger.log(\"internal\", LOG_ID + \"(setBubbleTopic) topic set\", bubbleData.topic);\r\n                bubble.topic = bubbleData.topic;\r\n                resolve(bubble);\r\n            }).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(setBubbleTopic) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleTopic) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method setBubbleName\r\n     * @instance\r\n     * @param {Bubble} bubble The Bubble\r\n     * @param {string} topic Bubble's name\r\n     * @description\r\n     *  Set the Bubble's name\r\n     * @async\r\n     * @return {Promise<Bubble, ErrorManager>}\r\n     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result\r\n     * @category async\r\n     */\r\n    setBubbleName(bubble, name) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setBubbleName) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setBubbleName) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.setBubbleName(bubble.id, name).then((bubbleData) => {\r\n                that._logger.log(\"debug\", LOG_ID + \"(setBubbleName) name set : \", bubbleData.name);\r\n                bubble.name = bubbleData.name;\r\n                resolve(bubble);\r\n            }).catch((err) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(setBubbleName) error\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(setBubbleName) error : \", err);\r\n                return reject(err);\r\n            });\r\n        });\r\n    }\r\n    randomString(length = 10) {\r\n        let string = \"\";\r\n        let rnd;\r\n        const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\r\n        while (length > 0) {\r\n            rnd = Math.floor(Math.random() * chars.length);\r\n            string += chars.charAt(rnd);\r\n            length--;\r\n        }\r\n        return string;\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method updateAvatarForBubble\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Update the bubble avatar (from given URL) <br/>\r\n     *    The image will be automaticalle resized <br/>\r\n     *    /!\\ if URL isn't valid or given image isn't loadable, it'll fail <br/>\r\n     *    Return a promise.\r\n     * @param {string} urlAvatar  The avatarUrl\r\n     * @param {Bubble} bubble  The bubble to update\r\n     * @return {Bubble} A bubble object of null if not found\r\n     */\r\n    updateAvatarForBubble(urlAvatar, bubble) {\r\n        return this.setAvatarBubble(bubble, urlAvatar);\r\n    }\r\n    /**\r\n     * @private\r\n     * @method setAvatarBubble\r\n     * @param bubble\r\n     * @param roomAvatarPath\r\n     */\r\n    setAvatarBubble(bubble, roomAvatarPath) {\r\n        let that = this;\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        if (!roomAvatarPath) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'roomAvatarPath' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'roomAvatarPath' parameter : \", roomAvatarPath);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            Utils_1.resizeImage(roomAvatarPath, 512, 512).then(function (resizedImage) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(setAvatarBubble) resizedImage : \", resizedImage);\r\n                let binaryData = Utils_1.getBinaryData(resizedImage);\r\n                that._rest.setAvatarRoom(bubble.id, binaryData).then(function success(result) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(setAvatarBubble) setAvatarRoom success : \" + result);\r\n                    /*\r\n                    let url = that.avatarDomain;\r\n                    if ($rootScope.cdn) {\r\n                        url = $rootScope.cdnServer;\r\n                    }\r\n                    bubble.avatar = url + \"/api/room-avatar/\" + bubble.id + \"?size=512&rand=\" + that.randomString();\r\n                    // */\r\n                    resolve(bubble);\r\n                }, function failure(err) {\r\n                    that._logger.log(\"error\", LOG_ID + \"(setAvatarBubble) error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) error : \", err);\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method deleteAvatarFromBubble\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Delete the bubble avatar <br/>\r\n\r\n     *    Return a promise.\r\n     * @param {Bubble} bubble  The bubble to update\r\n     * @return {Bubble} A bubble object of null if not found\r\n     */\r\n    deleteAvatarFromBubble(bubble) {\r\n        if (!bubble) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return this.deleteAvatarBubble(bubble.id);\r\n    }\r\n    /**\r\n     * @private\r\n     * @method deleteAvatarBubble\r\n     * @param bubbleId\r\n     */\r\n    deleteAvatarBubble(bubbleId) {\r\n        let that = this;\r\n        if (!bubbleId) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubbleId);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.deleteAvatarRoom(bubbleId).then((res) => {\r\n                resolve(res);\r\n            }).catch((err) => {\r\n                return reject(err);\r\n            });\r\n        });\r\n        /* return $q(function(resolve, reject) {\r\n            $http({\r\n                method: \"DELETE\",\r\n                url: service.portalURL + \"rooms/\" + roomId + \"/avatar\",\r\n                headers: authService.getRequestHeader()\r\n            }).then(function success() {\r\n                $log.info(\"[roomService] avatar room sucessfully deleted\");\r\n                resolve();\r\n            }).catch(function(err) {\r\n                reject(err);\r\n            });\r\n        });\r\n        // */\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method updateCustomDataForBubble\r\n     * @since 1.64\r\n     * @instance\r\n     * @description\r\n     *    Update the customData of the bubble  <br/>\r\n     *    Return a promise.\r\n     * @param {Object} customData\r\n     *    The customData to put to the bubble <br />\r\n     *    Example: { \"key1\" : 123, \"key2\" : \"a string\" }\r\n     * @param {Bubble} bubble   The bubble to update\r\n     * @return {Promise<Bubble>} The updated Bubble\r\n     */\r\n    updateCustomDataForBubble(customData, bubble) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateCustomDataForBubble) customData : \", customData);\r\n            return yield this.setBubbleCustomData(bubble, customData).then((bubbleUpdated) => {\r\n                return bubbleUpdated;\r\n            });\r\n            /*\r\n            let that = this;\r\n             // update bubble with internal copy to avoid user/moderator/owner side effects\r\n             let bubblefound : any = bubble && bubble.id ? await that.getBubbleById(bubble.id) : null;\r\n     \r\n             if (!customData) {\r\n                 this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'customData' parameter\");\r\n                 this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'customData' parameter : \", customData);\r\n                 return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n             } else if (!bubblefound) {\r\n                 this._logger.log(\"warn\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter\");\r\n                 this._logger.log(\"internalerror\", LOG_ID + \"(setAvatarBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                 return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n             } else {\r\n                 return new Promise((resolve, reject) => {\r\n                     bubblefound.customData = customData;\r\n                     this._rest.ownerUpdateRoomCustomData(bubblefound).then(function (updatedCustomData) {\r\n                         bubblefound.customData = updatedCustomData;\r\n                             resolve(bubblefound);\r\n                         })\r\n                         .catch(function (err) {\r\n                             reject(err);\r\n                         });\r\n                 });\r\n             }\r\n             // */\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method deleteCustomDataForBubble\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Delete the customData of the bubble  <br/>\r\n     *    Return a promise.\r\n     * @param {Bubble} bubble   The bubble to update\r\n     * @return {Promise<Bubble>} The updated Bubble\r\n     */\r\n    deleteCustomDataForBubble(bubble) {\r\n        return this.updateCustomDataForBubble(\"\", bubble);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method updateDescriptionForBubble\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Update the description of the bubble  <br/>\r\n     *    Return a promise.\r\n     * @param {string} strDescription   The description of the bubble (is is the topic on server side, and result event)\r\n     * @param {Bubble} bubble   The bubble to update\r\n     * @return {Bubble} A bubble object of null if not found\r\n     */\r\n    updateDescriptionForBubble(bubble, strDescription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.setBubbleTopic(bubble, strDescription);\r\n            /*let that = this;\r\n            // update bubble with internal copy to avoid user/moderator/owner side effects\r\n            let bubblefound : any = bubble && bubble.id ? await that.getBubbleById(bubble.id) : null;\r\n    \r\n            if (!strDescription) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'strDescription' parameter\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'strDescription' parameter : \", strDescription);\r\n                return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n            } else if (!bubblefound) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'bubble' parameter\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateDescriptionForBubble) bad or empty 'bubble' parameter : \", bubble);\r\n                return Promise.reject(ErrorManager.getErrorManager().BAD_REQUEST);\r\n            } else {\r\n                return new Promise((resolve, reject) => {\r\n                    bubblefound.desc = strDescription;\r\n                    this._rest.ownerUpdateRoom(bubblefound).then(function (updatedCustomData) {\r\n                        resolve(updatedCustomData);\r\n                    }).catch(function (err) {\r\n                        reject(err);\r\n                    });\r\n                });\r\n            } // */\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onInvitationReceived\r\n     * @instance\r\n     * @param {Object} invitation contains informations about bubble and user's jid\r\n     * @description\r\n     *      Method called when receiving an invitation to join a bubble\r\n     */\r\n    _onInvitationReceived(invitation) {\r\n        let that = this;\r\n        that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) invitation : \", invitation);\r\n        this._rest.getBubble(invitation.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n            that._logger.log(\"debug\", LOG_ID + \"(_onInvitationReceived) invitation received from bubble.\");\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) invitation received from bubble : \", bubbleUpdated);\r\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n            /*// Store the new bubble\r\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n            if (foundIndex > -1) {\r\n                bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                that._bubbles[foundIndex] = bubbleUpdated;\r\n            }\r\n            else {\r\n                bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                that._bubbles.push(bubbleUpdated);\r\n            } // */\r\n            that._eventEmitter.emit(\"evt_internal_invitationdetailsreceived\", bubble);\r\n        })).catch((err) => {\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onInvitationReceived) get bubble failed for invitation : \", invitation);\r\n        });\r\n        ;\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onAffiliationChanged\r\n     * @instance\r\n     * @param {Object} affiliation contains information about bubble and user's jid\r\n     * @description\r\n     *      Method called when affilitation to a bubble changed\r\n     */\r\n    _onAffiliationChanged(affiliation) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) affiliation : \", affiliation);\r\n            yield this._rest.getBubble(affiliation.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                that._logger.log(\"debug\", LOG_ID + \"(_onAffiliationChanged) user affiliation changed for bubble.\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) user affiliation changed for bubble : \", bubbleUpdated, \", affiliation : \", affiliation);\r\n                let bubbleProm = that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                let bubble = yield bubbleProm;\r\n                /*// Update the existing local bubble stored\r\n                let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                if (foundIndex > -1) {\r\n                    bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                    that._bubbles[foundIndex] = bubbleUpdated;\r\n                }\r\n                else {\r\n                    bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                    that._bubbles.push(bubbleUpdated);\r\n                } // */\r\n                that._eventEmitter.emit(\"evt_internal_affiliationdetailschanged\", bubble);\r\n            })).catch((err) => {\r\n                that._logger.log(\"internal\", LOG_ID + \"(_onAffiliationChanged) get bubble failed for affiliation : \", affiliation);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onOwnAffiliationChanged\r\n     * @instance\r\n     * @param {Object} affiliation contains information about bubble and user's jid\r\n     * @description\r\n     *      Method called when the user affilitation to a bubble changed\r\n     */\r\n    _onOwnAffiliationChanged(affiliation) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) parameters : affiliation : \", affiliation);\r\n            if (affiliation.status !== \"deleted\") {\r\n                if (affiliation.status === \"available\") {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) available state received. Nothing to do.\");\r\n                }\r\n                else {\r\n                    yield this._rest.getBubble(affiliation.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                        that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) own affiliation changed for bubble : \", bubbleUpdated.name + \" | \" + affiliation.status);\r\n                        // Update the existing local bubble stored\r\n                        let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n                        if (foundIndex > -1) {\r\n                            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                            //bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                            //that._bubbles[foundIndex] = bubbleUpdated;\r\n                            if (affiliation.status === \"accepted\") {\r\n                                if (bubble.isActive) {\r\n                                    that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) send initial presence to room : \", bubble.jid);\r\n                                    that._presence.sendInitialBubblePresence(bubble);\r\n                                }\r\n                                else {\r\n                                    that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) bubble not active, so do not send initial presence to room : \", bubble.jid);\r\n                                }\r\n                            }\r\n                            else if (affiliation.status === \"unsubscribed\") {\r\n                                that._xmpp.sendUnavailableBubblePresence(bubble.jid);\r\n                            }\r\n                        }\r\n                        else {\r\n                            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                            /*bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                            that._bubbles.push(bubbleUpdated); // */\r\n                            // New bubble, send initial presence\r\n                            if (bubble.isActive) {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) send initial presence to room : \", bubble.jid);\r\n                                that._presence.sendInitialBubblePresence(bubble);\r\n                            }\r\n                            else {\r\n                                that._logger.log(\"debug\", LOG_ID + \"(_onOwnAffiliationChanged) bubble not active, so do not send initial presence to room : \", bubble.jid);\r\n                            }\r\n                        }\r\n                        that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubbleUpdated);\r\n                    }));\r\n                }\r\n            }\r\n            else {\r\n                // remove it\r\n                let bubbleToRemoved = that._bubbles.findIndex(function (el) {\r\n                    return el.id === affiliation.bubbleId;\r\n                });\r\n                //*/\r\n                if (bubbleToRemoved != -1) {\r\n                    let bubbleRemoved = yield that.removeBubbleFromCache(affiliation.bubbleId);\r\n                    that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubbleRemoved);\r\n                    that._eventEmitter.emit(\"evt_internal_bubbledeleted\", bubbleRemoved);\r\n                }\r\n                else {\r\n                    that._logger.log(\"warn\", LOG_ID + \"(_onOwnAffiliationChanged) deleted bubble not found in cache, so raised the deleted event with only the id of this bubble : \", affiliation.bubbleId);\r\n                    let bubble = { id: null };\r\n                    bubble.id = affiliation.bubbleId;\r\n                    that._eventEmitter.emit(\"evt_internal_ownaffiliationdetailschanged\", bubble);\r\n                    that._eventEmitter.emit(\"evt_internal_bubbledeleted\", bubble);\r\n                } // */\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onCustomDataChanged\r\n     * @instance\r\n     * @param {Object} data contains information about bubble and new custom data received\r\n     * @description\r\n     *      Method called when custom data have changed for a bubble\r\n     */\r\n    _onCustomDataChanged(data) {\r\n        let that = this;\r\n        this._rest.getBubble(data.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onCustomDataChanged) Custom data changed for bubble : \", bubbleUpdated.name + \" | \" + data.customData);\r\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n            /*// Update the existing local bubble stored\r\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n            if (foundIndex > -1) {\r\n                bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                that._bubbles[foundIndex] = bubbleUpdated;\r\n            }\r\n            else {\r\n                bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                that._bubbles.push(bubbleUpdated);\r\n            } // */\r\n            that._eventEmitter.emit(\"evt_internal_bubblecustomDatachanged\", bubble);\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onTopicChanged\r\n     * @instance\r\n     * @param {Object} data contains information about bubble new topic received\r\n     * @description\r\n     *      Method called when the topic has changed for a bubble\r\n     */\r\n    _onTopicChanged(data) {\r\n        let that = this;\r\n        this._rest.getBubble(data.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onTopicChanged) Topic changed for bubble : \", bubbleUpdated.name + \" | \" + data.topic);\r\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n            /*// Update the existing local bubble stored\r\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n            if (foundIndex > -1) {\r\n                bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                that._bubbles[foundIndex] = bubbleUpdated;\r\n            }\r\n            else {\r\n                bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                that._bubbles.push(bubbleUpdated);\r\n            } // */\r\n            that._eventEmitter.emit(\"evt_internal_bubbletopicchanged\", bubble);\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onPrivilegeBubbleChanged\r\n     * @instance\r\n     * @param {Object} bubbleInfo modified bubble info\r\n     * @description\r\n     *     Method called when the owner of a bubble changed.\r\n     */\r\n    _onPrivilegeBubbleChanged(bubbleInfo) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            /*\r\n            let that = this;\r\n            let ownerContact = await that.getContactById(bubbleInfo.creator, false);\r\n             */\r\n            let that = this;\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onPrivilegeBubbleChanged) privilege changed for bubbleInfo : \", bubbleInfo);\r\n            this._rest.getBubble(bubbleInfo.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n                that._logger.log(\"internal\", LOG_ID + \"(_onPrivilegeBubbleChanged) privilege changed for bubble : \", bubbleUpdated.name);\r\n                let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n                that._eventEmitter.emit(\"evt_internal_bubbleprivilegechanged\", { bubble, \"privilege\": bubbleInfo.privilege });\r\n            }));\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onNameChanged\r\n     * @instance\r\n     * @param {Object} data contains information about bubble new name received\r\n     * @description\r\n     *      Method called when the name has changed for a bubble\r\n     */\r\n    _onNameChanged(data) {\r\n        let that = this;\r\n        this._rest.getBubble(data.bubbleId).then((bubbleUpdated) => __awaiter(this, void 0, void 0, function* () {\r\n            that._logger.log(\"internal\", LOG_ID + \"(_onNameChanged) Name changed for bubble : \", bubbleUpdated.name + \" | \" + data.name);\r\n            let bubble = yield that.addOrUpdateBubbleToCache(bubbleUpdated);\r\n            /*// Update the existing local bubble stored\r\n            let foundIndex = that._bubbles.findIndex(bubbleItem => bubbleItem.id === bubbleUpdated.id);\r\n            if (foundIndex > -1) {\r\n                bubbleUpdated = Object.assign( that._bubbles[foundIndex], bubbleUpdated);\r\n                that._bubbles[foundIndex] = bubbleUpdated;\r\n            }\r\n            else {\r\n                bubbleUpdated = Object.assign( new Bubble(), bubbleUpdated);\r\n                that._bubbles.push(bubbleUpdated);\r\n            } // */\r\n            that._eventEmitter.emit(\"evt_internal_bubblenamechanged\", bubble);\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @method _onbubblepresencechanged\r\n     * @instance\r\n     * @param {Object} bubbleInfo contains information about bubble\r\n     * @description\r\n     *      Method called when the name has changed for a bubble\r\n     */\r\n    _onbubblepresencechanged(bubbleInfo) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._logger.log(\"debug\", LOG_ID + \"(_onbubblepresencechanged) bubble presence received for : \", bubbleInfo.jid);\r\n            //that._logger.log(\"internal\", LOG_ID + \"(_onbubblepresencechanged) bubble presence : \", bubbleInfo );\r\n            // Find the bubble in service list, and else retrieve it from server.\r\n            let bubbleInMemory;\r\n            bubbleInMemory = yield that.getBubbleByJid(bubbleInfo.jid);\r\n            // that._bubbles.find((bubbleIter) => { return bubbleIter.jid === bubbleInfo.jid ; });\r\n            if (bubbleInMemory) {\r\n                that._logger.log(\"internal\", LOG_ID + \"(_onbubblepresencechanged) bubble found in memory : \", bubbleInMemory.jid);\r\n                if (bubbleInfo.statusCode === \"resumed\") {\r\n                    that._presence.sendInitialBubblePresence(bubbleInfo).then(() => {\r\n                        bubbleInMemory.isActive = true;\r\n                        that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\r\n                    });\r\n                }\r\n                if (bubbleInfo.statusCode === \"deactivated\") {\r\n                    bubbleInMemory.isActive = false;\r\n                    that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\r\n                }\r\n            }\r\n            else {\r\n                that._logger.log(\"warn\", LOG_ID + \"(_onbubblepresencechanged) bubble not found !\");\r\n                //that._bubbles.push(Object.assign(new Bubble(), bubble));\r\n            }\r\n            // that._eventEmitter.emit(\"evt_internal_bubblepresencechanged\", bubbleInMemory);\r\n        });\r\n    }\r\n};\r\nBubbles = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n     * @module\r\n     * @name Bubbles\r\n     * @version 1.67.1 \r\n     * @public\r\n     * @description\r\n     *      This service manages multi-party communications (aka bubbles). Bubbles allow to chat and to share files with several participants.<br><br>\r\n     *      Each user can create bubbles and invite other users to be part of it.\r\n     *      <br><br>\r\n     *      The main methods proposed in that module allow to: <br>\r\n     *      - Create a new bubble <br>\r\n     *      - Invite users in a bubble or remove them <br>\r\n     *      - Manage a bubble: close, delete <br>\r\n     *      - Leave a bubble <br>\r\n     *      - Accept or decline an invitation to join a bubble <br>\r\n     *      - Change the custom data attached to a bubble\r\n     */\r\n], Bubbles);\r\nexports.BubblesService = Bubbles;\r\nmodule.exports.BubblesService = Bubbles;\r\n//# sourceMappingURL=BubblesService.js.map"]},"metadata":{},"sourceType":"script"}