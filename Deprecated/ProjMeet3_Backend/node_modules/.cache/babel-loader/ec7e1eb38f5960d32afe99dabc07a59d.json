{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Contact_1 = require(\"../common/models/Contact\");\n\nconst util = require(\"util\");\n\nconst md5 = require(\"md5\");\n\nconst path = require(\"path\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst LOG_ID = \"CONTACTS/SVCE - \";\nlet Contacts =\n/**\n * @module\n * @name Contacts\n * @version 1.67.1 \n * @public\n * @description\n *       This module manages _contacts. A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information.<br>\n *       Using this module, you can get access to your network _contacts or search for Rainbow _contacts.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Get the network _contacts (roster) <br>\n *      - Get and search _contacts by Id, JID or loginEmail <br>\n */\nclass Contacts {\n  constructor(_eventEmitter, _http, _logger, _startConfig) {\n    this.ready = false;\n    this._startConfig = _startConfig;\n    this.avatarDomain = _http.host.split(\".\").length === 2 ? _http.protocol + \"://cdn.\" + _http.host + \":\" + _http.port : _http.protocol + \"://\" + _http.host + \":\" + _http.port;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._contacts = [];\n    this._eventEmitter = _eventEmitter;\n    this._logger = _logger;\n    this._rosterPresenceQueue = [];\n    this.userContact = new Contact_1.Contact();\n    this.ready = false;\n\n    this._eventEmitter.on(\"evt_internal_onrosterpresence\", this._onRosterPresenceChanged.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_onrostercontactinformationchanged\", this._onContactInfoChanged.bind(this)); // this._eventEmitter.on(\"evt_internal_userinvitemngtreceived\", this._onUserInviteReceived.bind(this));\n    // this._eventEmitter.on(\"evt_internal_userinviteaccepted\", this._onUserInviteAccepted.bind(this));\n    // this._eventEmitter.on(\"evt_internal_userinvitecanceled\", this._onUserInviteCanceled.bind(this));\n\n\n    this._eventEmitter.on(\"evt_internal_onrosters\", this._onRostersUpdate.bind(this));\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._invitationsService = _core.invitations;\n        that._presenceService = _core.presence;\n        that._contacts = []; // Create the user contact\n\n        that._logger.log(\"debug\", LOG_ID + \"(start) Create userContact (\" + that._xmpp.jid + \")\");\n\n        that.userContact = new Contact_1.Contact();\n        that.userContact.ask = null;\n        that.userContact.subscription = null; // Attach _xmpp information (check)\n\n        that.userContact._id = that._xmpp.jid;\n        that.userContact.jid = that._xmpp.jid;\n        that.userContact.jidtel = \"tel_\" + that._xmpp.jid;\n        that.userContact.jid_im = that._xmpp.jid;\n        that.userContact.jid_tel = \"tel_\" + that._xmpp.jid;\n        that.userContact.fullJid = that._xmpp.fullJid;\n        /*\n        // Update contact with user data auth information\n        that.userContact.language = that.currentLanguage;\n        that._logger.log(\"internal\", LOG_ID + \"(start) before updateFromUserData \", contact);\n        that.userContact.updateFromUserData(authService.userData);\n        that.userContact.getAvatar();\n        that.userContact.updateRichStatus();\n        // */\n\n        /*\n                        that._eventEmitter.on(\"evt_internal_onrosterpresence\", that._onRosterPresenceChanged.bind(that));\n                        that._eventEmitter.on(\"evt_internal_onrostercontactinformationchanged\", that._onContactInfoChanged.bind(that));\n                        that._eventEmitter.on(\"evt_internal_userinvitereceived\", that._onUserInviteReceived.bind(that));\n                        that._eventEmitter.on(\"evt_internal_userinviteaccepted\", that._onUserInviteAccepted.bind(that));\n                        that._eventEmitter.on(\"evt_internal_userinvitecanceled\", that._onUserInviteCanceled.bind(that));\n                        that._eventEmitter.on(\"evt_internal_onrosters\", that._onRostersUpdate.bind(that));\n        */\n\n        that.ready = true;\n        resolve();\n      } catch (err) {\n        that._logger.log(\"error\", LOG_ID + \"(start) Catch ErrorManager !!!\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(start) Catch ErrorManager !!! : \", err.message);\n\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = null;\n        that._rest = null;\n        that._contacts = [];\n        /*\n                        that._eventEmitter.removeListener(\"evt_internal_onrosterpresence\", that._onRosterPresenceChanged.bind(that));\n                        that._eventEmitter.removeListener(\"evt_internal_onrostercontactinformationchanged\", that._onContactInfoChanged.bind(that));\n                        that._eventEmitter.removeListener(\"evt_internal_userinvitereceived\", that._onUserInviteReceived.bind(that));\n                        that._eventEmitter.removeListener(\"evt_internal_userinviteaccepted\", that._onUserInviteAccepted.bind(that));\n                        that._eventEmitter.removeListener(\"evt_internal_userinvitecanceled\", that._onUserInviteCanceled.bind(that));\n                        that._eventEmitter.removeListener(\"evt_internal_onrosters\", that._onRostersUpdate.bind(that));\n        */\n\n        that.ready = false;\n        resolve();\n      } catch (err) {\n        return reject();\n      }\n    });\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      let that = this;\n      let userInfo = that.getContactById(that._rest.account.id, true).then(contact => {\n        //that._logger.log(\"internal\", LOG_ID + \"(init) before updateFromUserData \", contact);\n        that.userContact.updateFromUserData(contact);\n      });\n      Promise.all([userInfo]).then(() => {\n        resolve();\n      }).catch(() => {\n        return reject();\n      });\n    });\n  }\n  /**\n   * @public\n   * @method getDisplayName\n   * @instance\n   * @param {Contact} contact  The contact to get display name\n   * @return {String} The contact first name and last name\n   * @description\n   *      Get the display name of a contact\n   */\n\n\n  getDisplayName(contact) {\n    return contact.firstName + \" \" + contact.lastName;\n  }\n  /**\n   * @public\n   * @method getRosters\n   * @instance\n   * @description\n   *      Get the list of _contacts that are in the user's network (aka rosters)\n   * @async\n   * @return {Promise<Array>}\n   * @fulfil {ErrorManager} - ErrorManager object depending on the result (ErrorManager.getErrorManager().OK in case of success)\n   * @category async\n   */\n\n\n  getRosters() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._rest.getContacts().then(listOfContacts => {\n        listOfContacts.forEach(contactData => {\n          // Create the contact object\n          let contact = new Contact_1.Contact();\n          Object.assign(contact, contactData); // that._logger.log(\"internal\", LOG_ID + \"(getRosters) before updateFromUserData \", contact);\n\n          contact.updateFromUserData(contactData);\n          contact.roster = true;\n          contact.avatar = that.getAvatarByContactId(contact.id, contact.lastAvatarUpdateDate); // Append in contact list\n          // that._contacts[contact.id] = contact;\n\n          that._contacts.push(contact);\n        });\n\n        that._logger.log(\"internal\", LOG_ID + \"(getRosters) get rosters successfully : \", that._contacts);\n\n        that._logger.log(\"info\", LOG_ID + \"(getRosters) get rosters successfully\");\n\n        resolve(that.getAll());\n      }).catch(err => {\n        that._logger.log(\"error\", LOG_ID + \"(getRosters) error\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getRosters) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method getAll\n   * @instance\n   * @return {Contact[]} the list of _contacts\n   * @description\n   *  Return the list of _contacts that are in the network of the connected users (aka rosters)\n   */\n\n\n  getAll() {\n    return this._contacts;\n  }\n\n  createEmptyContactContact(jid) {\n    let that = this;\n    let contact = that.createBasicContact(jid);\n    contact.initials = \"?\";\n    contact.displayName = \"Unknown contact\";\n    contact.lastName = \"Unknown contact\";\n    contact.firstName = \"\";\n    contact.temp = true;\n    contact.avatar = {}; //new Image();\n\n    contact.avatar.src = \"/resources/skins/rainbow/images/conversations/unknownContact.png\";\n    return contact;\n  }\n\n  getContact(jid, phoneNumber) {\n    let that = this;\n    let contact = null;\n    let contactId = jid ? jid : phoneNumber;\n\n    if (that.isUserContactJid(contactId)) {\n      // Create the contact object\n      contact = new Contact_1.Contact(); // that._logger.log(\"internal\", LOG_ID + \"(getContact) before updateFromUserData \", contact);\n\n      contact.updateFromUserData(that._rest.account);\n    } else {\n      contact = that._contacts.find(_contact => _contact.jid_im === contactId);\n    }\n\n    return contact;\n  }\n\n  getOrCreateContact(jid, phoneNumber) {\n    let that = this; // Reject stupid request\n\n    if (!jid && !phoneNumber) {\n      let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n      error.msg += \" No jid or no phoneNumber\";\n      return Promise.reject(error);\n    } // Initialize contactsArray if necessary\n\n\n    if (!this._contacts) {\n      this._contacts = [];\n    } // Try to find an existing contact\n\n\n    let contact = this.getContact(jid, phoneNumber); // If contact found, return resolved promise with contact\n\n    if (contact) {\n      return Promise.resolve(contact);\n    } // Else create the contact\n\n\n    contact = that.createBasicContact(jid, phoneNumber); // Handle case where we have no jid\n\n    if (!jid) {\n      return Promise.resolve(contact);\n    } // Fill contact with vCard informations\n\n\n    return that._rest.getContactInformationByJID(jid).then(_contactFromServer => {\n      let contactIndex = that._contacts.findIndex(value => {\n        return value.jid_im === _contactFromServer.jid_im;\n      });\n\n      if (contactIndex !== -1) {\n        contact = that._contacts[contactIndex];\n      } //that._logger.log(\"internal\", LOG_ID + \"(getOrCreateContact) before updateFromUserData \", contact);\n\n\n      contact.updateFromUserData(_contactFromServer);\n      contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate); //that._contacts.push(contact);\n\n      return Promise.resolve(contact);\n    });\n  }\n\n  createBasicContact(jid, phoneNumber) {\n    let that = this;\n\n    that._logger.log(\"debug\", LOG_ID + \"[contactService] CreateContact \" + jid + \" \"\n    /* TODO + anonymizePhoneNumber(phoneNumber) */\n    ); // Create the contact object\n\n\n    let contact = new Contact_1.Contact(); // Handle case where we have no jid\n\n    if (!jid) {\n      contact.id = phoneNumber;\n      contact._id = phoneNumber;\n      contact.initials = \"?\";\n      contact.displayName = phoneNumber ? phoneNumber : \"Unknown contact\";\n      contact.lastName = phoneNumber ? phoneNumber : \"Unknown contact\";\n      contact.firstName = \"\";\n      contact.phoneProCan = phoneNumber ? phoneNumber : \"\";\n      contact.temp = true;\n      contact.loginEmail = \"noEmail\";\n      contact.avatar = {}; // new Image();\n\n      contact.avatar.src = \"/resources/skins/rainbow/images/conversations/unknownContact.png\";\n      contact.setNameUpdatePrio(Contact_1.NameUpdatePrio.NO_UPDATE_PRIO); //not yet updated\n\n      return contact;\n    } // Compute the contact id\n\n\n    let contactId = jid;\n\n    if (!contactId) {\n      contactId = phoneNumber;\n      contact.phoneProCan = phoneNumber;\n    }\n\n    if (!contactId) {\n      contactId = \"anonymous\";\n    } // Configure contact\n\n\n    contact.jid = jid;\n    contact.jid_im = jid;\n    contact.jidtel = \"tel_\" + jid;\n    contact.id = contactId;\n    contact._id = jid;\n    contact.ask = \"none\";\n    contact.subscription = \"none\"; // TODO ? contact.updateRichStatus();\n\n    contact.roster = false;\n    contact.presence = \"offline\";\n    contact.status = \"\"; // Append in contact list\n    // that._contacts[contact.id] = contact;\n\n    that._contacts.push(contact);\n\n    return contact;\n  }\n  /**\n   * @public\n   * @method getContactByJid\n   * @instance\n   * @param {string} jid The contact jid\n   * @description\n   *  Get a contact by his JID by searching in the connected user _contacts list (full information) and if not found by searching on the server too (limited set of information)\n   * @async\n   * @return {Promise<Contact, ErrorManager>}\n   * @fulfil {Contact} - Found contact or null or an error object depending on the result\n   * @category async\n   */\n\n\n  getContactByJid(jid) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!jid) {\n        that._logger.log(\"warn\", LOG_ID + \"(getContactByJid) bad or empty 'jid' parameter\", jid);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      } else {\n        let contactFound = null;\n\n        if (that._contacts) {\n          contactFound = that._contacts.find(contact => {\n            return contact.jid_im === jid;\n          });\n        }\n\n        if (contactFound) {\n          that._logger.log(\"info\", LOG_ID + \"(getContactByJid) contact found locally with jid \", jid);\n\n          resolve(contactFound);\n        } else {\n          that._logger.log(\"debug\", LOG_ID + \"(getContactByJid) contact not found locally. Ask the server...\");\n\n          that._rest.getContactInformationByJID(jid).then(_contactFromServer => {\n            let contact = null;\n\n            if (_contactFromServer) {\n              that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server\", _contactFromServer);\n\n              let contactIndex = that._contacts.findIndex(value => {\n                return value.jid_im === _contactFromServer.jid_im;\n              });\n\n              if (contactIndex !== -1) {\n                contact = that._contacts[contactIndex];\n\n                that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on local _contacts\", contact);\n              } else {\n                contact = that.createBasicContact(_contactFromServer.jid_im, undefined);\n              } //that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) before updateFromUserData \", contact);\n\n\n              contact.updateFromUserData(_contactFromServer);\n              contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n            } else {\n              that._logger.log(\"info\", LOG_ID + \"(getContactByJid) no contact found on the server with Jid\", jid);\n            }\n\n            resolve(contact);\n          }).catch(err => {\n            return reject(err);\n          });\n        }\n      }\n    });\n  }\n  /**\n   * @public\n   * @method getContactById\n   * @instance\n   * @param {string} id The contact id\n   * @param {boolean} forceServerSearch Boolean to force the search of the _contacts informations on the server.\n   * @description\n   *  Get a contact by his id\n   * @async\n   * @return {Promise<Contact, ErrorManager>}\n   * @fulfil {Contact} - Found contact or null or an error object depending on the result\n   * @category async\n   */\n\n\n  getContactById(id, forceServerSearch) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        that._logger.log(\"warn\", LOG_ID + \"(getContactById) bad or empty 'id' parameter\", id);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      } else {\n        let contactFound = null;\n\n        if (that._contacts && !forceServerSearch) {\n          contactFound = that._contacts.find(contact => {\n            return contact.id === id;\n          });\n        }\n\n        if (contactFound) {\n          that._logger.log(\"internal\", LOG_ID + \"(getContactById) contact found locally\", contactFound);\n\n          resolve(contactFound);\n        } else {\n          that._logger.log(\"debug\", LOG_ID + \"(getContactById) contact not found locally. Ask the server...\");\n\n          that._rest.getContactInformationByID(id).then(_contactFromServer => {\n            let contact = null;\n\n            if (_contactFromServer) {\n              that._logger.log(\"internal\", LOG_ID + \"(getContactById) contact found on the server\", _contactFromServer);\n\n              that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on the server\");\n\n              let contactIndex = that._contacts.findIndex(value => {\n                return value.jid_im === _contactFromServer.jid_im;\n              });\n\n              if (contactIndex !== -1) {\n                //that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on local _contacts\", contact);\n                that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on local _contacts\");\n\n                contact = that._contacts[contactIndex];\n              } else {\n                contact = that.createBasicContact(_contactFromServer.jid_im, undefined);\n              } //that._logger.log(\"internal\", LOG_ID + \"(getContactById) before updateFromUserData \", contact);\n\n\n              contact.updateFromUserData(_contactFromServer);\n              contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n            } else {\n              that._logger.log(\"info\", LOG_ID + \"(getContactById) no contact found on server with id\", id);\n            }\n\n            resolve(contact);\n          }).catch(err => {\n            return reject(err);\n          });\n        }\n      }\n    });\n  }\n  /**\n   * @public\n   * @method getContactByLoginEmail\n   * @instance\n   * @param {string} loginEmail The contact loginEmail\n   * @description\n   *  Get a contact by his loginEmail\n   * @async\n   * @return {Promise<Contact, ErrorManager>}\n   * @fulfil {Contact} - Found contact or null or an error object depending on the result\n   * @category async\n   */\n\n\n  getContactByLoginEmail(loginEmail) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (!loginEmail) {\n          this._logger.log(\"warn\", LOG_ID + \"(getContactByLoginEmail) bad or empty 'loginEmail' parameter\");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(getContactByLoginEmail) bad or empty 'loginEmail' parameter : \", loginEmail);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        } else {\n          let contactFound = null;\n\n          if (that._contacts) {\n            contactFound = that._contacts.find(contact => {\n              return contact.loginEmail === loginEmail;\n            });\n          }\n\n          if (contactFound) {\n            that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) contact found locally : \", contactFound);\n\n            resolve(contactFound);\n          } else {\n            that._logger.log(\"debug\", LOG_ID + \"(getContactByLoginEmail) contact not found locally. Ask server...\");\n\n            that._rest.getContactInformationByLoginEmail(loginEmail).then(contactsFromServeur => __awaiter(this, void 0, void 0, function* () {\n              if (contactsFromServeur && contactsFromServeur.length > 0) {\n                let contact = null;\n\n                that._logger.log(\"info\", LOG_ID + \"(getContactByLoginEmail) contact found on server\");\n\n                let _contactFromServer = contactsFromServeur[0];\n\n                if (_contactFromServer) {\n                  // The contact is not found by email in the that._contacts tab, so it need to be find on server to get or update it.\n                  yield that.getContactById(_contactFromServer.id, true).then(contactInformation => {\n                    contact = contactInformation; // Workaround because server does not return the email when not in same company, even if it has been found by email on server.\n\n                    if (!contact.loginEmail) {\n                      contact.loginEmail = loginEmail;\n                    }\n\n                    that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) full data contact : \", contact, \", found on server with loginEmail : \", loginEmail);\n                    /*let contactIndex = that._contacts.findIndex((value) => {\n                        return value.jid_im === contactInformation.jid_im;\n                    });\n                         if (contactIndex !== -1) {\n                        contact = that._contacts[contactIndex];\n                    } else {\n                        contact = that.createBasicContact(contactInformation.jid_im, undefined);\n                    }\n                    //that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) before updateFromUserData \", contact);\n                    contact.updateFromUserData(contactInformation);\n                    contact.avatar = that.getAvatarByContactId(contactInformation.id, contactInformation.lastAvatarUpdateDate);\n                          */\n\n                  });\n                } else {\n                  that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) no contact found on server with loginEmail : \", loginEmail);\n                }\n\n                resolve(contact);\n              } else {\n                that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) contact not found on server with loginEmail : \", loginEmail);\n\n                resolve(null);\n              }\n            })).catch(err => {\n              return reject(err);\n            });\n          }\n        }\n      });\n    });\n  }\n  /**\n   * @public\n   * @method getAvatarByContactId\n   * @instance\n   * @param {string} id The contact id\n   * @param {string} lastAvatarUpdateDate use this field to give the stored date ( could be retrieved with contact.lastAvatarUpdateDate )\n   *      if missing or null in case where no avatar available a local module file is provided instead of URL\n   * @description\n   *  Get a contact avatar by his contact id\n   * @return {String} Contact avatar URL or file\n   */\n\n\n  getAvatarByContactId(id, lastUpdate) {\n    if (lastUpdate) {\n      return this.avatarDomain + \"/api/avatar/\" + id + \"?update=\" + md5(lastUpdate);\n    }\n\n    return path.resolve(__dirname, \"../resources/unknownContact.png\");\n  } // ************************************************** //\n  // **  jid utilities                               ** //\n  // ************************************************** //\n\n\n  isTelJid(jid) {\n    return jid.indexOf(\"tel_\") === 0;\n  }\n\n  getImJid(jid) {\n    let that = this;\n    let bareJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\n    return that.isTelJid(bareJid) ? bareJid.substring(4) : bareJid;\n  }\n\n  getRessourceFromJid(jid) {\n    let result = \"\";\n\n    if (jid) {\n      let index = jid.indexOf(\"/\");\n\n      if (index !== -1) {\n        result = jid.substr(index + 1);\n      }\n    }\n\n    return result;\n  }\n\n  isUserContactJid(jid) {\n    let that = this;\n\n    if (!that._rest.account) {\n      return false;\n    }\n\n    return that._rest.account.jid_im === jid;\n  }\n\n  isUserContact(contact) {\n    let that = this;\n\n    if (!contact || !contact.jid) {\n      return false;\n    }\n\n    if (!that._rest.account) {\n      return contact.jid === that._xmpp.jid;\n    }\n\n    return that._rest.account.jid === contact.jid;\n  }\n  /**\n   * @public\n   * @method getConnectedUser\n   * @instance\n   * @description\n   *    Get the connected user information\n   * @return {Contact} Return a Contact object representing the connected user information or null if not connected\n   */\n\n\n  getConnectedUser() {\n    let that = this;\n\n    if (!that._rest.account) {\n      return null;\n    } // Create the contact object\n\n\n    let contact = new Contact_1.Contact(); //that._logger.log(\"internal\", LOG_ID + \"(getContactById) before updateFromUserData \", contact);\n\n    contact.updateFromUserData(that._rest.account);\n    contact.avatar = that.getAvatarByContactId(that._rest.account.id, that._rest.account.lastAvatarUpdateDate);\n    contact.status = that._presenceService.getUserConnectedPresence().status;\n    return contact;\n  }\n  /**\n   * @public\n   * @since 1.17\n   * @method\n   * @instance\n   * @description\n   *    Send an invitation to a Rainbow user for joining his network. <br>\n   *    The user will receive an invitation that can be accepted or declined <br>\n   *    In return, when accepted, he will be part of your network <br>\n   *    When in the same company, invitation is automatically accepted (ie: can't be declined)\n   * @param {Contact} contact The contact object to subscribe\n   * @return {Object} A promise that contains the contact added or an object describing an error\n   */\n\n\n  addToNetwork(contact) {\n    return this.addToContactsList(contact);\n  }\n  /**\n   * @public\n   * @since 1.17\n   * @method addToContactsList\n   * @instance\n   * @description\n   *    Send an invitation to a Rainbow user for joining his network. <br>\n   *    The user will receive an invitation that can be accepted or declined <br>\n   *    In return, when accepted, he will be part of your network <br>\n   *    When in the same company, invitation is automatically accepted (ie: can't be declined)\n   * @param {Contact} contact The contact object to subscribe\n   * @return {Object} A promise that contains the contact added or an object describing an error\n   * @category async\n   */\n\n\n  addToContactsList(contact) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!contact) {\n        this._logger.log(\"warn\", LOG_ID + \"(addToContactsList) bad or empty 'contact' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(addToContactsList) bad or empty 'contact' parameter : \", contact);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      } else {\n        that._logger.log(\"internal\", LOG_ID + \"(addToContactsList) contact invitation to server... : \", contact);\n\n        that._rest.joinContactInvitation(contact).then(_contact => {\n          if (_contact && _contact.status !== undefined) {\n            that._logger.log(\"info\", LOG_ID + \"(addToContactsList) contact invited : \", _contact.invitedUserId);\n\n            that.getContactById(_contact.invitedUserId, false).then(invitedUser => {\n              resolve(invitedUser);\n            }).catch(err => {\n              return reject(err);\n            });\n          } else {\n            that._logger.log(\"internal\", LOG_ID + \"(addToContactsList) contact cannot be added : \", util.inspect(contact));\n\n            resolve(null);\n          }\n        }).catch(err => {\n          return reject(err);\n        });\n      }\n    });\n  }\n  /**\n   * @public\n   * @since 1.64.0\n   * @method getInvitationById\n   * @instance\n   * @description\n   *    Get an invite by its id\n   * @param {String} strInvitationId the id of the invite to retrieve\n   * @return {Invitation} The invite if found\n   */\n\n\n  getInvitationById(strInvitationId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!strInvitationId) {\n        this._logger.log(\"warn\", LOG_ID + \"(getInvitationById) bad or empty 'strInvitationId' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(getInvitationById) bad or empty 'strInvitationId' parameter : \", strInvitationId);\n\n        let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n        error.msg += \", invitation not defined, can not getInvitationById\";\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      return this._invitationsService.getInvitation(strInvitationId);\n    });\n  }\n\n  /**\n   * @public\n   * @since 1.17\n   * @method\n   * @instance\n   * @description\n   *    Accept an invitation from an other Rainbow user to mutually join the network <br>\n   *    Once accepted, the user will be part of your network. <br>\n   *    Return a promise\n   * @param {Invitation} invitation The invitation to accept\n   * @return {Object} A promise that contains SDK.OK if success or an object that describes the error\n   */\n  acceptInvitation(invitation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"internal\", LOG_ID + \"(acceptInvitation) invitation : \", invitation);\n\n      if (!invitation) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n        error.msg += \", invitation not defined, can not acceptInvitation\";\n        throw error;\n      } else {\n        return that._invitationsService.acceptInvitation(invitation); //return that._rest.acceptInvitation(invitation);\n      }\n    });\n  }\n\n  /**\n   * @public\n   * @since 1.17\n   * @method\n   * @instance\n   * @description\n   *    Decline an invitation from an other Rainbow user to mutually join the network <br>\n   *    Once declined, the user will not be part of your network. <br>\n   *    Return a promise\n   * @param {Invitation} invitation The invitation to decline\n   * @return {Object} A promise that contains SDK.OK in case of success or an object that describes the error\n   */\n  declineInvitation(invitation) {\n    let that = this;\n\n    that._logger.log(\"internal\", LOG_ID + \"(declineInvitation) intivation : \", invitation);\n\n    if (!invitation) {\n      let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n      error.msg += \", invitation not defined, can not declineInvitation\";\n      throw error;\n    } else {\n      return that._invitationsService.declineInvitation(invitation); //return that._rest.declineInvitation(invitation);\n    }\n  }\n\n  /**\n   * @typedef {Object} joinContactsResult\n   * @property {String[]} success List of succeed joined users\n   * @property {String[]} failed List of failed to joined users\n   */\n\n  /**\n   * @public\n   * @since 1.41\n   * @beta\n   * @method joinContacts\n   * @instance\n   * @description\n   *    As admin, add _contacts to a user roster\n   * @param {Contact} contact The contact object to subscribe\n   * @param {String[]} contactIds List of contactId to add to the user roster\n   * @async\n   * @return {Promise<joinContactsResult, ErrorManager>}\n   * @fulfil {joinContactsResult} - Join result or an error object depending on the result\n   * @category async\n   */\n  joinContacts(contact, contactIds) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!contact) {\n        this._logger.log(\"warn\", LOG_ID + \"(joinContacts) bad or empty 'contact' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(joinContacts) bad or empty 'contact' parameter : \", contact);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      } else {\n        that._logger.log(\"debug\", LOG_ID + \"(joinContacts) contact join to server...\");\n\n        let promises = [];\n        contactIds.forEach(contactId => {\n          promises.push(that._rest.joinContacts(contact, [contactId], false).then(result => {\n            return Promise.resolve({\n              \"success\": [contactId]\n            });\n          }).catch(err => {\n            if (err.code === 409) {\n              resolve({\n                \"success\": [contactId]\n              });\n            }\n\n            resolve({\n              \"failed\": [contactId]\n            });\n          }));\n        });\n        Promise.all(promises).then(values => {\n          let mergeResult = values.reduce((prev, current) => {\n            return Object.assign(prev, current);\n          }, {\n            \"success\": [],\n            \"failed\": []\n          });\n\n          that._logger.log(\"internal\", LOG_ID + \"(joinContacts) \" + mergeResult.success.length + \" contact(s) joined, \" + mergeResult.failed.length + \" contact(s) failed \");\n\n          resolve(mergeResult);\n        }).catch(err => {\n          return reject(err);\n        });\n      }\n    });\n  }\n  /**\n   * @private\n   * @method _onRosterPresenceChanged\n   * @instance\n   * @param {Object} presence contains informations about contact changes\n   * @description\n   *      Method called when the presence of a contact changed\n   */\n\n\n  _onRosterPresenceChanged(presence) {\n    let contact = this._contacts.find(contactItem => {\n      return contactItem.jid_im === presence.jid;\n    });\n\n    if (contact) {\n      if (!contact.resources) {\n        contact.resources = {};\n      } // Store the presence of the resource\n\n\n      contact.resources[presence.resource] = presence.value;\n      let on_the_phone = false;\n      let manual_invisible = false;\n      let manual_dnd = false;\n      let manual_away = false;\n      let in_presentation_mode = false;\n      let in_webrtc_mode = false;\n      let webrtc_reason = \"\";\n      let is_online = false;\n      let is_online_mobile = false;\n      let auto_away = false;\n      let is_offline = false;\n\n      for (let resourceId in contact.resources) {\n        let resource = contact.resources[resourceId];\n\n        if (resource.type !== \"phone\") {\n          if (resource.show === \"xa\" && resource.status === \"\") {\n            manual_invisible = true;\n          } else if (resource.show === \"dnd\" && resource.status === \"\") {\n            manual_dnd = true;\n          } else if (resource.show === \"xa\" && resource.status === \"away\") {\n            manual_away = true;\n          } else if (resource.show === \"dnd\" && resource.status === \"presentation\") {\n            in_presentation_mode = true;\n          } else if (resource.show === \"dnd\" && resource.status.length > 0) {\n            in_webrtc_mode = true;\n            webrtc_reason = resource.status;\n          } else if ((resource.show === \"\" || resource.show === \"online\") && (resource.status === \"\" || resource.status === \"mode=auto\")) {\n            if (resource.type === \"mobile\") {\n              is_online_mobile = true;\n            } else {\n              is_online = true;\n            }\n          } else if (resource.show === \"away\" && resource.status === \"\") {\n            auto_away = true;\n          } else if (resource.show === \"unavailable\") {\n            is_offline = true;\n          }\n        } else {\n          if ((resource.status === \"EVT_SERVICE_INITIATED\" || resource.status === \"EVT_ESTABLISHED\") && resource.show === \"chat\") {\n            on_the_phone = true;\n          }\n\n          if (resource.status === \"EVT_CONNECTION_CLEARED\" && resource.show === \"chat\") {\n            on_the_phone = false;\n          }\n        }\n      } // Store previous presence state\n\n\n      let oldPresence = contact.presence;\n      let oldStatus = contact.status;\n\n      if (on_the_phone) {\n        contact.presence = \"busy\";\n        contact.status = \"phone\";\n      } else if (manual_invisible) {\n        contact.presence = \"offline\";\n        contact.status = \"\";\n      } else if (manual_dnd) {\n        contact.presence = \"busy\";\n        contact.status = \"\";\n      } else if (manual_away) {\n        contact.presence = \"away\";\n        contact.status = \"\";\n      } else if (in_presentation_mode) {\n        contact.presence = \"busy\";\n        contact.status = \"presentation\";\n      } else if (in_webrtc_mode) {\n        contact.presence = \"busy\";\n        contact.status = webrtc_reason;\n      } else if (is_online) {\n        contact.presence = \"online\";\n        contact.status = \"\";\n      } else if (is_online_mobile) {\n        contact.presence = \"online\";\n        contact.status = \"mobile\";\n      } else if (auto_away) {\n        contact.presence = \"away\";\n        contact.status = \"\";\n      } else if (is_offline && contact.presence !== \"unknown\") {\n        contact.presence = \"offline\";\n        contact.status = \"\";\n      } else {\n        contact.presence = \"unknown\";\n        contact.status = \"\";\n      }\n\n      if (contact.resources[presence.resource].show === \"unavailable\") {\n        delete contact.resources[presence.resource];\n      }\n\n      if (contact.presence === oldPresence && contact.status === oldStatus) {\n        return;\n      }\n\n      let presenceDisplayed = contact.status.length > 0 ? contact.presence + \"|\" + contact.status : contact.presence;\n\n      this._logger.log(\"internal\", LOG_ID + \"(onRosterPresenceChanged) presence changed to \" + presenceDisplayed + \" for \" + this.getDisplayName(contact));\n\n      this._eventEmitter.emit(\"evt_internal_onrosterpresencechanged\", contact);\n    } else {\n      this._logger.log(\"warn\", LOG_ID + \"(onRosterPresenceChanged) no contact found for \" + presence.jid); // Seems to be a pending presence update in roster associated contact not yet available\n\n\n      if (presence.value.show !== \"unavailable\") {\n        // To a pending presence queue\n        this._rosterPresenceQueue.push({\n          presence,\n          date: Date.now()\n        });\n      }\n    }\n  }\n  /**\n   * @private\n   * @method _onContactInfoChanged\n   * @instance\n   * @param {string} jid modified roster contact Jid\n   * @description\n   *     Method called when an roster user information are updated\n   */\n\n\n  _onContactInfoChanged(jid) {\n    let that = this;\n\n    that._rest.getContactInformationByJID(jid).then(_contactFromServer => {\n      that._logger.log(\"info\", LOG_ID + \"(getContactByJid) contact found on the server\");\n\n      that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server : \", util.inspect(_contactFromServer));\n\n      let contactIndex = -1; // Update or Add contact\n\n      if (that._contacts) {\n        contactIndex = that._contacts.findIndex(_contact => {\n          return _contact.jid_im === _contactFromServer.jid_im;\n        });\n        let contact = null;\n\n        that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server : \", contact);\n\n        if (contactIndex !== -1) {\n          contact = that._contacts[contactIndex]; //that._logger.log(\"internal\", LOG_ID + \"(_onContactInfoChanged) local contact before updateFromUserData \", contact);\n\n          contact.updateFromUserData(_contactFromServer);\n          contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n\n          this._eventEmitter.emit(\"evt_internal_contactinformationchanged\", that._contacts[contactIndex]);\n        } else {\n          contact = that.createBasicContact(_contactFromServer.jid_im, undefined); //that._logger.log(\"internal\", LOG_ID + \"(_onContactInfoChanged) from server contact before updateFromUserData \", contact);\n\n          contact.updateFromUserData(_contactFromServer);\n          contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n\n          this._eventEmitter.emit(\"evt_internal_contactinformationchanged\", contact);\n        }\n      }\n    }).catch(err => {\n      this._logger.log(\"info\", LOG_ID + \"(_onContactInfoChanged) no contact found with jid \" + jid);\n    });\n  }\n  /**\n   * @private\n   * @method _onUserInviteReceived\n   * @instance\n   * @param {Object} data contains the invitationId\n   * @description\n   *      Method called when an user invite is received\n   */\n\n  /* _onUserInviteReceived(data) {\n      let that = this;\n       that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteReceived) enter\");\n      that._logger.log(\"internal\", LOG_ID + \"(_onUserInviteReceived) enter : \", data);\n       that._rest.getInvitationById(data.invitationId).then( (invitation : any) => {\n          that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteReceived) invitation received id\", invitation.id);\n           that._eventEmitter.emit(\"evt_internal_userinvitereceived\", invitation);\n      }, err => {\n          that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteReceived) no invitation found for \" + data.invitationId);\n      });\n  } // */\n\n  /**\n   * @private\n   * @method _onUserInviteAccepted\n   * @instance\n   * @param {Object} data contains the invitationId\n   * @description\n   *      Method called when an user invite is accepted\n   */\n\n  /* _onUserInviteAccepted(data) {\n      let that = this;\n       that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteAccepted) enter\");\n       that._rest.getInvitationById(data.invitationId).then((invitation : any) => {\n          that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteAccepted) invitation accepted id\", invitation.id);\n           that._eventEmitter.emit(\"evt_internal_userinviteaccepted\", invitation);\n      }, err => {\n          that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteAccepted) no invitation found for \" + data.invitationId);\n      });\n  } // */\n\n  /**\n   * @private\n   * @method _onUserInviteCanceled\n   * @instance\n   * @param {Object} data contains the invitationId\n   * @description\n   *      Method called when an user invite is canceled\n   */\n\n  /* _onUserInviteCanceled(data) {\n      let that = this;\n       that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteCanceled) enter\");\n       that._rest.getInvitationById(data.invitationId).then((invitation: any) => {\n          that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteCanceled) invitation canceled id\", invitation.id);\n          that._eventEmitter.emit(\"evt_internal_userinvitecanceled\", invitation);\n      }, err => {\n          that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteCanceled) no invitation found for \" + data.invitationId);\n      });\n  } // */\n\n  /**\n   * @private\n   * @method _onRostersUpdate\n   * @instance\n   * @param {Object} _contacts contains a contact list with updated elements\n   * @description\n   *      Method called when the roster _contacts is updated\n   */\n\n\n  _onRostersUpdate(contacts) {\n    let that = this;\n\n    that._logger.log(\"debug\", LOG_ID + \"(_onRostersUpdate) enter\");\n\n    contacts.forEach(contact => {\n      if (contact.jid.substr(0, 3) !== \"tel\") {\n        // Ignore telephonny events\n        if (contact.subscription === \"remove\") {\n          let foundContact = that._contacts.find(item => item.jid_im === contact.jid);\n\n          if (foundContact) {\n            foundContact.presence = \"unknown\"; // Add suppression delay\n\n            setTimeout(() => {\n              that._contacts = that._contacts.filter(_contact => _contact.jid_im !== contact.jid);\n            }, 3000);\n          }\n\n          return;\n        }\n\n        if (contact.subscription === \"both\") {\n          if (!that._contacts.find(item => {\n            return item.jid_im === contact.jid;\n          })) {\n            that.getContactByJid(contact.jid).then(_contact => {\n              that._contacts.push(Object.assign(_contact, {\n                resources: {},\n                presence: \"offline\",\n                status: \"\"\n              }));\n\n              that._rosterPresenceQueue.filter(presenceItem => presenceItem.presence.jid === contact.jid).forEach(item => that._onRosterPresenceChanged(item.presence));\n\n              let currentDate = Date.now();\n              that._rosterPresenceQueue = that._rosterPresenceQueue.filter(presenceItem => presenceItem.presence.jid !== contact.jid || presenceItem.date + 10000 < currentDate);\n            });\n          }\n        }\n      }\n    });\n  }\n\n};\nContacts = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_1.isStarted([])\n/**\n * @module\n * @name Contacts\n * @version 1.67.1 \n * @public\n * @description\n *       This module manages _contacts. A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information.<br>\n *       Using this module, you can get access to your network _contacts or search for Rainbow _contacts.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Get the network _contacts (roster) <br>\n *      - Get and search _contacts by Id, JID or loginEmail <br>\n */\n], Contacts);\nexports.ContactsService = Contacts;\nmodule.exports.Contacts = Contacts;","map":{"version":3,"sources":["../../src/lib/services/ContactsService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\nconst Contact_1 = require(\"../common/models/Contact\");\nconst util = require(\"util\");\nconst md5 = require(\"md5\");\nconst path = require(\"path\");\nconst Utils_1 = require(\"../common/Utils\");\nconst LOG_ID = \"CONTACTS/SVCE - \";\nlet Contacts = \n/**\n * @module\n * @name Contacts\n * @version 1.67.1 \n * @public\n * @description\n *       This module manages _contacts. A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information.<br>\n *       Using this module, you can get access to your network _contacts or search for Rainbow _contacts.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Get the network _contacts (roster) <br>\n *      - Get and search _contacts by Id, JID or loginEmail <br>\n */\nclass Contacts {\n    constructor(_eventEmitter, _http, _logger, _startConfig) {\n        this.ready = false;\n        this._startConfig = _startConfig;\n        this.avatarDomain = _http.host.split(\".\").length === 2 ? _http.protocol + \"://cdn.\" + _http.host + \":\" + _http.port : _http.protocol + \"://\" + _http.host + \":\" + _http.port;\n        this._xmpp = null;\n        this._rest = null;\n        this._s2s = null;\n        this._options = {};\n        this._useXMPP = false;\n        this._useS2S = false;\n        this._contacts = [];\n        this._eventEmitter = _eventEmitter;\n        this._logger = _logger;\n        this._rosterPresenceQueue = [];\n        this.userContact = new Contact_1.Contact();\n        this.ready = false;\n        this._eventEmitter.on(\"evt_internal_onrosterpresence\", this._onRosterPresenceChanged.bind(this));\n        this._eventEmitter.on(\"evt_internal_onrostercontactinformationchanged\", this._onContactInfoChanged.bind(this));\n        // this._eventEmitter.on(\"evt_internal_userinvitemngtreceived\", this._onUserInviteReceived.bind(this));\n        // this._eventEmitter.on(\"evt_internal_userinviteaccepted\", this._onUserInviteAccepted.bind(this));\n        // this._eventEmitter.on(\"evt_internal_userinvitecanceled\", this._onUserInviteCanceled.bind(this));\n        this._eventEmitter.on(\"evt_internal_onrosters\", this._onRostersUpdate.bind(this));\n    }\n    get startConfig() {\n        return this._startConfig;\n    }\n    start(_options, _core) {\n        let that = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                that._xmpp = _core._xmpp;\n                that._rest = _core._rest;\n                that._options = _options;\n                that._s2s = _core._s2s;\n                that._useXMPP = that._options.useXMPP;\n                that._useS2S = that._options.useS2S;\n                that._invitationsService = _core.invitations;\n                that._presenceService = _core.presence;\n                that._contacts = [];\n                // Create the user contact\n                that._logger.log(\"debug\", LOG_ID + \"(start) Create userContact (\" + that._xmpp.jid + \")\");\n                that.userContact = new Contact_1.Contact();\n                that.userContact.ask = null;\n                that.userContact.subscription = null;\n                // Attach _xmpp information (check)\n                that.userContact._id = that._xmpp.jid;\n                that.userContact.jid = that._xmpp.jid;\n                that.userContact.jidtel = \"tel_\" + that._xmpp.jid;\n                that.userContact.jid_im = that._xmpp.jid;\n                that.userContact.jid_tel = \"tel_\" + that._xmpp.jid;\n                that.userContact.fullJid = that._xmpp.fullJid;\n                /*\n                // Update contact with user data auth information\n                that.userContact.language = that.currentLanguage;\n                that._logger.log(\"internal\", LOG_ID + \"(start) before updateFromUserData \", contact);\n                that.userContact.updateFromUserData(authService.userData);\n                that.userContact.getAvatar();\n                that.userContact.updateRichStatus();\n                // */\n                /*\n                                that._eventEmitter.on(\"evt_internal_onrosterpresence\", that._onRosterPresenceChanged.bind(that));\n                                that._eventEmitter.on(\"evt_internal_onrostercontactinformationchanged\", that._onContactInfoChanged.bind(that));\n                                that._eventEmitter.on(\"evt_internal_userinvitereceived\", that._onUserInviteReceived.bind(that));\n                                that._eventEmitter.on(\"evt_internal_userinviteaccepted\", that._onUserInviteAccepted.bind(that));\n                                that._eventEmitter.on(\"evt_internal_userinvitecanceled\", that._onUserInviteCanceled.bind(that));\n                                that._eventEmitter.on(\"evt_internal_onrosters\", that._onRostersUpdate.bind(that));\n                */\n                that.ready = true;\n                resolve();\n            }\n            catch (err) {\n                that._logger.log(\"error\", LOG_ID + \"(start) Catch ErrorManager !!!\");\n                that._logger.log(\"internalerror\", LOG_ID + \"(start) Catch ErrorManager !!! : \", err.message);\n                return reject(err);\n            }\n        });\n    }\n    stop() {\n        let that = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                that._xmpp = null;\n                that._rest = null;\n                that._contacts = [];\n                /*\n                                that._eventEmitter.removeListener(\"evt_internal_onrosterpresence\", that._onRosterPresenceChanged.bind(that));\n                                that._eventEmitter.removeListener(\"evt_internal_onrostercontactinformationchanged\", that._onContactInfoChanged.bind(that));\n                                that._eventEmitter.removeListener(\"evt_internal_userinvitereceived\", that._onUserInviteReceived.bind(that));\n                                that._eventEmitter.removeListener(\"evt_internal_userinviteaccepted\", that._onUserInviteAccepted.bind(that));\n                                that._eventEmitter.removeListener(\"evt_internal_userinvitecanceled\", that._onUserInviteCanceled.bind(that));\n                                that._eventEmitter.removeListener(\"evt_internal_onrosters\", that._onRostersUpdate.bind(that));\n                */\n                that.ready = false;\n                resolve();\n            }\n            catch (err) {\n                return reject();\n            }\n        });\n    }\n    init() {\n        return new Promise((resolve, reject) => {\n            let that = this;\n            let userInfo = that.getContactById(that._rest.account.id, true).then((contact) => {\n                //that._logger.log(\"internal\", LOG_ID + \"(init) before updateFromUserData \", contact);\n                that.userContact.updateFromUserData(contact);\n            });\n            Promise.all([userInfo]).then(() => { resolve(); }).catch(() => { return reject(); });\n        });\n    }\n    /**\n     * @public\n     * @method getDisplayName\n     * @instance\n     * @param {Contact} contact  The contact to get display name\n     * @return {String} The contact first name and last name\n     * @description\n     *      Get the display name of a contact\n     */\n    getDisplayName(contact) {\n        return contact.firstName + \" \" + contact.lastName;\n    }\n    /**\n     * @public\n     * @method getRosters\n     * @instance\n     * @description\n     *      Get the list of _contacts that are in the user's network (aka rosters)\n     * @async\n     * @return {Promise<Array>}\n     * @fulfil {ErrorManager} - ErrorManager object depending on the result (ErrorManager.getErrorManager().OK in case of success)\n     * @category async\n     */\n    getRosters() {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            that._rest.getContacts().then((listOfContacts) => {\n                listOfContacts.forEach((contactData) => {\n                    // Create the contact object\n                    let contact = new Contact_1.Contact();\n                    Object.assign(contact, contactData);\n                    // that._logger.log(\"internal\", LOG_ID + \"(getRosters) before updateFromUserData \", contact);\n                    contact.updateFromUserData(contactData);\n                    contact.roster = true;\n                    contact.avatar = that.getAvatarByContactId(contact.id, contact.lastAvatarUpdateDate);\n                    // Append in contact list\n                    // that._contacts[contact.id] = contact;\n                    that._contacts.push(contact);\n                });\n                that._logger.log(\"internal\", LOG_ID + \"(getRosters) get rosters successfully : \", that._contacts);\n                that._logger.log(\"info\", LOG_ID + \"(getRosters) get rosters successfully\");\n                resolve(that.getAll());\n            }).catch((err) => {\n                that._logger.log(\"error\", LOG_ID + \"(getRosters) error\");\n                that._logger.log(\"internalerror\", LOG_ID + \"(getRosters) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method getAll\n     * @instance\n     * @return {Contact[]} the list of _contacts\n     * @description\n     *  Return the list of _contacts that are in the network of the connected users (aka rosters)\n     */\n    getAll() {\n        return this._contacts;\n    }\n    createEmptyContactContact(jid) {\n        let that = this;\n        let contact = that.createBasicContact(jid);\n        contact.initials = \"?\";\n        contact.displayName = \"Unknown contact\";\n        contact.lastName = \"Unknown contact\";\n        contact.firstName = \"\";\n        contact.temp = true;\n        contact.avatar = {}; //new Image();\n        contact.avatar.src = \"/resources/skins/rainbow/images/conversations/unknownContact.png\";\n        return contact;\n    }\n    getContact(jid, phoneNumber) {\n        let that = this;\n        let contact = null;\n        let contactId = jid ? jid : phoneNumber;\n        if (that.isUserContactJid(contactId)) {\n            // Create the contact object\n            contact = new Contact_1.Contact();\n            // that._logger.log(\"internal\", LOG_ID + \"(getContact) before updateFromUserData \", contact);\n            contact.updateFromUserData(that._rest.account);\n        }\n        else {\n            contact = that._contacts.find((_contact) => _contact.jid_im === contactId);\n        }\n        return contact;\n    }\n    getOrCreateContact(jid, phoneNumber) {\n        let that = this;\n        // Reject stupid request\n        if (!jid && !phoneNumber) {\n            let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n            error.msg += \" No jid or no phoneNumber\";\n            return Promise.reject(error);\n        }\n        // Initialize contactsArray if necessary\n        if (!this._contacts) {\n            this._contacts = [];\n        }\n        // Try to find an existing contact\n        let contact = this.getContact(jid, phoneNumber);\n        // If contact found, return resolved promise with contact\n        if (contact) {\n            return Promise.resolve(contact);\n        }\n        // Else create the contact\n        contact = that.createBasicContact(jid, phoneNumber);\n        // Handle case where we have no jid\n        if (!jid) {\n            return Promise.resolve(contact);\n        }\n        // Fill contact with vCard informations\n        return that._rest.getContactInformationByJID(jid).then((_contactFromServer) => {\n            let contactIndex = that._contacts.findIndex((value) => {\n                return value.jid_im === _contactFromServer.jid_im;\n            });\n            if (contactIndex !== -1) {\n                contact = that._contacts[contactIndex];\n            }\n            //that._logger.log(\"internal\", LOG_ID + \"(getOrCreateContact) before updateFromUserData \", contact);\n            contact.updateFromUserData(_contactFromServer);\n            contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n            //that._contacts.push(contact);\n            return Promise.resolve(contact);\n        });\n    }\n    createBasicContact(jid, phoneNumber) {\n        let that = this;\n        that._logger.log(\"debug\", LOG_ID + \"[contactService] CreateContact \" + jid + \" \" /* TODO + anonymizePhoneNumber(phoneNumber) */);\n        // Create the contact object\n        let contact = new Contact_1.Contact();\n        // Handle case where we have no jid\n        if (!jid) {\n            contact.id = phoneNumber;\n            contact._id = phoneNumber;\n            contact.initials = \"?\";\n            contact.displayName = phoneNumber ? phoneNumber : \"Unknown contact\";\n            contact.lastName = phoneNumber ? phoneNumber : \"Unknown contact\";\n            contact.firstName = \"\";\n            contact.phoneProCan = phoneNumber ? phoneNumber : \"\";\n            contact.temp = true;\n            contact.loginEmail = \"noEmail\";\n            contact.avatar = {}; // new Image();\n            contact.avatar.src = \"/resources/skins/rainbow/images/conversations/unknownContact.png\";\n            contact.setNameUpdatePrio(Contact_1.NameUpdatePrio.NO_UPDATE_PRIO); //not yet updated\n            return contact;\n        }\n        // Compute the contact id\n        let contactId = jid;\n        if (!contactId) {\n            contactId = phoneNumber;\n            contact.phoneProCan = phoneNumber;\n        }\n        if (!contactId) {\n            contactId = \"anonymous\";\n        }\n        // Configure contact\n        contact.jid = jid;\n        contact.jid_im = jid;\n        contact.jidtel = \"tel_\" + jid;\n        contact.id = contactId;\n        contact._id = jid;\n        contact.ask = \"none\";\n        contact.subscription = \"none\";\n        // TODO ? contact.updateRichStatus();\n        contact.roster = false;\n        contact.presence = \"offline\";\n        contact.status = \"\";\n        // Append in contact list\n        // that._contacts[contact.id] = contact;\n        that._contacts.push(contact);\n        return contact;\n    }\n    /**\n     * @public\n     * @method getContactByJid\n     * @instance\n     * @param {string} jid The contact jid\n     * @description\n     *  Get a contact by his JID by searching in the connected user _contacts list (full information) and if not found by searching on the server too (limited set of information)\n     * @async\n     * @return {Promise<Contact, ErrorManager>}\n     * @fulfil {Contact} - Found contact or null or an error object depending on the result\n     * @category async\n     */\n    getContactByJid(jid) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            if (!jid) {\n                that._logger.log(\"warn\", LOG_ID + \"(getContactByJid) bad or empty 'jid' parameter\", jid);\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            else {\n                let contactFound = null;\n                if (that._contacts) {\n                    contactFound = that._contacts.find((contact) => {\n                        return contact.jid_im === jid;\n                    });\n                }\n                if (contactFound) {\n                    that._logger.log(\"info\", LOG_ID + \"(getContactByJid) contact found locally with jid \", jid);\n                    resolve(contactFound);\n                }\n                else {\n                    that._logger.log(\"debug\", LOG_ID + \"(getContactByJid) contact not found locally. Ask the server...\");\n                    that._rest.getContactInformationByJID(jid).then((_contactFromServer) => {\n                        let contact = null;\n                        if (_contactFromServer) {\n                            that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server\", _contactFromServer);\n                            let contactIndex = that._contacts.findIndex((value) => {\n                                return value.jid_im === _contactFromServer.jid_im;\n                            });\n                            if (contactIndex !== -1) {\n                                contact = that._contacts[contactIndex];\n                                that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on local _contacts\", contact);\n                            }\n                            else {\n                                contact = that.createBasicContact(_contactFromServer.jid_im, undefined);\n                            }\n                            //that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) before updateFromUserData \", contact);\n                            contact.updateFromUserData(_contactFromServer);\n                            contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n                        }\n                        else {\n                            that._logger.log(\"info\", LOG_ID + \"(getContactByJid) no contact found on the server with Jid\", jid);\n                        }\n                        resolve(contact);\n                    }).catch((err) => {\n                        return reject(err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * @public\n     * @method getContactById\n     * @instance\n     * @param {string} id The contact id\n     * @param {boolean} forceServerSearch Boolean to force the search of the _contacts informations on the server.\n     * @description\n     *  Get a contact by his id\n     * @async\n     * @return {Promise<Contact, ErrorManager>}\n     * @fulfil {Contact} - Found contact or null or an error object depending on the result\n     * @category async\n     */\n    getContactById(id, forceServerSearch) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            if (!id) {\n                that._logger.log(\"warn\", LOG_ID + \"(getContactById) bad or empty 'id' parameter\", id);\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            else {\n                let contactFound = null;\n                if (that._contacts && !forceServerSearch) {\n                    contactFound = that._contacts.find((contact) => {\n                        return contact.id === id;\n                    });\n                }\n                if (contactFound) {\n                    that._logger.log(\"internal\", LOG_ID + \"(getContactById) contact found locally\", contactFound);\n                    resolve(contactFound);\n                }\n                else {\n                    that._logger.log(\"debug\", LOG_ID + \"(getContactById) contact not found locally. Ask the server...\");\n                    that._rest.getContactInformationByID(id).then((_contactFromServer) => {\n                        let contact = null;\n                        if (_contactFromServer) {\n                            that._logger.log(\"internal\", LOG_ID + \"(getContactById) contact found on the server\", _contactFromServer);\n                            that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on the server\");\n                            let contactIndex = that._contacts.findIndex((value) => {\n                                return value.jid_im === _contactFromServer.jid_im;\n                            });\n                            if (contactIndex !== -1) {\n                                //that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on local _contacts\", contact);\n                                that._logger.log(\"info\", LOG_ID + \"(getContactById) contact found on local _contacts\");\n                                contact = that._contacts[contactIndex];\n                            }\n                            else {\n                                contact = that.createBasicContact(_contactFromServer.jid_im, undefined);\n                            }\n                            //that._logger.log(\"internal\", LOG_ID + \"(getContactById) before updateFromUserData \", contact);\n                            contact.updateFromUserData(_contactFromServer);\n                            contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n                        }\n                        else {\n                            that._logger.log(\"info\", LOG_ID + \"(getContactById) no contact found on server with id\", id);\n                        }\n                        resolve(contact);\n                    }).catch((err) => {\n                        return reject(err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * @public\n     * @method getContactByLoginEmail\n     * @instance\n     * @param {string} loginEmail The contact loginEmail\n     * @description\n     *  Get a contact by his loginEmail\n     * @async\n     * @return {Promise<Contact, ErrorManager>}\n     * @fulfil {Contact} - Found contact or null or an error object depending on the result\n     * @category async\n     */\n    getContactByLoginEmail(loginEmail) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            return new Promise((resolve, reject) => {\n                if (!loginEmail) {\n                    this._logger.log(\"warn\", LOG_ID + \"(getContactByLoginEmail) bad or empty 'loginEmail' parameter\");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(getContactByLoginEmail) bad or empty 'loginEmail' parameter : \", loginEmail);\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                }\n                else {\n                    let contactFound = null;\n                    if (that._contacts) {\n                        contactFound = that._contacts.find((contact) => {\n                            return contact.loginEmail === loginEmail;\n                        });\n                    }\n                    if (contactFound) {\n                        that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) contact found locally : \", contactFound);\n                        resolve(contactFound);\n                    }\n                    else {\n                        that._logger.log(\"debug\", LOG_ID + \"(getContactByLoginEmail) contact not found locally. Ask server...\");\n                        that._rest.getContactInformationByLoginEmail(loginEmail).then((contactsFromServeur) => __awaiter(this, void 0, void 0, function* () {\n                            if (contactsFromServeur && contactsFromServeur.length > 0) {\n                                let contact = null;\n                                that._logger.log(\"info\", LOG_ID + \"(getContactByLoginEmail) contact found on server\");\n                                let _contactFromServer = contactsFromServeur[0];\n                                if (_contactFromServer) {\n                                    // The contact is not found by email in the that._contacts tab, so it need to be find on server to get or update it.\n                                    yield that.getContactById(_contactFromServer.id, true).then((contactInformation) => {\n                                        contact = contactInformation;\n                                        // Workaround because server does not return the email when not in same company, even if it has been found by email on server.\n                                        if (!contact.loginEmail) {\n                                            contact.loginEmail = loginEmail;\n                                        }\n                                        that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) full data contact : \", contact, \", found on server with loginEmail : \", loginEmail);\n                                        /*let contactIndex = that._contacts.findIndex((value) => {\n                                            return value.jid_im === contactInformation.jid_im;\n                                        });\n    \n                                        if (contactIndex !== -1) {\n                                            contact = that._contacts[contactIndex];\n                                        } else {\n                                            contact = that.createBasicContact(contactInformation.jid_im, undefined);\n                                        }\n                                        //that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) before updateFromUserData \", contact);\n                                        contact.updateFromUserData(contactInformation);\n                                        contact.avatar = that.getAvatarByContactId(contactInformation.id, contactInformation.lastAvatarUpdateDate);\n    \n                                         */\n                                    });\n                                }\n                                else {\n                                    that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) no contact found on server with loginEmail : \", loginEmail);\n                                }\n                                resolve(contact);\n                            }\n                            else {\n                                that._logger.log(\"internal\", LOG_ID + \"(getContactByLoginEmail) contact not found on server with loginEmail : \", loginEmail);\n                                resolve(null);\n                            }\n                        })).catch((err) => {\n                            return reject(err);\n                        });\n                    }\n                }\n            });\n        });\n    }\n    /**\n     * @public\n     * @method getAvatarByContactId\n     * @instance\n     * @param {string} id The contact id\n     * @param {string} lastAvatarUpdateDate use this field to give the stored date ( could be retrieved with contact.lastAvatarUpdateDate )\n     *      if missing or null in case where no avatar available a local module file is provided instead of URL\n     * @description\n     *  Get a contact avatar by his contact id\n     * @return {String} Contact avatar URL or file\n     */\n    getAvatarByContactId(id, lastUpdate) {\n        if (lastUpdate) {\n            return this.avatarDomain + \"/api/avatar/\" + id + \"?update=\" + md5(lastUpdate);\n        }\n        return path.resolve(__dirname, \"../resources/unknownContact.png\");\n    }\n    // ************************************************** //\n    // **  jid utilities                               ** //\n    // ************************************************** //\n    isTelJid(jid) {\n        return (jid.indexOf(\"tel_\") === 0);\n    }\n    getImJid(jid) {\n        let that = this;\n        let bareJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\n        return that.isTelJid(bareJid) ? bareJid.substring(4) : bareJid;\n    }\n    getRessourceFromJid(jid) {\n        let result = \"\";\n        if (jid) {\n            let index = jid.indexOf(\"/\");\n            if (index !== -1) {\n                result = jid.substr(index + 1);\n            }\n        }\n        return result;\n    }\n    isUserContactJid(jid) {\n        let that = this;\n        if (!that._rest.account) {\n            return false;\n        }\n        return (that._rest.account.jid_im === jid);\n    }\n    isUserContact(contact) {\n        let that = this;\n        if (!contact || !contact.jid) {\n            return false;\n        }\n        if (!that._rest.account) {\n            return (contact.jid === that._xmpp.jid);\n        }\n        return (that._rest.account.jid === contact.jid);\n    }\n    /**\n     * @public\n     * @method getConnectedUser\n     * @instance\n     * @description\n     *    Get the connected user information\n     * @return {Contact} Return a Contact object representing the connected user information or null if not connected\n     */\n    getConnectedUser() {\n        let that = this;\n        if (!that._rest.account) {\n            return null;\n        }\n        // Create the contact object\n        let contact = new Contact_1.Contact();\n        //that._logger.log(\"internal\", LOG_ID + \"(getContactById) before updateFromUserData \", contact);\n        contact.updateFromUserData(that._rest.account);\n        contact.avatar = that.getAvatarByContactId(that._rest.account.id, that._rest.account.lastAvatarUpdateDate);\n        contact.status = that._presenceService.getUserConnectedPresence().status;\n        return contact;\n    }\n    /**\n     * @public\n     * @since 1.17\n     * @method\n     * @instance\n     * @description\n     *    Send an invitation to a Rainbow user for joining his network. <br>\n     *    The user will receive an invitation that can be accepted or declined <br>\n     *    In return, when accepted, he will be part of your network <br>\n     *    When in the same company, invitation is automatically accepted (ie: can't be declined)\n     * @param {Contact} contact The contact object to subscribe\n     * @return {Object} A promise that contains the contact added or an object describing an error\n     */\n    addToNetwork(contact) {\n        return this.addToContactsList(contact);\n    }\n    /**\n     * @public\n     * @since 1.17\n     * @method addToContactsList\n     * @instance\n     * @description\n     *    Send an invitation to a Rainbow user for joining his network. <br>\n     *    The user will receive an invitation that can be accepted or declined <br>\n     *    In return, when accepted, he will be part of your network <br>\n     *    When in the same company, invitation is automatically accepted (ie: can't be declined)\n     * @param {Contact} contact The contact object to subscribe\n     * @return {Object} A promise that contains the contact added or an object describing an error\n     * @category async\n     */\n    addToContactsList(contact) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            if (!contact) {\n                this._logger.log(\"warn\", LOG_ID + \"(addToContactsList) bad or empty 'contact' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(addToContactsList) bad or empty 'contact' parameter : \", contact);\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            else {\n                that._logger.log(\"internal\", LOG_ID + \"(addToContactsList) contact invitation to server... : \", contact);\n                that._rest.joinContactInvitation(contact).then((_contact) => {\n                    if (_contact && _contact.status !== undefined) {\n                        that._logger.log(\"info\", LOG_ID + \"(addToContactsList) contact invited : \", _contact.invitedUserId);\n                        that.getContactById(_contact.invitedUserId, false).then((invitedUser) => {\n                            resolve(invitedUser);\n                        }).catch((err) => {\n                            return reject(err);\n                        });\n                    }\n                    else {\n                        that._logger.log(\"internal\", LOG_ID + \"(addToContactsList) contact cannot be added : \", util.inspect(contact));\n                        resolve(null);\n                    }\n                }).catch((err) => {\n                    return reject(err);\n                });\n            }\n        });\n    }\n    /**\n     * @public\n     * @since 1.64.0\n     * @method getInvitationById\n     * @instance\n     * @description\n     *    Get an invite by its id\n     * @param {String} strInvitationId the id of the invite to retrieve\n     * @return {Invitation} The invite if found\n     */\n    getInvitationById(strInvitationId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!strInvitationId) {\n                this._logger.log(\"warn\", LOG_ID + \"(getInvitationById) bad or empty 'strInvitationId' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(getInvitationById) bad or empty 'strInvitationId' parameter : \", strInvitationId);\n                let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n                error.msg += \", invitation not defined, can not getInvitationById\";\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            return this._invitationsService.getInvitation(strInvitationId);\n        });\n    }\n    ;\n    /**\n     * @public\n     * @since 1.17\n     * @method\n     * @instance\n     * @description\n     *    Accept an invitation from an other Rainbow user to mutually join the network <br>\n     *    Once accepted, the user will be part of your network. <br>\n     *    Return a promise\n     * @param {Invitation} invitation The invitation to accept\n     * @return {Object} A promise that contains SDK.OK if success or an object that describes the error\n     */\n    acceptInvitation(invitation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            that._logger.log(\"internal\", LOG_ID + \"(acceptInvitation) invitation : \", invitation);\n            if (!invitation) {\n                let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n                error.msg += \", invitation not defined, can not acceptInvitation\";\n                throw error;\n            }\n            else {\n                return that._invitationsService.acceptInvitation(invitation);\n                //return that._rest.acceptInvitation(invitation);\n            }\n        });\n    }\n    ;\n    /**\n     * @public\n     * @since 1.17\n     * @method\n     * @instance\n     * @description\n     *    Decline an invitation from an other Rainbow user to mutually join the network <br>\n     *    Once declined, the user will not be part of your network. <br>\n     *    Return a promise\n     * @param {Invitation} invitation The invitation to decline\n     * @return {Object} A promise that contains SDK.OK in case of success or an object that describes the error\n     */\n    declineInvitation(invitation) {\n        let that = this;\n        that._logger.log(\"internal\", LOG_ID + \"(declineInvitation) intivation : \", invitation);\n        if (!invitation) {\n            let error = ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST;\n            error.msg += \", invitation not defined, can not declineInvitation\";\n            throw error;\n        }\n        else {\n            return that._invitationsService.declineInvitation(invitation);\n            //return that._rest.declineInvitation(invitation);\n        }\n    }\n    ;\n    /**\n     * @typedef {Object} joinContactsResult\n     * @property {String[]} success List of succeed joined users\n     * @property {String[]} failed List of failed to joined users\n     */\n    /**\n     * @public\n     * @since 1.41\n     * @beta\n     * @method joinContacts\n     * @instance\n     * @description\n     *    As admin, add _contacts to a user roster\n     * @param {Contact} contact The contact object to subscribe\n     * @param {String[]} contactIds List of contactId to add to the user roster\n     * @async\n     * @return {Promise<joinContactsResult, ErrorManager>}\n     * @fulfil {joinContactsResult} - Join result or an error object depending on the result\n     * @category async\n     */\n    joinContacts(contact, contactIds) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            if (!contact) {\n                this._logger.log(\"warn\", LOG_ID + \"(joinContacts) bad or empty 'contact' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(joinContacts) bad or empty 'contact' parameter : \", contact);\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            else {\n                that._logger.log(\"debug\", LOG_ID + \"(joinContacts) contact join to server...\");\n                let promises = [];\n                contactIds.forEach((contactId) => {\n                    promises.push(that._rest.joinContacts(contact, [contactId], false).then((result) => {\n                        return Promise.resolve({ \"success\": [contactId] });\n                    }).catch((err) => {\n                        if (err.code === 409) {\n                            resolve({ \"success\": [contactId] });\n                        }\n                        resolve({ \"failed\": [contactId] });\n                    }));\n                });\n                Promise.all(promises).then((values) => {\n                    let mergeResult = values.reduce((prev, current) => {\n                        return Object.assign(prev, current);\n                    }, { \"success\": [], \"failed\": [] });\n                    that._logger.log(\"internal\", LOG_ID + \"(joinContacts) \" + mergeResult.success.length + \" contact(s) joined, \" + mergeResult.failed.length + \" contact(s) failed \");\n                    resolve(mergeResult);\n                }).catch((err) => {\n                    return reject(err);\n                });\n            }\n        });\n    }\n    /**\n     * @private\n     * @method _onRosterPresenceChanged\n     * @instance\n     * @param {Object} presence contains informations about contact changes\n     * @description\n     *      Method called when the presence of a contact changed\n     */\n    _onRosterPresenceChanged(presence) {\n        let contact = this._contacts.find((contactItem) => {\n            return contactItem.jid_im === presence.jid;\n        });\n        if (contact) {\n            if (!contact.resources) {\n                contact.resources = {};\n            }\n            // Store the presence of the resource\n            contact.resources[presence.resource] = presence.value;\n            let on_the_phone = false;\n            let manual_invisible = false;\n            let manual_dnd = false;\n            let manual_away = false;\n            let in_presentation_mode = false;\n            let in_webrtc_mode = false;\n            let webrtc_reason = \"\";\n            let is_online = false;\n            let is_online_mobile = false;\n            let auto_away = false;\n            let is_offline = false;\n            for (let resourceId in contact.resources) {\n                let resource = contact.resources[resourceId];\n                if (resource.type !== \"phone\") {\n                    if (resource.show === \"xa\" && resource.status === \"\") {\n                        manual_invisible = true;\n                    }\n                    else if (resource.show === \"dnd\" && resource.status === \"\") {\n                        manual_dnd = true;\n                    }\n                    else if (resource.show === \"xa\" && resource.status === \"away\") {\n                        manual_away = true;\n                    }\n                    else if (resource.show === \"dnd\" && resource.status === \"presentation\") {\n                        in_presentation_mode = true;\n                    }\n                    else if (resource.show === \"dnd\" && resource.status.length > 0) {\n                        in_webrtc_mode = true;\n                        webrtc_reason = resource.status;\n                    }\n                    else if ((resource.show === \"\" || resource.show === \"online\") && (resource.status === \"\" || resource.status === \"mode=auto\")) {\n                        if (resource.type === \"mobile\") {\n                            is_online_mobile = true;\n                        }\n                        else {\n                            is_online = true;\n                        }\n                    }\n                    else if (resource.show === \"away\" && resource.status === \"\") {\n                        auto_away = true;\n                    }\n                    else if (resource.show === \"unavailable\") {\n                        is_offline = true;\n                    }\n                }\n                else {\n                    if ((resource.status === \"EVT_SERVICE_INITIATED\" || resource.status === \"EVT_ESTABLISHED\") && resource.show === \"chat\") {\n                        on_the_phone = true;\n                    }\n                    if (resource.status === \"EVT_CONNECTION_CLEARED\" && resource.show === \"chat\") {\n                        on_the_phone = false;\n                    }\n                }\n            }\n            // Store previous presence state\n            let oldPresence = contact.presence;\n            let oldStatus = contact.status;\n            if (on_the_phone) {\n                contact.presence = \"busy\";\n                contact.status = \"phone\";\n            }\n            else if (manual_invisible) {\n                contact.presence = \"offline\";\n                contact.status = \"\";\n            }\n            else if (manual_dnd) {\n                contact.presence = \"busy\";\n                contact.status = \"\";\n            }\n            else if (manual_away) {\n                contact.presence = \"away\";\n                contact.status = \"\";\n            }\n            else if (in_presentation_mode) {\n                contact.presence = \"busy\";\n                contact.status = \"presentation\";\n            }\n            else if (in_webrtc_mode) {\n                contact.presence = \"busy\";\n                contact.status = webrtc_reason;\n            }\n            else if (is_online) {\n                contact.presence = \"online\";\n                contact.status = \"\";\n            }\n            else if (is_online_mobile) {\n                contact.presence = \"online\";\n                contact.status = \"mobile\";\n            }\n            else if (auto_away) {\n                contact.presence = \"away\";\n                contact.status = \"\";\n            }\n            else if (is_offline && contact.presence !== \"unknown\") {\n                contact.presence = \"offline\";\n                contact.status = \"\";\n            }\n            else {\n                contact.presence = \"unknown\";\n                contact.status = \"\";\n            }\n            if (contact.resources[presence.resource].show === \"unavailable\") {\n                delete contact.resources[presence.resource];\n            }\n            if (contact.presence === oldPresence && contact.status === oldStatus) {\n                return;\n            }\n            let presenceDisplayed = contact.status.length > 0 ? contact.presence + \"|\" + contact.status : contact.presence;\n            this._logger.log(\"internal\", LOG_ID + \"(onRosterPresenceChanged) presence changed to \" + presenceDisplayed + \" for \" + this.getDisplayName(contact));\n            this._eventEmitter.emit(\"evt_internal_onrosterpresencechanged\", contact);\n        }\n        else {\n            this._logger.log(\"warn\", LOG_ID + \"(onRosterPresenceChanged) no contact found for \" + presence.jid);\n            // Seems to be a pending presence update in roster associated contact not yet available\n            if (presence.value.show !== \"unavailable\") {\n                // To a pending presence queue\n                this._rosterPresenceQueue.push({ presence, date: Date.now() });\n            }\n        }\n    }\n    /**\n     * @private\n     * @method _onContactInfoChanged\n     * @instance\n     * @param {string} jid modified roster contact Jid\n     * @description\n     *     Method called when an roster user information are updated\n     */\n    _onContactInfoChanged(jid) {\n        let that = this;\n        that._rest.getContactInformationByJID(jid).then((_contactFromServer) => {\n            that._logger.log(\"info\", LOG_ID + \"(getContactByJid) contact found on the server\");\n            that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server : \", util.inspect(_contactFromServer));\n            let contactIndex = -1;\n            // Update or Add contact\n            if (that._contacts) {\n                contactIndex = that._contacts.findIndex((_contact) => {\n                    return _contact.jid_im === _contactFromServer.jid_im;\n                });\n                let contact = null;\n                that._logger.log(\"internal\", LOG_ID + \"(getContactByJid) contact found on the server : \", contact);\n                if (contactIndex !== -1) {\n                    contact = that._contacts[contactIndex];\n                    //that._logger.log(\"internal\", LOG_ID + \"(_onContactInfoChanged) local contact before updateFromUserData \", contact);\n                    contact.updateFromUserData(_contactFromServer);\n                    contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n                    this._eventEmitter.emit(\"evt_internal_contactinformationchanged\", that._contacts[contactIndex]);\n                }\n                else {\n                    contact = that.createBasicContact(_contactFromServer.jid_im, undefined);\n                    //that._logger.log(\"internal\", LOG_ID + \"(_onContactInfoChanged) from server contact before updateFromUserData \", contact);\n                    contact.updateFromUserData(_contactFromServer);\n                    contact.avatar = that.getAvatarByContactId(_contactFromServer.id, _contactFromServer.lastAvatarUpdateDate);\n                    this._eventEmitter.emit(\"evt_internal_contactinformationchanged\", contact);\n                }\n            }\n        }).catch((err) => {\n            this._logger.log(\"info\", LOG_ID + \"(_onContactInfoChanged) no contact found with jid \" + jid);\n        });\n    }\n    /**\n     * @private\n     * @method _onUserInviteReceived\n     * @instance\n     * @param {Object} data contains the invitationId\n     * @description\n     *      Method called when an user invite is received\n     */\n    /* _onUserInviteReceived(data) {\n        let that = this;\n\n        that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteReceived) enter\");\n        that._logger.log(\"internal\", LOG_ID + \"(_onUserInviteReceived) enter : \", data);\n\n        that._rest.getInvitationById(data.invitationId).then( (invitation : any) => {\n            that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteReceived) invitation received id\", invitation.id);\n\n            that._eventEmitter.emit(\"evt_internal_userinvitereceived\", invitation);\n        }, err => {\n            that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteReceived) no invitation found for \" + data.invitationId);\n        });\n    } // */\n    /**\n     * @private\n     * @method _onUserInviteAccepted\n     * @instance\n     * @param {Object} data contains the invitationId\n     * @description\n     *      Method called when an user invite is accepted\n     */\n    /* _onUserInviteAccepted(data) {\n        let that = this;\n\n        that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteAccepted) enter\");\n\n        that._rest.getInvitationById(data.invitationId).then((invitation : any) => {\n            that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteAccepted) invitation accepted id\", invitation.id);\n\n            that._eventEmitter.emit(\"evt_internal_userinviteaccepted\", invitation);\n        }, err => {\n            that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteAccepted) no invitation found for \" + data.invitationId);\n        });\n    } // */\n    /**\n     * @private\n     * @method _onUserInviteCanceled\n     * @instance\n     * @param {Object} data contains the invitationId\n     * @description\n     *      Method called when an user invite is canceled\n     */\n    /* _onUserInviteCanceled(data) {\n        let that = this;\n\n        that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteCanceled) enter\");\n\n        that._rest.getInvitationById(data.invitationId).then((invitation: any) => {\n            that._logger.log(\"debug\", LOG_ID + \"(_onUserInviteCanceled) invitation canceled id\", invitation.id);\n            that._eventEmitter.emit(\"evt_internal_userinvitecanceled\", invitation);\n        }, err => {\n            that._logger.log(\"warn\", LOG_ID + \"(_onUserInviteCanceled) no invitation found for \" + data.invitationId);\n        });\n    } // */\n    /**\n     * @private\n     * @method _onRostersUpdate\n     * @instance\n     * @param {Object} _contacts contains a contact list with updated elements\n     * @description\n     *      Method called when the roster _contacts is updated\n     */\n    _onRostersUpdate(contacts) {\n        let that = this;\n        that._logger.log(\"debug\", LOG_ID + \"(_onRostersUpdate) enter\");\n        contacts.forEach(contact => {\n            if (contact.jid.substr(0, 3) !== \"tel\") { // Ignore telephonny events\n                if (contact.subscription === \"remove\") {\n                    let foundContact = that._contacts.find(item => item.jid_im === contact.jid);\n                    if (foundContact) {\n                        foundContact.presence = \"unknown\";\n                        // Add suppression delay\n                        setTimeout(() => {\n                            that._contacts = that._contacts.filter(_contact => _contact.jid_im !== contact.jid);\n                        }, 3000);\n                    }\n                    return;\n                }\n                if (contact.subscription === \"both\") {\n                    if (!that._contacts.find(item => {\n                        return item.jid_im === contact.jid;\n                    })) {\n                        that\n                            .getContactByJid(contact.jid)\n                            .then((_contact) => {\n                            that\n                                ._contacts\n                                .push(Object.assign(_contact, {\n                                resources: {},\n                                presence: \"offline\",\n                                status: \"\"\n                            }));\n                            that._rosterPresenceQueue.filter(presenceItem => presenceItem.presence.jid === contact.jid).forEach(item => that._onRosterPresenceChanged(item.presence));\n                            let currentDate = Date.now();\n                            that._rosterPresenceQueue = that._rosterPresenceQueue.filter(presenceItem => presenceItem.presence.jid !== contact.jid || (presenceItem.date + 10000) < currentDate);\n                        });\n                    }\n                }\n            }\n        });\n    }\n};\nContacts = __decorate([\n    Utils_1.logEntryExit(LOG_ID),\n    Utils_1.isStarted([])\n    /**\n     * @module\n     * @name Contacts\n     * @version 1.67.1 \n     * @public\n     * @description\n     *       This module manages _contacts. A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information.<br>\n     *       Using this module, you can get access to your network _contacts or search for Rainbow _contacts.\n     *      <br><br>\n     *      The main methods proposed in that module allow to: <br>\n     *      - Get the network _contacts (roster) <br>\n     *      - Get and search _contacts by Id, JID or loginEmail <br>\n     */\n], Contacts);\nexports.ContactsService = Contacts;\nmodule.exports.Contacts = Contacts;\n//# sourceMappingURL=ContactsService.js.map"]},"metadata":{},"sourceType":"script"}