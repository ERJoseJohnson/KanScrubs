{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ErrorManager_1 = require(\"./ErrorManager\");\n\nconst utils = require(\"./Utils\");\n\nconst types = {\n  \"STARTED\": \"started\",\n  \"STARTING\": \"starting\",\n  \"CONNECTED\": \"connected\",\n  \"READY\": \"ready\",\n  \"STOPPED\": \"stopped\",\n  \"DISCONNECTED\": \"disconnected\",\n  \"RECONNECTING\": \"reconnecting\",\n  \"FAILED\": \"failed\",\n  \"ERROR\": \"error\"\n};\nconst LOG_ID = \"STATEMGR - \";\n\nclass StateManager {\n  constructor(_eventEmitter, logger) {\n    this.eventEmitter = _eventEmitter;\n    this.logger = logger; // Initial state\n\n    this.state = types.STOPPED;\n  }\n\n  start() {\n    let that = this;\n    this.logger.log(\"debug\", LOG_ID + \"(start) _entering_\");\n    return new Promise(function (resolve, reject) {\n      try {\n        if (that.isSTOPPED()) {\n          that.state = types.STARTING;\n          that.logger.log(\"info\", LOG_ID + \"(start) current state\", that.state);\n          that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n          resolve();\n        } else {\n          that.logger.log(\"error\", LOG_ID + \"(start) The Rainbow Node Sdk can not start because state \\\"\" + that.state + \"\\\" is not \\\"\" + types.STOPPED + \"\\\"  state. Please, call the stop method before start, or create a new rainbow-node-sdk instance\");\n          that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n          let err = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(-1, \"The Rainbow Node Sdk can not start when it is not in an idle state.\", \"The Rainbow Node Sdk can not start. Current state \\\"\" + that.state + \"\\\" is not \\\"\" + types.STOPPED + \"\\\" state. Please, call the stop method before start, or create a new rainbow-node-sdk instance\");\n          return reject(err);\n        }\n      } catch (err) {\n        that.state = types.STOPPED;\n        that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    this.logger.log(\"debug\", LOG_ID + \"(stop) _entering_\");\n    return new Promise(function (resolve, reject) {\n      try {\n        that.transitTo(types.STOPPED).then(() => {\n          that.logger.log(\"info\", LOG_ID + \"(stop) current state\", that.state);\n          that.logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\n          resolve();\n        }).catch(err => {\n          return reject(err);\n        });\n      } catch (err) {\n        that.logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\n        return reject(err);\n      }\n    });\n  }\n\n  transitTo(state, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (this.state === state) {\n          this.logger.log(\"info\", LOG_ID + \"(transitTo) the state is yet \", this.state, \", so ignore it.\");\n          resolve();\n        } else {\n          this.state = state;\n\n          if (this.isSTOPPED() || this.isREADY()) {\n            yield utils.setTimeoutPromised(1500).then(() => {\n              this.logger.log(\"info\", LOG_ID + \"(transitTo) set state\", this.state);\n              this.eventEmitter.publish(state, data);\n              resolve();\n            });\n          } else {\n            this.logger.log(\"info\", LOG_ID + \"(transitTo) set state\", this.state);\n            this.eventEmitter.publish(state, data);\n            resolve();\n          }\n        }\n      }));\n    });\n  }\n\n  get STOPPED() {\n    return types.STOPPED;\n  }\n\n  get CONNECTED() {\n    return types.CONNECTED;\n  }\n\n  get STARTED() {\n    return types.STARTED;\n  }\n\n  get STARTING() {\n    return types.STARTING;\n  }\n\n  get DISCONNECTED() {\n    return types.DISCONNECTED;\n  }\n\n  get RECONNECTING() {\n    return types.RECONNECTING;\n  }\n\n  get READY() {\n    return types.READY;\n  }\n\n  get FAILED() {\n    return types.FAILED;\n  }\n\n  get ERROR() {\n    return types.ERROR;\n  }\n\n  isSTOPPED() {\n    return this.state === types.STOPPED;\n  }\n\n  isCONNECTED() {\n    return this.state === types.CONNECTED;\n  }\n\n  isSTARTED() {\n    return this.state === types.STARTED;\n  }\n\n  isSTARTING() {\n    return this.state === types.STARTED;\n  }\n\n  isDISCONNECTED() {\n    return this.state === types.DISCONNECTED;\n  }\n\n  isRECONNECTING() {\n    return this.state === types.RECONNECTING;\n  }\n\n  isREADY() {\n    return this.state === types.READY;\n  }\n\n  isFAILED() {\n    return this.state === types.FAILED;\n  }\n\n  isERROR() {\n    return this.state === types.ERROR;\n  }\n\n}\n\nexports.StateManager = StateManager;\nmodule.exports.StateManager = StateManager;","map":{"version":3,"sources":["../../src/lib/common/StateManager.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAM,KAAK,GAAE,OAAO,CAAC,SAAD,CAApB;;AAEA,MAAM,KAAK,GAAG;AACV,aAAW,SADD;AAEV,cAAY,UAFF;AAGV,eAAa,WAHH;AAIV,WAAS,OAJC;AAKV,aAAW,SALD;AAMV,kBAAgB,cANN;AAOV,kBAAgB,cAPN;AAQV,YAAU,QARA;AASV,WAAS;AATC,CAAd;AAYA,MAAM,MAAM,GAAG,aAAf;;AAEA,MAAM,YAAN,CAAkB;AAKd,EAAA,WAAA,CAAY,aAAZ,EAA2B,MAA3B,EAAiC;AAC7B,SAAK,YAAL,GAAoB,aAApB;AACA,SAAK,MAAL,GAAc,MAAd,CAF6B,CAI7B;;AACA,SAAK,KAAL,GAAa,KAAK,CAAC,OAAnB;AACH;;AAED,EAAA,KAAK,GAAA;AACD,QAAI,IAAI,GAAG,IAAX;AAEA,SAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,oBAAlC;AAEA,WAAO,IAAI,OAAJ,CAAY,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AACvC,UAAI;AACA,YAAI,IAAI,CAAC,SAAL,EAAJ,EAAsB;AAClB,UAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,QAAnB;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,uBAAjC,EAA0D,IAAI,CAAC,KAA/D;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mBAAlC;AACA,UAAA,OAAO;AACV,SALD,MAKO;AACH,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,6DAAT,GAAyE,IAAI,CAAC,KAA9E,GAAsF,cAAtF,GAAuG,KAAK,CAAC,OAA7G,GAAuH,iGAAhJ;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mBAAlC;AACA,cAAI,GAAG,GAAG,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA/B,CAA2C,CAAC,CAA5C,EAA+C,qEAA/C,EAAsH,yDAAyD,IAAI,CAAC,KAA9D,GAAsE,cAAtE,GAAuF,KAAK,CAAC,OAA7F,GAAuG,gGAA7N,CAAV;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,OAZD,CAYE,OAAO,GAAP,EAAY;AACV,QAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,OAAnB;AACA,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mBAAlC;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAlBM,CAAP;AAmBH;;AAED,EAAA,IAAI,GAAA;AACA,QAAI,IAAI,GAAG,IAAX;AAEA,SAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,mBAAlC;AAEA,WAAO,IAAI,OAAJ,CAAY,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AACvC,UAAI;AACA,QAAA,IAAI,CAAC,SAAL,CAAe,KAAK,CAAC,OAArB,EAA8B,IAA9B,CAAmC,MAAK;AACpC,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,sBAAjC,EAAyD,IAAI,CAAC,KAA9D;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kBAAlC;AACA,UAAA,OAAO;AACV,SAJD,EAIG,KAJH,CAIU,GAAD,IAAO;AAAG,iBAAO,MAAM,CAAC,GAAD,CAAb;AAAqB,SAJxC;AAKH,OAND,CAME,OAAO,GAAP,EAAY;AACV,QAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAyB,MAAM,GAAG,kBAAlC;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAXM,CAAP;AAYH;;AAEK,EAAA,SAAS,CAAC,KAAD,EAAQ,IAAR,EAAa;;AACxB,aAAO,IAAI,OAAJ,CAAa,CAAO,OAAP,EAAgB,MAAhB,KAA0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC1C,YAAI,KAAK,KAAL,KAAe,KAAnB,EAA0B;AACtB,eAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,+BAAjC,EAAkE,KAAK,KAAvE,EAA8E,iBAA9E;AACA,UAAA,OAAO;AACV,SAHD,MAGO;AACH,eAAK,KAAL,GAAa,KAAb;;AACA,cAAI,KAAK,SAAL,MAAoB,KAAK,OAAL,EAAxB,EAAwC;AACpC,kBAAM,KAAK,CAAC,kBAAN,CAAyB,IAAzB,EAA+B,IAA/B,CAAoC,MAAK;AAC3C,mBAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,uBAAjC,EAA0D,KAAK,KAA/D;AACA,mBAAK,YAAL,CAAkB,OAAlB,CAA0B,KAA1B,EAAiC,IAAjC;AACA,cAAA,OAAO;AACV,aAJK,CAAN;AAKH,WAND,MAMO;AACH,iBAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,EAAwB,MAAM,GAAG,uBAAjC,EAA0D,KAAK,KAA/D;AACA,iBAAK,YAAL,CAAkB,OAAlB,CAA0B,KAA1B,EAAiC,IAAjC;AACA,YAAA,OAAO;AACV;AACJ;AACJ,OAlB6C,CAAvC,CAAP;AAmBH,K;AAAA;;AAED,MAAI,OAAJ,GAAW;AACP,WAAO,KAAK,CAAC,OAAb;AACH;;AAED,MAAI,SAAJ,GAAa;AACT,WAAO,KAAK,CAAC,SAAb;AACH;;AAED,MAAI,OAAJ,GAAW;AACP,WAAO,KAAK,CAAC,OAAb;AACH;;AAED,MAAI,QAAJ,GAAY;AACR,WAAO,KAAK,CAAC,QAAb;AACH;;AAED,MAAI,YAAJ,GAAgB;AACZ,WAAO,KAAK,CAAC,YAAb;AACH;;AAED,MAAI,YAAJ,GAAgB;AACZ,WAAO,KAAK,CAAC,YAAb;AACH;;AAED,MAAI,KAAJ,GAAS;AACL,WAAO,KAAK,CAAC,KAAb;AACH;;AAED,MAAI,MAAJ,GAAU;AACN,WAAO,KAAK,CAAC,MAAb;AACH;;AAED,MAAI,KAAJ,GAAS;AACL,WAAO,KAAK,CAAC,KAAb;AACH;;AAED,EAAA,SAAS,GAAA;AACL,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,OAA7B;AACH;;AAED,EAAA,WAAW,GAAA;AACP,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,SAA7B;AACH;;AAED,EAAA,SAAS,GAAA;AACL,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,OAA7B;AACH;;AAED,EAAA,UAAU,GAAA;AACN,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,OAA7B;AACH;;AAED,EAAA,cAAc,GAAA;AACV,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,YAA7B;AACH;;AAED,EAAA,cAAc,GAAA;AACV,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,YAA7B;AACH;;AAED,EAAA,OAAO,GAAA;AACH,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,KAA7B;AACH;;AAED,EAAA,QAAQ,GAAA;AACJ,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,MAA7B;AACH;;AAED,EAAA,OAAO,GAAA;AACH,WAAQ,KAAK,KAAL,KAAe,KAAK,CAAC,KAA7B;AACH;;AAtJa;;AA2JX,OAAA,CAAA,YAAA,GAAA,YAAA;AADP,MAAM,CAAC,OAAP,CAAe,YAAf,GAA8B,YAA9B","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ErrorManager_1 = require(\"./ErrorManager\");\nconst utils = require(\"./Utils\");\nconst types = {\n    \"STARTED\": \"started\",\n    \"STARTING\": \"starting\",\n    \"CONNECTED\": \"connected\",\n    \"READY\": \"ready\",\n    \"STOPPED\": \"stopped\",\n    \"DISCONNECTED\": \"disconnected\",\n    \"RECONNECTING\": \"reconnecting\",\n    \"FAILED\": \"failed\",\n    \"ERROR\": \"error\"\n};\nconst LOG_ID = \"STATEMGR - \";\nclass StateManager {\n    constructor(_eventEmitter, logger) {\n        this.eventEmitter = _eventEmitter;\n        this.logger = logger;\n        // Initial state\n        this.state = types.STOPPED;\n    }\n    start() {\n        let that = this;\n        this.logger.log(\"debug\", LOG_ID + \"(start) _entering_\");\n        return new Promise(function (resolve, reject) {\n            try {\n                if (that.isSTOPPED()) {\n                    that.state = types.STARTING;\n                    that.logger.log(\"info\", LOG_ID + \"(start) current state\", that.state);\n                    that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n                    resolve();\n                }\n                else {\n                    that.logger.log(\"error\", LOG_ID + \"(start) The Rainbow Node Sdk can not start because state \\\"\" + that.state + \"\\\" is not \\\"\" + types.STOPPED + \"\\\"  state. Please, call the stop method before start, or create a new rainbow-node-sdk instance\");\n                    that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n                    let err = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(-1, \"The Rainbow Node Sdk can not start when it is not in an idle state.\", \"The Rainbow Node Sdk can not start. Current state \\\"\" + that.state + \"\\\" is not \\\"\" + types.STOPPED + \"\\\" state. Please, call the stop method before start, or create a new rainbow-node-sdk instance\");\n                    return reject(err);\n                }\n            }\n            catch (err) {\n                that.state = types.STOPPED;\n                that.logger.log(\"debug\", LOG_ID + \"(start) _exiting_\");\n                return reject(err);\n            }\n        });\n    }\n    stop() {\n        let that = this;\n        this.logger.log(\"debug\", LOG_ID + \"(stop) _entering_\");\n        return new Promise(function (resolve, reject) {\n            try {\n                that.transitTo(types.STOPPED).then(() => {\n                    that.logger.log(\"info\", LOG_ID + \"(stop) current state\", that.state);\n                    that.logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\n                    resolve();\n                }).catch((err) => { return reject(err); });\n            }\n            catch (err) {\n                that.logger.log(\"debug\", LOG_ID + \"(stop) _exiting_\");\n                return reject(err);\n            }\n        });\n    }\n    transitTo(state, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                if (this.state === state) {\n                    this.logger.log(\"info\", LOG_ID + \"(transitTo) the state is yet \", this.state, \", so ignore it.\");\n                    resolve();\n                }\n                else {\n                    this.state = state;\n                    if (this.isSTOPPED() || this.isREADY()) {\n                        yield utils.setTimeoutPromised(1500).then(() => {\n                            this.logger.log(\"info\", LOG_ID + \"(transitTo) set state\", this.state);\n                            this.eventEmitter.publish(state, data);\n                            resolve();\n                        });\n                    }\n                    else {\n                        this.logger.log(\"info\", LOG_ID + \"(transitTo) set state\", this.state);\n                        this.eventEmitter.publish(state, data);\n                        resolve();\n                    }\n                }\n            }));\n        });\n    }\n    get STOPPED() {\n        return types.STOPPED;\n    }\n    get CONNECTED() {\n        return types.CONNECTED;\n    }\n    get STARTED() {\n        return types.STARTED;\n    }\n    get STARTING() {\n        return types.STARTING;\n    }\n    get DISCONNECTED() {\n        return types.DISCONNECTED;\n    }\n    get RECONNECTING() {\n        return types.RECONNECTING;\n    }\n    get READY() {\n        return types.READY;\n    }\n    get FAILED() {\n        return types.FAILED;\n    }\n    get ERROR() {\n        return types.ERROR;\n    }\n    isSTOPPED() {\n        return (this.state === types.STOPPED);\n    }\n    isCONNECTED() {\n        return (this.state === types.CONNECTED);\n    }\n    isSTARTED() {\n        return (this.state === types.STARTED);\n    }\n    isSTARTING() {\n        return (this.state === types.STARTED);\n    }\n    isDISCONNECTED() {\n        return (this.state === types.DISCONNECTED);\n    }\n    isRECONNECTING() {\n        return (this.state === types.RECONNECTING);\n    }\n    isREADY() {\n        return (this.state === types.READY);\n    }\n    isFAILED() {\n        return (this.state === types.FAILED);\n    }\n    isERROR() {\n        return (this.state === types.ERROR);\n    }\n}\nexports.StateManager = StateManager;\nmodule.exports.StateManager = StateManager;\n//# sourceMappingURL=StateManager.js.map"]},"metadata":{},"sourceType":"script"}