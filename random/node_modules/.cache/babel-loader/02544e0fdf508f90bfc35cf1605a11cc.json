{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar util = require('util');\n\nvar _require = require('triple-beam'),\n    SPLAT = _require.SPLAT;\n/**\r\n * Captures the number of format (i.e. %s strings) in a given string.\r\n * Based on `util.format`, see Node.js source:\r\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\r\n * @type {RegExp}\r\n */\n\n\nvar formatRegExp = /%[scdjifoO%]/g;\n/**\r\n * Captures the number of escaped % signs in a format string (i.e. %s strings).\r\n * @type {RegExp}\r\n */\n\nvar escapedPercent = /%%/g;\n\nvar Splatter = /*#__PURE__*/function () {\n  function Splatter(opts) {\n    _classCallCheck(this, Splatter);\n\n    this.options = opts;\n  }\n  /**\r\n     * Check to see if tokens <= splat.length, assign { splat, meta } into the\r\n     * `info` accordingly, and write to this instance.\r\n     *\r\n     * @param  {Info} info Logform info message.\r\n     * @param  {String[]} tokens Set of string interpolation tokens.\r\n     * @returns {Info} Modified info message\r\n     * @private\r\n     */\n\n\n  _createClass(Splatter, [{\n    key: \"_splat\",\n    value: function _splat(info, tokens) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat || [];\n      var percents = msg.match(escapedPercent);\n      var escapes = percents && percents.length || 0; // The expected splat is the number of tokens minus the number of escapes\n      // e.g.\n      // - { expectedSplat: 3 } '%d %s %j'\n      // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'\n      //\n      // Any \"meta\" will be arugments in addition to the expected splat size\n      // regardless of type. e.g.\n      //\n      // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });\n      // would result in splat of four (4), but only three (3) are expected. Therefore:\n      //\n      // extraSplat = 3 - 4 = -1\n      // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);\n      // splat = [100, 'wow', { such: 'js' }]\n\n      var expectedSplat = tokens.length - escapes;\n      var extraSplat = expectedSplat - splat.length;\n      var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : []; // Now that { splat } has been separated from any potential { meta }. we\n      // can assign this to the `info` object and write it to our format stream.\n      // If the additional metas are **NOT** objects or **LACK** enumerable properties\n      // you are going to have a bad time.\n\n      var metalen = metas.length;\n\n      if (metalen) {\n        for (var i = 0; i < metalen; i++) {\n          Object.assign(info, metas[i]);\n        }\n      }\n\n      info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));\n      return info;\n    }\n    /**\r\n      * Transforms the `info` message by using `util.format` to complete\r\n      * any `info.message` provided it has string interpolation tokens.\r\n      * If no tokens exist then `info` is immutable.\r\n      *\r\n      * @param  {Info} info Logform info message.\r\n      * @param  {Object} opts Options for this instance.\r\n      * @returns {Info} Modified info message\r\n      */\n\n  }, {\n    key: \"transform\",\n    value: function transform(info) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat; // No need to process anything if splat is undefined\n\n      if (!splat || !splat.length) {\n        return info;\n      } // Extract tokens, if none available default to empty array to\n      // ensure consistancy in expected results\n\n\n      var tokens = msg && msg.match && msg.match(formatRegExp); // This condition will take care of inputs with info[SPLAT]\n      // but no tokens present\n\n      if (!tokens && (splat || splat.length)) {\n        var metas = splat.length > 1 ? splat.splice(0) : splat; // Now that { splat } has been separated from any potential { meta }. we\n        // can assign this to the `info` object and write it to our format stream.\n        // If the additional metas are **NOT** objects or **LACK** enumerable properties\n        // you are going to have a bad time.\n\n        var metalen = metas.length;\n\n        if (metalen) {\n          for (var i = 0; i < metalen; i++) {\n            Object.assign(info, metas[i]);\n          }\n        }\n\n        return info;\n      }\n\n      if (tokens) {\n        return this._splat(info, tokens);\n      }\n\n      return info;\n    }\n  }]);\n\n  return Splatter;\n}();\n/*\r\n * function splat (info)\r\n * Returns a new instance of the splat format TransformStream\r\n * which performs string interpolation from `info` objects. This was\r\n * previously exposed implicitly in `winston < 3.0.0`.\r\n */\n\n\nmodule.exports = function (opts) {\n  return new Splatter(opts);\n};","map":{"version":3,"sources":["C:/Users/Jose Johnson/Desktop/KanScrubs/random/node_modules/logform/dist/splat.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","util","require","_require","SPLAT","formatRegExp","escapedPercent","Splatter","opts","options","value","_splat","info","tokens","msg","message","splat","percents","match","escapes","expectedSplat","extraSplat","metas","splice","metalen","assign","format","apply","concat","transform","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\r\n\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\r\n\r\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\r\n\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar util = require('util');\r\n\r\nvar _require = require('triple-beam'),\r\n    SPLAT = _require.SPLAT;\r\n/**\r\n * Captures the number of format (i.e. %s strings) in a given string.\r\n * Based on `util.format`, see Node.js source:\r\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\r\n * @type {RegExp}\r\n */\r\n\r\n\r\nvar formatRegExp = /%[scdjifoO%]/g;\r\n/**\r\n * Captures the number of escaped % signs in a format string (i.e. %s strings).\r\n * @type {RegExp}\r\n */\r\n\r\nvar escapedPercent = /%%/g;\r\n\r\nvar Splatter =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Splatter(opts) {\r\n    _classCallCheck(this, Splatter);\r\n\r\n    this.options = opts;\r\n  }\r\n  /**\r\n     * Check to see if tokens <= splat.length, assign { splat, meta } into the\r\n     * `info` accordingly, and write to this instance.\r\n     *\r\n     * @param  {Info} info Logform info message.\r\n     * @param  {String[]} tokens Set of string interpolation tokens.\r\n     * @returns {Info} Modified info message\r\n     * @private\r\n     */\r\n\r\n\r\n  _createClass(Splatter, [{\r\n    key: \"_splat\",\r\n    value: function _splat(info, tokens) {\r\n      var msg = info.message;\r\n      var splat = info[SPLAT] || info.splat || [];\r\n      var percents = msg.match(escapedPercent);\r\n      var escapes = percents && percents.length || 0; // The expected splat is the number of tokens minus the number of escapes\r\n      // e.g.\r\n      // - { expectedSplat: 3 } '%d %s %j'\r\n      // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'\r\n      //\r\n      // Any \"meta\" will be arugments in addition to the expected splat size\r\n      // regardless of type. e.g.\r\n      //\r\n      // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });\r\n      // would result in splat of four (4), but only three (3) are expected. Therefore:\r\n      //\r\n      // extraSplat = 3 - 4 = -1\r\n      // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);\r\n      // splat = [100, 'wow', { such: 'js' }]\r\n\r\n      var expectedSplat = tokens.length - escapes;\r\n      var extraSplat = expectedSplat - splat.length;\r\n      var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : []; // Now that { splat } has been separated from any potential { meta }. we\r\n      // can assign this to the `info` object and write it to our format stream.\r\n      // If the additional metas are **NOT** objects or **LACK** enumerable properties\r\n      // you are going to have a bad time.\r\n\r\n      var metalen = metas.length;\r\n\r\n      if (metalen) {\r\n        for (var i = 0; i < metalen; i++) {\r\n          Object.assign(info, metas[i]);\r\n        }\r\n      }\r\n\r\n      info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));\r\n      return info;\r\n    }\r\n    /**\r\n      * Transforms the `info` message by using `util.format` to complete\r\n      * any `info.message` provided it has string interpolation tokens.\r\n      * If no tokens exist then `info` is immutable.\r\n      *\r\n      * @param  {Info} info Logform info message.\r\n      * @param  {Object} opts Options for this instance.\r\n      * @returns {Info} Modified info message\r\n      */\r\n\r\n  }, {\r\n    key: \"transform\",\r\n    value: function transform(info) {\r\n      var msg = info.message;\r\n      var splat = info[SPLAT] || info.splat; // No need to process anything if splat is undefined\r\n\r\n      if (!splat || !splat.length) {\r\n        return info;\r\n      } // Extract tokens, if none available default to empty array to\r\n      // ensure consistancy in expected results\r\n\r\n\r\n      var tokens = msg && msg.match && msg.match(formatRegExp); // This condition will take care of inputs with info[SPLAT]\r\n      // but no tokens present\r\n\r\n      if (!tokens && (splat || splat.length)) {\r\n        var metas = splat.length > 1 ? splat.splice(0) : splat; // Now that { splat } has been separated from any potential { meta }. we\r\n        // can assign this to the `info` object and write it to our format stream.\r\n        // If the additional metas are **NOT** objects or **LACK** enumerable properties\r\n        // you are going to have a bad time.\r\n\r\n        var metalen = metas.length;\r\n\r\n        if (metalen) {\r\n          for (var i = 0; i < metalen; i++) {\r\n            Object.assign(info, metas[i]);\r\n          }\r\n        }\r\n\r\n        return info;\r\n      }\r\n\r\n      if (tokens) {\r\n        return this._splat(info, tokens);\r\n      }\r\n\r\n      return info;\r\n    }\r\n  }]);\r\n\r\n  return Splatter;\r\n}();\r\n/*\r\n * function splat (info)\r\n * Returns a new instance of the splat format TransformStream\r\n * which performs string interpolation from `info` objects. This was\r\n * previously exposed implicitly in `winston < 3.0.0`.\r\n */\r\n\r\n\r\nmodule.exports = function (opts) {\r\n  return new Splatter(opts);\r\n};"]},"metadata":{},"sourceType":"script"}