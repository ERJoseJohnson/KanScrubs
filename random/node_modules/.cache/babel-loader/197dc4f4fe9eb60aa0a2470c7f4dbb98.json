{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\n\nconst moment = require(\"moment\"); // @ts-ignore\n\n\nglobal.window = {};\n\nconst momentDurationFormatSetup = require(\"moment-duration-format\");\n\nmomentDurationFormatSetup(moment); // @ts-ignore\n\nglobal.window = undefined;\n\nconst GenericHandler = require(\"./genericHandler\");\n\nconst xml = require(\"@xmpp/xml\");\n\nconst Message_1 = require(\"../../common/models/Message\");\n\nconst Utils_1 = require(\"../../common/Utils\");\n\nconst LOG_ID = \"XMPP/HNDL/CONVERSATIONS - \";\nlet ConversationHistoryHandler = class ConversationHistoryHandler extends GenericHandler {\n  constructor(xmppService, conversationService) {\n    super(xmppService);\n    this.MESSAGE_MAM = \"urn:xmpp:mam:1.result\";\n    this.FIN_MAM = \"urn:xmpp:mam:1.fin\";\n    this.conversationService = conversationService;\n    let that = this;\n\n    this.onMamMessageReceived = function (msg, stanza) {\n      try {\n        // Get queryId and deleteId\n        let queryId = stanza.getChild(\"result\") ? stanza.getChild(\"result\").getAttr(\"queryid\") : null;\n\n        if (!queryId) {\n          queryId = stanza.getChild(\"fin\") ? stanza.getChild(\"fin\").getAttr(\"queryid\") : null;\n        } // jidTel are used for callLog\n\n\n        if (queryId && queryId.indexOf(\"tel_\") !== 0 && that.onHistoryMessageReceived) {\n          that.onHistoryMessageReceived(msg, stanza);\n        } // jidIm are used for history\n        else if (that.callLogHandler) {\n            that.callLogHandler(stanza);\n          }\n\n        return true;\n      } catch (error) {\n        return true;\n      }\n    };\n\n    this.onHistoryMessageReceived = (msg, stanza) => {\n      // Handle response\n      try {\n        var conversation = null;\n        var queryId = stanza.getChild(\"result\") ? stanza.getChild(\"result\").getAttr(\"queryid\") : null;\n\n        if (queryId) {\n          // Get associated conversation\n          conversation = this.conversationService.getConversationById(queryId);\n\n          if (conversation) {\n            // Extract info\n            let stanzaForwarded = stanza.getChild(\"result\").getChild(\"forwarded\");\n            let stanzaMessage = stanzaForwarded.getChild(\"message\");\n\n            if (stanzaMessage.getChild(\"call_log\")) {\n              return this.onWebrtcHistoryMessageReceived(stanza, conversation);\n            }\n\n            var brutJid = stanzaMessage.getAttr(\"from\"); // Extract fromJid\n\n            let fromJid;\n            let roomEvent = null;\n\n            if (brutJid.indexOf(\"room_\") === 0) {\n              fromJid = brutJid.split(\"/\")[1];\n            } else {\n              fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(brutJid);\n            }\n\n            if (!fromJid && stanzaMessage.getChild(\"event\")) {\n              roomEvent = stanzaMessage.getChild(\"event\").attr(\"name\") + \"\";\n              fromJid = stanzaMessage.getChild(\"event\").attr(\"jid\");\n\n              if (roomEvent === \"welcome\" && conversation.bubble && conversation.bubble.creator) {\n                let ownerContact = conversation.bubble.users.find(user => conversation.bubble.creator === user.userId);\n                fromJid = ownerContact ? ownerContact.jid_im : \"\";\n              }\n            }\n\n            if (!fromJid) {\n              that.logger.log(\"warn\", LOG_ID + \"[conversationService] onHistoryMessageReceived - Receive message without valid fromJid information\");\n              return true;\n            }\n\n            if (!conversation.pendingPromise) {\n              conversation.pendingPromise = [];\n            }\n\n            let promise = new Promise(resolve => {\n              conversationService._contacts.getContactByJid(fromJid).then(from => {\n                resolve(from);\n              }).catch(() => {\n                resolve(null);\n              });\n            }).then(from => __awaiter(this, void 0, void 0, function* () {\n              let type = stanzaMessage.getAttr(\"type\");\n              let messageId = stanzaMessage.getAttr(\"id\");\n              let date = new Date(stanzaForwarded.getChild(\"delay\").getAttr(\"stamp\"));\n              let body = stanzaMessage.getChild(\"body\").text();\n              let ack = stanzaMessage.getChild(\"ack\");\n              let oob = stanzaMessage.getChild(\"x\", \"jabber:x:oob\");\n              let conference = stanzaMessage.getChild(\"x\", \"jabber:x:audioconference\");\n              let content = stanzaMessage.getChild(\"content\", \"urn:xmpp:content\");\n\n              if (!from) {\n                that.logger.log(\"warn\", LOG_ID + \"[Conversation] onHistoryMessageReceived missing contact for jid : \" + fromJid + \", ignore message\"); //create basic contact\n\n                from = that.conversationService._contacts.createEmptyContactContact(fromJid);\n              }\n\n              if (roomEvent) {\n                that.logger.log(\"internal\", LOG_ID + \"[Conversation] (\" + conversation.id + \") add Room admin event message \" + roomEvent);\n                type = \"admin\"; // Ignore meeting events\n\n                if (conversation.bubble && conversation.bubble.isMeetingBubble()) {\n                  if (roomEvent === \"welcome\" || roomEvent === \"conferenceAdd\" || roomEvent === \"conferenceRemove\" || roomEvent === \"invitation\") {\n                    return true;\n                  }\n                }\n\n                if ((roomEvent === \"conferenceAdd\" || roomEvent === \"conferenceRemove\") && conversation.bubble && conversation.bubble.creator) {\n                  let ownerContact = conversation.bubble.users.find(user => conversation.bubble.creator === user.userId);\n                  from = ownerContact;\n                }\n              }\n\n              let message = conversation.getMessageById(messageId);\n\n              if (!message) {\n                message = conversation.historyMessages.find(item => {\n                  return item.id === messageId;\n                });\n              }\n\n              if (message) {\n                that.logger.log(\"info\", LOG_ID + \"[Conversation] (\" + conversation.id + \") try to add an already stored message with id \" + message.id);\n              } else {\n                // Create new message\n                let side = that.conversationService._contacts.isUserContact(from) ? Message_1.Message.Side.RIGHT : Message_1.Message.Side.LEFT;\n\n                switch (type) {\n                  case \"webrtc\":\n                    message = Message_1.Message.createWebRTCMessage(messageId, date, from, side, body, false);\n                    break;\n\n                  case \"admin\":\n                    message = Message_1.Message.createBubbleAdminMessage(messageId, date, from, roomEvent);\n                    break;\n\n                  default:\n                    if (oob && oob.children.length) {\n                      let url = oob.getChild(\"url\").text();\n                      let mime = oob.getChild(\"mime\").text();\n                      let filename = oob.getChild(\"filename\").text();\n                      let filesize = oob.getChild(\"size\").text();\n                      let fileId = Message_1.Message.extractFileIdFromUrl(url); // TODO later - let fileDescriptor = fileStorageService.getFileDescriptorById(fileId);\n\n                      let shortFileDescriptor = {\n                        id: fileId,\n                        url: url,\n                        mime: mime,\n                        filename: filename,\n                        filesize: filesize,\n                        previewBlob: null\n                      };\n                      message = Message_1.Message.createFileSharingMessage(messageId, date, from, side, body, false, shortFileDescriptor);\n                    } else {\n                      let isMarkdown = content && content.getAttr(\"type\") === \"text/markdown\";\n                      body = isMarkdown ? content.text() : body;\n                      message = Message_1.Message.create(messageId, date, from, side, body, false, isMarkdown);\n                    }\n\n                    break;\n                } // console.error(\"message \"+ JSON.stringify(message.date));\n\n\n                message.receiptStatus = ack.getAttr(\"read\") === \"true\" ? 5 : ack.getAttr(\"received\") === \"true\" ? 4 : 3; // if (conversation.bubble) {\n                // \tmessage.receiptStatus = 3;\n                // }\n\n                conversation.historyMessages.push(message);\n                return Promise.resolve();\n              }\n            }));\n            conversation.pendingPromise.push(promise);\n          }\n        } else {\n          // Get associated conversation\n          queryId = stanza.getChild(\"fin\").getAttr(\"queryid\");\n          conversation = this.conversationService.getConversationById(queryId);\n\n          if (conversation) {\n            if (conversation.pendingPromise) {\n              Promise.all(conversation.pendingPromise).then(() => {\n                // Extract info\n                conversation.historyComplete = stanza.getChild(\"fin\").getAttr(\"complete\") === \"true\";\n                let historyIndex = stanza.getChild(\"fin\").getChild(\"set\").getChild(\"first\") ? stanza.getChild(\"fin\").getChild(\"set\").getChild(\"first\").text() : -1; // Handle very particular case of historyIndex == -1\n\n                if (conversation.historyIndex === -1) {\n                  conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\n\n                  if (conversation.chatRenderer) {\n                    conversation.chatRenderer.prependMessages(conversation.messages, conversation.bubble);\n                  }\n                } // Classic case\n                else {\n                    conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\n\n                    if (conversation.chatRenderer) {\n                      conversation.chatRenderer.prependMessages(conversation.historyMessages, conversation.bubble);\n                    }\n                  }\n\n                conversation.historyIndex = historyIndex;\n                conversation.historyMessages = []; //that.logger.log(\"internal\", LOG_ID + \"[Conversation] onHistoryMessageReceived conversation not ordered: \", conversation);\n                // @ts-ignore\n\n                conversation.messages.sort((msg1, msg2) => new Date(msg1.date) - new Date(msg2.date)); //that.logger.log(\"internal\", LOG_ID + \"[Conversation] onHistoryMessageReceived conversation ordered by date: \", conversation);\n\n                if (conversation.messages && conversation.messages.length > 0) {\n                  conversation.lastMessageText = conversation.messages[conversation.messages.length - 1].content;\n                } else {\n                  // conversation.lastModification = conversation.historyIndex === \"\" ? new Date() : new Date(0);\n                  conversation.lastMessageText = \"\";\n                }\n\n                conversation.historyDefered.resolve(conversation);\n                delete conversation.pendingPromise;\n              });\n            } else {\n              // @ts-ignore\n              conversation.messages.sort((msg1, msg2) => new Date(msg1.date) - new Date(msg2.date));\n              conversation.historyDefered.resolve(conversation);\n            }\n          }\n        }\n\n        return true;\n      } catch (error) {\n        that.logger.log(\"error\", LOG_ID + \"[Conversation] onHistoryMessageReceived error \");\n        that.logger.log(\"internalerror\", LOG_ID + \"[Conversation] onHistoryMessageReceived error : \", error);\n        return true;\n      }\n    };\n\n    this.onWebrtcHistoryMessageReceived = (stanza, conversation) => {\n      let that = this;\n\n      try {\n        let stanzaMessage = stanza.getChild(\"result\").getChild(\"forwarded\").getChild(\"message\");\n        let messageId = stanzaMessage.getAttr(\"id\");\n        let stanzaMessageCallLog = stanzaMessage.getChild(\"call_log\");\n        let callerJid = stanzaMessageCallLog.getChild(\"caller\").text();\n        let state = stanzaMessageCallLog.getChild(\"state\").text();\n        let duration = 0;\n        let durationTxt = \"0\";\n\n        if (stanzaMessageCallLog.getChild(\"duration\")) {\n          duration = stanzaMessageCallLog.getChild(\"duration\").text();\n          duration = parseInt(String(duration), 10);\n        }\n\n        if (duration > 0) {\n          durationTxt = \"(\" + moment.duration(duration, \"ms\").format(\"h[H] mm[m] ss[s]\") + \")\";\n        } else {\n          duration = 0;\n        }\n\n        let date = stanzaMessageCallLog.getChild(\"date\").text();\n\n        if (date) {\n          date = new Date(date);\n        } else {\n          date = new Date(stanza.getChild(\"result\").getChild(\"forwarded\").getChild(\"delay\").attr(\"stamp\"));\n        }\n\n        let body = \"\";\n\n        if (state === \"missed\") {\n          body = \"missedCall||\" + date;\n        } else if (state === \"answered\") {\n          body = \"activeCallMsg||\" + date + \"||\" + durationTxt;\n        }\n\n        let message = conversation.getMessageById(messageId);\n\n        if (!message) {\n          message = conversation.historyMessages.find(function (item) {\n            return item.id === messageId;\n          });\n        }\n\n        if (message) {\n          that.logger.log(\"info\", LOG_ID + \"[Conversation] (\" + conversation.id + \") try to add an already stored message with id \" + message.id);\n        } else {\n          if (!conversation.pendingPromise) {\n            conversation.pendingPromise = [];\n          }\n\n          let promise = new Promise(resolve => {\n            conversationService._contacts.getContactByJid(callerJid).then(from => {\n              resolve(from);\n            }).catch(() => {\n              resolve(null);\n            });\n          }).then(from => {\n            // Create new message\n            if (!from) {\n              that.logger.log(\"warn\", LOG_ID + \"[Conversation] onWebrtcHistoryMessageReceived missing contact for jid : \" + callerJid + \", ignore message\"); //create basic contact\n\n              from = that.conversationService._contacts.createEmptyContactContact(callerJid);\n            }\n\n            let side = that.conversationService._contacts.isUserContact(from) ? Message_1.Message.Side.RIGHT : Message_1.Message.Side.LEFT;\n            message = Message_1.Message.createWebRTCMessage(messageId, date, from, side, body, false);\n            let ack = stanzaMessage.getChild('ack');\n\n            if (ack) {\n              message.receiptStatus = ack.getAttr(\"read\") === \"true\" ? 5 : ack.getAttr(\"received\") === \"true\" ? 4 : 3;\n            }\n\n            conversation.historyMessages.push(message);\n            return Promise.resolve();\n          });\n          conversation.pendingPromise.push(promise);\n        }\n\n        return true;\n      } catch (error) {\n        console.error(error);\n        return true;\n      }\n    };\n  }\n\n};\nConversationHistoryHandler = __decorate([Utils_1.logEntryExit(LOG_ID)], ConversationHistoryHandler);\nexports.ConversationHistoryHandler = ConversationHistoryHandler;\nmodule.exports.ConversationHistoryHandler = ConversationHistoryHandler;","map":{"version":3,"sources":["../../../src/lib/connection/XMPPServiceHandler/conversationHistoryHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\r\nconst moment = require(\"moment\");\r\n// @ts-ignore\r\nglobal.window = {};\r\nconst momentDurationFormatSetup = require(\"moment-duration-format\");\r\nmomentDurationFormatSetup(moment);\r\n// @ts-ignore\r\nglobal.window = undefined;\r\nconst GenericHandler = require(\"./genericHandler\");\r\nconst xml = require(\"@xmpp/xml\");\r\nconst Message_1 = require(\"../../common/models/Message\");\r\nconst Utils_1 = require(\"../../common/Utils\");\r\nconst LOG_ID = \"XMPP/HNDL/CONVERSATIONS - \";\r\nlet ConversationHistoryHandler = class ConversationHistoryHandler extends GenericHandler {\r\n    constructor(xmppService, conversationService) {\r\n        super(xmppService);\r\n        this.MESSAGE_MAM = \"urn:xmpp:mam:1.result\";\r\n        this.FIN_MAM = \"urn:xmpp:mam:1.fin\";\r\n        this.conversationService = conversationService;\r\n        let that = this;\r\n        this.onMamMessageReceived = function (msg, stanza) {\r\n            try {\r\n                // Get queryId and deleteId\r\n                let queryId = stanza.getChild(\"result\") ? stanza.getChild(\"result\").getAttr(\"queryid\") : null;\r\n                if (!queryId) {\r\n                    queryId = stanza.getChild(\"fin\") ? stanza.getChild(\"fin\").getAttr(\"queryid\") : null;\r\n                }\r\n                // jidTel are used for callLog\r\n                if (queryId && queryId.indexOf(\"tel_\") !== 0 && that.onHistoryMessageReceived) {\r\n                    that.onHistoryMessageReceived(msg, stanza);\r\n                }\r\n                // jidIm are used for history\r\n                else if (that.callLogHandler) {\r\n                    that.callLogHandler(stanza);\r\n                }\r\n                return true;\r\n            }\r\n            catch (error) {\r\n                return true;\r\n            }\r\n        };\r\n        this.onHistoryMessageReceived = (msg, stanza) => {\r\n            // Handle response\r\n            try {\r\n                var conversation = null;\r\n                var queryId = stanza.getChild(\"result\") ? stanza.getChild(\"result\").getAttr(\"queryid\") : null;\r\n                if (queryId) {\r\n                    // Get associated conversation\r\n                    conversation = this.conversationService.getConversationById(queryId);\r\n                    if (conversation) {\r\n                        // Extract info\r\n                        let stanzaForwarded = stanza.getChild(\"result\").getChild(\"forwarded\");\r\n                        let stanzaMessage = stanzaForwarded.getChild(\"message\");\r\n                        if (stanzaMessage.getChild(\"call_log\")) {\r\n                            return this.onWebrtcHistoryMessageReceived(stanza, conversation);\r\n                        }\r\n                        var brutJid = stanzaMessage.getAttr(\"from\");\r\n                        // Extract fromJid\r\n                        let fromJid;\r\n                        let roomEvent = null;\r\n                        if (brutJid.indexOf(\"room_\") === 0) {\r\n                            fromJid = brutJid.split(\"/\")[1];\r\n                        }\r\n                        else {\r\n                            fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(brutJid);\r\n                        }\r\n                        if (!fromJid && stanzaMessage.getChild(\"event\")) {\r\n                            roomEvent = stanzaMessage.getChild(\"event\").attr(\"name\") + \"\";\r\n                            fromJid = stanzaMessage.getChild(\"event\").attr(\"jid\");\r\n                            if (roomEvent === \"welcome\" && conversation.bubble && conversation.bubble.creator) {\r\n                                let ownerContact = conversation.bubble.users.find((user) => conversation.bubble.creator === user.userId);\r\n                                fromJid = ownerContact ? ownerContact.jid_im : \"\";\r\n                            }\r\n                        }\r\n                        if (!fromJid) {\r\n                            that.logger.log(\"warn\", LOG_ID + \"[conversationService] onHistoryMessageReceived - Receive message without valid fromJid information\");\r\n                            return true;\r\n                        }\r\n                        if (!conversation.pendingPromise) {\r\n                            conversation.pendingPromise = [];\r\n                        }\r\n                        let promise = new Promise((resolve) => {\r\n                            conversationService._contacts.getContactByJid(fromJid)\r\n                                .then((from) => {\r\n                                resolve(from);\r\n                            }).catch(() => {\r\n                                resolve(null);\r\n                            });\r\n                        }).then((from) => __awaiter(this, void 0, void 0, function* () {\r\n                            let type = stanzaMessage.getAttr(\"type\");\r\n                            let messageId = stanzaMessage.getAttr(\"id\");\r\n                            let date = new Date(stanzaForwarded.getChild(\"delay\").getAttr(\"stamp\"));\r\n                            let body = stanzaMessage.getChild(\"body\").text();\r\n                            let ack = stanzaMessage.getChild(\"ack\");\r\n                            let oob = stanzaMessage.getChild(\"x\", \"jabber:x:oob\");\r\n                            let conference = stanzaMessage.getChild(\"x\", \"jabber:x:audioconference\");\r\n                            let content = stanzaMessage.getChild(\"content\", \"urn:xmpp:content\");\r\n                            if (!from) {\r\n                                that.logger.log(\"warn\", LOG_ID + \"[Conversation] onHistoryMessageReceived missing contact for jid : \" + fromJid + \", ignore message\");\r\n                                //create basic contact\r\n                                from = that.conversationService._contacts.createEmptyContactContact(fromJid);\r\n                            }\r\n                            if (roomEvent) {\r\n                                that.logger.log(\"internal\", LOG_ID + \"[Conversation] (\" + conversation.id + \") add Room admin event message \" + roomEvent);\r\n                                type = \"admin\";\r\n                                // Ignore meeting events\r\n                                if (conversation.bubble && conversation.bubble.isMeetingBubble()) {\r\n                                    if (roomEvent === \"welcome\" ||\r\n                                        roomEvent === \"conferenceAdd\" ||\r\n                                        roomEvent === \"conferenceRemove\" ||\r\n                                        roomEvent === \"invitation\") {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                                if ((roomEvent === \"conferenceAdd\" || roomEvent === \"conferenceRemove\") && conversation.bubble && conversation.bubble.creator) {\r\n                                    let ownerContact = conversation.bubble.users.find((user) => conversation.bubble.creator === user.userId);\r\n                                    from = ownerContact;\r\n                                }\r\n                            }\r\n                            let message = conversation.getMessageById(messageId);\r\n                            if (!message) {\r\n                                message = conversation.historyMessages.find((item) => { return item.id === messageId; });\r\n                            }\r\n                            if (message) {\r\n                                that.logger.log(\"info\", LOG_ID + \"[Conversation] (\" + conversation.id + \") try to add an already stored message with id \" + message.id);\r\n                            }\r\n                            else {\r\n                                // Create new message\r\n                                let side = that.conversationService._contacts.isUserContact(from) ? Message_1.Message.Side.RIGHT : Message_1.Message.Side.LEFT;\r\n                                switch (type) {\r\n                                    case \"webrtc\":\r\n                                        message = Message_1.Message.createWebRTCMessage(messageId, date, from, side, body, false);\r\n                                        break;\r\n                                    case \"admin\":\r\n                                        message = Message_1.Message.createBubbleAdminMessage(messageId, date, from, roomEvent);\r\n                                        break;\r\n                                    default:\r\n                                        if (oob && oob.children.length) {\r\n                                            let url = oob.getChild(\"url\").text();\r\n                                            let mime = oob.getChild(\"mime\").text();\r\n                                            let filename = oob.getChild(\"filename\").text();\r\n                                            let filesize = oob.getChild(\"size\").text();\r\n                                            let fileId = Message_1.Message.extractFileIdFromUrl(url);\r\n                                            // TODO later - let fileDescriptor = fileStorageService.getFileDescriptorById(fileId);\r\n                                            let shortFileDescriptor = {\r\n                                                id: fileId,\r\n                                                url: url,\r\n                                                mime: mime,\r\n                                                filename: filename,\r\n                                                filesize: filesize,\r\n                                                previewBlob: null,\r\n                                            };\r\n                                            message = Message_1.Message.createFileSharingMessage(messageId, date, from, side, body, false, shortFileDescriptor);\r\n                                        }\r\n                                        else {\r\n                                            let isMarkdown = content && content.getAttr(\"type\") === \"text/markdown\";\r\n                                            body = isMarkdown ? content.text() : body;\r\n                                            message = Message_1.Message.create(messageId, date, from, side, body, false, isMarkdown);\r\n                                        }\r\n                                        break;\r\n                                }\r\n                                // console.error(\"message \"+ JSON.stringify(message.date));\r\n                                message.receiptStatus = ack.getAttr(\"read\") === \"true\" ? 5 : (ack.getAttr(\"received\") === \"true\" ? 4 : 3);\r\n                                // if (conversation.bubble) {\r\n                                // \tmessage.receiptStatus = 3;\r\n                                // }\r\n                                conversation.historyMessages.push(message);\r\n                                return Promise.resolve();\r\n                            }\r\n                        }));\r\n                        conversation.pendingPromise.push(promise);\r\n                    }\r\n                }\r\n                else {\r\n                    // Get associated conversation\r\n                    queryId = stanza.getChild(\"fin\").getAttr(\"queryid\");\r\n                    conversation = this.conversationService.getConversationById(queryId);\r\n                    if (conversation) {\r\n                        if (conversation.pendingPromise) {\r\n                            Promise.all(conversation.pendingPromise).then(() => {\r\n                                // Extract info\r\n                                conversation.historyComplete = stanza.getChild(\"fin\").getAttr(\"complete\") === \"true\";\r\n                                let historyIndex = stanza.getChild(\"fin\").getChild(\"set\").getChild(\"first\") ?\r\n                                    stanza.getChild(\"fin\").getChild(\"set\").getChild(\"first\").text() : -1;\r\n                                // Handle very particular case of historyIndex == -1\r\n                                if (conversation.historyIndex === -1) {\r\n                                    conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\r\n                                    if (conversation.chatRenderer) {\r\n                                        conversation.chatRenderer.prependMessages(conversation.messages, conversation.bubble);\r\n                                    }\r\n                                }\r\n                                // Classic case\r\n                                else {\r\n                                    conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\r\n                                    if (conversation.chatRenderer) {\r\n                                        conversation.chatRenderer.prependMessages(conversation.historyMessages, conversation.bubble);\r\n                                    }\r\n                                }\r\n                                conversation.historyIndex = historyIndex;\r\n                                conversation.historyMessages = [];\r\n                                //that.logger.log(\"internal\", LOG_ID + \"[Conversation] onHistoryMessageReceived conversation not ordered: \", conversation);\r\n                                // @ts-ignore\r\n                                conversation.messages.sort((msg1, msg2) => new Date(msg1.date) - new Date(msg2.date));\r\n                                //that.logger.log(\"internal\", LOG_ID + \"[Conversation] onHistoryMessageReceived conversation ordered by date: \", conversation);\r\n                                if (conversation.messages && conversation.messages.length > 0) {\r\n                                    conversation.lastMessageText = conversation.messages[conversation.messages.length - 1].content;\r\n                                }\r\n                                else {\r\n                                    // conversation.lastModification = conversation.historyIndex === \"\" ? new Date() : new Date(0);\r\n                                    conversation.lastMessageText = \"\";\r\n                                }\r\n                                conversation.historyDefered.resolve(conversation);\r\n                                delete conversation.pendingPromise;\r\n                            });\r\n                        }\r\n                        else {\r\n                            // @ts-ignore\r\n                            conversation.messages.sort((msg1, msg2) => new Date(msg1.date) - new Date(msg2.date));\r\n                            conversation.historyDefered.resolve(conversation);\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            catch (error) {\r\n                that.logger.log(\"error\", LOG_ID + \"[Conversation] onHistoryMessageReceived error \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"[Conversation] onHistoryMessageReceived error : \", error);\r\n                return true;\r\n            }\r\n        };\r\n        this.onWebrtcHistoryMessageReceived = (stanza, conversation) => {\r\n            let that = this;\r\n            try {\r\n                let stanzaMessage = stanza.getChild(\"result\").getChild(\"forwarded\").getChild(\"message\");\r\n                let messageId = stanzaMessage.getAttr(\"id\");\r\n                let stanzaMessageCallLog = stanzaMessage.getChild(\"call_log\");\r\n                let callerJid = stanzaMessageCallLog.getChild(\"caller\").text();\r\n                let state = stanzaMessageCallLog.getChild(\"state\").text();\r\n                let duration = 0;\r\n                let durationTxt = \"0\";\r\n                if (stanzaMessageCallLog.getChild(\"duration\")) {\r\n                    duration = stanzaMessageCallLog.getChild(\"duration\").text();\r\n                    duration = parseInt(String(duration), 10);\r\n                }\r\n                if (duration > 0) {\r\n                    durationTxt = \"(\" + moment.duration(duration, \"ms\").format(\"h[H] mm[m] ss[s]\") + \")\";\r\n                }\r\n                else {\r\n                    duration = 0;\r\n                }\r\n                let date = stanzaMessageCallLog.getChild(\"date\").text();\r\n                if (date) {\r\n                    date = new Date(date);\r\n                }\r\n                else {\r\n                    date = new Date(stanza.getChild(\"result\").getChild(\"forwarded\").getChild(\"delay\").attr(\"stamp\"));\r\n                }\r\n                let body = \"\";\r\n                if (state === \"missed\") {\r\n                    body = \"missedCall||\" + date;\r\n                }\r\n                else if (state === \"answered\") {\r\n                    body = \"activeCallMsg||\" + date + \"||\" + durationTxt;\r\n                }\r\n                let message = conversation.getMessageById(messageId);\r\n                if (!message) {\r\n                    message = conversation.historyMessages.find(function (item) { return item.id === messageId; });\r\n                }\r\n                if (message) {\r\n                    that.logger.log(\"info\", LOG_ID + \"[Conversation] (\" + conversation.id + \") try to add an already stored message with id \" + message.id);\r\n                }\r\n                else {\r\n                    if (!conversation.pendingPromise) {\r\n                        conversation.pendingPromise = [];\r\n                    }\r\n                    let promise = new Promise((resolve) => {\r\n                        conversationService._contacts.getContactByJid(callerJid)\r\n                            .then((from) => {\r\n                            resolve(from);\r\n                        }).catch(() => {\r\n                            resolve(null);\r\n                        });\r\n                    }).then((from) => {\r\n                        // Create new message\r\n                        if (!from) {\r\n                            that.logger.log(\"warn\", LOG_ID + \"[Conversation] onWebrtcHistoryMessageReceived missing contact for jid : \" + callerJid + \", ignore message\");\r\n                            //create basic contact\r\n                            from = that.conversationService._contacts.createEmptyContactContact(callerJid);\r\n                        }\r\n                        let side = that.conversationService._contacts.isUserContact(from) ? Message_1.Message.Side.RIGHT : Message_1.Message.Side.LEFT;\r\n                        message = Message_1.Message.createWebRTCMessage(messageId, date, from, side, body, false);\r\n                        let ack = stanzaMessage.getChild('ack');\r\n                        if (ack) {\r\n                            message.receiptStatus = ack.getAttr(\"read\") === \"true\" ? 5 : (ack.getAttr(\"received\") === \"true\" ? 4 : 3);\r\n                        }\r\n                        conversation.historyMessages.push(message);\r\n                        return Promise.resolve();\r\n                    });\r\n                    conversation.pendingPromise.push(promise);\r\n                }\r\n                return true;\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n};\r\nConversationHistoryHandler = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID)\r\n], ConversationHistoryHandler);\r\nexports.ConversationHistoryHandler = ConversationHistoryHandler;\r\nmodule.exports.ConversationHistoryHandler = ConversationHistoryHandler;\r\n//# sourceMappingURL=conversationHistoryHandler.js.map"]},"metadata":{},"sourceType":"script"}