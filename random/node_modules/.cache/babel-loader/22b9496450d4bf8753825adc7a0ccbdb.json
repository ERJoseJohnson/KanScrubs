{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst config = require(\"../config/config\");\n\nconst atob_1 = require(\"atob\");\n\nconst Jimp = require('jimp');\n\nlet makeId = n => {\n  let text = \"\";\n  let possible = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n\n  for (let i = 0; i < n; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n};\n\nexports.makeId = makeId;\n\nlet createPassword = size => {\n  let possible = [\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\", \"?=.*[_~!@#\\$%\\^&\\*\\-\\+=`\\|\\(\\){}\\[\\]:;\\\"'<>,\\.\\?\\/]\", \"0123456789\"];\n  let key = \"\";\n\n  for (let i = 0; i < size - 4; i++) {\n    let index = Math.floor(Math.random() * possible.length);\n    key += possible[index].charAt(Math.floor(Math.random() * possible[index].length));\n  }\n\n  for (let i = 0; i < 4; i++) {\n    key += possible[i].charAt(Math.floor(Math.random() * possible[i].length));\n  }\n\n  return key;\n};\n\nexports.createPassword = createPassword;\n\nlet isAdmin = roles => {\n  return Array.isArray(roles) && roles.indexOf(\"admin\") !== -1;\n};\n\nexports.isAdmin = isAdmin;\n\nclass Deferred {\n  constructor() {\n    let that = this;\n    this.resolve = null;\n    this.reject = null;\n    this.promise = new Promise(function (resolve, reject) {\n      that.resolve = resolve;\n      that.reject = reject;\n    }.bind(this));\n    Object.freeze(this);\n  }\n\n}\n\nexports.Deferred = Deferred;\n\nlet isSuperAdmin = roles => {\n  return Array.isArray(roles) && roles.indexOf(\"superadmin\") !== -1;\n};\n\nexports.isSuperAdmin = isSuperAdmin;\n\nlet anonymizePhoneNumber = function (number) {\n  if (number === null || typeof number === \"undefined\") {\n    return null;\n  }\n\n  if (config && config.debug === true) {\n    return number;\n  }\n\n  let result = \"\";\n\n  if (number.indexOf(\"+\") === 0) {\n    result = \"+\";\n  }\n\n  if (number.length > 4) {\n    result = result + \"*\".repeat(number.length - 4 - result.length) + number.slice(number.length - 4);\n  } else {\n    result = number;\n  }\n\n  return result;\n};\n\nexports.anonymizePhoneNumber = anonymizePhoneNumber;\n\nlet setTimeoutPromised = function (time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    }, time);\n  });\n};\n\nexports.setTimeoutPromised = setTimeoutPromised;\n/*\nmyFunction() in the original question can be modified as follows\n\nasync function myFunction(number) {\n\n    let x=number;\n...\n... more initializations\n\n    await until(_ => flag == true);\n\n...\n... do something\n\n}\n// */\n//where until() is this utility function\n\n/**\n * @description\n * function to wait for a condition for a few time before it is resolved of rejected.\n * To be used with asunchrone function :\n * myFunction() is the code using until function.\n *\n * async function myFunction(number) {\n  *    let x=number;\n * ... more initializations\n *\n *    await until(_ => flag == true);\n * ...\n * ... do something when until is resolved/rejected\n * }\n *\n * @param conditionFunction\n * @returns {Promise<any>}\n */\n\nfunction until(conditionFunction, labelOfWaitingCondition, waitMsTimeBeforeReject = 5000) {\n  let now = new Date(); //.toJSON().replace(/-/g, '_');\n\n  if (!waitMsTimeBeforeReject) {\n    waitMsTimeBeforeReject = 1000 * 5; // wait 5 seconds\n  }\n\n  let end = new Date(now.getTime() + waitMsTimeBeforeReject);\n\n  const poll = (resolve, reject) => {\n    if (conditionFunction()) {\n      resolve();\n    } else {\n      if (new Date() > end) {\n        labelOfWaitingCondition = labelOfWaitingCondition ? labelOfWaitingCondition : \"\";\n        reject(new Error('ErrorManager the condition \\'' + labelOfWaitingCondition + '\\' failed')); //throw new ErrorManager('ErrorManager the condition ' + labelOfWaitingCondition ? labelOfWaitingCondition : \"\" + ' failed');\n\n        return;\n      }\n\n      setTimeout(_ => poll(resolve, reject), 400);\n    }\n  };\n\n  return new Promise(poll);\n}\n\nexports.until = until;\n\nfunction orderByFilter(originalArray, filterFct, flag, sortFct) {\n  let o = [];\n  let objectsCompared = [];\n\n  if (!originalArray) {\n    return [];\n  }\n\n  originalArray.forEach((objectOriginal, index) => {\n    let tabOfArgForApply = [];\n    tabOfArgForApply.push(objectOriginal);\n    let objectComparing = {\n      keyToCompare: null,\n      objectOriginal: null\n    };\n    objectComparing.keyToCompare = filterFct.apply(null, tabOfArgForApply);\n    objectComparing.objectOriginal = objectOriginal;\n    objectsCompared.push(objectComparing); //that.waitingBotConversations.splice(index, 1);\n  });\n\n  function compWithkeyToCompare(objectComparingA, objectComparingB) {\n    return sortFct(objectComparingA.keyToCompare, objectComparingB.keyToCompare);\n  }\n\n  o = objectsCompared.sort(compWithkeyToCompare); //        o = objs.sort(sortFct);\n\n  let tabOrdered = [];\n  o.forEach((objectCompared, index) => {\n    tabOrdered.push(objectCompared.objectOriginal);\n  });\n\n  if (flag) {\n    tabOrdered.reverse();\n  } else {\n    return tabOrdered;\n  }\n}\n\nexports.orderByFilter = orderByFilter;\n\nfunction isStart_upService(serviceoptions) {\n  let start_up = true;\n\n  if (!serviceoptions.optional) {\n    start_up = true;\n  } else {\n    start_up = !!serviceoptions.start_up;\n  }\n\n  return start_up;\n}\n\nexports.isStart_upService = isStart_upService;\n\nfunction isStarted(_methodsToIgnoreStartedState = []) {\n  return function (target, key, descriptor) {\n    let keys = Object.getOwnPropertyNames(target.prototype);\n    keys.forEach(propertyName => {\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, propertyName);\n      const isMethod = descriptor.value instanceof Function;\n      if (!isMethod) return; // Keep the method store in a local variable\n\n      const originalMethod = descriptor.value;\n\n      descriptor.value = function (...args) {\n        // Execute the method with its initial context and arguments\n        // Return value is stored into a variable instead of being passed to the execution stack\n        let returnValue = undefined;\n        let methodsToIgnoreStartedState = [\"start\", \"stop\", \"contructor\", \"attachHandlers\"];\n        methodsToIgnoreStartedState = methodsToIgnoreStartedState.concat(_methodsToIgnoreStartedState[0]);\n        let ignoreTheStartedState = methodsToIgnoreStartedState.find(elt => {\n          return elt === propertyName;\n        }) != undefined;\n\n        if (this == null) {\n          returnValue = originalMethod.apply(this, args);\n        } else {\n          let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n          let start_up = isStart_upService(this.startConfig);\n\n          if (ignoreTheStartedState) {\n            if (start_up) {\n              //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n              returnValue = originalMethod.apply(this, args); //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n            } else {\n              return Promise.resolve({\n                msg: \"The service of the Object \" + target.name + \" is not configured for start-up!!! Can not call method : \" + propertyName\n              }); //throw({msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName});\n            }\n          } else {\n            if (start_up) {\n              if (this.ready) {\n                //  logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n                returnValue = originalMethod.apply(this, args); //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n              } else {\n                //return Promise.resolve({msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName});\n                throw {\n                  msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName\n                };\n              }\n            } else {\n              return Promise.resolve({\n                msg: \"The service of the Object \" + target.name + \" is not configured for start-up!!! Can not call method : \" + propertyName\n              });\n            }\n          }\n        } // Return back the value to the execution stack\n\n\n        return returnValue;\n        /* console.log(\"The method args are: \" + JSON.stringify(args));\n        const result = originalMethod.apply(this, args);\n        console.log(\"The return value is: \" + result);\n        return result; // */\n      };\n\n      Object.defineProperty(target.prototype, propertyName, descriptor);\n    });\n  };\n}\n\nexports.isStarted = isStarted;\n\nfunction logEntryExit(LOG_ID) {\n  return function (target, key, descriptor) {\n    let keys = Object.getOwnPropertyNames(target.prototype);\n    keys.forEach(propertyName => {\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, propertyName);\n      const isMethod = descriptor.value instanceof Function;\n      if (!isMethod) return; // Keep the method store in a local variable\n\n      const originalMethod = descriptor.value;\n\n      descriptor.value = function (...args) {\n        // Execute the method with its initial context and arguments\n        // Return value is stored into a variable instead of being passed to the execution stack\n        let returnValue = undefined;\n\n        if (this == null) {\n          returnValue = originalMethod.apply(this, args);\n        } else {\n          let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n          logger.log(\"internal\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n          returnValue = originalMethod.apply(this, args);\n          logger.log(\"internal\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n        } // Return back the value to the execution stack\n\n\n        return returnValue;\n      };\n\n      Object.defineProperty(target.prototype, propertyName, descriptor);\n    });\n  };\n}\n\nexports.logEntryExit = logEntryExit;\n/**\n * @private\n * @param avatarImg\n * @param maxWidth\n * @param maxHeight\n */\n\nfunction resizeImage(avatarImg, maxWidth, maxHeight) {\n  let that = this; //let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n\n  return new Promise((resolve, reject) => {\n    Jimp.read(avatarImg) // this can be url or local location\n    .then(image => {\n      // logger.log(\"debug\", \"(resizeImage) image : \", image);\n      image.resize(maxHeight, maxWidth) // jimp.AUTO automatically sets the width so that the image doesnot looks odd\n      // @ts-ignore\n      .getBase64(Jimp.AUTO, (err, res) => {\n        // logger.log(\"debug\", \"(setAvatarBubble) getBase64 : \", res);\n\n        /*\n        const buf = new Buffer(\n            res.replace(/^data:image\\/\\w+;base64,/, \"\"),\n            \"base64\"\n        );\n        let data = {\n            Body: buf,\n            ContentEncoding: \"base64\",\n            ContentType: \"image/jpeg\"\n        };\n        // */\n        return resolve(res);\n      });\n    }).catch(err => {\n      console.log(\"error\", \"(setAvatarBubble) Error : \", err);\n    });\n  });\n  /*\n  let defered = $q.defer();\n  let image = new Image();\n  image.src = avatarImg;\n   image.onload = function() {\n      let imageWidth = image.width;\n      let imageHeight = image.height;\n       if (imageWidth > imageHeight) {\n          if (imageWidth > maxWidth) {\n              imageHeight *= maxWidth / imageWidth;\n              imageWidth = maxWidth;\n          }\n      }\n      else {\n          if (imageHeight > maxHeight) {\n              imageWidth *= maxHeight / imageHeight;\n              imageHeight = maxHeight;\n          }\n      }\n       let canvas = document.createElement(\"canvas\");\n      canvas.width = imageWidth;\n      canvas.height = imageHeight;\n      image.width = imageWidth;\n      image.height = imageHeight;\n      let ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this, 0, 0, imageWidth, imageHeight);\n       let resizedImage = new Image();\n      resizedImage.src = canvas.toDataURL(\"image/png\");\n      defered.resolve(resizedImage);\n  };\n  return defered.promise;\n  // */\n}\n\nexports.resizeImage = resizeImage;\n/**\n * @private\n * @param image\n */\n\nfunction getBinaryData(image) {\n  let typeIndex = image.indexOf(\"image/\") + 6;\n  let binaryIndex = image.indexOf(\";base64,\");\n  let binaryData = image.slice(binaryIndex + 8);\n  let imageType = image.slice(typeIndex, binaryIndex);\n  let binary_string = atob_1.atob(binaryData);\n  let len = binary_string.length;\n  let bytes = new Uint8Array(len);\n\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binary_string.charCodeAt(i);\n  }\n\n  return {\n    type: imageType,\n    data: bytes\n  };\n}\n\nexports.getBinaryData = getBinaryData;","map":{"version":3,"sources":["../../src/lib/common/Utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config = require(\"../config/config\");\nconst atob_1 = require(\"atob\");\nconst Jimp = require('jimp');\nlet makeId = (n) => {\n    let text = \"\";\n    let possible = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    for (let i = 0; i < n; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n};\nexports.makeId = makeId;\nlet createPassword = (size) => {\n    let possible = [\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\", \"?=.*[_~!@#\\$%\\^&\\*\\-\\+=`\\|\\(\\){}\\[\\]:;\\\"'<>,\\.\\?\\/]\", \"0123456789\"];\n    let key = \"\";\n    for (let i = 0; i < size - 4; i++) {\n        let index = Math.floor(Math.random() * possible.length);\n        key += possible[index].charAt(Math.floor(Math.random() * possible[index].length));\n    }\n    for (let i = 0; i < 4; i++) {\n        key += possible[i].charAt(Math.floor(Math.random() * possible[i].length));\n    }\n    return key;\n};\nexports.createPassword = createPassword;\nlet isAdmin = (roles) => {\n    return Array.isArray(roles) && roles.indexOf(\"admin\") !== -1;\n};\nexports.isAdmin = isAdmin;\nclass Deferred {\n    constructor() {\n        let that = this;\n        this.resolve = null;\n        this.reject = null;\n        this.promise = new Promise(function (resolve, reject) {\n            that.resolve = resolve;\n            that.reject = reject;\n        }.bind(this));\n        Object.freeze(this);\n    }\n}\nexports.Deferred = Deferred;\nlet isSuperAdmin = (roles) => {\n    return Array.isArray(roles) && roles.indexOf(\"superadmin\") !== -1;\n};\nexports.isSuperAdmin = isSuperAdmin;\nlet anonymizePhoneNumber = function (number) {\n    if (number === null || typeof number === \"undefined\") {\n        return null;\n    }\n    if (config && config.debug === true) {\n        return number;\n    }\n    let result = \"\";\n    if (number.indexOf(\"+\") === 0) {\n        result = \"+\";\n    }\n    if (number.length > 4) {\n        result = result + \"*\".repeat(number.length - 4 - result.length) + number.slice(number.length - 4);\n    }\n    else {\n        result = number;\n    }\n    return result;\n};\nexports.anonymizePhoneNumber = anonymizePhoneNumber;\nlet setTimeoutPromised = function (time) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            try {\n                resolve();\n            }\n            catch (err) {\n                return reject(err);\n            }\n        }, time);\n    });\n};\nexports.setTimeoutPromised = setTimeoutPromised;\n/*\nmyFunction() in the original question can be modified as follows\n\nasync function myFunction(number) {\n\n    let x=number;\n...\n... more initializations\n\n    await until(_ => flag == true);\n\n...\n... do something\n\n}\n// */\n//where until() is this utility function\n/**\n * @description\n * function to wait for a condition for a few time before it is resolved of rejected.\n * To be used with asunchrone function :\n * myFunction() is the code using until function.\n *\n * async function myFunction(number) {\n  *    let x=number;\n * ... more initializations\n *\n *    await until(_ => flag == true);\n * ...\n * ... do something when until is resolved/rejected\n * }\n *\n * @param conditionFunction\n * @returns {Promise<any>}\n */\nfunction until(conditionFunction, labelOfWaitingCondition, waitMsTimeBeforeReject = 5000) {\n    let now = new Date(); //.toJSON().replace(/-/g, '_');\n    if (!waitMsTimeBeforeReject) {\n        waitMsTimeBeforeReject = 1000 * 5; // wait 5 seconds\n    }\n    let end = new Date(now.getTime() + waitMsTimeBeforeReject);\n    const poll = (resolve, reject) => {\n        if (conditionFunction()) {\n            resolve();\n        }\n        else {\n            if (new Date() > end) {\n                labelOfWaitingCondition = labelOfWaitingCondition ? labelOfWaitingCondition : \"\";\n                reject(new Error('ErrorManager the condition \\'' + labelOfWaitingCondition + '\\' failed'));\n                //throw new ErrorManager('ErrorManager the condition ' + labelOfWaitingCondition ? labelOfWaitingCondition : \"\" + ' failed');\n                return;\n            }\n            setTimeout(_ => poll(resolve, reject), 400);\n        }\n    };\n    return new Promise(poll);\n}\nexports.until = until;\nfunction orderByFilter(originalArray, filterFct, flag, sortFct) {\n    let o = [];\n    let objectsCompared = [];\n    if (!originalArray) {\n        return [];\n    }\n    originalArray.forEach((objectOriginal, index) => {\n        let tabOfArgForApply = [];\n        tabOfArgForApply.push(objectOriginal);\n        let objectComparing = {\n            keyToCompare: null,\n            objectOriginal: null\n        };\n        objectComparing.keyToCompare = filterFct.apply(null, tabOfArgForApply);\n        objectComparing.objectOriginal = objectOriginal;\n        objectsCompared.push(objectComparing);\n        //that.waitingBotConversations.splice(index, 1);\n    });\n    function compWithkeyToCompare(objectComparingA, objectComparingB) {\n        return sortFct(objectComparingA.keyToCompare, objectComparingB.keyToCompare);\n    }\n    o = objectsCompared.sort(compWithkeyToCompare);\n    //        o = objs.sort(sortFct);\n    let tabOrdered = [];\n    o.forEach((objectCompared, index) => {\n        tabOrdered.push(objectCompared.objectOriginal);\n    });\n    if (flag) {\n        tabOrdered.reverse();\n    }\n    else {\n        return tabOrdered;\n    }\n}\nexports.orderByFilter = orderByFilter;\nfunction isStart_upService(serviceoptions) {\n    let start_up = true;\n    if (!serviceoptions.optional) {\n        start_up = true;\n    }\n    else {\n        start_up = !!serviceoptions.start_up;\n    }\n    return start_up;\n}\nexports.isStart_upService = isStart_upService;\nfunction isStarted(_methodsToIgnoreStartedState = []) {\n    return function (target, key, descriptor) {\n        let keys = Object.getOwnPropertyNames(target.prototype);\n        keys.forEach((propertyName) => {\n            const descriptor = Object.getOwnPropertyDescriptor(target.prototype, propertyName);\n            const isMethod = descriptor.value instanceof Function;\n            if (!isMethod)\n                return;\n            // Keep the method store in a local variable\n            const originalMethod = descriptor.value;\n            descriptor.value = function (...args) {\n                // Execute the method with its initial context and arguments\n                // Return value is stored into a variable instead of being passed to the execution stack\n                let returnValue = undefined;\n                let methodsToIgnoreStartedState = [\"start\", \"stop\", \"contructor\", \"attachHandlers\"];\n                methodsToIgnoreStartedState = methodsToIgnoreStartedState.concat(_methodsToIgnoreStartedState[0]);\n                let ignoreTheStartedState = (methodsToIgnoreStartedState.find((elt) => { return elt === propertyName; }) != undefined);\n                if (this == null) {\n                    returnValue = originalMethod.apply(this, args);\n                }\n                else {\n                    let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n                    let start_up = isStart_upService(this.startConfig);\n                    if (ignoreTheStartedState) {\n                        if (start_up) {\n                            //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n                            returnValue = originalMethod.apply(this, args);\n                            //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n                        }\n                        else {\n                            return Promise.resolve({ msg: \"The service of the Object \" + target.name + \" is not configured for start-up!!! Can not call method : \" + propertyName });\n                            //throw({msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName});\n                        }\n                    }\n                    else {\n                        if (start_up) {\n                            if (this.ready) {\n                                //  logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n                                returnValue = originalMethod.apply(this, args);\n                                //logger.log(\"debug\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n                            }\n                            else {\n                                //return Promise.resolve({msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName});\n                                throw ({ msg: \"The service of the Object \" + target.name + \" is not ready!!! Can not call method : \" + propertyName });\n                            }\n                        }\n                        else {\n                            return Promise.resolve({ msg: \"The service of the Object \" + target.name + \" is not configured for start-up!!! Can not call method : \" + propertyName });\n                        }\n                    }\n                }\n                // Return back the value to the execution stack\n                return returnValue;\n                /* console.log(\"The method args are: \" + JSON.stringify(args));\n                const result = originalMethod.apply(this, args);\n                console.log(\"The return value is: \" + result);\n                return result; // */\n            };\n            Object.defineProperty(target.prototype, propertyName, descriptor);\n        });\n    };\n}\nexports.isStarted = isStarted;\nfunction logEntryExit(LOG_ID) {\n    return function (target, key, descriptor) {\n        let keys = Object.getOwnPropertyNames(target.prototype);\n        keys.forEach((propertyName) => {\n            const descriptor = Object.getOwnPropertyDescriptor(target.prototype, propertyName);\n            const isMethod = descriptor.value instanceof Function;\n            if (!isMethod)\n                return;\n            // Keep the method store in a local variable\n            const originalMethod = descriptor.value;\n            descriptor.value = function (...args) {\n                // Execute the method with its initial context and arguments\n                // Return value is stored into a variable instead of being passed to the execution stack\n                let returnValue = undefined;\n                if (this == null) {\n                    returnValue = originalMethod.apply(this, args);\n                }\n                else {\n                    let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n                    logger.log(\"internal\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _entering_\"));\n                    returnValue = originalMethod.apply(this, args);\n                    logger.log(\"internal\", LOG_ID + logger.colors.data(\"Method \" + propertyName + \"(...) _exiting_\"));\n                }\n                // Return back the value to the execution stack\n                return returnValue;\n            };\n            Object.defineProperty(target.prototype, propertyName, descriptor);\n        });\n    };\n}\nexports.logEntryExit = logEntryExit;\n/**\n * @private\n * @param avatarImg\n * @param maxWidth\n * @param maxHeight\n */\nfunction resizeImage(avatarImg, maxWidth, maxHeight) {\n    let that = this;\n    //let logger = this.logger ? this.logger : this._logger ? this._logger : {};\n    return new Promise((resolve, reject) => {\n        Jimp.read(avatarImg) // this can be url or local location\n            .then(image => {\n            // logger.log(\"debug\", \"(resizeImage) image : \", image);\n            image.resize(maxHeight, maxWidth) // jimp.AUTO automatically sets the width so that the image doesnot looks odd\n                // @ts-ignore\n                .getBase64(Jimp.AUTO, (err, res) => {\n                // logger.log(\"debug\", \"(setAvatarBubble) getBase64 : \", res);\n                /*\n                const buf = new Buffer(\n                    res.replace(/^data:image\\/\\w+;base64,/, \"\"),\n                    \"base64\"\n                );\n                let data = {\n                    Body: buf,\n                    ContentEncoding: \"base64\",\n                    ContentType: \"image/jpeg\"\n                };\n                // */\n                return resolve(res);\n            });\n        })\n            .catch(err => {\n            console.log(\"error\", \"(setAvatarBubble) Error : \", err);\n        });\n    });\n    /*\n    let defered = $q.defer();\n    let image = new Image();\n    image.src = avatarImg;\n\n    image.onload = function() {\n        let imageWidth = image.width;\n        let imageHeight = image.height;\n\n        if (imageWidth > imageHeight) {\n            if (imageWidth > maxWidth) {\n                imageHeight *= maxWidth / imageWidth;\n                imageWidth = maxWidth;\n            }\n        }\n        else {\n            if (imageHeight > maxHeight) {\n                imageWidth *= maxHeight / imageHeight;\n                imageHeight = maxHeight;\n            }\n        }\n\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = imageWidth;\n        canvas.height = imageHeight;\n        image.width = imageWidth;\n        image.height = imageHeight;\n        let ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(this, 0, 0, imageWidth, imageHeight);\n\n        let resizedImage = new Image();\n        resizedImage.src = canvas.toDataURL(\"image/png\");\n        defered.resolve(resizedImage);\n    };\n    return defered.promise;\n    // */\n}\nexports.resizeImage = resizeImage;\n/**\n * @private\n * @param image\n */\nfunction getBinaryData(image) {\n    let typeIndex = image.indexOf(\"image/\") + 6;\n    let binaryIndex = image.indexOf(\";base64,\");\n    let binaryData = image.slice(binaryIndex + 8);\n    let imageType = image.slice(typeIndex, binaryIndex);\n    let binary_string = atob_1.atob(binaryData);\n    let len = binary_string.length;\n    let bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return { type: imageType, data: bytes };\n}\nexports.getBinaryData = getBinaryData;\n//# sourceMappingURL=Utils.js.map"]},"metadata":{},"sourceType":"script"}