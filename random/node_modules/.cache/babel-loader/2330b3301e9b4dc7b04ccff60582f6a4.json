{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst favoriteEventHandler_1 = require(\"../connection/XMPPServiceHandler/favoriteEventHandler\");\n\nconst Favorite_1 = require(\"../common/models/Favorite\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"FAVTE/SVCE - \";\nlet FavoritesService =\n/**\r\n* @module\r\n* @name FavoritesService\r\n * @version 1.67.1 \r\n * @public\r\n* @description\r\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\r\n*      - Retrieve all information linked to that Favorite, <br>\r\n*/\nclass FavoritesService {\n  constructor(_eventEmitter, logger, _startConfig) {\n    //public static $inject: string[] = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];\n    this.favorites = [];\n    this.ready = false;\n    /*********************************************************/\n\n    /**                 LIFECYCLE STUFF                     **/\n\n    /*********************************************************/\n\n    this._startConfig = _startConfig; //let that = this;\n\n    this._eventEmitter = _eventEmitter;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._logger = logger;\n    this.started = false;\n    this._initialized = false;\n\n    this._eventEmitter.on(\"evt_internal_favoritecreated_handle\", this.onFavoriteCreated.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_favoritedeleted_handle\", this.onFavoriteDeleted.bind(this));\n\n    this.ready = false;\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that._xmpp = _core._xmpp;\n      that._rest = _core._rest;\n      that._options = _options;\n      that._s2s = _core._s2s;\n      that._useXMPP = that._options.useXMPP;\n      that._useS2S = that._options.useS2S;\n      this._favoriteHandlerToken = [];\n\n      that._logger.log(\"info\", LOG_ID + \" \");\n\n      that._logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\n\n      let startDate = new Date().getTime();\n      this.attachHandlers(); //this.conversationService.favoriteService = this;\n      //this.attachHandlers();\n\n      let startDuration = Math.round(new Date().getTime() - startDate); //stats.push({ service: 'favoriteService', startDuration: startDuration });\n\n      that._logger.log(\"info\", LOG_ID + `=== STARTED (${startDuration} ms) ===`);\n\n      this.ready = true;\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"info\", LOG_ID + \"[stop] Stopping\"); //remove all saved call logs\n\n\n      this.started = false;\n      this._initialized = false;\n      that._xmpp = null;\n      that._rest = null;\n      delete that._favoriteEventHandler;\n      that._favoriteEventHandler = null;\n\n      if (that._favoriteHandlerToken) {\n        that._favoriteHandlerToken.forEach(token => PubSub.unsubscribe(token));\n      }\n\n      that._favoriteHandlerToken = [];\n      /*this.$log.info('Stopping');\r\n      if (this._xmppManagementHandler) {\r\n          this.xmppService.deleteHandler(this._xmppManagementHandler);\r\n          this._xmppManagementHandler = null;\r\n      }\r\n      this.$log.info('Stopped');\r\n             */\n\n      this.ready = false;\n\n      that._logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\n    });\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      yield this.getServerFavorites();\n      /*await setTimeoutPromised(3000).then(() => {\r\n          let startDate = new Date();\r\n          that.getCallLogHistoryPage()\r\n              .then(() => {\r\n                  // @ts-ignore\r\n                  let duration = new Date() - startDate;\r\n                  let startDuration = Math.round(duration);\r\n                  that._logger.log(\"info\", LOG_ID + \" callLogService start duration : \",  startDuration);\r\n                  that._logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\r\n                  that.started = true;\r\n              })\r\n              .catch(() => {\r\n                  that._logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\r\n              });\r\n      });\r\n             */\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n\n    that._logger.log(\"info\", LOG_ID + \"[attachHandlers] attachHandlers\");\n\n    that._favoriteEventHandler = new favoriteEventHandler_1.FavoriteEventHandler(that._xmpp, that);\n    that._favoriteHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_MANAGEMENT, that._favoriteEventHandler.onManagementMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_ERROR, that._favoriteEventHandler.onErrorMessageReceived)];\n    /*\r\n    if (this._xmppManagementHandler) { this.xmppService.deleteHandler(this._xmppManagementHandler); }\r\n    this._xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, \"message\", \"management\");\r\n       */\n\n    /*\r\n    //if reconnection, update the call-logs\r\n    if (that.started && that.lastTimestamp) {\r\n        $interval(function () {\r\n            that.getCallLogHistoryPage(that.lastTimestamp);\r\n        }, 1000, 1, true);\r\n    }\r\n    // */\n  }\n\n  reconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.getServerFavorites(); //this.conversationService.favoriteService = this;\n\n      this.attachHandlers();\n    });\n  }\n\n  getServerFavorites() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let that = this;\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n          this._rest.getServerFavorites().then(favorite => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"info\", LOG_ID + \"(getServerFavorites) favorite tab length : \", favorite.length);\n\n            if (favorite) {\n              let promises = favorite.map(data => __awaiter(this, void 0, void 0, function* () {\n                return this.createFavoriteObj(data.id, data.peerId, data.type);\n              }));\n              let favorites = yield Promise.all(promises);\n              this.favorites = favorites.filter(favorite => {\n                return favorite !== null;\n              });\n\n              that._logger.log(\"info\", LOG_ID + `getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n            }\n\n            resolve(this.favorites);\n          })).catch(err => {\n            that._logger.log(\"error\", LOG_ID + \"(getServerFavorites) error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(getServerFavorites) error : \", err);\n\n            return reject(err);\n          });\n          /*\r\n          //            let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\r\n          //          let response = await this.$http({ method: \"GET\", url: url, headers: this.authService.getRequestHeader() });\r\n          let promises = response.data.data.map(async (data: any) => { return this.createFavorite(data.id, data.peerId, data.type); });\r\n          let favorites = await Promise.all(promises);\r\n          this.favorites = favorites.filter((favorite) => { return favorite !== null; });\r\n          this.$log.info(`getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\r\n          return this.favorites;\r\n          */\n\n        }));\n      } catch (error) {\n        let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;\n\n        this._logger.log(\"error\", LOG_ID + `[getServerFavorites] CATCH Error !!! `);\n\n        this._logger.log(\"internalerror\", LOG_ID + `CATCH Error !!! : ${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  addServerFavorite(peerId, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        let favorite = yield that._rest.addServerFavorite(peerId, type);\n\n        that._logger.log(\"internal\", LOG_ID + `addServerFavorite(${peerId}, ${type}) -- SUCCESS`, favorite);\n\n        return favorite;\n      } catch (error) {\n        let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;\n\n        that._logger.log(\"error\", LOG_ID + `[addServerFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  removeServerFavorite(favoriteId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n          that._rest.removeServerFavorite(favoriteId).then(favoriteDeleted => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"info\", LOG_ID + \"(removeServerFavorite) -- SUCCESS.\");\n\n            that._logger.log(\"internal\", LOG_ID + \"(removeServerFavorite) -- SUCCESS : \", favoriteDeleted);\n\n            resolve(favoriteDeleted);\n          })).catch(err => {\n            that._logger.log(\"error\", LOG_ID + \"(removeServerFavorite) error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(removeServerFavorite) error : \", err);\n\n            return reject(err);\n          });\n        }));\n      } catch (error) {\n        let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;\n\n        that._logger.log(\"error\", LOG_ID + `[removeServerFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  toggleFavorite(conversation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n      let type = conversation.contact ? conversation.contact.isBot ? 'bot' : 'user' : 'room';\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === peerId;\n      });\n\n      if (!favorite) {\n        return this.addServerFavorite(peerId, type);\n      } else {\n        return this.removeServerFavorite(favorite.id);\n      }\n    });\n  }\n\n  updateFavorites(conversation) {\n    let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n    let favorite = this.favorites.find(favoriteConv => {\n      return favoriteConv.peerId === peerId;\n    });\n\n    if (favorite) {\n      conversation.isFavorite = true;\n      favorite.conv = conversation;\n    }\n  }\n\n  getFavorite(peerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === peerId;\n      }); //let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);\n      //return await convGetter;\n    });\n  }\n\n  createFavoriteObj(id, peerId, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        let favorite = new Favorite_1.Favorite(id, peerId, type);\n        /*\r\n        // Get peer object\r\n        if (type === 'room') { favorite.room = this.roomService.getRoomById(peerId); }\r\n        else { favorite.contact = await this.contactService.getContactByDBId(peerId); }\r\n              // Fetch eventual conversation\r\n        let convId: string = favorite.room ? favorite.room.jid : favorite.contact.jid;\r\n        let conv: any = this.conversationService.getConversationById(convId);\r\n        if (conv) { conv.isFavorite = true; favorite.conv = conv; }\r\n               */\n\n        return favorite;\n      } catch (error) {\n        that._logger.log(\"error\", LOG_ID + `[createFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);\n\n        return null;\n      }\n    });\n  }\n\n  onXmppEvent(stanza) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        /*\r\n        let stanzaElem = $(stanza);\r\n        let favoriteElem = stanzaElem.find(\"favorite\");\r\n        if (favoriteElem) {\r\n          let id = favoriteElem.attr(\"id\");\r\n          let type = favoriteElem.attr(\"type\");\r\n          let peerId = favoriteElem.attr(\"peer_id\");\r\n          let action = favoriteElem.attr(\"action\");\r\n                if (action === 'create') {\r\n              let favorite: Favorite = this.favorites.find((favoriteConv: any) => { return favoriteConv.peerId === peerId; });\r\n              if (!favorite) {\r\n                  favorite = await this.createFavorite(id, peerId, type);\r\n                  this.favorites.push(favorite);\r\n                  this.sendEvent('ON_FAVORITE_CREATED', { favorite });\r\n              }\r\n          }\r\n                if (action === 'delete') {\r\n              let index = this.favorites.findIndex((fav) => { return fav.id === id; });\r\n              if (index !== -1) {\r\n                  let favorite = this.favorites[index];\r\n                  if (favorite.conv) { favorite.conv.isFavorite = false; }\r\n                  this.favorites.splice(index, 1);\r\n                  this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\r\n              }\r\n          }\r\n        }\r\n        return true;\r\n        */\n      } catch (error) {\n        return true;\n      }\n    });\n  }\n  /*private sendEvent(eventName: string, detail: any): void {\r\n      let event = new CustomEvent(eventName, { detail });\r\n      window.dispatchEvent(event);\r\n  }\r\n     */\n\n  /**\r\n   * @public\r\n   * @since 1.56\r\n   * @method fetchAllFavorites()\r\n   * @instance\r\n   * @description\r\n   *   Fetch all the Favorites from the server in a form of an Array\r\n   * @return {Conversation[]} An array of Favorite objects\r\n   */\n\n\n  fetchAllFavorites() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        that.getServerFavorites().then(function (favorites) {\n          that._logger.log(\"debug\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites`);\n\n          that._logger.log(\"internal\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites : `, favorites);\n\n          resolve(favorites);\n        }).catch(function (err) {\n          that._logger.log(\"error\", LOG_ID + `[fetchAllFavorites] :: Error.`);\n\n          that._logger.log(\"internalerror\", LOG_ID + `[fetchAllFavorites] :: ERROR : `, err);\n\n          return reject(err);\n        });\n      });\n    });\n  }\n\n  /**\r\n   * @public\r\n   * @since 1.56\r\n   * @method createFavorite()\r\n   * @instance\r\n   * @description\r\n   *   Add conversation/bubble/bot to Favorites Array\r\n   * @param {String} id of the conversation/bubble\r\n   * @param {String} type of Favorite (can be 'user' or 'bubble')\r\n   * @return {Promise<Favorite>} A Favorite object\r\n   */\n  createFavorite(id, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (!id) {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (!type) {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (type !== \"bubble\" && type !== \"user\") {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: type should be set to \\\"user\\\" or \\\"bubble\\\"\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (type === \"bubble\") {\n          type = \"room\";\n        }\n\n        that.addServerFavorite(id, type).then(favorite => {\n          that._logger.log(\"debug\", LOG_ID + `[createFavorite] :: Successfully added ${type} to favorites`);\n\n          return resolve(favorite);\n        }).catch(err => {\n          that._logger.log(\"error\", LOG_ID + \"[createFavorite] :: Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"[createFavorite] :: Error : \", err);\n\n          return reject(err);\n        });\n      });\n    });\n  }\n\n  /**\r\n   * @public\r\n   * @since 1.56\r\n   * @method deleteFavorite()\r\n   * @instance\r\n   * @description\r\n   *   Delete conversation/bubble/bot from Favorites Array\r\n   * @param {String} id of the Favorite item\r\n   * @return {Favorite[]} A Favorite object\r\n   */\n  deleteFavorite(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (!id) {\n          that._logger.log(\"debug\", LOG_ID + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n\n          return reject(\"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n        }\n\n        that.removeServerFavorite(id).then(favDeleted => {\n          return resolve(favDeleted);\n        }).catch(err => {\n          that._logger.log(\"error\", LOG_ID + \"[deleteFavorite] :: Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"[deleteFavorite] :: Error : \", err);\n\n          return reject(err);\n        });\n      });\n    });\n  } // ******************* Event XMPP parsed in favoriteEventHandler ***************\n\n\n  onFavoriteCreated(fav) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === fav.peerId;\n      });\n\n      if (!favorite) {\n        favorite = yield this.createFavoriteObj(fav.id, fav.peerId, fav.type);\n        this.favorites.push(favorite); //that._logger.log(\"internal\", LOG_ID + \"[onFavoriteCreated] send event : \", favorite);\n        //this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n\n        that._eventEmitter.emit(\"evt_internal_favoritecreated\", favorite);\n      }\n    });\n  }\n\n  onFavoriteDeleted(fav) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let index = this.favorites.findIndex(fav => {\n        return fav.id === fav.id;\n      });\n\n      if (index !== -1) {\n        let favorite = this.favorites[index];\n\n        if (favorite.conv) {\n          favorite.conv.isFavorite = false;\n        }\n\n        this.favorites.splice(index, 1); //that._logger.log(\"debug\", LOG_ID + \"[onFavoriteDeleted] send event : \", { favoriteId: favorite.id });\n        //this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n\n        that._eventEmitter.emit(\"evt_internal_favoritedeleted\", fav);\n      }\n    });\n  }\n\n};\nFavoritesService = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n* @module\r\n* @name FavoritesService\r\n * @version 1.67.1 \r\n * @public\r\n* @description\r\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\r\n*      - Retrieve all information linked to that Favorite, <br>\r\n*/\n], FavoritesService);\nexports.FavoritesService = FavoritesService;\nmodule.exports.FavoritesService = FavoritesService;","map":{"version":3,"sources":["../../src/lib/services/FavoritesService.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAKA,MAAM,MAAM,GAAG,eAAf;AAeA,IAAM,gBAAgB;AAXtB;;;;;;;;;;;AAWA,MAAM,gBAAN,CAAsB;AAyBlB,EAAA,WAAA,CAAY,aAAZ,EAA0C,MAA1C,EAA2D,YAA3D,EAAuE;AAZvE;AACQ,SAAA,SAAA,GAAmB,EAAnB;AAED,SAAA,KAAA,GAAiB,KAAjB;AAWH;;AACA;;AACA;;AACA,SAAK,YAAL,GAAoB,YAApB,CALmE,CAMnE;;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,QAAL,GAAgB,EAAhB;AACA,SAAK,QAAL,GAAgB,KAAhB;AACA,SAAK,OAAL,GAAe,KAAf;AACA,SAAK,OAAL,GAAe,MAAf;AAEA,SAAK,OAAL,GAAe,KAAf;AACA,SAAK,YAAL,GAAoB,KAApB;;AAEA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,qCAAtB,EAA6D,KAAK,iBAAL,CAAuB,IAAvB,CAA4B,IAA5B,CAA7D;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,qCAAtB,EAA6D,KAAK,iBAAL,CAAuB,IAAvB,CAA4B,IAA5B,CAA7D;;AACA,SAAK,KAAL,GAAa,KAAb;AACH;;AA1BD,MAAI,WAAJ,GAAe;AACX,WAAO,KAAK,YAAZ;AACH;;AA2BY,EAAA,KAAK,CAAC,QAAD,EAAW,KAAX,EAAuB;;AACrC,UAAI,IAAI,GAAG,IAAX;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB;AACA,MAAA,IAAI,CAAC,IAAL,GAAY,KAAK,CAAC,IAAlB;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,QAAL,CAAc,OAA9B;AACA,MAAA,IAAI,CAAC,OAAL,GAAe,IAAI,CAAC,QAAL,CAAc,MAA7B;AACA,WAAK,qBAAL,GAA6B,EAA7B;;AAEA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,GAAlC;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0BAAlC;;AACA,UAAI,SAAS,GAAG,IAAI,IAAJ,GAAW,OAAX,EAAhB;AACA,WAAK,cAAL,G,CAEA;AACA;;AAEA,UAAI,aAAa,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,IAAJ,GAAW,OAAX,KAAuB,SAAlC,CAApB,C,CACA;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gBAAgB,aAAa,UAA/D;;AACA,WAAK,KAAL,GAAa,IAAb;AAEH,K;AAAA;;AAEY,EAAA,IAAI,GAAA;;AACb,UAAI,IAAI,GAAG,IAAX;;AAEA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iBAAlC,E,CAEA;;;AACA,WAAK,OAAL,GAAe,KAAf;AACA,WAAK,YAAL,GAAoB,KAApB;AAEA,MAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AAEA,aAAO,IAAI,CAAC,qBAAZ;AACA,MAAA,IAAI,CAAC,qBAAL,GAA6B,IAA7B;;AACA,UAAI,IAAI,CAAC,qBAAT,EAAgC;AAC5B,QAAA,IAAI,CAAC,qBAAL,CAA2B,OAA3B,CAAoC,KAAD,IAAW,MAAM,CAAC,WAAP,CAAmB,KAAnB,CAA9C;AACH;;AACD,MAAA,IAAI,CAAC,qBAAL,GAA6B,EAA7B;AAEA;;;;;;;;AAUA,WAAK,KAAL,GAAa,KAAb;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gBAAlC;AACH,K;AAAA;;AAEY,EAAA,IAAI,GAAA;;AACb,UAAI,IAAI,GAAG,IAAX;AACA,YAAM,KAAK,kBAAL,EAAN;AACA;;;;;;;;;;;;;;;;AAkBH,K;AAAA;;AAEO,EAAA,cAAc,GAAA;AAClB,QAAI,IAAI,GAAG,IAAX;;AAEA,IAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iCAAlC;;AAEA,IAAA,IAAI,CAAC,qBAAL,GAA6B,IAAI,sBAAA,CAAA,oBAAJ,CAAyB,IAAI,CAAC,KAA9B,EAAqC,IAArC,CAA7B;AACA,IAAA,IAAI,CAAC,qBAAL,GAA6B,CACzB,MAAM,CAAC,SAAP,CAAiB,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,GAAlB,GAAwB,IAAI,CAAC,qBAAL,CAA2B,kBAApE,EAAwF,IAAI,CAAC,qBAAL,CAA2B,2BAAnH,CADyB,EAEzB,MAAM,CAAC,SAAP,CAAkB,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,GAAlB,GAAwB,IAAI,CAAC,qBAAL,CAA2B,aAArE,EAAoF,IAAI,CAAC,qBAAL,CAA2B,sBAA/G,CAFyB,CAA7B;AAKA;;;;;AAMA;;;;;;;;AAQH;;AAGY,EAAA,SAAS,GAAA;;AAClB,YAAM,KAAK,kBAAL,EAAN,C,CACA;;AACA,WAAK,cAAL;AACH,K;AAAA;;AAGa,EAAA,kBAAkB,GAAA;;AAC5B,UAAI;AACA,YAAI,IAAI,GAAG,IAAX;AACA,eAAO,IAAI,OAAJ,CAAY,CAAO,OAAP,EAAgB,MAAhB,KAA0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACzC,eAAK,KAAL,CAAW,kBAAX,GAAgC,IAAhC,CAA4C,QAAP,IAAwB,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACzD,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,6CAAlC,EAAiF,QAAQ,CAAC,MAA1F;;AACA,gBAAI,QAAJ,EAAc;AACV,kBAAI,QAAQ,GAAG,QAAQ,CAAC,GAAT,CAAoB,IAAP,IAAoB,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC5C,uBAAO,KAAK,iBAAL,CAAuB,IAAI,CAAC,EAA5B,EAAgC,IAAI,CAAC,MAArC,EAA6C,IAAI,CAAC,IAAlD,CAAP;AACH,eAF+C,CAAjC,CAAf;AAGA,kBAAI,SAAS,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAtB;AACA,mBAAK,SAAL,GAAiB,SAAS,CAAC,MAAV,CAAkB,QAAD,IAAa;AAC3C,uBAAO,QAAQ,KAAK,IAApB;AACH,eAFgB,CAAjB;;AAGA,cAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0CAA0C,KAAK,SAAL,CAAe,MAAM,YAAjG;AACH;;AACD,YAAA,OAAO,CAAC,KAAK,SAAN,CAAP;AACH,WAb4D,CAA7D,EAaG,KAbH,CAaU,GAAD,IAAQ;AACb,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,6BAAnC;;AACA,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,+BAA3C,EAA4E,GAA5E;;AACA,mBAAO,MAAM,CAAC,GAAD,CAAb;AACH,WAjBD;AAmBA;;;;;;;;;;AASH,SA7B4C,CAAtC,CAAP;AA8BH,OAhCD,CAiCA,OAAO,KAAP,EAAc;AACV,YAAI,YAAY,GAAG,oCAAoC,KAAK,CAAC,OAAO,EAApE;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,uCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,qBAAqB,YAAY,EAA5E;;AACA,cAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;AACH;AACJ,K;AAAA;;AAEa,EAAA,iBAAiB,CAAC,MAAD,EAAiB,IAAjB,EAA6B;;AACxD,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI;AACA,YAAI,QAAQ,GAAG,MAAM,IAAI,CAAC,KAAL,CAAW,iBAAX,CAA6B,MAA7B,EAAqC,IAArC,CAArB;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAE,qBAAqB,MAAM,KAAK,IAAI,cAAzE,EAAyF,QAAzF;;AACA,eAAO,QAAP;AACH,OAJD,CAKA,OAAO,KAAP,EAAc;AACV,YAAI,YAAY,GAAG,qBAAqB,MAAM,KAAK,IAAI,mBAAmB,KAAK,CAAC,OAAO,EAAvF;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,GAAG,YAAY,EAA1D;;AACA,cAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;AACH;AACJ,K;AAAA;;AAEa,EAAA,oBAAoB,CAAC,UAAD,EAAmB;;AACjD,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI;AACA,eAAO,IAAI,OAAJ,CAAY,CAAO,OAAP,EAAgB,MAAhB,KAA0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACzC,UAAA,IAAI,CAAC,KAAL,CAAW,oBAAX,CAAgC,UAAhC,EAA4C,IAA5C,CAAwD,eAAP,IAA2B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACxE,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAE,oCAAjC;;AACA,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAE,sCAArC,EAA6E,eAA7E;;AACA,YAAA,OAAO,CAAC,eAAD,CAAP;AACH,WAJ2E,CAA5E,EAIG,KAJH,CAIU,GAAD,IAAQ;AACb,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,+BAAnC;;AACA,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iCAA3C,EAA8E,GAA9E;;AACA,mBAAO,MAAM,CAAC,GAAD,CAAb;AACH,WARD;AAUH,SAX4C,CAAtC,CAAP;AAYH,OAbD,CAcA,OAAO,KAAP,EAAc;AACV,YAAI,YAAY,GAAG,wBAAwB,UAAU,mBAAmB,KAAK,CAAC,UAAU,EAAxF;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAE,+BAAlC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAE,GAAG,YAAY,EAAzD;;AACA,cAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;AACH;AACJ,K;AAAA;;AAEa,EAAA,cAAc,CAAC,YAAD,EAAkB;;AAC1C,UAAI,MAAM,GAAG,YAAY,CAAC,OAAb,GAAuB,YAAY,CAAC,OAAb,CAAqB,IAA5C,GAAmD,YAAY,CAAC,IAAb,CAAkB,IAAlF;AACA,UAAI,IAAI,GAAG,YAAY,CAAC,OAAb,GAAwB,YAAY,CAAC,OAAb,CAAqB,KAArB,GAA6B,KAA7B,GAAqC,MAA7D,GAAuE,MAAlF;AACA,UAAI,QAAQ,GAAa,KAAK,SAAL,CAAe,IAAf,CAAqB,YAAD,IAAsB;AAAG,eAAO,YAAY,CAAC,MAAb,KAAwB,MAA/B;AAAwC,OAArF,CAAzB;;AACA,UAAI,CAAC,QAAL,EAAe;AACX,eAAO,KAAK,iBAAL,CAAuB,MAAvB,EAA+B,IAA/B,CAAP;AACH,OAFD,MAEO;AACH,eAAO,KAAK,oBAAL,CAA0B,QAAQ,CAAC,EAAnC,CAAP;AACH;AACJ,K;AAAA;;AAEO,EAAA,eAAe,CAAC,YAAD,EAAkB;AACrC,QAAI,MAAM,GAAG,YAAY,CAAC,OAAb,GAAuB,YAAY,CAAC,OAAb,CAAqB,IAA5C,GAAmD,YAAY,CAAC,IAAb,CAAkB,IAAlF;AACA,QAAI,QAAQ,GAAa,KAAK,SAAL,CAAe,IAAf,CAAqB,YAAD,IAAsB;AAAG,aAAO,YAAY,CAAC,MAAb,KAAwB,MAA/B;AAAwC,KAArF,CAAzB;;AACA,QAAI,QAAJ,EAAc;AAAE,MAAA,YAAY,CAAC,UAAb,GAA0B,IAA1B;AAAgC,MAAA,QAAQ,CAAC,IAAT,GAAgB,YAAhB;AAA+B;AAClF;;AAEa,EAAA,WAAW,CAAC,MAAD,EAAe;;AACpC,UAAI,QAAQ,GAAG,KAAK,SAAL,CAAe,IAAf,CAAqB,YAAD,IAAsB;AAAG,eAAO,YAAY,CAAC,MAAb,KAAwB,MAA/B;AAAwC,OAArF,CAAf,C,CACA;AACA;AACH,K;AAAA;;AAEa,EAAA,iBAAiB,CAAC,EAAD,EAAa,MAAb,EAA6B,IAA7B,EAAyC;;AACpE,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI;AACA,YAAI,QAAQ,GAAQ,IAAI,UAAA,CAAA,QAAJ,CAAa,EAAb,EAAiB,MAAjB,EAAyB,IAAzB,CAApB;AAEA;;;;;;;;;;AAWA,eAAO,QAAP;AACH,OAfD,CAgBA,OAAO,KAAP,EAAc;AACV,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,yBAAnC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kBAAkB,EAAE,KAAK,MAAM,KAAK,IAAI,mBAAmB,KAAK,CAAC,OAAO,EAAnH;;AACA,eAAO,IAAP;AACH;AACJ,K;AAAA;;AAEa,EAAA,WAAW,CAAC,MAAD,EAAO;;AAC5B,UAAI;AAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BJ,OA9BD,CA+BA,OAAO,KAAP,EAAc;AAAE,eAAO,IAAP;AAAc;AACjC,K;AAAA;AAED;;;;;;AAQA;;;;;;;;;;;AASa,EAAA,iBAAiB,GAAA;;AAC1B,UAAI,IAAI,GAAG,IAAX;AAEA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,QAAA,IAAI,CAAC,kBAAL,GACK,IADL,CACU,UAAS,SAAT,EAAkB;AACpB,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,2DAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,8DAAtC,EAAsG,SAAtG;;AACA,UAAA,OAAO,CAAC,SAAD,CAAP;AACH,SALL,EAMK,KANL,CAMW,UAAS,GAAT,EAAY;AACf,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,+BAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iCAA3C,EAA8E,GAA9E;;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAVL;AAWH,OAZM,CAAP;AAaH,K;AAAA;;AAED;;;;;;;;;;;AAWa,EAAA,cAAc,CAAC,EAAD,EAAK,IAAL,EAAS;;AAChC,UAAI,IAAI,GAAG,IAAX;AAEA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,YAAI,CAAC,EAAL,EAAS;AACL,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,8DAAnC;;AACA,iBAAO,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAb;AACH;;AAED,YAAI,CAAC,IAAL,EAAW;AACP,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,gEAAnC;;AACA,iBAAO,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAb;AACH;;AAED,YAAI,IAAI,KAAK,QAAT,IAAqB,IAAI,KAAK,MAAlC,EAA0C;AACtC,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,yEAAnC;;AACA,iBAAO,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAb;AACH;;AAED,YAAI,IAAI,KAAK,QAAb,EAAuB;AACnB,UAAA,IAAI,GAAG,MAAP;AACH;;AAED,QAAA,IAAI,CAAC,iBAAL,CAAuB,EAAvB,EAA2B,IAA3B,EAAiC,IAAjC,CAAuC,QAAD,IAAkB;AACpD,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,0CAA0C,IAAI,eAAjF;;AACA,iBAAO,OAAO,CAAC,QAAD,CAAd;AACH,SAHD,EAGG,KAHH,CAGS,GAAG,IAAG;AACX,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8BAA3C,EAA2E,GAA3E;;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAPD;AASH,OA9BM,CAAP;AA+BH,K;AAAA;;AAED;;;;;;;;;;AAUM,EAAA,cAAc,CAAC,EAAD,EAAG;;AACnB,UAAI,IAAI,GAAG,IAAX;AACA,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,YAAI,CAAC,EAAL,EAAS;AACL,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,8DAAnC;;AACA,iBAAO,MAAM,CAAC,8DAAD,CAAb;AACH;;AAED,QAAA,IAAI,CAAC,oBAAL,CAA0B,EAA1B,EACK,IADL,CACW,UAAD,IAAe;AACjB,iBAAO,OAAO,CAAC,UAAD,CAAd;AACH,SAHL,EAIK,KAJL,CAIW,GAAG,IAAG;AACT,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8BAA3C,EAA2E,GAA3E;;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SARL;AASH,OAfM,CAAP;AAgBH,K;AAAA,GAxbiB,CA0blB;;;AACc,EAAA,iBAAiB,CAAC,GAAD,EAA+C;;AAC1E,UAAI,IAAI,GAAG,IAAX;AACA,UAAI,QAAQ,GAAa,KAAK,SAAL,CAAe,IAAf,CAAqB,YAAD,IAAsB;AAAG,eAAO,YAAY,CAAC,MAAb,KAAwB,GAAG,CAAC,MAAnC;AAA4C,OAAzF,CAAzB;;AACA,UAAI,CAAC,QAAL,EAAe;AACX,QAAA,QAAQ,GAAG,MAAM,KAAK,iBAAL,CAAuB,GAAG,CAAC,EAA3B,EAA+B,GAAG,CAAC,MAAnC,EAA2C,GAAG,CAAC,IAA/C,CAAjB;AACA,aAAK,SAAL,CAAe,IAAf,CAAoB,QAApB,EAFW,CAGX;AACA;;AAEA,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,8BAAxB,EAAwD,QAAxD;AACH;AACJ,K;AAAA;;AAEY,EAAA,iBAAiB,CAAC,GAAD,EAA+C;;AACzE,UAAI,IAAI,GAAG,IAAX;AACA,UAAI,KAAK,GAAG,KAAK,SAAL,CAAe,SAAf,CAA0B,GAAD,IAAQ;AAAG,eAAO,GAAG,CAAC,EAAJ,KAAW,GAAG,CAAC,EAAtB;AAA2B,OAA/D,CAAZ;;AACA,UAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd,YAAI,QAAQ,GAAG,KAAK,SAAL,CAAe,KAAf,CAAf;;AACA,YAAI,QAAQ,CAAC,IAAb,EAAmB;AAAE,UAAA,QAAQ,CAAC,IAAT,CAAc,UAAd,GAA2B,KAA3B;AAAmC;;AACxD,aAAK,SAAL,CAAe,MAAf,CAAsB,KAAtB,EAA6B,CAA7B,EAHc,CAId;AACA;;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,8BAAxB,EAAwD,GAAxD;AACH;AACJ,K;AAAA;;AAndiB,CAAtB;AAAM,gBAAgB,GAAA,UAAA,CAAA,CAbrB,OAAA,CAAA,YAAA,CAAa,MAAb,CAaqB,EAZrB,OAAA,CAAA,SAAA,CAAU,EAAV;AACD;;;;;;;;;;;AAWsB,CAAA,EAAhB,gBAAgB,CAAhB;AAudE,OAAA,CAAA,gBAAA,GAAA,gBAAA;AADR,MAAM,CAAC,OAAP,CAAe,gBAAf,GAAkC,gBAAlC","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst PubSub = require(\"pubsub-js\");\r\nconst favoriteEventHandler_1 = require(\"../connection/XMPPServiceHandler/favoriteEventHandler\");\r\nconst Favorite_1 = require(\"../common/models/Favorite\");\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst LOG_ID = \"FAVTE/SVCE - \";\r\nlet FavoritesService = \r\n/**\r\n* @module\r\n* @name FavoritesService\r\n * @version 1.67.1 \r\n * @public\r\n* @description\r\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\r\n*      - Retrieve all information linked to that Favorite, <br>\r\n*/\r\nclass FavoritesService {\r\n    constructor(_eventEmitter, logger, _startConfig) {\r\n        //public static $inject: string[] = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];\r\n        this.favorites = [];\r\n        this.ready = false;\r\n        /*********************************************************/\r\n        /**                 LIFECYCLE STUFF                     **/\r\n        /*********************************************************/\r\n        this._startConfig = _startConfig;\r\n        //let that = this;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._logger = logger;\r\n        this.started = false;\r\n        this._initialized = false;\r\n        this._eventEmitter.on(\"evt_internal_favoritecreated_handle\", this.onFavoriteCreated.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_favoritedeleted_handle\", this.onFavoriteDeleted.bind(this));\r\n        this.ready = false;\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._xmpp = _core._xmpp;\r\n            that._rest = _core._rest;\r\n            that._options = _options;\r\n            that._s2s = _core._s2s;\r\n            that._useXMPP = that._options.useXMPP;\r\n            that._useS2S = that._options.useS2S;\r\n            this._favoriteHandlerToken = [];\r\n            that._logger.log(\"info\", LOG_ID + \" \");\r\n            that._logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\r\n            let startDate = new Date().getTime();\r\n            this.attachHandlers();\r\n            //this.conversationService.favoriteService = this;\r\n            //this.attachHandlers();\r\n            let startDuration = Math.round(new Date().getTime() - startDate);\r\n            //stats.push({ service: 'favoriteService', startDuration: startDuration });\r\n            that._logger.log(\"info\", LOG_ID + `=== STARTED (${startDuration} ms) ===`);\r\n            this.ready = true;\r\n        });\r\n    }\r\n    stop() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._logger.log(\"info\", LOG_ID + \"[stop] Stopping\");\r\n            //remove all saved call logs\r\n            this.started = false;\r\n            this._initialized = false;\r\n            that._xmpp = null;\r\n            that._rest = null;\r\n            delete that._favoriteEventHandler;\r\n            that._favoriteEventHandler = null;\r\n            if (that._favoriteHandlerToken) {\r\n                that._favoriteHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n            }\r\n            that._favoriteHandlerToken = [];\r\n            /*this.$log.info('Stopping');\r\n            if (this._xmppManagementHandler) {\r\n                this.xmppService.deleteHandler(this._xmppManagementHandler);\r\n                this._xmppManagementHandler = null;\r\n            }\r\n            this.$log.info('Stopped');\r\n    \r\n             */\r\n            this.ready = false;\r\n            that._logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\r\n        });\r\n    }\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            yield this.getServerFavorites();\r\n            /*await setTimeoutPromised(3000).then(() => {\r\n                let startDate = new Date();\r\n                that.getCallLogHistoryPage()\r\n                    .then(() => {\r\n                        // @ts-ignore\r\n                        let duration = new Date() - startDate;\r\n                        let startDuration = Math.round(duration);\r\n                        that._logger.log(\"info\", LOG_ID + \" callLogService start duration : \",  startDuration);\r\n                        that._logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\r\n                        that.started = true;\r\n                    })\r\n                    .catch(() => {\r\n                        that._logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\r\n                    });\r\n            });\r\n    \r\n             */\r\n        });\r\n    }\r\n    attachHandlers() {\r\n        let that = this;\r\n        that._logger.log(\"info\", LOG_ID + \"[attachHandlers] attachHandlers\");\r\n        that._favoriteEventHandler = new favoriteEventHandler_1.FavoriteEventHandler(that._xmpp, that);\r\n        that._favoriteHandlerToken = [\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_MANAGEMENT, that._favoriteEventHandler.onManagementMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_ERROR, that._favoriteEventHandler.onErrorMessageReceived)\r\n        ];\r\n        /*\r\n        if (this._xmppManagementHandler) { this.xmppService.deleteHandler(this._xmppManagementHandler); }\r\n        this._xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, \"message\", \"management\");\r\n\r\n         */\r\n        /*\r\n        //if reconnection, update the call-logs\r\n        if (that.started && that.lastTimestamp) {\r\n            $interval(function () {\r\n                that.getCallLogHistoryPage(that.lastTimestamp);\r\n            }, 1000, 1, true);\r\n        }\r\n        // */\r\n    }\r\n    reconnect() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.getServerFavorites();\r\n            //this.conversationService.favoriteService = this;\r\n            this.attachHandlers();\r\n        });\r\n    }\r\n    getServerFavorites() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                let that = this;\r\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                    this._rest.getServerFavorites().then((favorite) => __awaiter(this, void 0, void 0, function* () {\r\n                        that._logger.log(\"info\", LOG_ID + \"(getServerFavorites) favorite tab length : \", favorite.length);\r\n                        if (favorite) {\r\n                            let promises = favorite.map((data) => __awaiter(this, void 0, void 0, function* () {\r\n                                return this.createFavoriteObj(data.id, data.peerId, data.type);\r\n                            }));\r\n                            let favorites = yield Promise.all(promises);\r\n                            this.favorites = favorites.filter((favorite) => {\r\n                                return favorite !== null;\r\n                            });\r\n                            that._logger.log(\"info\", LOG_ID + `getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\r\n                        }\r\n                        resolve(this.favorites);\r\n                    })).catch((err) => {\r\n                        that._logger.log(\"error\", LOG_ID + \"(getServerFavorites) error.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"(getServerFavorites) error : \", err);\r\n                        return reject(err);\r\n                    });\r\n                    /*\r\n    //            let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\r\n      //          let response = await this.$http({ method: \"GET\", url: url, headers: this.authService.getRequestHeader() });\r\n                let promises = response.data.data.map(async (data: any) => { return this.createFavorite(data.id, data.peerId, data.type); });\r\n                let favorites = await Promise.all(promises);\r\n                this.favorites = favorites.filter((favorite) => { return favorite !== null; });\r\n                this.$log.info(`getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\r\n                return this.favorites;\r\n                */\r\n                }));\r\n            }\r\n            catch (error) {\r\n                let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;\r\n                this._logger.log(\"error\", LOG_ID + `[getServerFavorites] CATCH Error !!! `);\r\n                this._logger.log(\"internalerror\", LOG_ID + `CATCH Error !!! : ${errorMessage}`);\r\n                throw new Error(errorMessage);\r\n            }\r\n        });\r\n    }\r\n    addServerFavorite(peerId, type) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            try {\r\n                let favorite = yield that._rest.addServerFavorite(peerId, type);\r\n                that._logger.log(\"internal\", LOG_ID + `addServerFavorite(${peerId}, ${type}) -- SUCCESS`, favorite);\r\n                return favorite;\r\n            }\r\n            catch (error) {\r\n                let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;\r\n                that._logger.log(\"error\", LOG_ID + `[addServerFavorite] Error.`);\r\n                that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\r\n                throw new Error(errorMessage);\r\n            }\r\n        });\r\n    }\r\n    removeServerFavorite(favoriteId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            try {\r\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                    that._rest.removeServerFavorite(favoriteId).then((favoriteDeleted) => __awaiter(this, void 0, void 0, function* () {\r\n                        that._logger.log(\"info\", LOG_ID + \"(removeServerFavorite) -- SUCCESS.\");\r\n                        that._logger.log(\"internal\", LOG_ID + \"(removeServerFavorite) -- SUCCESS : \", favoriteDeleted);\r\n                        resolve(favoriteDeleted);\r\n                    })).catch((err) => {\r\n                        that._logger.log(\"error\", LOG_ID + \"(removeServerFavorite) error.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"(removeServerFavorite) error : \", err);\r\n                        return reject(err);\r\n                    });\r\n                }));\r\n            }\r\n            catch (error) {\r\n                let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;\r\n                that._logger.log(\"error\", LOG_ID + `[removeServerFavorite] Error.`);\r\n                that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\r\n                throw new Error(errorMessage);\r\n            }\r\n        });\r\n    }\r\n    toggleFavorite(conversation) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\r\n            let type = conversation.contact ? (conversation.contact.isBot ? 'bot' : 'user') : 'room';\r\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\r\n            if (!favorite) {\r\n                return this.addServerFavorite(peerId, type);\r\n            }\r\n            else {\r\n                return this.removeServerFavorite(favorite.id);\r\n            }\r\n        });\r\n    }\r\n    updateFavorites(conversation) {\r\n        let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\r\n        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\r\n        if (favorite) {\r\n            conversation.isFavorite = true;\r\n            favorite.conv = conversation;\r\n        }\r\n    }\r\n    getFavorite(peerId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\r\n            //let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);\r\n            //return await convGetter;\r\n        });\r\n    }\r\n    createFavoriteObj(id, peerId, type) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            try {\r\n                let favorite = new Favorite_1.Favorite(id, peerId, type);\r\n                /*\r\n                // Get peer object\r\n                if (type === 'room') { favorite.room = this.roomService.getRoomById(peerId); }\r\n                else { favorite.contact = await this.contactService.getContactByDBId(peerId); }\r\n    \r\n                // Fetch eventual conversation\r\n                let convId: string = favorite.room ? favorite.room.jid : favorite.contact.jid;\r\n                let conv: any = this.conversationService.getConversationById(convId);\r\n                if (conv) { conv.isFavorite = true; favorite.conv = conv; }\r\n    \r\n                 */\r\n                return favorite;\r\n            }\r\n            catch (error) {\r\n                that._logger.log(\"error\", LOG_ID + `[createFavorite] Error.`);\r\n                that._logger.log(\"internalerror\", LOG_ID + `createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n    onXmppEvent(stanza) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try { /*\r\n                let stanzaElem = $(stanza);\r\n                let favoriteElem = stanzaElem.find(\"favorite\");\r\n                if (favoriteElem) {\r\n                    let id = favoriteElem.attr(\"id\");\r\n                    let type = favoriteElem.attr(\"type\");\r\n                    let peerId = favoriteElem.attr(\"peer_id\");\r\n                    let action = favoriteElem.attr(\"action\");\r\n    \r\n                    if (action === 'create') {\r\n                        let favorite: Favorite = this.favorites.find((favoriteConv: any) => { return favoriteConv.peerId === peerId; });\r\n                        if (!favorite) {\r\n                            favorite = await this.createFavorite(id, peerId, type);\r\n                            this.favorites.push(favorite);\r\n                            this.sendEvent('ON_FAVORITE_CREATED', { favorite });\r\n                        }\r\n                    }\r\n    \r\n                    if (action === 'delete') {\r\n                        let index = this.favorites.findIndex((fav) => { return fav.id === id; });\r\n                        if (index !== -1) {\r\n                            let favorite = this.favorites[index];\r\n                            if (favorite.conv) { favorite.conv.isFavorite = false; }\r\n                            this.favorites.splice(index, 1);\r\n                            this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n                */\r\n            }\r\n            catch (error) {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    /*private sendEvent(eventName: string, detail: any): void {\r\n        let event = new CustomEvent(eventName, { detail });\r\n        window.dispatchEvent(event);\r\n    }\r\n\r\n     */\r\n    /**\r\n     * @public\r\n     * @since 1.56\r\n     * @method fetchAllFavorites()\r\n     * @instance\r\n     * @description\r\n     *   Fetch all the Favorites from the server in a form of an Array\r\n     * @return {Conversation[]} An array of Favorite objects\r\n     */\r\n    fetchAllFavorites() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                that.getServerFavorites()\r\n                    .then(function (favorites) {\r\n                    that._logger.log(\"debug\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites`);\r\n                    that._logger.log(\"internal\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites : `, favorites);\r\n                    resolve(favorites);\r\n                })\r\n                    .catch(function (err) {\r\n                    that._logger.log(\"error\", LOG_ID + `[fetchAllFavorites] :: Error.`);\r\n                    that._logger.log(\"internalerror\", LOG_ID + `[fetchAllFavorites] :: ERROR : `, err);\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @since 1.56\r\n     * @method createFavorite()\r\n     * @instance\r\n     * @description\r\n     *   Add conversation/bubble/bot to Favorites Array\r\n     * @param {String} id of the conversation/bubble\r\n     * @param {String} type of Favorite (can be 'user' or 'bubble')\r\n     * @return {Promise<Favorite>} A Favorite object\r\n     */\r\n    createFavorite(id, type) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                if (!id) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                }\r\n                if (!type) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                }\r\n                if (type !== \"bubble\" && type !== \"user\") {\r\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: type should be set to \\\"user\\\" or \\\"bubble\\\"\");\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                }\r\n                if (type === \"bubble\") {\r\n                    type = \"room\";\r\n                }\r\n                that.addServerFavorite(id, type).then((favorite) => {\r\n                    that._logger.log(\"debug\", LOG_ID + `[createFavorite] :: Successfully added ${type} to favorites`);\r\n                    return resolve(favorite);\r\n                }).catch(err => {\r\n                    that._logger.log(\"error\", LOG_ID + \"[createFavorite] :: Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"[createFavorite] :: Error : \", err);\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @since 1.56\r\n     * @method deleteFavorite()\r\n     * @instance\r\n     * @description\r\n     *   Delete conversation/bubble/bot from Favorites Array\r\n     * @param {String} id of the Favorite item\r\n     * @return {Favorite[]} A Favorite object\r\n     */\r\n    deleteFavorite(id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                if (!id) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\r\n                    return reject(\"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\r\n                }\r\n                that.removeServerFavorite(id)\r\n                    .then((favDeleted) => {\r\n                    return resolve(favDeleted);\r\n                })\r\n                    .catch(err => {\r\n                    that._logger.log(\"error\", LOG_ID + \"[deleteFavorite] :: Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"[deleteFavorite] :: Error : \", err);\r\n                    return reject(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    // ******************* Event XMPP parsed in favoriteEventHandler ***************\r\n    onFavoriteCreated(fav) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === fav.peerId; });\r\n            if (!favorite) {\r\n                favorite = yield this.createFavoriteObj(fav.id, fav.peerId, fav.type);\r\n                this.favorites.push(favorite);\r\n                //that._logger.log(\"internal\", LOG_ID + \"[onFavoriteCreated] send event : \", favorite);\r\n                //this.sendEvent('ON_FAVORITE_CREATED', { favorite });\r\n                that._eventEmitter.emit(\"evt_internal_favoritecreated\", favorite);\r\n            }\r\n        });\r\n    }\r\n    onFavoriteDeleted(fav) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            let index = this.favorites.findIndex((fav) => { return fav.id === fav.id; });\r\n            if (index !== -1) {\r\n                let favorite = this.favorites[index];\r\n                if (favorite.conv) {\r\n                    favorite.conv.isFavorite = false;\r\n                }\r\n                this.favorites.splice(index, 1);\r\n                //that._logger.log(\"debug\", LOG_ID + \"[onFavoriteDeleted] send event : \", { favoriteId: favorite.id });\r\n                //this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\r\n                that._eventEmitter.emit(\"evt_internal_favoritedeleted\", fav);\r\n            }\r\n        });\r\n    }\r\n};\r\nFavoritesService = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n    * @module\r\n    * @name FavoritesService\r\n     * @version 1.67.1 \r\n     * @public\r\n    * @description\r\n    *      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\r\n    *      The main methods and events proposed in that service allow to: <br>\r\n    *      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\r\n    *      - Retrieve all information linked to that Favorite, <br>\r\n    */\r\n], FavoritesService);\r\nexports.FavoritesService = FavoritesService;\r\nmodule.exports.FavoritesService = FavoritesService;\r\n//# sourceMappingURL=FavoritesService.js.map"]},"metadata":{},"sourceType":"script"}