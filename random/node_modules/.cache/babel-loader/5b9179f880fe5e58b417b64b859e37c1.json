{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Conversation_1 = require(\"../common/models/Conversation\");\n\nconst Call_1 = require(\"../common/models/Call\");\n\nconst moment = require(\"moment\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst conversationEventHandler_1 = require(\"../connection/XMPPServiceHandler/conversationEventHandler\");\n\nconst conversationHistoryHandler_1 = require(\"../connection/XMPPServiceHandler/conversationHistoryHandler\");\n\nconst Emoji_1 = require(\"../common/Emoji\");\n\nconst FileViewer_1 = require(\"../common/models/FileViewer\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"CONVERSATIONS/SVCE - \";\nlet Conversations =\n/**\r\n * @module\r\n * @name Conversations\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n * This module is the basic module for handling conversations in Rainbow. In Rainbow, conversations are the way to get in touch with someone or something (i.e. a Rainbow contact, a external phone number, a connected thing, ...) so a conversation is the \"long tail\" of communication between you and someone or something else like a bubble.\r\n * A Rainbow conversation by default supports sending and receiving Instant Messages with a single recipient (one-to-one conversation) or with several persons (bubble). Using the FileStorage service, you can share files in conversations.\r\n *\r\n * The main methods and events proposed in that service allow to:\r\n *   - Create or close a Rainbow conversation (one-to-one of bubble),\r\n *   - Get all conversations or get a conversation by Id, bubbleID or bubbleJid\r\n *   - Retrieve all information linked to that conversation,\r\n *\r\n *   */\nclass Conversations {\n  constructor(_eventEmitter, _logger, _startConfig, _conversationsRetrievedFormat, _nbMaxConversations) {\n    this.ready = false;\n    this.conversationsRetrievedFormat = \"small\";\n    this._startConfig = _startConfig;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._contacts = null;\n    this._fileStorageService = null;\n    this._fileServerService = null;\n    this._eventEmitter = _eventEmitter;\n    this._logger = _logger;\n    this.pendingMessages = {};\n    this._conversationEventHandler = null;\n    this._conversationHandlerToken = [];\n    this._conversationHistoryHandlerToken = [];\n    this.conversationsRetrievedFormat = _conversationsRetrievedFormat;\n    this.nbMaxConversations = _nbMaxConversations; //that._eventEmitter.removeListener(\"evt_internal_onreceipt\", that._onReceipt.bind(that));\n\n    this.ready = false;\n\n    this._eventEmitter.on(\"evt_internal_onreceipt\", this._onReceipt.bind(this));\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    that._conversationHandlerToken = [];\n    that._conversationHistoryHandlerToken = [];\n    return new Promise((resolve, reject) => {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._contacts = _core.contacts;\n        that._bubbles = _core.bubbles;\n        that._fileStorageService = _core.fileStorage;\n        that._fileServerService = _core.fileServer;\n        that._presence = _core.presence;\n        that.activeConversation = null;\n        that.conversations = [];\n        that.inCallConversations = [];\n        that.idleConversations = [];\n        that.involvedContactIds = [];\n        that.involvedRoomIds = []; //all conversations with Bots\n\n        that.waitingBotConversations = [];\n        that.botServiceReady = false;\n        that.attachHandlers();\n        this.ready = true;\n        resolve();\n      } catch (err) {\n        that._logger.log(\"error\", LOG_ID + \"(start) !!! Catch error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(start) !!! Catch error : \", err);\n\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      try {\n        that._xmpp = null;\n        that._rest = null;\n        delete that._conversationEventHandler;\n        that._conversationEventHandler = null;\n\n        if (that._conversationHandlerToken) {\n          that._conversationHandlerToken.forEach(token => PubSub.unsubscribe(token));\n        }\n\n        that._conversationHandlerToken = [];\n\n        if (that._conversationHistoryHandlerToken) {\n          that._conversationHistoryHandlerToken.forEach(token => PubSub.unsubscribe(token));\n        }\n\n        that._conversationHistoryHandlerToken = []; //that._eventEmitter.removeListener(\"evt_internal_onreceipt\", that._onReceipt.bind(that));\n\n        this.ready = false;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n    that._conversationEventHandler = new conversationEventHandler_1.ConversationEventHandler(that._xmpp, that, that._fileStorageService, that._fileServerService);\n    that._conversationHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_CHAT, that._conversationEventHandler.onChatMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_GROUPCHAT, that._conversationEventHandler.onChatMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_WEBRTC, that._conversationEventHandler.onWebRTCMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_MANAGEMENT, that._conversationEventHandler.onManagementMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_ERROR, that._conversationEventHandler.onErrorMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_CLOSE, that._conversationEventHandler.onCloseMessageReceived)];\n    that._conversationHistoryHandler = new conversationHistoryHandler_1.ConversationHistoryHandler(that._xmpp, this);\n    that._conversationHistoryHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationHistoryHandler.MESSAGE_MAM, that._conversationHistoryHandler.onMamMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationHistoryHandler.FIN_MAM, that._conversationHistoryHandler.onMamMessageReceived)];\n  }\n\n  _onReceipt(receipt) {\n    let that = this;\n    let messageInfo = this.pendingMessages[receipt.id];\n\n    if (messageInfo && messageInfo.message) {\n      let message = messageInfo.message;\n      let conversation = messageInfo.conversation;\n\n      that._logger.log(\"debug\", LOG_ID + \"[conversationService] Receive server ack (\" + conversation.id + \", \" + message.id + \")\"); //message.setReceiptStatus(Message.ReceiptStatus.SENT);\n\n\n      conversation.addMessage(message);\n      that.removePendingMessage(message); //delete this.pendingMessages[message.id];\n      // Send event\n\n      that._eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n    }\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Allow to get the list of existing conversations from server (p2p and bubbles)\r\n   * @return {Conversation[]} An array of Conversation object\r\n   */\n\n\n  getServerConversations() {\n    let that = this;\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      yield that._rest.getServerConversations(that.conversationsRetrievedFormat).then(conversations => __awaiter(this, void 0, void 0, function* () {\n        yield that.removeOlderConversations(conversations);\n      })).catch(error => {\n        that._logger.log(\"warn\", LOG_ID + \"getServerConversations Failed to retrieve conversations for removeOlderConversations : \", error);\n\n        that._logger.log(\"internalerror\", LOG_ID + \"getServerConversations Failed to retrieve conversations for removeOlderConversations : \", error); // The remove of old conversations is not mandatory, so lets continue the treatment.\n\n      });\n\n      that._rest.getServerConversations(that.conversationsRetrievedFormat).then(conversations => {\n        // Create conversation promises\n        let conversationPromises = [];\n\n        that._logger.log(\"debug\", LOG_ID + \"getServerConversations conversations.length retrieved : \", conversations.length);\n\n        conversations.forEach(function (conversationData) {\n          let missedImCounter = parseInt(conversationData.unreadMessageNumber, 10);\n          let conversationPromise = null;\n          let muted = conversationData.mute === true; //that._logger.log(\"debug\", LOG_ID + \"getServerConversations conversationData retrieved : \", conversationData);\n\n          if (conversationData.type === \"user\") {\n            conversationPromise = that.getOrCreateOneToOneConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, muted, conversationData.creationDate);\n          } else {\n            conversationPromise = that.getBubbleConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, true, muted, conversationData.creationDate, conversationData.lastMessageSender);\n          } // */\n\n\n          conversationPromises.push(conversationPromise);\n        }); // Resolve all promises\n\n        return Promise.all(conversationPromises)\n        /*.then(async (result) => {\r\n            await that.removeOlderConversations();\r\n            return result;\r\n        }) // */\n        .then(conversationsResult => {\n          //that.orderConversations();\n          resolve(conversationsResult);\n        }).catch(error => {\n          let errorMessage = \"getServerConversations failure: \" + error.message;\n\n          that._logger.log(\"error\", LOG_ID + \"error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"error : \", errorMessage);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        });\n      }).catch(err => {\n        let errorMessage = \"getServerConversations failure: no server response\";\n\n        if (err) {\n          errorMessage = \"getServerConversations failure: \" + JSON.stringify(err);\n        }\n\n        that._logger.log(\"error\", LOG_ID + \"error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"error : \", errorMessage);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n      });\n    }));\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Allow to create a conversations on server (p2p and bubbles)\r\n   * @param {String} conversation of the conversation (dbId field)\r\n   * @return {Conversation} Created conversation object\r\n   */\n\n\n  createServerConversation(conversation) {\n    let that = this; // Ignore already stored existing conversation\n\n    if (conversation.dbId) {\n      return Promise.resolve(conversation);\n    } // Prepare global variables\n\n\n    let data = {\n      peerId: null,\n      type: null\n    }; // Handle one to one conversation\n\n    if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\n      // Ignore conversation with user without dbId\n      if (!conversation.contact.id) {\n        return Promise.resolve(conversation);\n      } // Fill conversation request data\n\n\n      data.peerId = conversation.contact.id;\n      data.type = \"user\";\n    } else if (conversation.type === Conversation_1.Conversation.Type.BOT) {\n      conversation.type = Conversation_1.Conversation.Type.ONE_TO_ONE; // Ignore conversation with user without dbId\n\n      if (!conversation.contact.id) {\n        return Promise.resolve(conversation);\n      } // Fill conversation request data\n\n\n      data.peerId = conversation.contact.id;\n      data.type = \"bot\";\n    } // Handle bubble conversation\n    else {\n        // Fill conversation request data\n        data.peerId = conversation.bubble.id;\n        data.type = \"room\";\n      }\n\n    if (conversation.bubble && conversation.bubble.avatar) {\n      let avatarRoom = conversation.bubble.avatar;\n    }\n\n    return this._rest.createServerConversation(data).then(result => {\n      that._logger.log(\"info\", LOG_ID + \"createServerConversation success: \" + conversation.id);\n\n      conversation.dbId = result.id;\n      conversation.lastModification = result.lastMessageDate ? new Date(result.lastMessageDate) : undefined;\n      conversation.creationDate = result.creationDate ? new Date(result.creationDate) : new Date();\n      conversation.missedCounter = parseInt(result.unreadMessageNumber, 10);\n      /* if (avatarRoom) {\r\n           conversation.bubble.avatar = avatarRoom;\r\n       } */\n      // TODO ? that.orderConversations();\n\n      return Promise.resolve(conversation);\n    }).catch(err => {\n      let errorMessage = \"createServerConversation failure: \" + err.errorDetails;\n\n      that._logger.log(\"error\", LOG_ID + \"\" + errorMessage);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n    });\n  } // */\n\n\n  removeOlderConversations(conversations) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // if (!authService.fromSDK) {\n      let maxConversations = that.nbMaxConversations; //add protection when the local storage does not work correctly ...\n\n      if (!maxConversations || maxConversations < 15) {\n        that.nbMaxConversations = 15;\n        maxConversations = 15;\n      }\n\n      let orderedConversations = conversations ? conversations.sort(that.sortFunction) : that.getConversations().sort(that.sortFunction);\n\n      that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- maxConversations : \", maxConversations);\n\n      if (orderedConversations.length > maxConversations) {\n        that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- orderedConversations : \", orderedConversations.length);\n\n        let removePromises = [];\n\n        for (let index = maxConversations; index < orderedConversations.length; index++) {\n          let conv = orderedConversations[index];\n\n          if (conv) {\n            removePromises.push(that.deleteServerConversation(conv.id));\n          } else {\n            that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- conversation undefined, so cannot delete it.\");\n          }\n        }\n\n        Promise.all(removePromises).then(result => {\n          resolve(result);\n        }).catch(err => {\n          resolve(err);\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  sortFunction(aa, bb) {\n    let aLast = aa.lastModification;\n    let aCreation = aa.creationDate;\n    let bLast = bb.lastModification;\n    let bCreation = bb.creationDate;\n    let aDate = aCreation;\n    let bDate = bCreation; //get the most recent of the creation date or the last message date\n\n    if (!aLast && aCreation) {\n      aDate = aCreation;\n    } else {\n      aDate = aLast;\n    }\n\n    if (!bLast && bCreation) {\n      bDate = bCreation;\n    } else {\n      bDate = bLast;\n    }\n\n    return bDate - aDate;\n  }\n\n  /* formatDate (date){\r\n       return moment(date).utc().format(\"YYYY-MM-DDTHH:mm:ss\") + \"Z\";\r\n   }; // */\n\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Allow to delete a conversation on server (p2p and bubbles)\r\n   * @param {String} conversationId of the conversation (id field)\r\n   * @return {Promise}\r\n   */\n  deleteServerConversation(conversationId) {\n    let that = this;\n\n    that._logger.log(\"info\", LOG_ID + \"deleteServerConversation conversationId : \", conversationId); // Ignore conversation without dbId\n\n\n    if (!conversationId) {\n      return Promise.resolve();\n    }\n\n    return that._rest.deleteServerConversation(conversationId).then(result => {\n      // TODO ? that.orderConversations();\n      return Promise.resolve(result);\n    }).catch(err => {\n      // Check particular case where we are trying to remove an already removed conversation\n      if (err.errorDetailsCode === 404002) {\n        that._logger.log(\"info\", LOG_ID + \"deleteServerConversation success: \" + conversationId);\n\n        return Promise.resolve();\n      }\n\n      let errorMessage = \"deleteServerConversation failure: \" + err.errorDetails;\n\n      that._logger.log(\"warn\", LOG_ID + \"Error.\");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n    });\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Allow to mute notification in a conversations (p2p and bubbles)\r\n   *    When a conversation is muted/unmuted, all user's resources will receive the notification\r\n   * @param {String} ID of the conversation (dbId field)\r\n   * @param {Boolean} mute mutation state\r\n   * @return {Promise}\r\n   */\n\n\n  updateServerConversation(conversationId, mute) {\n    // Ignore conversation without dbId\n    if (!conversationId) {\n      return Promise.resolve();\n    }\n\n    return this._rest.updateServerConversation(conversationId, mute);\n  }\n  /**\r\n   * @public\r\n   * @method sendConversationByEmail\r\n   * @instance\r\n   * @description\r\n   *    Allow to get the specified conversation as mail attachment to the login email of the current user (p2p and bubbles)\r\n   *    can be used to backup a conversation between a rainbow user and another one, or between a user and a room,\r\n   *    The backup of the conversation is restricted to a number of days before now. By default the limit is 30 days.\r\n   * @param {String} ID of the conversation (dbId field)\r\n   * @async\r\n   * @return {Promise<Conversation[]>}\r\n   * @fulfil {Conversation[]} - Array of Conversation object\r\n   * @category async\r\n   */\n\n\n  sendConversationByEmail(conversationDbId) {\n    return this._rest.sendConversationByEmail(conversationDbId);\n  }\n  /**\r\n   * @public\r\n   * @method ackAllMessages\r\n   * @instance\r\n   * @description\r\n   *    Mark all unread messages in the conversation as read.\r\n   * @param {String} ID of the conversation (dbId field)\r\n   * @async\r\n   * @return {Promise<Conversation[]>}\r\n   * @fulfil {Conversation[]} - Array of Conversation object\r\n   * @category async\r\n   */\n\n\n  ackAllMessages(conversationDbId) {\n    return this._rest.ackAllMessages(conversationDbId);\n  }\n  /**\r\n   * @public\r\n   * @method getHistoryPage\r\n   * @instance\r\n   * @description\r\n   *    Retrieve the remote history of a specific conversation.\r\n   * @param {Conversation} conversation Conversation to retrieve\r\n   * @param {number} size Maximum number of element to retrieve\r\n   * @async\r\n   * @return {Promise<Conversation[]>}\r\n   * @fulfil {Conversation[]} - Array of Conversation object\r\n   * @category async\r\n   */\n\n\n  getHistoryPage(conversation, size) {\n    let that = this; // Avoid to call several time the same request\n\n    if (conversation.currentHistoryId && conversation.currentHistoryId === conversation.historyIndex) {\n      that._logger.log(\"debug\", LOG_ID + \"[conversationServiceHistory] getHistoryPage(\", conversation.id, \", \", size, \", \", conversation.historyIndex, \") already asked\");\n\n      return Promise.resolve();\n    }\n\n    conversation.currentHistoryId = conversation.historyIndex;\n\n    that._logger.log(\"debug\", LOG_ID + \"[conversationServiceHistory] getHistoryPage(\", conversation.id, \", \", size, \", \", conversation.historyIndex, \")\"); // Create the defered object\n\n\n    let defered = conversation.historyDefered = new Utils_1.Deferred(); // Do nothing for userContact\n\n    if (that._contacts.isUserContact(conversation.contact)) {\n      defered.reject();\n      return defered.promise;\n    }\n\n    if (conversation.historyComplete) {\n      that._logger.log(\"debug\", LOG_ID + \"getHistoryPage(\" + conversation.id + \") : already complete\");\n\n      defered.reject();\n      return defered.promise;\n    }\n\n    let mamRequest = {\n      \"queryid\": conversation.id,\n      \"with\": conversation.id,\n      \"max\": size,\n      \"before\": \"\"\n    };\n\n    if (conversation.historyIndex !== -1) {\n      mamRequest.before = conversation.historyIndex;\n    } // Request for history messages for the room chat\n\n\n    if (conversation.bubble) {\n      mamRequest = {\n        \"queryid\": conversation.id,\n        \"with\": that._xmpp.jid_im,\n        \"max\": size,\n        \"before\": \"\"\n      };\n\n      if (conversation.historyIndex !== -1) {\n        mamRequest.before = conversation.historyIndex;\n      }\n\n      that._xmpp.mamQueryMuc(conversation.id, conversation.bubble.jid, mamRequest);\n    } else {\n      // Request for history messages for the conversation\n      that._xmpp.mamQuery(conversation.id, mamRequest);\n    }\n\n    return defered.promise;\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   */\n\n\n  getOrCreateOneToOneConversation(conversationId, conversationDbId, lastModification, lastMessageText, missedIMCounter, muted, creationDate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        // Fetch the conversation\n        let conv = that.getConversationById(conversationId);\n\n        if (conv) {\n          conv.preload = true;\n          return resolve(conv);\n        }\n\n        that._logger.log(\"info\", LOG_ID + \"getOrCreateOneToOneConversation \" + conversationId + \" \" + conversationDbId + \" \" + missedIMCounter); // No conversation found, then create it\n\n\n        that._contacts.getOrCreateContact(conversationId, undefined)\n        /* Get or create the conversation*/\n        .then(contact => {\n          that._logger.log(\"info\", LOG_ID + \"[Conversation] Create one to one conversation (\" + contact.id + \")\");\n\n          let conversation = Conversation_1.Conversation.createOneToOneConversation(contact);\n          conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\n          conversation.lastMessageText = lastMessageText;\n          conversation.muted = muted;\n          conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\n          conversation.preload = false; // TODO ? that.computeCapabilitiesForContact(contact);\n\n          conversation.dbId = conversationDbId;\n          conversation.missedCounter = missedIMCounter ? missedIMCounter : 0;\n          that.conversations[contact.jid_im] = conversation;\n          return Promise.resolve(conversation); //return that.createServerConversation(conversation);\n        }).then(conversation => {\n          // TODO ? $rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\", conversation);\n          resolve(conversation);\n        }).catch(error => {\n          let errorMessage = \"getOrCreateOneToOneConversation \" + conversationId + \" failure \" + error.message;\n\n          that._logger.log(\"error\", LOG_ID + \"Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getBubbleConversation\r\n   * @instance\r\n   * @description\r\n   *    Get a conversation associated to a bubble (using the bubble ID to retrieve it)\r\n   * @param {String} bubbleJid JID of the bubble (dbId field)\r\n   * @param conversationDbId\r\n   * @param lastModification\r\n   * @param lastMessageText\r\n   * @param missedIMCounter\r\n   * @param noError\r\n   * @param muted\r\n   * @param creationDate\r\n   * @param lastMessageSender\r\n   * @async\r\n   * @return {Promise<Conversation>}\r\n   * @fulfil {Conversation} - Conversation object or null if not found\r\n   * @category async\r\n   */\n\n\n  getBubbleConversation(bubbleJid, conversationDbId, lastModification, lastMessageText, missedIMCounter, noError, muted, creationDate, lastMessageSender) {\n    let that = this;\n\n    that._logger.log(\"internal\", LOG_ID + \"getBubbleConversation bubbleJib : \", bubbleJid); // Fetch the conversation in memory\n\n\n    let conversationResult = that.getConversationById(conversationDbId);\n\n    if (conversationResult) {\n      conversationResult.preload = true;\n      return Promise.resolve(conversationResult);\n    }\n\n    let conversation = that.getConversationByBubbleJid(bubbleJid);\n\n    if (conversation) {\n      conversation.preload = true;\n      return Promise.resolve(conversation);\n    } // No conversation found, then create it\n\n\n    return new Promise((resolve, reject) => {\n      // Get the associated bubble\n      that._bubbles.getBubbleByJid(bubbleJid).then(bubble => {\n        if (!bubble) {\n          that._logger.log(\"debug\", LOG_ID + \"getBubbleConversation (\" + bubbleJid + \") failure : no such bubble\");\n\n          let obj = {\n            jid: bubbleJid,\n            conversationDbId: conversationDbId,\n            lastModification: lastModification,\n            lastMessageText: lastMessageText,\n            missedIMCounter: missedIMCounter,\n            muted: muted,\n            creationDate: creationDate\n          };\n          that.waitingBotConversations.push(obj);\n          that.unlockWaitingBotConversations();\n          resolve();\n        } else {\n          that._logger.log(\"info\", LOG_ID + \"[Conversation] Create bubble conversation (\" + bubble.jid + \")\");\n\n          conversation = Conversation_1.Conversation.createBubbleConversation(bubble);\n          conversation.dbId = conversationDbId;\n          conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\n          conversation.lastMessageText = lastMessageText;\n          conversation.muted = muted;\n          conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\n          conversation.preload = false;\n          conversation.lastMessageSender = lastMessageSender;\n\n          if (missedIMCounter) {\n            conversation.missedCounter = missedIMCounter;\n          }\n\n          that.conversations[conversation.id] = conversation;\n\n          if (conversationDbId) {\n            that.getRoomConferences(conversation).then(function () {\n              that._eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n\n              resolve(conversation);\n            } // Create server side if necessary\n            );\n          } else {\n            // that.createServerConversation(conversation)\n            Promise.resolve(conversation).then(function (__conversation) {\n              if (bubble) {\n                that._presence.sendInitialBubblePresence(bubble);\n              } // Send conversations update event\n\n\n              that._eventEmitter.emit(\"evt_internal_conversationupdated\", __conversation);\n\n              resolve(__conversation);\n            }).catch(function (error) {\n              return __awaiter(this, void 0, void 0, function* () {\n                let errorMessage = \"getBubbleConversation (\" + bubbleJid + \") failure : \" + error.message;\n\n                that._logger.log(\"error\", LOG_ID + \"Error.\");\n\n                that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\n\n                yield that.deleteServerConversation(conversationDbId);\n\n                if (noError) {\n                  resolve();\n                } else {\n                  return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n                }\n              });\n            });\n          }\n        }\n      }).catch(error => __awaiter(this, void 0, void 0, function* () {\n        let errorMessage = \"getBubbleConversation (\" + bubbleJid + \") failure : \" + error.message;\n\n        that._logger.log(\"error\", LOG_ID + \"Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\n\n        yield that.deleteServerConversation(conversationDbId);\n\n        if (noError) {\n          resolve();\n        } else {\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        }\n      }));\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendIsTypingState\r\n   * @instance Conversations\r\n   * @description\r\n   *    Switch the \"is typing\" state in a conversation<br>\r\n   * @param {Conversation} conversation The conversation recipient\r\n   * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n   * @return a promise with no success parameter\r\n   */\n\n\n  sendIsTypingState(conversation, status) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!conversation) {\n        return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'conversation' is missing or null\"\n        }));\n      }\n      /* else if (!status) {\r\n          reject(Object.assign( ErrorManager.BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n      } // */\n      else {\n          conversation = conversation.id ? that.getConversationById(conversation.id) : null;\n\n          if (!conversation) {\n            return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"Parameter \\'conversation\\': this conversation doesn\\'t exist\"), {\n              msg: \"Parameter 'conversation': this conversation doesn't exist\"\n            }));\n          } else {\n            that._xmpp.sendIsTypingState(conversation, status);\n\n            resolve();\n          }\n        }\n    });\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   * Get a pstn conference\r\n   */\n\n\n  getRoomConferences(conversation) {\n    let that = this;\n    return new Promise(resolve => {\n      let confEndpoints = conversation.bubble.confEndpoints;\n\n      if (confEndpoints) {\n        confEndpoints.forEach(function (confEndpoint) {\n          if (confEndpoint.mediaType === \"pstnAudio\") {// TODO later\n            // let conferenceSession = pstnConferenceService.getConferenceSessionById(confEndpoint.confEndpointId);\n            // if (conferenceSession) {\n            //     conversation.pstnConferenceSession = conferenceSession;\n            // }\n          }\n        });\n      }\n\n      resolve();\n    });\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   * Update a pstn conference\r\n   */\n\n\n  updateRoomConferences() {\n    let that = this;\n    let conversations = that.getConversations();\n    conversations.forEach(function (conversation) {\n      if (conversation.bubble && conversation.bubble.confEndpoints) {// TODO Later\n        // let conferenceSession = pstnConferenceService.getConferenceSessionById(conversation.bubble.getPstnConfEndpointId());\n        // if (conferenceSession) {\n        //     conversation.pstnConferenceSession = conferenceSession;\n        // } else {\n        //     conversation.pstnConferenceSession = null;\n        // }\n      } else {\n        // A room conversation without confEndpoint should not have a conferenceSession attached\n        conversation.pstnConferenceSession = null;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method closeConversation\r\n   * @instance\r\n   * @description\r\n   *    Close a conversation <br/>\r\n   *    This method returns a promise\r\n   * @param {Conversation} conversation The conversation to close\r\n   * @async\r\n   * @return {Promise}\r\n   * @fulfil {} Return nothing in case success\r\n   * @category async\r\n   */\n\n\n  closeConversation(conversation) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"info\", LOG_ID + \"closeConversation \" + conversation.id); // Remove this contact from favorite group\n\n\n      that.deleteServerConversation(conversation.dbId).then(() => {\n        that.removeConversation(conversation);\n        resolve();\n      }).catch(error => {\n        return reject(error);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Remove locally a conversation <br/>\r\n   *    This method returns a promise\r\n   * @param {Conversation} conversation The conversation to remove\r\n   */\n\n\n  removeConversation(conversation) {\n    let that = this;\n\n    that._logger.log(\"info\", LOG_ID + \"remove conversation \" + conversation.id);\n\n    if (conversation.videoCall && conversation.videoCall.status !== Call_1.Call.Status.UNKNOWN) {\n      that._logger.log(\"info\", LOG_ID + \"Ignore conversation deletion message for conversation\" + conversation.id);\n\n      return;\n    }\n\n    delete that.conversations[conversation.id];\n    /* that.orderConversations();\r\n     let conversations = that.getOrderedConversations();\r\n        if (that.activeConversation && !(conversations.idle.indexOf(service.activeConversation) >= 0)) {\r\n         if (conversations.idle.length > 0) {\r\n             that.setActiveConversation(conversations.idle.first());\r\n         } else if (conversations.inCall.length > 0) {\r\n             service.setActiveConversation(conversations.inCall.first());\r\n         } else {\r\n             service.setActiveConversation(null);\r\n         }\r\n     }*/\n    // To avoid leak\n\n    if (conversation.contact) {\n      conversation.contact.conversation = null;\n      conversation.contact = null;\n    }\n\n    that._eventEmitter.emit(\"evt_internal_conversationdeleted\", {\n      \"conversationId\": conversation.id\n    }); //conversation = null;\n\n  }\n  /*********************************************************/\n\n  /**                   MESSAGES STUFF                    **/\n\n  /*********************************************************/\n\n  /**\r\n   * @private\r\n   * @method sendFSMessage\r\n   * @instance\r\n   * @description\r\n   *   Send an file sharing message\r\n   */\n\n\n  sendFSMessage(conversation, file, data) {\n    //let message = conversation.sendFSMessage(file, data);\n    //Conversation.prototype.sendFSMessage = function(file, data) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"info\", LOG_ID + \"sendFSMessage\"); // Add message in messages array\n\n\n      let fileExtension = file.name.split(\".\").pop();\n      let fileMimeType = file.type;\n      let viewers = []; //let message = typeof (data) === \"object\" ? data : undefined;\n\n      let message = data;\n      let currentFileDescriptor;\n\n      if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\n        viewers.push(FileViewer_1.FileViewerElementFactory(conversation.contact.id, \"user\", undefined, undefined));\n        /*viewers = fileViewerFactory([{\r\n            \"viewerId\": this.contact.dbId,\r\n            \"type\": \"user\"\r\n        }]); // */\n      } else {\n        viewers.push(FileViewer_1.FileViewerElementFactory(conversation.bubble.id, \"room\", undefined, undefined));\n        /*viewers = fileViewerFactory([{\r\n            \"viewerId\": this.room.dbId,\r\n            \"type\": \"room\"\r\n        }]); // */\n      }\n\n      that._fileStorageService.createFileDescriptor(file.name, fileExtension, file.size, viewers).then(function (fileDescriptor) {\n        currentFileDescriptor = fileDescriptor;\n        fileDescriptor.fileToSend = file;\n\n        if (fileDescriptor.isImage()) {\n          // let URLObj = $window.URL || $window.webkitURL;\n          // fileDescriptor.previewBlob = URLObj.createObjectURL(file);\n          if (file.preview) {\n            fileDescriptor.previewBlob = file.preview;\n          }\n        }\n        /*  if (!message) {\r\n              message = that.addFSMessage(fileDescriptor.id, fileMimeType, data, \"uploading\");\r\n          }\r\n          message.fileId = fileDescriptor.id;\r\n          message.fileName = fileDescriptor.fileName;\r\n          // */\n        // Upload file\n\n\n        fileDescriptor.state = \"uploading\";\n        /*if (that.chatRenderer) {\r\n            that.chatRenderer.updateFileTransferState(message, fileDescriptor);\r\n        } */\n\n        return that._fileServerService.uploadAFileByChunk(fileDescriptor, file.path\n        /*, message , function (msg, fileDesc) {\r\n        if (that.chatRenderer) {\r\n        that.chatRenderer.updateFileTransferState(msg, fileDesc);\r\n        }\r\n        } */\n        ).then(function successCallback(fileDesc) {\n          that._logger.log(\"debug\", LOG_ID + \"uploadAFileByChunk success\");\n\n          if (that.chatRenderer) {\n            that.chatRenderer.updateFileTransferState(message, fileDesc);\n          } // resolve(fileDescriptor);\n\n\n          return Promise.resolve(fileDesc);\n        }, function errorCallback(error) {\n          that._logger.log(\"error\", LOG_ID + \"uploadAFileByChunk error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"uploadAFileByChunk error : \", error); //do we need to delete the file descriptor from the server if error ??\n\n\n          that._fileStorageService.deleteFileDescriptor(currentFileDescriptor.id); // .then(function() {\n          // let msgKey = error.translatedMessage ? error.translatedMessage : \"Unable to share file\";\n          // $rootScope.$broadcast(\"ON_SHOW_INFO_MESSAGE\", { type: \"error\", messageKey: msgKey });\n          // currentFileDescriptor.state = \"uploadError\";\n          // message.receiptStatus = Message.ReceiptStatus.ERROR;\n          // message.fileErrorMsg = msgKey;\n          // that.updateMessage(message);\n          // });\n          // let msgKey = error.translatedMessage ? error.translatedMessage : \"Unable to share file\";\n          //$rootScope.$broadcast(\"ON_SHOW_INFO_MESSAGE\", {type: \"error\", messageKey: msgKey});\n\n\n          currentFileDescriptor.state = \"uploadError\"; //message.receiptStatus = Message.ReceiptStatus.ERROR;\n          //message.fileErrorMsg = msgKey;\n          //that.updateMessage(message);\n\n          return Promise.reject(error);\n        });\n      }).then(function successCallback(fileDescriptorResult) {\n        fileDescriptorResult.state = \"uploaded\";\n        fileDescriptorResult.chunkPerformed = 0;\n        fileDescriptorResult.chunkTotalNumber = 0;\n        let messagefs = that.sendExistingFSMessage(conversation, message, fileDescriptorResult);\n        that.storePendingMessage(conversation, messagefs);\n        resolve(messagefs);\n      }, function errorCallback(error) {\n        that._logger.log(\"error\", LOG_ID + \"createFileDescriptor error\");\n\n        return reject(error);\n      }); //};\n\n      /*\r\n      todo: VBR What is this pendingMessages list coming from WebSDK ? Is it necessary for node SDK ?\r\n      this.pendingMessages[message.id] = {\r\n          conversation: conversation,\r\n          message: message\r\n      };\r\n      // */\n\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendExistingMessage\r\n   * @instance\r\n   * @param {string} data The text message to send\r\n   * @description\r\n   *    Send a message to this conversation\r\n   * @return {Message} The message sent\r\n   */\n\n\n  sendExistingFSMessage(conversation, message, fileDescriptor) {\n    let that = this; //conversation.sendAckReadMessages();\n\n    let unicodeData = message;\n\n    if (!message) {\n      return null;\n    }\n\n    let lang = 'en';\n\n    if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\n      let to = conversation.contact.jid;\n      return that._xmpp.sendChatExistingFSMessage(unicodeData, to, lang, fileDescriptor);\n    } else {\n      let to = conversation.bubble.jid;\n      return that._xmpp.sendChatExistingFSMessageToBubble(unicodeData, to, lang, fileDescriptor);\n    }\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *   Send an existing file sharing message\r\n   */\n\n\n  sendEFSMessage(conversation, fileDescriptor, data) {\n    let message = conversation.sendEFSMessage(fileDescriptor, data);\n    this.storePendingMessage(conversation, message);\n    return message;\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *    Send a instant message to a conversation\r\n   *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>\r\n   * @param {Conversation} conversation The conversation to clean\r\n   * @param {String} data Test message to send\r\n   */\n\n\n  sendChatMessage(conversation, data, answeredMsg) {\n    let message = conversation.sendChatMessage(data, answeredMsg);\n    this.storePendingMessage(conversation, message);\n    return message;\n  }\n  /**\r\n   * SEND CORRECTED MESSAGE\r\n   */\n\n  /**\r\n   * @public\r\n   * @method sendCorrectedChatMessage\r\n   * @instance\r\n   * @description\r\n   *    Send a corrected message to a conversation\r\n   *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>\r\n   *    The new message has the property originalMessageReplaced which spot on original message // Warning this is a circular depend.\r\n   *    The original message has the property replacedByMessage  which spot on the new message // Warning this is a circular depend.\r\n   *    Note: only the last sent message on the conversation can be changed. The connected user must be the sender of the original message.\r\n   * @param conversation\r\n   * @param data\r\n   * @param origMsgId\r\n   * @returns {Promise<String>} message the message new correction message sent. Throw an error if the send fails.\r\n   */\n\n\n  sendCorrectedChatMessage(conversation, data, origMsgId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!conversation) {\n        this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'conversation' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'conversation' parameter : \", conversation);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      if (data == undefined || data == null) {\n        this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'data' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'data' parameter : \", data);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      if (!origMsgId) {\n        this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'origMsgId' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'origMsgId' parameter : \", origMsgId);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(sendCorrectedChatMessage) _entering_ conversation.id : \", conversation.id, \", data : \", data, \"origMsgId : \", origMsgId);\n\n      let originalMessage = conversation.getMessageById(origMsgId);\n      let originalMessageFrom = originalMessage.fromJid || originalMessage.from;\n\n      if (originalMessageFrom !== that._rest.loggedInUser.jid_im) {\n        that._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\");\n\n        throw ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\", \"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\");\n      }\n\n      let lastEditableMsg = conversation.getlastEditableMsg();\n\n      if (lastEditableMsg.id !== originalMessage.id) {\n        that._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\");\n\n        throw ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\", \"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\");\n      }\n\n      let messageUnicode = Emoji_1.shortnameToUnicode(data);\n\n      try {\n        let sentMessageId = yield that._xmpp.sendCorrectedChatMessage(conversation, originalMessage, messageUnicode, origMsgId, originalMessage.lang);\n        let newMsg = Object.assign({}, originalMessage);\n        newMsg.id = sentMessageId;\n        newMsg.content = messageUnicode;\n        newMsg.date = new Date();\n        newMsg.originalMessageReplaced = originalMessage; // Warning this is a circular depend.\n\n        originalMessage.replacedByMessage = newMsg; // Warning this is a circular depend.\n\n        this.pendingMessages[sentMessageId] = {\n          conversation: conversation,\n          message: newMsg\n        };\n        return newMsg;\n      } catch (err) {\n        that._logger.log(\"error\", LOG_ID + \"createFileDescriptor error\");\n\n        let error = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(err.message, \"(sendCorrectedChatMessage) error while sending corrected message : \" + err); // @ts-ignore\n\n        error.newMessageText = data; // @ts-ignore\n\n        error.originaleMessageId = origMsgId;\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @since 1.58\r\n   * @method deleteMessage\r\n   * @instance\r\n   * @async\r\n   * @description\r\n   *    Delete a message by sending an empty string in a correctedMessage\r\n   * @param {Conversation} conversation The conversation object\r\n   * @param {String} messageId The id of the message to be deleted\r\n   * @return {Message} - message object with updated replaceMsgs property\r\n   */\n\n\n  deleteMessage(conversation, messageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!conversation) {\n        that._logger.log(\"error\", LOG_ID + \"(deleteMessage) Parameter 'conversation' is missing or null\");\n\n        throw ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST();\n      }\n\n      if (!messageId) {\n        that._logger.log(\"error\", LOG_ID + \"(deleteMessage) Parameter 'messageId' is missing or empty\");\n\n        throw ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST();\n      }\n\n      let messageOrig = conversation.getMessageById(messageId);\n      let correctedMsg = yield that.sendCorrectedChatMessage(conversation, \"\", messageId);\n      return messageOrig;\n    });\n  }\n  /**\r\n   *\r\n   * @public\r\n   * @since 1.67.0\r\n   * @method deleteAllMessageInOneToOneConversation\r\n   * @instance\r\n   * @async\r\n   * @description\r\n   *   DELETE ALL MESSAGES IN ONE2ONE CONVERSATION\r\n   * @param {Conversation} conversation The conversation object\r\n   * @return {Message} - message object with updated replaceMsgs property\r\n   */\n\n\n  deleteAllMessageInOneToOneConversation(conversation) {\n    let that = this;\n\n    if (!conversation) {\n      this._logger.log(\"error\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation' parameter.\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation' parameter : \", conversation);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let conversationObj = that.getConversationById(conversation.id);\n\n    if (conversationObj.type !== Conversation_1.Conversation.Type.ONE_TO_ONE) {\n      this._logger.log(\"error\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation.type' parameter.\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation.type' parameter : \", conversationObj);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return that._xmpp.deleteAllMessageInOneToOneConversation(conversationObj.id);\n  }\n  /**\r\n   * @private\r\n   * @description\r\n   *      Store the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n   *      It allow to give back the status of the sending process.\r\n   * @param conversation\r\n   * @param message\r\n   */\n\n\n  storePendingMessage(conversation, message) {\n    this.pendingMessages[message.id] = {\n      conversation: conversation,\n      message: message\n    };\n  }\n  /**\r\n   * @private\r\n   * @description\r\n   *      delete the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n   *      It allow to give back the status of the sending process.\r\n   * @param message\r\n   */\n\n\n  removePendingMessage(message) {\n    delete this.pendingMessages[message.id];\n  }\n  /**\r\n   * @public\r\n   * @method removeAllMessages\r\n   * @instance\r\n   * @description\r\n   *    Cleanup a conversation by removing all previous messages<br/>\r\n   *    This method returns a promise\r\n   * @param {Conversation} conversation The conversation to clean\r\n   * @async\r\n   * @return {Promise}\r\n   * @fulfil {} Return nothing in case success\r\n   * @category async\r\n   */\n\n\n  removeAllMessages(conversation) {\n    let that = this;\n    return new Promise(resolve => {\n      if (!conversation) {\n        this._logger.log(\"error\", LOG_ID + \"(removeAllMessages) bad or empty 'conversation' parameter.\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(removeAllMessages) bad or empty 'conversation' parameter : \", conversation);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      that._logger.log(\"info\", LOG_ID + \"(removeAllMessage) _entering_ \" + conversation.id); // Id must be filled by lower layer\n\n\n      let mamRequest = {\n        //\"queryid\": mamRequestId,\n        \"with\": conversation.id,\n        \"onComplete\": function (result) {\n          that._logger.log(\"internal\", LOG_ID + \" removeAllMessage \" + conversation.id, \", result : \", result); // FIXME : handle error message (ask Andre)\n\n\n          resolve(result);\n        }\n      };\n      that.pendingMessages = [];\n\n      that._xmpp.mamDelete(mamRequest);\n      /*\r\n                  let mamRequest = {\r\n                      \"deleteid\": \"remove_\" + conversation.id,\r\n                      \"with\": conversation.id,\r\n                      \"before\": moment().add(1, 'minutes')\r\n                          .utc()\r\n                          .format(\"YYYY-MM-DDTHH:mm:ss\") + \"Z\",\r\n                      \"onComplete\": function (result) {\r\n                          that._logger.log(\"debug\", LOG_ID + \" removeAllMessage \" + conversation.id, \", result : \", result);\r\n                          // FIXME : handle error message (ask Andre)\r\n                          resolve(result);\r\n                      }\r\n                  };\r\n      \r\n                  that.pendingMessages = [];\r\n      \r\n                  // Request for history messages\r\n                  that._xmpp.mamDelete(conversation.id, mamRequest);\r\n                  // */\n\n    });\n  }\n  /**\r\n   * @public\r\n   * @method removeMessagesFromConversation\r\n   * @instance\r\n   * @description\r\n   *    Remove a specific range of message in a conversation<br/>\r\n   *    This method returns a promise\r\n   * @param {Conversation} conversation The conversation to clean\r\n   * @async\r\n   * @return {Promise}\r\n   * @fulfil {} Return nothing in case success\r\n   * @category async\r\n   */\n\n\n  removeMessagesFromConversation(conversation, date, number) {\n    let that = this;\n    return new Promise(resolve => {\n      that._logger.log(\"info\", LOG_ID + \" removeMessagesFromConversation \" + conversation.id);\n\n      that._logger.log(\"info\", LOG_ID + \" removing \" + number + \" messages after \" + date);\n\n      let mamRequest = {\n        \"deleteid\": \"remove_\" + conversation.id,\n        \"with\": conversation.id,\n        \"start\": moment(date).format(\"YYYY-MM-DDTHH:mm:ss.SSSSSSZ\"),\n        \"max\": number,\n        \"onComplete\": () => {\n          that._logger.log(\"info\", LOG_ID + \" MAM Message deleted !!!\");\n\n          resolve();\n        }\n      };\n      that.pendingMessages = that.pendingMessages.filter(messagePending => {\n        if (messagePending.date > date) {\n          return false;\n        }\n      }); // Request for history messages\n\n      that._xmpp.mamDelete(mamRequest); //that._xmpp.mamDelete(conversation.id, mamRequest);\n\n    });\n  }\n  /**\r\n   * @public\r\n   * @method getConversationById\r\n   * @instance\r\n   * @description\r\n   *      Get a p2p conversation by id\r\n   * @param {String} conversationId Conversation id of the conversation to clean\r\n   * @return {Conversation} The conversation to retrieve\r\n   */\n\n\n  getConversationById(conversationId) {\n    let that = this;\n\n    that._logger.log(\"debug\", LOG_ID + \" (getConversationById) conversationId : \", conversationId);\n\n    if (!this.conversations) {\n      return null;\n    }\n\n    that._logger.log(\"internal\", LOG_ID + \" (getConversationById) conversation : \", this.conversations[conversationId]);\n\n    return this.conversations[conversationId];\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *      Get a conversation by db id\r\n   * @param {String} dbId db id of the conversation to retrieve\r\n   * @return {Conversation} The conversation to retrieve\r\n   */\n\n\n  getConversationByDbId(dbId) {\n    let that = this;\n\n    if (that.conversations) {\n      for (let key in that.conversations) {\n        if (that.conversations.hasOwnProperty(key) && that.conversations[key].dbId === dbId) {\n          return that.conversations[key];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *      Get a bubble conversation by bubble id\r\n   * @param {String} bubbleId Bubble id of the conversation to retrieve\r\n   * @return {Conversation} The conversation to retrieve\r\n   */\n  getConversationByBubbleId(bubbleId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.conversations) {\n        for (let key in this.conversations) {\n          if (this.conversations.hasOwnProperty(key) && this.conversations[key].bubble && this.conversations[key].bubble.id === bubbleId) {\n            return this.conversations[key];\n          }\n        }\n      }\n\n      return null;\n    });\n  }\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *      Get a bubble conversation by bubble id\r\n   * @param {String} bubbleJid Bubble jid of the conversation to retrieve\r\n   * @return {Conversation} The conversation to retrieve\r\n   */\n\n\n  getConversationByBubbleJid(bubbleJid) {\n    if (this.conversations) {\n      for (let key in this.conversations) {\n        if (this.conversations.hasOwnProperty(key) && this.conversations[key].bubble && this.conversations[key].bubble.jid === bubbleJid) {\n          return this.conversations[key];\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * @public\r\n   * @method getAllConversations\r\n   * @instance\r\n   * @description\r\n   *    Allow to get the list of existing conversations (p2p and bubbles)\r\n   * @return {Conversation[]} An array of Conversation object\r\n   */\n\n\n  getAllConversations() {\n    let that = this;\n    return that.getConversations();\n  }\n\n  /**\r\n   * @private\r\n   * @method\r\n   * @instance\r\n   * @description\r\n   *      Get all conversation\r\n   * @return {Conversation[]} The conversation list to retrieve\r\n   */\n  getConversations() {\n    let conversationArray = [];\n\n    for (let key in this.conversations) {\n      if (this.conversations.hasOwnProperty(key)) {\n        conversationArray.push(this.conversations[key]);\n      }\n    }\n\n    return conversationArray;\n  }\n  /**\r\n   * @public\r\n   * @method openConversationForContact\r\n   * @instance\r\n   * @description\r\n   *    Open a conversation to a contact <br/>\r\n   *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\r\n   *    This method returns a promise\r\n   * @param {Contact} contact The contact involved in the conversation\r\n   * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n   */\n\n\n  openConversationForContact(contact) {\n    let that = this;\n    return new Promise(function (resolve, __reject) {\n      if (!contact) {\n        return __reject({\n          code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\n          label: \"Parameter 'contact' is missing or null\"\n        });\n      } else {\n        that._logger.log(\"info\", LOG_ID + \" :: Try to create of get a conversation.\");\n\n        that._logger.log(\"internal\", LOG_ID + \" :: Try to create of get a conversation with \" + contact.lastName + \" \" + contact.firstName);\n\n        that.getOrCreateOneToOneConversation(contact.jid).then(function (conversation) {\n          that._logger.log(\"info\", LOG_ID + \"  :: Conversation retrieved or created \" + conversation.id);\n\n          resolve(conversation);\n        }).catch(function (result) {\n          that._logger.log(\"error\", LOG_ID + \"[openConversationForContact] Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"[openConversationForContact] Error : \", result);\n\n          return __reject(result);\n        });\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method openConversationForBubble\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    Open a conversation to a bubble <br/>\r\n   *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\r\n   *    This method returns a promise\r\n   * @param {Bubble} bubble The bubble involved in this conversation\r\n   * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n   */\n\n\n  openConversationForBubble(bubble) {\n    let that = this;\n    return new Promise(function (resolve, __reject) {\n      if (!bubble) {\n        return __reject({\n          code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\n          label: \"Parameter 'bubble' is missing or null\"\n        });\n      } else {\n        that._logger.log(\"info\", LOG_ID + \"(openConversationForBubble), Try to create of get a conversation for bubble.\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble), Try to create of get a conversation with bubble : \", bubble);\n\n        that.getBubbleConversation(bubble.jid, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined).then(function (conversation) {\n          that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble), Conversation retrieved or created, conversation : \", conversation);\n\n          resolve(conversation);\n        }).catch(function (result) {\n          that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble) Error : \", result);\n\n          __reject(result);\n        });\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @method getS2SServerConversation\r\n   * @since 1.65\r\n   * @instance\r\n   * @description\r\n   *    get a conversation from id on S2S API Server.<br/>\r\n   *    This method returns a promise\r\n   * @param {string} conversationId The id of the conversation to find.\r\n   * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n   */\n\n\n  getS2SServerConversation(conversationId) {\n    let that = this;\n    return new Promise(function (resolve, __reject) {\n      if (!conversationId) {\n        return __reject({\n          code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\n          label: \"Parameter 'conversationId' is missing or null\"\n        });\n      } else {\n        that._logger.log(\"info\", LOG_ID + \"(getS2SServerConversation), Try to create of get a conversation for bubble.\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation), Try to create of get a conversation with bubble : \", conversationId);\n\n        that.getS2SServerConversation(conversationId).then(function (conversationInfos) {\n          that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation), Conversation retrieved or created, conversation : \", conversationInfos);\n          /*that._logger.log(\"info\", LOG_ID + \"[Conversation] Create bubble conversation (\" + bubble.jid + \")\");\r\n            let conversation = Conversation.createBubbleConversation(bubble);\r\n          conversation.dbId = conversationId;\r\n          conversation.lastModification = undefined;\r\n          conversation.lastMessageText = undefined;\r\n          conversation.muted = false;\r\n          conversation.creationDate = new Date();\r\n          conversation.preload = false;\r\n          conversation.lastMessageSender = undefined;\r\n          conversation.missedCounter = 0;\r\n          that.conversations[conversation.id] = conversation;\r\n          resolve(conversation)\r\n             */\n\n\n          resolve(conversationInfos);\n        }).catch(function (result) {\n          that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation) Error : \", result);\n\n          __reject(result);\n        });\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  onRoomChangedEvent(__event, bubble, action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (bubble) {\n        let conversation = this.getConversationById(bubble.jid);\n\n        if (conversation) {\n          if (action === \"remove\") {\n            yield this.closeConversation(conversation);\n          } else {\n            conversation.bubble = bubble;\n          }\n        }\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  onRoomHistoryChangedEvent(__event, room) {\n    if (room) {\n      let conversation = this.getConversationById(room.jid);\n\n      if (conversation && conversation.chatRenderer) {\n        conversation.reset();\n        conversation.chatRenderer.loadMore();\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  onRoomAdminMessageEvent(__event, roomJid, userJid, type, msgId) {\n    this._logger.log(\"info\", LOG_ID + \" onRoomAdminMessageEvent\");\n\n    let conversation = this.getConversationById(roomJid);\n\n    if (conversation && (type === \"welcome\" || type === \"conferenceAdd\" || type === \"conferenceRemove\") && conversation.bubble && conversation.bubble.ownerContact) {\n      userJid = conversation.bubble.ownerContact.jid;\n    }\n\n    let contact = this._contacts.getContactByJid(userJid);\n\n    if (conversation && contact) {\n      // If invitation msg and I'm not the owner\n      if (!conversation.bubble.owner && type === \"invitation\") {\n        return;\n      }\n\n      if (conversation.bubble && conversation.bubble.isMeetingBubble()) {\n        return;\n      }\n\n      this._conversationServiceEventHandler.onRoomAdminMessageReceived(conversation, contact, type, msgId);\n    }\n  }\n  /*********************************************************************/\n\n  /** Remove the conversation history                                 **/\n\n  /*********************************************************************/\n\n  /**\r\n   * @private\r\n   *\r\n   */\n\n\n  reinit() {\n    let that = this;\n    return new Promise(resolve => {\n      that._logger.log(\"info\", LOG_ID + \" Re-initialize conversation service\"); // Remove all my conversation\n\n\n      delete that.conversations;\n      that.conversations = []; // bot service is ready / TODO ? service.botServiceReady = true; Fetch\n      // conversations from server\n\n      that._rest.getServerConversations(that.conversationsRetrievedFormat).then(function () {\n        // TODO ? service.linkAllActiveCallsToConversations();\n        resolve();\n      }).catch(function () {\n        setInterval(() => {\n          that._logger.log(\"info\", LOG_ID + \" getServerConversations failure, try again\");\n\n          that._rest.getServerConversations(that.conversationsRetrievedFormat).then(function () {// TODO ? that.linkAllActiveCallsToConversations();\n          });\n        }, 10000, 1, true);\n        resolve();\n      });\n    });\n  }\n  /*********************************************************************/\n\n  /** BOT SERVICE IS RUNNING, CREATE ALL BOT CONVERSATIONS            **/\n\n  /*********************************************************************/\n\n\n  unlockWaitingBotConversations(isBotServiceReady) {\n    let that = this;\n\n    if (isBotServiceReady) {\n      that.botServiceReady = true;\n    }\n\n    if (that.botServiceReady) {\n      //stop infinite loop in case of error\n      that.botServiceReady = false;\n      that.waitingBotConversations.forEach(function (obj, index) {\n        return __awaiter(this, void 0, void 0, function* () {\n          let contact = yield that._contacts.getContactByJid(obj.jid);\n\n          if (contact) {\n            yield that.getOrCreateOneToOneConversation(contact.jid, null, obj.lastModification, obj.lastMessageText, obj.missedIMCounter, obj.muted, obj.creationDate);\n            that.waitingBotConversations.splice(index, 1);\n          }\n        });\n      });\n      that.waitingBotConversations = [];\n    }\n  }\n\n};\nConversations = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n * @module\r\n * @name Conversations\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n * This module is the basic module for handling conversations in Rainbow. In Rainbow, conversations are the way to get in touch with someone or something (i.e. a Rainbow contact, a external phone number, a connected thing, ...) so a conversation is the \"long tail\" of communication between you and someone or something else like a bubble.\r\n * A Rainbow conversation by default supports sending and receiving Instant Messages with a single recipient (one-to-one conversation) or with several persons (bubble). Using the FileStorage service, you can share files in conversations.\r\n *\r\n * The main methods and events proposed in that service allow to:\r\n *   - Create or close a Rainbow conversation (one-to-one of bubble),\r\n *   - Get all conversations or get a conversation by Id, bubbleID or bubbleJid\r\n *   - Retrieve all information linked to that conversation,\r\n *\r\n *   */\n], Conversations);\nexports.ConversationsService = Conversations;\nmodule.exports.ConversationsService = Conversations;","map":{"version":3,"sources":["../../src/lib/services/ConversationsService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Conversation_1 = require(\"../common/models/Conversation\");\r\nconst Call_1 = require(\"../common/models/Call\");\r\nconst moment = require(\"moment\");\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst PubSub = require(\"pubsub-js\");\r\nconst conversationEventHandler_1 = require(\"../connection/XMPPServiceHandler/conversationEventHandler\");\r\nconst conversationHistoryHandler_1 = require(\"../connection/XMPPServiceHandler/conversationHistoryHandler\");\r\nconst Emoji_1 = require(\"../common/Emoji\");\r\nconst FileViewer_1 = require(\"../common/models/FileViewer\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst LOG_ID = \"CONVERSATIONS/SVCE - \";\r\nlet Conversations = \r\n/**\r\n * @module\r\n * @name Conversations\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n * This module is the basic module for handling conversations in Rainbow. In Rainbow, conversations are the way to get in touch with someone or something (i.e. a Rainbow contact, a external phone number, a connected thing, ...) so a conversation is the \"long tail\" of communication between you and someone or something else like a bubble.\r\n * A Rainbow conversation by default supports sending and receiving Instant Messages with a single recipient (one-to-one conversation) or with several persons (bubble). Using the FileStorage service, you can share files in conversations.\r\n *\r\n * The main methods and events proposed in that service allow to:\r\n *   - Create or close a Rainbow conversation (one-to-one of bubble),\r\n *   - Get all conversations or get a conversation by Id, bubbleID or bubbleJid\r\n *   - Retrieve all information linked to that conversation,\r\n *\r\n *   */\r\nclass Conversations {\r\n    constructor(_eventEmitter, _logger, _startConfig, _conversationsRetrievedFormat, _nbMaxConversations) {\r\n        this.ready = false;\r\n        this.conversationsRetrievedFormat = \"small\";\r\n        this._startConfig = _startConfig;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._contacts = null;\r\n        this._fileStorageService = null;\r\n        this._fileServerService = null;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._logger = _logger;\r\n        this.pendingMessages = {};\r\n        this._conversationEventHandler = null;\r\n        this._conversationHandlerToken = [];\r\n        this._conversationHistoryHandlerToken = [];\r\n        this.conversationsRetrievedFormat = _conversationsRetrievedFormat;\r\n        this.nbMaxConversations = _nbMaxConversations;\r\n        //that._eventEmitter.removeListener(\"evt_internal_onreceipt\", that._onReceipt.bind(that));\r\n        this.ready = false;\r\n        this._eventEmitter.on(\"evt_internal_onreceipt\", this._onReceipt.bind(this));\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        let that = this;\r\n        that._conversationHandlerToken = [];\r\n        that._conversationHistoryHandlerToken = [];\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                that._xmpp = _core._xmpp;\r\n                that._rest = _core._rest;\r\n                that._options = _options;\r\n                that._s2s = _core._s2s;\r\n                that._useXMPP = that._options.useXMPP;\r\n                that._useS2S = that._options.useS2S;\r\n                that._contacts = _core.contacts;\r\n                that._bubbles = _core.bubbles;\r\n                that._fileStorageService = _core.fileStorage;\r\n                that._fileServerService = _core.fileServer;\r\n                that._presence = _core.presence;\r\n                that.activeConversation = null;\r\n                that.conversations = [];\r\n                that.inCallConversations = [];\r\n                that.idleConversations = [];\r\n                that.involvedContactIds = [];\r\n                that.involvedRoomIds = [];\r\n                //all conversations with Bots\r\n                that.waitingBotConversations = [];\r\n                that.botServiceReady = false;\r\n                that.attachHandlers();\r\n                this.ready = true;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(start) !!! Catch error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(start) !!! Catch error : \", err);\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    stop() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                that._xmpp = null;\r\n                that._rest = null;\r\n                delete that._conversationEventHandler;\r\n                that._conversationEventHandler = null;\r\n                if (that._conversationHandlerToken) {\r\n                    that._conversationHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n                }\r\n                that._conversationHandlerToken = [];\r\n                if (that._conversationHistoryHandlerToken) {\r\n                    that._conversationHistoryHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n                }\r\n                that._conversationHistoryHandlerToken = [];\r\n                //that._eventEmitter.removeListener(\"evt_internal_onreceipt\", that._onReceipt.bind(that));\r\n                this.ready = false;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    attachHandlers() {\r\n        let that = this;\r\n        that._conversationEventHandler = new conversationEventHandler_1.ConversationEventHandler(that._xmpp, that, that._fileStorageService, that._fileServerService);\r\n        that._conversationHandlerToken = [\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_CHAT, that._conversationEventHandler.onChatMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_GROUPCHAT, that._conversationEventHandler.onChatMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_WEBRTC, that._conversationEventHandler.onWebRTCMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_MANAGEMENT, that._conversationEventHandler.onManagementMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_ERROR, that._conversationEventHandler.onErrorMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationEventHandler.MESSAGE_CLOSE, that._conversationEventHandler.onCloseMessageReceived)\r\n        ];\r\n        that._conversationHistoryHandler = new conversationHistoryHandler_1.ConversationHistoryHandler(that._xmpp, this);\r\n        that._conversationHistoryHandlerToken = [\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationHistoryHandler.MESSAGE_MAM, that._conversationHistoryHandler.onMamMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._conversationHistoryHandler.FIN_MAM, that._conversationHistoryHandler.onMamMessageReceived)\r\n        ];\r\n    }\r\n    _onReceipt(receipt) {\r\n        let that = this;\r\n        let messageInfo = this.pendingMessages[receipt.id];\r\n        if (messageInfo && messageInfo.message) {\r\n            let message = messageInfo.message;\r\n            let conversation = messageInfo.conversation;\r\n            that._logger.log(\"debug\", LOG_ID + \"[conversationService] Receive server ack (\" + conversation.id + \", \" + message.id + \")\");\r\n            //message.setReceiptStatus(Message.ReceiptStatus.SENT);\r\n            conversation.addMessage(message);\r\n            that.removePendingMessage(message);\r\n            //delete this.pendingMessages[message.id];\r\n            // Send event\r\n            that._eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Allow to get the list of existing conversations from server (p2p and bubbles)\r\n     * @return {Conversation[]} An array of Conversation object\r\n     */\r\n    getServerConversations() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            yield that._rest.getServerConversations(that.conversationsRetrievedFormat).then((conversations) => __awaiter(this, void 0, void 0, function* () {\r\n                yield that.removeOlderConversations(conversations);\r\n            })).catch((error) => {\r\n                that._logger.log(\"warn\", LOG_ID + \"getServerConversations Failed to retrieve conversations for removeOlderConversations : \", error);\r\n                that._logger.log(\"internalerror\", LOG_ID + \"getServerConversations Failed to retrieve conversations for removeOlderConversations : \", error);\r\n                // The remove of old conversations is not mandatory, so lets continue the treatment.\r\n            });\r\n            that._rest.getServerConversations(that.conversationsRetrievedFormat).then((conversations) => {\r\n                // Create conversation promises\r\n                let conversationPromises = [];\r\n                that._logger.log(\"debug\", LOG_ID + \"getServerConversations conversations.length retrieved : \", conversations.length);\r\n                conversations.forEach(function (conversationData) {\r\n                    let missedImCounter = parseInt(conversationData.unreadMessageNumber, 10);\r\n                    let conversationPromise = null;\r\n                    let muted = (conversationData.mute === true);\r\n                    //that._logger.log(\"debug\", LOG_ID + \"getServerConversations conversationData retrieved : \", conversationData);\r\n                    if (conversationData.type === \"user\") {\r\n                        conversationPromise = that.getOrCreateOneToOneConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, muted, conversationData.creationDate);\r\n                    }\r\n                    else {\r\n                        conversationPromise = that.getBubbleConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, true, muted, conversationData.creationDate, conversationData.lastMessageSender);\r\n                    } // */\r\n                    conversationPromises.push(conversationPromise);\r\n                });\r\n                // Resolve all promises\r\n                return Promise\r\n                    .all(conversationPromises)\r\n                    /*.then(async (result) => {\r\n                        await that.removeOlderConversations();\r\n                        return result;\r\n                    }) // */\r\n                    .then((conversationsResult) => {\r\n                    //that.orderConversations();\r\n                    resolve(conversationsResult);\r\n                })\r\n                    .catch((error) => {\r\n                    let errorMessage = \"getServerConversations failure: \" + error.message;\r\n                    that._logger.log(\"error\", LOG_ID + \"error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"error : \", errorMessage);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                });\r\n            })\r\n                .catch((err) => {\r\n                let errorMessage = \"getServerConversations failure: no server response\";\r\n                if (err) {\r\n                    errorMessage = \"getServerConversations failure: \" + JSON.stringify(err);\r\n                }\r\n                that._logger.log(\"error\", LOG_ID + \"error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"error : \", errorMessage);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Allow to create a conversations on server (p2p and bubbles)\r\n     * @param {String} conversation of the conversation (dbId field)\r\n     * @return {Conversation} Created conversation object\r\n     */\r\n    createServerConversation(conversation) {\r\n        let that = this;\r\n        // Ignore already stored existing conversation\r\n        if (conversation.dbId) {\r\n            return Promise.resolve(conversation);\r\n        }\r\n        // Prepare global variables\r\n        let data = { peerId: null, type: null };\r\n        // Handle one to one conversation\r\n        if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n            // Ignore conversation with user without dbId\r\n            if (!conversation.contact.id) {\r\n                return Promise.resolve(conversation);\r\n            }\r\n            // Fill conversation request data\r\n            data.peerId = conversation.contact.id;\r\n            data.type = \"user\";\r\n        }\r\n        else if (conversation.type === Conversation_1.Conversation.Type.BOT) {\r\n            conversation.type = Conversation_1.Conversation.Type.ONE_TO_ONE;\r\n            // Ignore conversation with user without dbId\r\n            if (!conversation.contact.id) {\r\n                return Promise.resolve(conversation);\r\n            }\r\n            // Fill conversation request data\r\n            data.peerId = conversation.contact.id;\r\n            data.type = \"bot\";\r\n        }\r\n        // Handle bubble conversation\r\n        else {\r\n            // Fill conversation request data\r\n            data.peerId = conversation.bubble.id;\r\n            data.type = \"room\";\r\n        }\r\n        if (conversation.bubble && conversation.bubble.avatar) {\r\n            let avatarRoom = conversation.bubble.avatar;\r\n        }\r\n        return this._rest.createServerConversation(data).then((result) => {\r\n            that._logger.log(\"info\", LOG_ID + \"createServerConversation success: \" + conversation.id);\r\n            conversation.dbId = result.id;\r\n            conversation.lastModification = result.lastMessageDate ? new Date(result.lastMessageDate) : undefined;\r\n            conversation.creationDate = result.creationDate ? new Date(result.creationDate) : new Date();\r\n            conversation.missedCounter = parseInt(result.unreadMessageNumber, 10);\r\n            /* if (avatarRoom) {\r\n                 conversation.bubble.avatar = avatarRoom;\r\n             } */\r\n            // TODO ? that.orderConversations();\r\n            return Promise.resolve(conversation);\r\n        }).catch((err) => {\r\n            let errorMessage = \"createServerConversation failure: \" + err.errorDetails;\r\n            that._logger.log(\"error\", LOG_ID + \"\" + errorMessage);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n        });\r\n    } // */\r\n    removeOlderConversations(conversations) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // if (!authService.fromSDK) {\r\n            let maxConversations = that.nbMaxConversations;\r\n            //add protection when the local storage does not work correctly ...\r\n            if (!maxConversations || maxConversations < 15) {\r\n                that.nbMaxConversations = 15;\r\n                maxConversations = 15;\r\n            }\r\n            let orderedConversations = conversations ? conversations.sort(that.sortFunction) : that.getConversations().sort(that.sortFunction);\r\n            that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- maxConversations : \", maxConversations);\r\n            if (orderedConversations.length > maxConversations) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- orderedConversations : \", orderedConversations.length);\r\n                let removePromises = [];\r\n                for (let index = maxConversations; index < orderedConversations.length; index++) {\r\n                    let conv = orderedConversations[index];\r\n                    if (conv) {\r\n                        removePromises.push(that.deleteServerConversation(conv.id));\r\n                    }\r\n                    else {\r\n                        that._logger.log(\"debug\", LOG_ID + \"(removeOlderConversations) -- conversation undefined, so cannot delete it.\");\r\n                    }\r\n                }\r\n                Promise.all(removePromises).then((result) => {\r\n                    resolve(result);\r\n                }).catch((err) => {\r\n                    resolve(err);\r\n                });\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    sortFunction(aa, bb) {\r\n        let aLast = aa.lastModification;\r\n        let aCreation = aa.creationDate;\r\n        let bLast = bb.lastModification;\r\n        let bCreation = bb.creationDate;\r\n        let aDate = aCreation;\r\n        let bDate = bCreation;\r\n        //get the most recent of the creation date or the last message date\r\n        if (!aLast && aCreation) {\r\n            aDate = aCreation;\r\n        }\r\n        else {\r\n            aDate = aLast;\r\n        }\r\n        if (!bLast && bCreation) {\r\n            bDate = bCreation;\r\n        }\r\n        else {\r\n            bDate = bLast;\r\n        }\r\n        return (bDate - aDate);\r\n    }\r\n    ;\r\n    /* formatDate (date){\r\n         return moment(date).utc().format(\"YYYY-MM-DDTHH:mm:ss\") + \"Z\";\r\n     }; // */\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Allow to delete a conversation on server (p2p and bubbles)\r\n     * @param {String} conversationId of the conversation (id field)\r\n     * @return {Promise}\r\n     */\r\n    deleteServerConversation(conversationId) {\r\n        let that = this;\r\n        that._logger.log(\"info\", LOG_ID + \"deleteServerConversation conversationId : \", conversationId);\r\n        // Ignore conversation without dbId\r\n        if (!conversationId) {\r\n            return Promise.resolve();\r\n        }\r\n        return that._rest.deleteServerConversation(conversationId).then((result) => {\r\n            // TODO ? that.orderConversations();\r\n            return Promise.resolve(result);\r\n        }).catch((err) => {\r\n            // Check particular case where we are trying to remove an already removed conversation\r\n            if (err.errorDetailsCode === 404002) {\r\n                that._logger.log(\"info\", LOG_ID + \"deleteServerConversation success: \" + conversationId);\r\n                return Promise.resolve();\r\n            }\r\n            let errorMessage = \"deleteServerConversation failure: \" + err.errorDetails;\r\n            that._logger.log(\"warn\", LOG_ID + \"Error.\");\r\n            that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Allow to mute notification in a conversations (p2p and bubbles)\r\n     *    When a conversation is muted/unmuted, all user's resources will receive the notification\r\n     * @param {String} ID of the conversation (dbId field)\r\n     * @param {Boolean} mute mutation state\r\n     * @return {Promise}\r\n     */\r\n    updateServerConversation(conversationId, mute) {\r\n        // Ignore conversation without dbId\r\n        if (!conversationId) {\r\n            return Promise.resolve();\r\n        }\r\n        return this._rest.updateServerConversation(conversationId, mute);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendConversationByEmail\r\n     * @instance\r\n     * @description\r\n     *    Allow to get the specified conversation as mail attachment to the login email of the current user (p2p and bubbles)\r\n     *    can be used to backup a conversation between a rainbow user and another one, or between a user and a room,\r\n     *    The backup of the conversation is restricted to a number of days before now. By default the limit is 30 days.\r\n     * @param {String} ID of the conversation (dbId field)\r\n     * @async\r\n     * @return {Promise<Conversation[]>}\r\n     * @fulfil {Conversation[]} - Array of Conversation object\r\n     * @category async\r\n     */\r\n    sendConversationByEmail(conversationDbId) {\r\n        return this._rest.sendConversationByEmail(conversationDbId);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method ackAllMessages\r\n     * @instance\r\n     * @description\r\n     *    Mark all unread messages in the conversation as read.\r\n     * @param {String} ID of the conversation (dbId field)\r\n     * @async\r\n     * @return {Promise<Conversation[]>}\r\n     * @fulfil {Conversation[]} - Array of Conversation object\r\n     * @category async\r\n     */\r\n    ackAllMessages(conversationDbId) {\r\n        return this._rest.ackAllMessages(conversationDbId);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getHistoryPage\r\n     * @instance\r\n     * @description\r\n     *    Retrieve the remote history of a specific conversation.\r\n     * @param {Conversation} conversation Conversation to retrieve\r\n     * @param {number} size Maximum number of element to retrieve\r\n     * @async\r\n     * @return {Promise<Conversation[]>}\r\n     * @fulfil {Conversation[]} - Array of Conversation object\r\n     * @category async\r\n     */\r\n    getHistoryPage(conversation, size) {\r\n        let that = this;\r\n        // Avoid to call several time the same request\r\n        if (conversation.currentHistoryId && conversation.currentHistoryId === conversation.historyIndex) {\r\n            that._logger.log(\"debug\", LOG_ID + \"[conversationServiceHistory] getHistoryPage(\", conversation.id, \", \", size, \", \", conversation.historyIndex, \") already asked\");\r\n            return Promise.resolve();\r\n        }\r\n        conversation.currentHistoryId = conversation.historyIndex;\r\n        that._logger.log(\"debug\", LOG_ID + \"[conversationServiceHistory] getHistoryPage(\", conversation.id, \", \", size, \", \", conversation.historyIndex, \")\");\r\n        // Create the defered object\r\n        let defered = conversation.historyDefered = new Utils_1.Deferred();\r\n        // Do nothing for userContact\r\n        if (that._contacts.isUserContact(conversation.contact)) {\r\n            defered.reject();\r\n            return defered.promise;\r\n        }\r\n        if (conversation.historyComplete) {\r\n            that._logger.log(\"debug\", LOG_ID + \"getHistoryPage(\" + conversation.id + \") : already complete\");\r\n            defered.reject();\r\n            return defered.promise;\r\n        }\r\n        let mamRequest = {\r\n            \"queryid\": conversation.id,\r\n            \"with\": conversation.id,\r\n            \"max\": size,\r\n            \"before\": \"\"\r\n        };\r\n        if (conversation.historyIndex !== -1) {\r\n            mamRequest.before = conversation.historyIndex;\r\n        }\r\n        // Request for history messages for the room chat\r\n        if (conversation.bubble) {\r\n            mamRequest = {\r\n                \"queryid\": conversation.id,\r\n                \"with\": that._xmpp.jid_im,\r\n                \"max\": size,\r\n                \"before\": \"\"\r\n            };\r\n            if (conversation.historyIndex !== -1) {\r\n                mamRequest.before = conversation.historyIndex;\r\n            }\r\n            that._xmpp.mamQueryMuc(conversation.id, conversation.bubble.jid, mamRequest);\r\n        }\r\n        else {\r\n            // Request for history messages for the conversation\r\n            that._xmpp.mamQuery(conversation.id, mamRequest);\r\n        }\r\n        return defered.promise;\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     */\r\n    getOrCreateOneToOneConversation(conversationId, conversationDbId, lastModification, lastMessageText, missedIMCounter, muted, creationDate) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            return new Promise((resolve, reject) => {\r\n                // Fetch the conversation\r\n                let conv = that.getConversationById(conversationId);\r\n                if (conv) {\r\n                    conv.preload = true;\r\n                    return resolve(conv);\r\n                }\r\n                that._logger.log(\"info\", LOG_ID + \"getOrCreateOneToOneConversation \" + conversationId + \" \" + conversationDbId + \" \" + missedIMCounter);\r\n                // No conversation found, then create it\r\n                that._contacts.getOrCreateContact(conversationId, undefined) /* Get or create the conversation*/.then((contact) => {\r\n                    that._logger.log(\"info\", LOG_ID + \"[Conversation] Create one to one conversation (\" + contact.id + \")\");\r\n                    let conversation = Conversation_1.Conversation.createOneToOneConversation(contact);\r\n                    conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\r\n                    conversation.lastMessageText = lastMessageText;\r\n                    conversation.muted = muted;\r\n                    conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\r\n                    conversation.preload = false;\r\n                    // TODO ? that.computeCapabilitiesForContact(contact);\r\n                    conversation.dbId = conversationDbId;\r\n                    conversation.missedCounter = missedIMCounter ? missedIMCounter : 0;\r\n                    that.conversations[contact.jid_im] = conversation;\r\n                    return Promise.resolve(conversation);\r\n                    //return that.createServerConversation(conversation);\r\n                })\r\n                    .then((conversation) => {\r\n                    // TODO ? $rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\", conversation);\r\n                    resolve(conversation);\r\n                })\r\n                    .catch((error) => {\r\n                    let errorMessage = \"getOrCreateOneToOneConversation \" + conversationId + \" failure \" + error.message;\r\n                    that._logger.log(\"error\", LOG_ID + \"Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getBubbleConversation\r\n     * @instance\r\n     * @description\r\n     *    Get a conversation associated to a bubble (using the bubble ID to retrieve it)\r\n     * @param {String} bubbleJid JID of the bubble (dbId field)\r\n     * @param conversationDbId\r\n     * @param lastModification\r\n     * @param lastMessageText\r\n     * @param missedIMCounter\r\n     * @param noError\r\n     * @param muted\r\n     * @param creationDate\r\n     * @param lastMessageSender\r\n     * @async\r\n     * @return {Promise<Conversation>}\r\n     * @fulfil {Conversation} - Conversation object or null if not found\r\n     * @category async\r\n     */\r\n    getBubbleConversation(bubbleJid, conversationDbId, lastModification, lastMessageText, missedIMCounter, noError, muted, creationDate, lastMessageSender) {\r\n        let that = this;\r\n        that._logger.log(\"internal\", LOG_ID + \"getBubbleConversation bubbleJib : \", bubbleJid);\r\n        // Fetch the conversation in memory\r\n        let conversationResult = that.getConversationById(conversationDbId);\r\n        if (conversationResult) {\r\n            conversationResult.preload = true;\r\n            return Promise.resolve(conversationResult);\r\n        }\r\n        let conversation = that.getConversationByBubbleJid(bubbleJid);\r\n        if (conversation) {\r\n            conversation.preload = true;\r\n            return Promise.resolve(conversation);\r\n        }\r\n        // No conversation found, then create it\r\n        return new Promise((resolve, reject) => {\r\n            // Get the associated bubble\r\n            that._bubbles.getBubbleByJid(bubbleJid).then((bubble) => {\r\n                if (!bubble) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"getBubbleConversation (\" + bubbleJid + \") failure : no such bubble\");\r\n                    let obj = {\r\n                        jid: bubbleJid,\r\n                        conversationDbId: conversationDbId,\r\n                        lastModification: lastModification,\r\n                        lastMessageText: lastMessageText,\r\n                        missedIMCounter: missedIMCounter,\r\n                        muted: muted,\r\n                        creationDate: creationDate\r\n                    };\r\n                    that.waitingBotConversations.push(obj);\r\n                    that.unlockWaitingBotConversations();\r\n                    resolve();\r\n                }\r\n                else {\r\n                    that._logger.log(\"info\", LOG_ID + \"[Conversation] Create bubble conversation (\" + bubble.jid + \")\");\r\n                    conversation = Conversation_1.Conversation.createBubbleConversation(bubble);\r\n                    conversation.dbId = conversationDbId;\r\n                    conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\r\n                    conversation.lastMessageText = lastMessageText;\r\n                    conversation.muted = muted;\r\n                    conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\r\n                    conversation.preload = false;\r\n                    conversation.lastMessageSender = lastMessageSender;\r\n                    if (missedIMCounter) {\r\n                        conversation.missedCounter = missedIMCounter;\r\n                    }\r\n                    that.conversations[conversation.id] = conversation;\r\n                    if (conversationDbId) {\r\n                        that.getRoomConferences(conversation).then(function () {\r\n                            that._eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                            resolve(conversation);\r\n                        } // Create server side if necessary\r\n                        );\r\n                    }\r\n                    else {\r\n                        // that.createServerConversation(conversation)\r\n                        Promise.resolve(conversation).then(function (__conversation) {\r\n                            if (bubble) {\r\n                                that._presence.sendInitialBubblePresence(bubble);\r\n                            }\r\n                            // Send conversations update event\r\n                            that._eventEmitter.emit(\"evt_internal_conversationupdated\", __conversation);\r\n                            resolve(__conversation);\r\n                        }).catch(function (error) {\r\n                            return __awaiter(this, void 0, void 0, function* () {\r\n                                let errorMessage = \"getBubbleConversation (\" + bubbleJid + \") failure : \" + error.message;\r\n                                that._logger.log(\"error\", LOG_ID + \"Error.\");\r\n                                that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\r\n                                yield that.deleteServerConversation(conversationDbId);\r\n                                if (noError) {\r\n                                    resolve();\r\n                                }\r\n                                else {\r\n                                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            }).catch((error) => __awaiter(this, void 0, void 0, function* () {\r\n                let errorMessage = \"getBubbleConversation (\" + bubbleJid + \") failure : \" + error.message;\r\n                that._logger.log(\"error\", LOG_ID + \"Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"Error : \", errorMessage);\r\n                yield that.deleteServerConversation(conversationDbId);\r\n                if (noError) {\r\n                    resolve();\r\n                }\r\n                else {\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendIsTypingState\r\n     * @instance Conversations\r\n     * @description\r\n     *    Switch the \"is typing\" state in a conversation<br>\r\n     * @param {Conversation} conversation The conversation recipient\r\n     * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n     * @return a promise with no success parameter\r\n     */\r\n    sendIsTypingState(conversation, status) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!conversation) {\r\n                return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is missing or null\" }));\r\n            }\r\n            /* else if (!status) {\r\n                reject(Object.assign( ErrorManager.BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n            } // */\r\n            else {\r\n                conversation = conversation.id ? that.getConversationById(conversation.id) : null;\r\n                if (!conversation) {\r\n                    return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"Parameter \\'conversation\\': this conversation doesn\\'t exist\"), { msg: \"Parameter 'conversation': this conversation doesn't exist\" }));\r\n                }\r\n                else {\r\n                    that._xmpp.sendIsTypingState(conversation, status);\r\n                    resolve();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     * Get a pstn conference\r\n     */\r\n    getRoomConferences(conversation) {\r\n        let that = this;\r\n        return new Promise((resolve) => {\r\n            let confEndpoints = conversation.bubble.confEndpoints;\r\n            if (confEndpoints) {\r\n                confEndpoints.forEach(function (confEndpoint) {\r\n                    if (confEndpoint.mediaType === \"pstnAudio\") {\r\n                        // TODO later\r\n                        // let conferenceSession = pstnConferenceService.getConferenceSessionById(confEndpoint.confEndpointId);\r\n                        // if (conferenceSession) {\r\n                        //     conversation.pstnConferenceSession = conferenceSession;\r\n                        // }\r\n                    }\r\n                });\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     * Update a pstn conference\r\n     */\r\n    updateRoomConferences() {\r\n        let that = this;\r\n        let conversations = that.getConversations();\r\n        conversations.forEach(function (conversation) {\r\n            if (conversation.bubble && conversation.bubble.confEndpoints) {\r\n                // TODO Later\r\n                // let conferenceSession = pstnConferenceService.getConferenceSessionById(conversation.bubble.getPstnConfEndpointId());\r\n                // if (conferenceSession) {\r\n                //     conversation.pstnConferenceSession = conferenceSession;\r\n                // } else {\r\n                //     conversation.pstnConferenceSession = null;\r\n                // }\r\n            }\r\n            else {\r\n                // A room conversation without confEndpoint should not have a conferenceSession attached\r\n                conversation.pstnConferenceSession = null;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method closeConversation\r\n     * @instance\r\n     * @description\r\n     *    Close a conversation <br/>\r\n     *    This method returns a promise\r\n     * @param {Conversation} conversation The conversation to close\r\n     * @async\r\n     * @return {Promise}\r\n     * @fulfil {} Return nothing in case success\r\n     * @category async\r\n     */\r\n    closeConversation(conversation) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"info\", LOG_ID + \"closeConversation \" + conversation.id);\r\n            // Remove this contact from favorite group\r\n            that\r\n                .deleteServerConversation(conversation.dbId)\r\n                .then(() => {\r\n                that.removeConversation(conversation);\r\n                resolve();\r\n            })\r\n                .catch((error) => {\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Remove locally a conversation <br/>\r\n     *    This method returns a promise\r\n     * @param {Conversation} conversation The conversation to remove\r\n     */\r\n    removeConversation(conversation) {\r\n        let that = this;\r\n        that._logger.log(\"info\", LOG_ID + \"remove conversation \" + conversation.id);\r\n        if (conversation.videoCall && conversation.videoCall.status !== Call_1.Call.Status.UNKNOWN) {\r\n            that._logger.log(\"info\", LOG_ID + \"Ignore conversation deletion message for conversation\" + conversation.id);\r\n            return;\r\n        }\r\n        delete that.conversations[conversation.id];\r\n        /* that.orderConversations();\r\n         let conversations = that.getOrderedConversations();\r\n \r\n         if (that.activeConversation && !(conversations.idle.indexOf(service.activeConversation) >= 0)) {\r\n             if (conversations.idle.length > 0) {\r\n                 that.setActiveConversation(conversations.idle.first());\r\n             } else if (conversations.inCall.length > 0) {\r\n                 service.setActiveConversation(conversations.inCall.first());\r\n             } else {\r\n                 service.setActiveConversation(null);\r\n             }\r\n         }*/\r\n        // To avoid leak\r\n        if (conversation.contact) {\r\n            conversation.contact.conversation = null;\r\n            conversation.contact = null;\r\n        }\r\n        that._eventEmitter.emit(\"evt_internal_conversationdeleted\", { \"conversationId\": conversation.id });\r\n        //conversation = null;\r\n    }\r\n    /*********************************************************/\r\n    /**                   MESSAGES STUFF                    **/\r\n    /*********************************************************/\r\n    /**\r\n     * @private\r\n     * @method sendFSMessage\r\n     * @instance\r\n     * @description\r\n     *   Send an file sharing message\r\n     */\r\n    sendFSMessage(conversation, file, data) {\r\n        //let message = conversation.sendFSMessage(file, data);\r\n        //Conversation.prototype.sendFSMessage = function(file, data) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"info\", LOG_ID + \"sendFSMessage\");\r\n            // Add message in messages array\r\n            let fileExtension = file.name.split(\".\").pop();\r\n            let fileMimeType = file.type;\r\n            let viewers = [];\r\n            //let message = typeof (data) === \"object\" ? data : undefined;\r\n            let message = data;\r\n            let currentFileDescriptor;\r\n            if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n                viewers.push(FileViewer_1.FileViewerElementFactory(conversation.contact.id, \"user\", undefined, undefined));\r\n                /*viewers = fileViewerFactory([{\r\n                    \"viewerId\": this.contact.dbId,\r\n                    \"type\": \"user\"\r\n                }]); // */\r\n            }\r\n            else {\r\n                viewers.push(FileViewer_1.FileViewerElementFactory(conversation.bubble.id, \"room\", undefined, undefined));\r\n                /*viewers = fileViewerFactory([{\r\n                    \"viewerId\": this.room.dbId,\r\n                    \"type\": \"room\"\r\n                }]); // */\r\n            }\r\n            that._fileStorageService.createFileDescriptor(file.name, fileExtension, file.size, viewers).then(function (fileDescriptor) {\r\n                currentFileDescriptor = fileDescriptor;\r\n                fileDescriptor.fileToSend = file;\r\n                if (fileDescriptor.isImage()) {\r\n                    // let URLObj = $window.URL || $window.webkitURL;\r\n                    // fileDescriptor.previewBlob = URLObj.createObjectURL(file);\r\n                    if (file.preview) {\r\n                        fileDescriptor.previewBlob = file.preview;\r\n                    }\r\n                }\r\n                /*  if (!message) {\r\n                      message = that.addFSMessage(fileDescriptor.id, fileMimeType, data, \"uploading\");\r\n                  }\r\n                  message.fileId = fileDescriptor.id;\r\n                  message.fileName = fileDescriptor.fileName;\r\n                  // */\r\n                // Upload file\r\n                fileDescriptor.state = \"uploading\";\r\n                /*if (that.chatRenderer) {\r\n                    that.chatRenderer.updateFileTransferState(message, fileDescriptor);\r\n                } */\r\n                return that._fileServerService.uploadAFileByChunk(fileDescriptor, file.path /*, message , function (msg, fileDesc) {\r\n                   if (that.chatRenderer) {\r\n                       that.chatRenderer.updateFileTransferState(msg, fileDesc);\r\n                   }\r\n               } */)\r\n                    .then(function successCallback(fileDesc) {\r\n                    that._logger.log(\"debug\", LOG_ID + \"uploadAFileByChunk success\");\r\n                    if (that.chatRenderer) {\r\n                        that.chatRenderer.updateFileTransferState(message, fileDesc);\r\n                    }\r\n                    // resolve(fileDescriptor);\r\n                    return Promise.resolve(fileDesc);\r\n                }, function errorCallback(error) {\r\n                    that._logger.log(\"error\", LOG_ID + \"uploadAFileByChunk error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"uploadAFileByChunk error : \", error);\r\n                    //do we need to delete the file descriptor from the server if error ??\r\n                    that._fileStorageService.deleteFileDescriptor(currentFileDescriptor.id);\r\n                    // .then(function() {\r\n                    // let msgKey = error.translatedMessage ? error.translatedMessage : \"Unable to share file\";\r\n                    // $rootScope.$broadcast(\"ON_SHOW_INFO_MESSAGE\", { type: \"error\", messageKey: msgKey });\r\n                    // currentFileDescriptor.state = \"uploadError\";\r\n                    // message.receiptStatus = Message.ReceiptStatus.ERROR;\r\n                    // message.fileErrorMsg = msgKey;\r\n                    // that.updateMessage(message);\r\n                    // });\r\n                    // let msgKey = error.translatedMessage ? error.translatedMessage : \"Unable to share file\";\r\n                    //$rootScope.$broadcast(\"ON_SHOW_INFO_MESSAGE\", {type: \"error\", messageKey: msgKey});\r\n                    currentFileDescriptor.state = \"uploadError\";\r\n                    //message.receiptStatus = Message.ReceiptStatus.ERROR;\r\n                    //message.fileErrorMsg = msgKey;\r\n                    //that.updateMessage(message);\r\n                    return Promise.reject(error);\r\n                });\r\n            })\r\n                .then(function successCallback(fileDescriptorResult) {\r\n                fileDescriptorResult.state = \"uploaded\";\r\n                fileDescriptorResult.chunkPerformed = 0;\r\n                fileDescriptorResult.chunkTotalNumber = 0;\r\n                let messagefs = that.sendExistingFSMessage(conversation, message, fileDescriptorResult);\r\n                that.storePendingMessage(conversation, messagefs);\r\n                resolve(messagefs);\r\n            }, function errorCallback(error) {\r\n                that._logger.log(\"error\", LOG_ID + \"createFileDescriptor error\");\r\n                return reject(error);\r\n            });\r\n            //};\r\n            /*\r\n            todo: VBR What is this pendingMessages list coming from WebSDK ? Is it necessary for node SDK ?\r\n            this.pendingMessages[message.id] = {\r\n                conversation: conversation,\r\n                message: message\r\n            };\r\n            // */\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendExistingMessage\r\n     * @instance\r\n     * @param {string} data The text message to send\r\n     * @description\r\n     *    Send a message to this conversation\r\n     * @return {Message} The message sent\r\n     */\r\n    sendExistingFSMessage(conversation, message, fileDescriptor) {\r\n        let that = this;\r\n        //conversation.sendAckReadMessages();\r\n        let unicodeData = message;\r\n        if (!message) {\r\n            return null;\r\n        }\r\n        let lang = 'en';\r\n        if (conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n            let to = conversation.contact.jid;\r\n            return that._xmpp.sendChatExistingFSMessage(unicodeData, to, lang, fileDescriptor);\r\n        }\r\n        else {\r\n            let to = conversation.bubble.jid;\r\n            return that._xmpp.sendChatExistingFSMessageToBubble(unicodeData, to, lang, fileDescriptor);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *   Send an existing file sharing message\r\n     */\r\n    sendEFSMessage(conversation, fileDescriptor, data) {\r\n        let message = conversation.sendEFSMessage(fileDescriptor, data);\r\n        this.storePendingMessage(conversation, message);\r\n        return message;\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *    Send a instant message to a conversation\r\n     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>\r\n     * @param {Conversation} conversation The conversation to clean\r\n     * @param {String} data Test message to send\r\n     */\r\n    sendChatMessage(conversation, data, answeredMsg) {\r\n        let message = conversation.sendChatMessage(data, answeredMsg);\r\n        this.storePendingMessage(conversation, message);\r\n        return message;\r\n    }\r\n    /**\r\n     * SEND CORRECTED MESSAGE\r\n     */\r\n    /**\r\n     * @public\r\n     * @method sendCorrectedChatMessage\r\n     * @instance\r\n     * @description\r\n     *    Send a corrected message to a conversation\r\n     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>\r\n     *    The new message has the property originalMessageReplaced which spot on original message // Warning this is a circular depend.\r\n     *    The original message has the property replacedByMessage  which spot on the new message // Warning this is a circular depend.\r\n     *    Note: only the last sent message on the conversation can be changed. The connected user must be the sender of the original message.\r\n     * @param conversation\r\n     * @param data\r\n     * @param origMsgId\r\n     * @returns {Promise<String>} message the message new correction message sent. Throw an error if the send fails.\r\n     */\r\n    sendCorrectedChatMessage(conversation, data, origMsgId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!conversation) {\r\n                this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'conversation' parameter\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'conversation' parameter : \", conversation);\r\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            if (data == undefined || data == null) {\r\n                this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'data' parameter\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'data' parameter : \", data);\r\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            if (!origMsgId) {\r\n                this._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'origMsgId' parameter\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendCorrectedChatMessage) bad or empty 'origMsgId' parameter : \", origMsgId);\r\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(sendCorrectedChatMessage) _entering_ conversation.id : \", conversation.id, \", data : \", data, \"origMsgId : \", origMsgId);\r\n            let originalMessage = conversation.getMessageById(origMsgId);\r\n            let originalMessageFrom = originalMessage.fromJid || originalMessage.from;\r\n            if (originalMessageFrom !== that._rest.loggedInUser.jid_im) {\r\n                that._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\");\r\n                throw ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\", \"(sendCorrectedChatMessage) forbidden Action - only sent messages can be modified\");\r\n            }\r\n            let lastEditableMsg = conversation.getlastEditableMsg();\r\n            if (lastEditableMsg.id !== originalMessage.id) {\r\n                that._logger.log(\"error\", LOG_ID + \"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\");\r\n                throw ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\", \"(sendCorrectedChatMessage) forbidden Action - only last sent message can be modified\");\r\n            }\r\n            let messageUnicode = Emoji_1.shortnameToUnicode(data);\r\n            try {\r\n                let sentMessageId = yield that._xmpp.sendCorrectedChatMessage(conversation, originalMessage, messageUnicode, origMsgId, originalMessage.lang);\r\n                let newMsg = Object.assign({}, originalMessage);\r\n                newMsg.id = sentMessageId;\r\n                newMsg.content = messageUnicode;\r\n                newMsg.date = new Date();\r\n                newMsg.originalMessageReplaced = originalMessage; // Warning this is a circular depend.\r\n                originalMessage.replacedByMessage = newMsg; // Warning this is a circular depend.\r\n                this.pendingMessages[sentMessageId] = { conversation: conversation, message: newMsg };\r\n                return newMsg;\r\n            }\r\n            catch (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"createFileDescriptor error\");\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(err.message, \"(sendCorrectedChatMessage) error while sending corrected message : \" + err);\r\n                // @ts-ignore\r\n                error.newMessageText = data;\r\n                // @ts-ignore\r\n                error.originaleMessageId = origMsgId;\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @since 1.58\r\n     * @method deleteMessage\r\n     * @instance\r\n     * @async\r\n     * @description\r\n     *    Delete a message by sending an empty string in a correctedMessage\r\n     * @param {Conversation} conversation The conversation object\r\n     * @param {String} messageId The id of the message to be deleted\r\n     * @return {Message} - message object with updated replaceMsgs property\r\n     */\r\n    deleteMessage(conversation, messageId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!conversation) {\r\n                that._logger.log(\"error\", LOG_ID + \"(deleteMessage) Parameter 'conversation' is missing or null\");\r\n                throw ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST();\r\n            }\r\n            if (!messageId) {\r\n                that._logger.log(\"error\", LOG_ID + \"(deleteMessage) Parameter 'messageId' is missing or empty\");\r\n                throw ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST();\r\n            }\r\n            let messageOrig = conversation.getMessageById(messageId);\r\n            let correctedMsg = yield that.sendCorrectedChatMessage(conversation, \"\", messageId);\r\n            return messageOrig;\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * @public\r\n     * @since 1.67.0\r\n     * @method deleteAllMessageInOneToOneConversation\r\n     * @instance\r\n     * @async\r\n     * @description\r\n     *   DELETE ALL MESSAGES IN ONE2ONE CONVERSATION\r\n     * @param {Conversation} conversation The conversation object\r\n     * @return {Message} - message object with updated replaceMsgs property\r\n     */\r\n    deleteAllMessageInOneToOneConversation(conversation) {\r\n        let that = this;\r\n        if (!conversation) {\r\n            this._logger.log(\"error\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation' parameter.\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation' parameter : \", conversation);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        let conversationObj = that.getConversationById(conversation.id);\r\n        if (conversationObj.type !== Conversation_1.Conversation.Type.ONE_TO_ONE) {\r\n            this._logger.log(\"error\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation.type' parameter.\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllMessageInOne2OneConversation) bad or empty 'conversation.type' parameter : \", conversationObj);\r\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n        }\r\n        return that._xmpp.deleteAllMessageInOneToOneConversation(conversationObj.id);\r\n    }\r\n    /**\r\n     * @private\r\n     * @description\r\n     *      Store the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n     *      It allow to give back the status of the sending process.\r\n     * @param conversation\r\n     * @param message\r\n     */\r\n    storePendingMessage(conversation, message) {\r\n        this.pendingMessages[message.id] = {\r\n            conversation: conversation,\r\n            message: message\r\n        };\r\n    }\r\n    /**\r\n     * @private\r\n     * @description\r\n     *      delete the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n     *      It allow to give back the status of the sending process.\r\n     * @param message\r\n     */\r\n    removePendingMessage(message) {\r\n        delete this.pendingMessages[message.id];\r\n    }\r\n    /**\r\n     * @public\r\n     * @method removeAllMessages\r\n     * @instance\r\n     * @description\r\n     *    Cleanup a conversation by removing all previous messages<br/>\r\n     *    This method returns a promise\r\n     * @param {Conversation} conversation The conversation to clean\r\n     * @async\r\n     * @return {Promise}\r\n     * @fulfil {} Return nothing in case success\r\n     * @category async\r\n     */\r\n    removeAllMessages(conversation) {\r\n        let that = this;\r\n        return new Promise((resolve) => {\r\n            if (!conversation) {\r\n                this._logger.log(\"error\", LOG_ID + \"(removeAllMessages) bad or empty 'conversation' parameter.\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(removeAllMessages) bad or empty 'conversation' parameter : \", conversation);\r\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n            }\r\n            that._logger.log(\"info\", LOG_ID + \"(removeAllMessage) _entering_ \" + conversation.id);\r\n            // Id must be filled by lower layer\r\n            let mamRequest = {\r\n                //\"queryid\": mamRequestId,\r\n                \"with\": conversation.id,\r\n                \"onComplete\": function (result) {\r\n                    that._logger.log(\"internal\", LOG_ID + \" removeAllMessage \" + conversation.id, \", result : \", result);\r\n                    // FIXME : handle error message (ask Andre)\r\n                    resolve(result);\r\n                }\r\n            };\r\n            that.pendingMessages = [];\r\n            that._xmpp.mamDelete(mamRequest);\r\n            /*\r\n                        let mamRequest = {\r\n                            \"deleteid\": \"remove_\" + conversation.id,\r\n                            \"with\": conversation.id,\r\n                            \"before\": moment().add(1, 'minutes')\r\n                                .utc()\r\n                                .format(\"YYYY-MM-DDTHH:mm:ss\") + \"Z\",\r\n                            \"onComplete\": function (result) {\r\n                                that._logger.log(\"debug\", LOG_ID + \" removeAllMessage \" + conversation.id, \", result : \", result);\r\n                                // FIXME : handle error message (ask Andre)\r\n                                resolve(result);\r\n                            }\r\n                        };\r\n            \r\n                        that.pendingMessages = [];\r\n            \r\n                        // Request for history messages\r\n                        that._xmpp.mamDelete(conversation.id, mamRequest);\r\n                        // */\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method removeMessagesFromConversation\r\n     * @instance\r\n     * @description\r\n     *    Remove a specific range of message in a conversation<br/>\r\n     *    This method returns a promise\r\n     * @param {Conversation} conversation The conversation to clean\r\n     * @async\r\n     * @return {Promise}\r\n     * @fulfil {} Return nothing in case success\r\n     * @category async\r\n     */\r\n    removeMessagesFromConversation(conversation, date, number) {\r\n        let that = this;\r\n        return new Promise((resolve) => {\r\n            that._logger.log(\"info\", LOG_ID + \" removeMessagesFromConversation \" + conversation.id);\r\n            that._logger.log(\"info\", LOG_ID + \" removing \" + number + \" messages after \" + date);\r\n            let mamRequest = {\r\n                \"deleteid\": \"remove_\" + conversation.id,\r\n                \"with\": conversation.id,\r\n                \"start\": moment(date).format(\"YYYY-MM-DDTHH:mm:ss.SSSSSSZ\"),\r\n                \"max\": number,\r\n                \"onComplete\": () => {\r\n                    that\r\n                        ._logger\r\n                        .log(\"info\", LOG_ID + \" MAM Message deleted !!!\");\r\n                    resolve();\r\n                }\r\n            };\r\n            that.pendingMessages = that.pendingMessages.filter((messagePending) => { if (messagePending.date > date) {\r\n                return false;\r\n            } });\r\n            // Request for history messages\r\n            that._xmpp.mamDelete(mamRequest);\r\n            //that._xmpp.mamDelete(conversation.id, mamRequest);\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getConversationById\r\n     * @instance\r\n     * @description\r\n     *      Get a p2p conversation by id\r\n     * @param {String} conversationId Conversation id of the conversation to clean\r\n     * @return {Conversation} The conversation to retrieve\r\n     */\r\n    getConversationById(conversationId) {\r\n        let that = this;\r\n        that._logger.log(\"debug\", LOG_ID + \" (getConversationById) conversationId : \", conversationId);\r\n        if (!this.conversations) {\r\n            return null;\r\n        }\r\n        that._logger.log(\"internal\", LOG_ID + \" (getConversationById) conversation : \", this.conversations[conversationId]);\r\n        return this.conversations[conversationId];\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *      Get a conversation by db id\r\n     * @param {String} dbId db id of the conversation to retrieve\r\n     * @return {Conversation} The conversation to retrieve\r\n     */\r\n    getConversationByDbId(dbId) {\r\n        let that = this;\r\n        if (that.conversations) {\r\n            for (let key in that.conversations) {\r\n                if (that.conversations.hasOwnProperty(key) && that.conversations[key].dbId === dbId) {\r\n                    return that.conversations[key];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    ;\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *      Get a bubble conversation by bubble id\r\n     * @param {String} bubbleId Bubble id of the conversation to retrieve\r\n     * @return {Conversation} The conversation to retrieve\r\n     */\r\n    getConversationByBubbleId(bubbleId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.conversations) {\r\n                for (let key in this.conversations) {\r\n                    if (this.conversations.hasOwnProperty(key) && this.conversations[key].bubble && this.conversations[key].bubble.id === bubbleId) {\r\n                        return this.conversations[key];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *      Get a bubble conversation by bubble id\r\n     * @param {String} bubbleJid Bubble jid of the conversation to retrieve\r\n     * @return {Conversation} The conversation to retrieve\r\n     */\r\n    getConversationByBubbleJid(bubbleJid) {\r\n        if (this.conversations) {\r\n            for (let key in this.conversations) {\r\n                if (this.conversations.hasOwnProperty(key) && this.conversations[key].bubble && this.conversations[key].bubble.jid === bubbleJid) {\r\n                    return this.conversations[key];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAllConversations\r\n     * @instance\r\n     * @description\r\n     *    Allow to get the list of existing conversations (p2p and bubbles)\r\n     * @return {Conversation[]} An array of Conversation object\r\n     */\r\n    getAllConversations() {\r\n        let that = this;\r\n        return that.getConversations();\r\n    }\r\n    ;\r\n    /**\r\n     * @private\r\n     * @method\r\n     * @instance\r\n     * @description\r\n     *      Get all conversation\r\n     * @return {Conversation[]} The conversation list to retrieve\r\n     */\r\n    getConversations() {\r\n        let conversationArray = [];\r\n        for (let key in this.conversations) {\r\n            if (this.conversations.hasOwnProperty(key)) {\r\n                conversationArray.push(this.conversations[key]);\r\n            }\r\n        }\r\n        return conversationArray;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method openConversationForContact\r\n     * @instance\r\n     * @description\r\n     *    Open a conversation to a contact <br/>\r\n     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\r\n     *    This method returns a promise\r\n     * @param {Contact} contact The contact involved in the conversation\r\n     * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n     */\r\n    openConversationForContact(contact) {\r\n        let that = this;\r\n        return new Promise(function (resolve, __reject) {\r\n            if (!contact) {\r\n                return __reject({\r\n                    code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\r\n                    label: \"Parameter 'contact' is missing or null\"\r\n                });\r\n            }\r\n            else {\r\n                that._logger.log(\"info\", LOG_ID + \" :: Try to create of get a conversation.\");\r\n                that._logger.log(\"internal\", LOG_ID + \" :: Try to create of get a conversation with \" + contact.lastName + \" \" + contact.firstName);\r\n                that.getOrCreateOneToOneConversation(contact.jid).then(function (conversation) {\r\n                    that._logger.log(\"info\", LOG_ID + \"  :: Conversation retrieved or created \" + conversation.id);\r\n                    resolve(conversation);\r\n                }).catch(function (result) {\r\n                    that._logger.log(\"error\", LOG_ID + \"[openConversationForContact] Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"[openConversationForContact] Error : \", result);\r\n                    return __reject(result);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method openConversationForBubble\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    Open a conversation to a bubble <br/>\r\n     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\r\n     *    This method returns a promise\r\n     * @param {Bubble} bubble The bubble involved in this conversation\r\n     * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n     */\r\n    openConversationForBubble(bubble) {\r\n        let that = this;\r\n        return new Promise(function (resolve, __reject) {\r\n            if (!bubble) {\r\n                return __reject({\r\n                    code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\r\n                    label: \"Parameter 'bubble' is missing or null\"\r\n                });\r\n            }\r\n            else {\r\n                that._logger.log(\"info\", LOG_ID + \"(openConversationForBubble), Try to create of get a conversation for bubble.\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble), Try to create of get a conversation with bubble : \", bubble);\r\n                that.getBubbleConversation(bubble.jid, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined).then(function (conversation) {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble), Conversation retrieved or created, conversation : \", conversation);\r\n                    resolve(conversation);\r\n                }).catch(function (result) {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(openConversationForBubble) Error : \", result);\r\n                    __reject(result);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method getS2SServerConversation\r\n     * @since 1.65\r\n     * @instance\r\n     * @description\r\n     *    get a conversation from id on S2S API Server.<br/>\r\n     *    This method returns a promise\r\n     * @param {string} conversationId The id of the conversation to find.\r\n     * @return {Conversation} The conversation (created or retrieved) or null in case of error\r\n     */\r\n    getS2SServerConversation(conversationId) {\r\n        let that = this;\r\n        return new Promise(function (resolve, __reject) {\r\n            if (!conversationId) {\r\n                return __reject({\r\n                    code: ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST,\r\n                    label: \"Parameter 'conversationId' is missing or null\"\r\n                });\r\n            }\r\n            else {\r\n                that._logger.log(\"info\", LOG_ID + \"(getS2SServerConversation), Try to create of get a conversation for bubble.\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation), Try to create of get a conversation with bubble : \", conversationId);\r\n                that.getS2SServerConversation(conversationId).then(function (conversationInfos) {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation), Conversation retrieved or created, conversation : \", conversationInfos);\r\n                    /*that._logger.log(\"info\", LOG_ID + \"[Conversation] Create bubble conversation (\" + bubble.jid + \")\");\r\n\r\n                    let conversation = Conversation.createBubbleConversation(bubble);\r\n                    conversation.dbId = conversationId;\r\n                    conversation.lastModification = undefined;\r\n                    conversation.lastMessageText = undefined;\r\n                    conversation.muted = false;\r\n                    conversation.creationDate = new Date();\r\n                    conversation.preload = false;\r\n                    conversation.lastMessageSender = undefined;\r\n                    conversation.missedCounter = 0;\r\n                    that.conversations[conversation.id] = conversation;\r\n                    resolve(conversation)\r\n\r\n                     */\r\n                    resolve(conversationInfos);\r\n                }).catch(function (result) {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(getS2SServerConversation) Error : \", result);\r\n                    __reject(result);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    onRoomChangedEvent(__event, bubble, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (bubble) {\r\n                let conversation = this.getConversationById(bubble.jid);\r\n                if (conversation) {\r\n                    if (action === \"remove\") {\r\n                        yield this.closeConversation(conversation);\r\n                    }\r\n                    else {\r\n                        conversation.bubble = bubble;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    onRoomHistoryChangedEvent(__event, room) {\r\n        if (room) {\r\n            let conversation = this.getConversationById(room.jid);\r\n            if (conversation && conversation.chatRenderer) {\r\n                conversation.reset();\r\n                conversation\r\n                    .chatRenderer\r\n                    .loadMore();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    onRoomAdminMessageEvent(__event, roomJid, userJid, type, msgId) {\r\n        this._logger.log(\"info\", LOG_ID + \" onRoomAdminMessageEvent\");\r\n        let conversation = this.getConversationById(roomJid);\r\n        if (conversation && (type === \"welcome\" || type === \"conferenceAdd\" || type === \"conferenceRemove\") && conversation.bubble && conversation.bubble.ownerContact) {\r\n            userJid = conversation.bubble.ownerContact.jid;\r\n        }\r\n        let contact = this._contacts.getContactByJid(userJid);\r\n        if (conversation && contact) {\r\n            // If invitation msg and I'm not the owner\r\n            if (!conversation.bubble.owner && type === \"invitation\") {\r\n                return;\r\n            }\r\n            if (conversation.bubble && conversation.bubble.isMeetingBubble()) {\r\n                return;\r\n            }\r\n            this._conversationServiceEventHandler.onRoomAdminMessageReceived(conversation, contact, type, msgId);\r\n        }\r\n    }\r\n    /*********************************************************************/\r\n    /** Remove the conversation history                                 **/\r\n    /*********************************************************************/\r\n    /**\r\n     * @private\r\n     *\r\n     */\r\n    reinit() {\r\n        let that = this;\r\n        return new Promise((resolve) => {\r\n            that._logger.log(\"info\", LOG_ID + \" Re-initialize conversation service\");\r\n            // Remove all my conversation\r\n            delete that.conversations;\r\n            that.conversations = [];\r\n            // bot service is ready / TODO ? service.botServiceReady = true; Fetch\r\n            // conversations from server\r\n            that._rest.getServerConversations(that.conversationsRetrievedFormat).then(function () {\r\n                // TODO ? service.linkAllActiveCallsToConversations();\r\n                resolve();\r\n            })\r\n                .catch(function () {\r\n                setInterval(() => {\r\n                    that._logger.log(\"info\", LOG_ID + \" getServerConversations failure, try again\");\r\n                    that._rest.getServerConversations(that.conversationsRetrievedFormat).then(function () {\r\n                        // TODO ? that.linkAllActiveCallsToConversations();\r\n                    });\r\n                }, 10000, 1, true);\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n    /*********************************************************************/\r\n    /** BOT SERVICE IS RUNNING, CREATE ALL BOT CONVERSATIONS            **/\r\n    /*********************************************************************/\r\n    unlockWaitingBotConversations(isBotServiceReady) {\r\n        let that = this;\r\n        if (isBotServiceReady) {\r\n            that.botServiceReady = true;\r\n        }\r\n        if (that.botServiceReady) {\r\n            //stop infinite loop in case of error\r\n            that.botServiceReady = false;\r\n            that.waitingBotConversations.forEach(function (obj, index) {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    let contact = yield that._contacts.getContactByJid(obj.jid);\r\n                    if (contact) {\r\n                        yield that.getOrCreateOneToOneConversation(contact.jid, null, obj.lastModification, obj.lastMessageText, obj.missedIMCounter, obj.muted, obj.creationDate);\r\n                        that.waitingBotConversations.splice(index, 1);\r\n                    }\r\n                });\r\n            });\r\n            that.waitingBotConversations = [];\r\n        }\r\n    }\r\n};\r\nConversations = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n     * @module\r\n     * @name Conversations\r\n     * @version 1.67.1 \r\n     * @public\r\n     * @description\r\n     * This module is the basic module for handling conversations in Rainbow. In Rainbow, conversations are the way to get in touch with someone or something (i.e. a Rainbow contact, a external phone number, a connected thing, ...) so a conversation is the \"long tail\" of communication between you and someone or something else like a bubble.\r\n     * A Rainbow conversation by default supports sending and receiving Instant Messages with a single recipient (one-to-one conversation) or with several persons (bubble). Using the FileStorage service, you can share files in conversations.\r\n     *\r\n     * The main methods and events proposed in that service allow to:\r\n     *   - Create or close a Rainbow conversation (one-to-one of bubble),\r\n     *   - Get all conversations or get a conversation by Id, bubbleID or bubbleJid\r\n     *   - Retrieve all information linked to that conversation,\r\n     *\r\n     *   */\r\n], Conversations);\r\nexports.ConversationsService = Conversations;\r\nmodule.exports.ConversationsService = Conversations;\r\n//# sourceMappingURL=ConversationsService.js.map"]},"metadata":{},"sourceType":"script"}