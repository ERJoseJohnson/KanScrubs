{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst favoriteEventHandler_1 = require(\"../connection/XMPPServiceHandler/favoriteEventHandler\");\n\nconst Favorite_1 = require(\"../common/models/Favorite\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"FAVTE/SVCE - \";\nlet FavoritesService =\n/**\n* @module\n* @name FavoritesService\n * @version 1.67.1 \n * @public\n* @description\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\n*      The main methods and events proposed in that service allow to: <br>\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\n*      - Retrieve all information linked to that Favorite, <br>\n*/\nclass FavoritesService {\n  constructor(_eventEmitter, logger, _startConfig) {\n    //public static $inject: string[] = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];\n    this.favorites = [];\n    this.ready = false;\n    /*********************************************************/\n\n    /**                 LIFECYCLE STUFF                     **/\n\n    /*********************************************************/\n\n    this._startConfig = _startConfig; //let that = this;\n\n    this._eventEmitter = _eventEmitter;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._logger = logger;\n    this.started = false;\n    this._initialized = false;\n\n    this._eventEmitter.on(\"evt_internal_favoritecreated_handle\", this.onFavoriteCreated.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_favoritedeleted_handle\", this.onFavoriteDeleted.bind(this));\n\n    this.ready = false;\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that._xmpp = _core._xmpp;\n      that._rest = _core._rest;\n      that._options = _options;\n      that._s2s = _core._s2s;\n      that._useXMPP = that._options.useXMPP;\n      that._useS2S = that._options.useS2S;\n      this._favoriteHandlerToken = [];\n\n      that._logger.log(\"info\", LOG_ID + \" \");\n\n      that._logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\n\n      let startDate = new Date().getTime();\n      this.attachHandlers(); //this.conversationService.favoriteService = this;\n      //this.attachHandlers();\n\n      let startDuration = Math.round(new Date().getTime() - startDate); //stats.push({ service: 'favoriteService', startDuration: startDuration });\n\n      that._logger.log(\"info\", LOG_ID + `=== STARTED (${startDuration} ms) ===`);\n\n      this.ready = true;\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"info\", LOG_ID + \"[stop] Stopping\"); //remove all saved call logs\n\n\n      this.started = false;\n      this._initialized = false;\n      that._xmpp = null;\n      that._rest = null;\n      delete that._favoriteEventHandler;\n      that._favoriteEventHandler = null;\n\n      if (that._favoriteHandlerToken) {\n        that._favoriteHandlerToken.forEach(token => PubSub.unsubscribe(token));\n      }\n\n      that._favoriteHandlerToken = [];\n      /*this.$log.info('Stopping');\n      if (this._xmppManagementHandler) {\n          this.xmppService.deleteHandler(this._xmppManagementHandler);\n          this._xmppManagementHandler = null;\n      }\n      this.$log.info('Stopped');\n            */\n\n      this.ready = false;\n\n      that._logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\n    });\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      yield this.getServerFavorites();\n      /*await setTimeoutPromised(3000).then(() => {\n          let startDate = new Date();\n          that.getCallLogHistoryPage()\n              .then(() => {\n                  // @ts-ignore\n                  let duration = new Date() - startDate;\n                  let startDuration = Math.round(duration);\n                  that._logger.log(\"info\", LOG_ID + \" callLogService start duration : \",  startDuration);\n                  that._logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\n                  that.started = true;\n              })\n              .catch(() => {\n                  that._logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\n              });\n      });\n            */\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n\n    that._logger.log(\"info\", LOG_ID + \"[attachHandlers] attachHandlers\");\n\n    that._favoriteEventHandler = new favoriteEventHandler_1.FavoriteEventHandler(that._xmpp, that);\n    that._favoriteHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_MANAGEMENT, that._favoriteEventHandler.onManagementMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_ERROR, that._favoriteEventHandler.onErrorMessageReceived)];\n    /*\n    if (this._xmppManagementHandler) { this.xmppService.deleteHandler(this._xmppManagementHandler); }\n    this._xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, \"message\", \"management\");\n      */\n\n    /*\n    //if reconnection, update the call-logs\n    if (that.started && that.lastTimestamp) {\n        $interval(function () {\n            that.getCallLogHistoryPage(that.lastTimestamp);\n        }, 1000, 1, true);\n    }\n    // */\n  }\n\n  reconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.getServerFavorites(); //this.conversationService.favoriteService = this;\n\n      this.attachHandlers();\n    });\n  }\n\n  getServerFavorites() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let that = this;\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n          this._rest.getServerFavorites().then(favorite => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"info\", LOG_ID + \"(getServerFavorites) favorite tab length : \", favorite.length);\n\n            if (favorite) {\n              let promises = favorite.map(data => __awaiter(this, void 0, void 0, function* () {\n                return this.createFavoriteObj(data.id, data.peerId, data.type);\n              }));\n              let favorites = yield Promise.all(promises);\n              this.favorites = favorites.filter(favorite => {\n                return favorite !== null;\n              });\n\n              that._logger.log(\"info\", LOG_ID + `getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n            }\n\n            resolve(this.favorites);\n          })).catch(err => {\n            that._logger.log(\"error\", LOG_ID + \"(getServerFavorites) error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(getServerFavorites) error : \", err);\n\n            return reject(err);\n          });\n          /*\n          //            let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\n          //          let response = await this.$http({ method: \"GET\", url: url, headers: this.authService.getRequestHeader() });\n          let promises = response.data.data.map(async (data: any) => { return this.createFavorite(data.id, data.peerId, data.type); });\n          let favorites = await Promise.all(promises);\n          this.favorites = favorites.filter((favorite) => { return favorite !== null; });\n          this.$log.info(`getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n          return this.favorites;\n          */\n\n        }));\n      } catch (error) {\n        let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;\n\n        this._logger.log(\"error\", LOG_ID + `[getServerFavorites] CATCH Error !!! `);\n\n        this._logger.log(\"internalerror\", LOG_ID + `CATCH Error !!! : ${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  addServerFavorite(peerId, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        let favorite = yield that._rest.addServerFavorite(peerId, type);\n\n        that._logger.log(\"internal\", LOG_ID + `addServerFavorite(${peerId}, ${type}) -- SUCCESS`, favorite);\n\n        return favorite;\n      } catch (error) {\n        let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;\n\n        that._logger.log(\"error\", LOG_ID + `[addServerFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  removeServerFavorite(favoriteId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n          that._rest.removeServerFavorite(favoriteId).then(favoriteDeleted => __awaiter(this, void 0, void 0, function* () {\n            that._logger.log(\"info\", LOG_ID + \"(removeServerFavorite) -- SUCCESS.\");\n\n            that._logger.log(\"internal\", LOG_ID + \"(removeServerFavorite) -- SUCCESS : \", favoriteDeleted);\n\n            resolve(favoriteDeleted);\n          })).catch(err => {\n            that._logger.log(\"error\", LOG_ID + \"(removeServerFavorite) error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(removeServerFavorite) error : \", err);\n\n            return reject(err);\n          });\n        }));\n      } catch (error) {\n        let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;\n\n        that._logger.log(\"error\", LOG_ID + `[removeServerFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n\n        throw new Error(errorMessage);\n      }\n    });\n  }\n\n  toggleFavorite(conversation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n      let type = conversation.contact ? conversation.contact.isBot ? 'bot' : 'user' : 'room';\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === peerId;\n      });\n\n      if (!favorite) {\n        return this.addServerFavorite(peerId, type);\n      } else {\n        return this.removeServerFavorite(favorite.id);\n      }\n    });\n  }\n\n  updateFavorites(conversation) {\n    let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n    let favorite = this.favorites.find(favoriteConv => {\n      return favoriteConv.peerId === peerId;\n    });\n\n    if (favorite) {\n      conversation.isFavorite = true;\n      favorite.conv = conversation;\n    }\n  }\n\n  getFavorite(peerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === peerId;\n      }); //let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);\n      //return await convGetter;\n    });\n  }\n\n  createFavoriteObj(id, peerId, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      try {\n        let favorite = new Favorite_1.Favorite(id, peerId, type);\n        /*\n        // Get peer object\n        if (type === 'room') { favorite.room = this.roomService.getRoomById(peerId); }\n        else { favorite.contact = await this.contactService.getContactByDBId(peerId); }\n             // Fetch eventual conversation\n        let convId: string = favorite.room ? favorite.room.jid : favorite.contact.jid;\n        let conv: any = this.conversationService.getConversationById(convId);\n        if (conv) { conv.isFavorite = true; favorite.conv = conv; }\n              */\n\n        return favorite;\n      } catch (error) {\n        that._logger.log(\"error\", LOG_ID + `[createFavorite] Error.`);\n\n        that._logger.log(\"internalerror\", LOG_ID + `createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);\n\n        return null;\n      }\n    });\n  }\n\n  onXmppEvent(stanza) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        /*\n        let stanzaElem = $(stanza);\n        let favoriteElem = stanzaElem.find(\"favorite\");\n        if (favoriteElem) {\n          let id = favoriteElem.attr(\"id\");\n          let type = favoriteElem.attr(\"type\");\n          let peerId = favoriteElem.attr(\"peer_id\");\n          let action = favoriteElem.attr(\"action\");\n               if (action === 'create') {\n              let favorite: Favorite = this.favorites.find((favoriteConv: any) => { return favoriteConv.peerId === peerId; });\n              if (!favorite) {\n                  favorite = await this.createFavorite(id, peerId, type);\n                  this.favorites.push(favorite);\n                  this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n              }\n          }\n               if (action === 'delete') {\n              let index = this.favorites.findIndex((fav) => { return fav.id === id; });\n              if (index !== -1) {\n                  let favorite = this.favorites[index];\n                  if (favorite.conv) { favorite.conv.isFavorite = false; }\n                  this.favorites.splice(index, 1);\n                  this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n              }\n          }\n        }\n        return true;\n        */\n      } catch (error) {\n        return true;\n      }\n    });\n  }\n  /*private sendEvent(eventName: string, detail: any): void {\n      let event = new CustomEvent(eventName, { detail });\n      window.dispatchEvent(event);\n  }\n    */\n\n  /**\n   * @public\n   * @since 1.56\n   * @method fetchAllFavorites()\n   * @instance\n   * @description\n   *   Fetch all the Favorites from the server in a form of an Array\n   * @return {Conversation[]} An array of Favorite objects\n   */\n\n\n  fetchAllFavorites() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        that.getServerFavorites().then(function (favorites) {\n          that._logger.log(\"debug\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites`);\n\n          that._logger.log(\"internal\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites : `, favorites);\n\n          resolve(favorites);\n        }).catch(function (err) {\n          that._logger.log(\"error\", LOG_ID + `[fetchAllFavorites] :: Error.`);\n\n          that._logger.log(\"internalerror\", LOG_ID + `[fetchAllFavorites] :: ERROR : `, err);\n\n          return reject(err);\n        });\n      });\n    });\n  }\n\n  /**\n   * @public\n   * @since 1.56\n   * @method createFavorite()\n   * @instance\n   * @description\n   *   Add conversation/bubble/bot to Favorites Array\n   * @param {String} id of the conversation/bubble\n   * @param {String} type of Favorite (can be 'user' or 'bubble')\n   * @return {Promise<Favorite>} A Favorite object\n   */\n  createFavorite(id, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (!id) {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (!type) {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (type !== \"bubble\" && type !== \"user\") {\n          that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: type should be set to \\\"user\\\" or \\\"bubble\\\"\");\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n\n        if (type === \"bubble\") {\n          type = \"room\";\n        }\n\n        that.addServerFavorite(id, type).then(favorite => {\n          that._logger.log(\"debug\", LOG_ID + `[createFavorite] :: Successfully added ${type} to favorites`);\n\n          return resolve(favorite);\n        }).catch(err => {\n          that._logger.log(\"error\", LOG_ID + \"[createFavorite] :: Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"[createFavorite] :: Error : \", err);\n\n          return reject(err);\n        });\n      });\n    });\n  }\n\n  /**\n   * @public\n   * @since 1.56\n   * @method deleteFavorite()\n   * @instance\n   * @description\n   *   Delete conversation/bubble/bot from Favorites Array\n   * @param {String} id of the Favorite item\n   * @return {Favorite[]} A Favorite object\n   */\n  deleteFavorite(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      return new Promise((resolve, reject) => {\n        if (!id) {\n          that._logger.log(\"debug\", LOG_ID + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n\n          return reject(\"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n        }\n\n        that.removeServerFavorite(id).then(favDeleted => {\n          return resolve(favDeleted);\n        }).catch(err => {\n          that._logger.log(\"error\", LOG_ID + \"[deleteFavorite] :: Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"[deleteFavorite] :: Error : \", err);\n\n          return reject(err);\n        });\n      });\n    });\n  } // ******************* Event XMPP parsed in favoriteEventHandler ***************\n\n\n  onFavoriteCreated(fav) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let favorite = this.favorites.find(favoriteConv => {\n        return favoriteConv.peerId === fav.peerId;\n      });\n\n      if (!favorite) {\n        favorite = yield this.createFavoriteObj(fav.id, fav.peerId, fav.type);\n        this.favorites.push(favorite); //that._logger.log(\"internal\", LOG_ID + \"[onFavoriteCreated] send event : \", favorite);\n        //this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n\n        that._eventEmitter.emit(\"evt_internal_favoritecreated\", favorite);\n      }\n    });\n  }\n\n  onFavoriteDeleted(fav) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let index = this.favorites.findIndex(fav => {\n        return fav.id === fav.id;\n      });\n\n      if (index !== -1) {\n        let favorite = this.favorites[index];\n\n        if (favorite.conv) {\n          favorite.conv.isFavorite = false;\n        }\n\n        this.favorites.splice(index, 1); //that._logger.log(\"debug\", LOG_ID + \"[onFavoriteDeleted] send event : \", { favoriteId: favorite.id });\n        //this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n\n        that._eventEmitter.emit(\"evt_internal_favoritedeleted\", fav);\n      }\n    });\n  }\n\n};\nFavoritesService = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\n* @module\n* @name FavoritesService\n * @version 1.67.1 \n * @public\n* @description\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\n*      The main methods and events proposed in that service allow to: <br>\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\n*      - Retrieve all information linked to that Favorite, <br>\n*/\n], FavoritesService);\nexports.FavoritesService = FavoritesService;\nmodule.exports.FavoritesService = FavoritesService;","map":{"version":3,"sources":["../../src/lib/services/FavoritesService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Utils_1 = require(\"../common/Utils\");\nconst PubSub = require(\"pubsub-js\");\nconst favoriteEventHandler_1 = require(\"../connection/XMPPServiceHandler/favoriteEventHandler\");\nconst Favorite_1 = require(\"../common/models/Favorite\");\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\nconst Utils_2 = require(\"../common/Utils\");\nconst LOG_ID = \"FAVTE/SVCE - \";\nlet FavoritesService = \n/**\n* @module\n* @name FavoritesService\n * @version 1.67.1 \n * @public\n* @description\n*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\n*      The main methods and events proposed in that service allow to: <br>\n*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\n*      - Retrieve all information linked to that Favorite, <br>\n*/\nclass FavoritesService {\n    constructor(_eventEmitter, logger, _startConfig) {\n        //public static $inject: string[] = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];\n        this.favorites = [];\n        this.ready = false;\n        /*********************************************************/\n        /**                 LIFECYCLE STUFF                     **/\n        /*********************************************************/\n        this._startConfig = _startConfig;\n        //let that = this;\n        this._eventEmitter = _eventEmitter;\n        this._xmpp = null;\n        this._rest = null;\n        this._s2s = null;\n        this._options = {};\n        this._useXMPP = false;\n        this._useS2S = false;\n        this._logger = logger;\n        this.started = false;\n        this._initialized = false;\n        this._eventEmitter.on(\"evt_internal_favoritecreated_handle\", this.onFavoriteCreated.bind(this));\n        this._eventEmitter.on(\"evt_internal_favoritedeleted_handle\", this.onFavoriteDeleted.bind(this));\n        this.ready = false;\n    }\n    get startConfig() {\n        return this._startConfig;\n    }\n    start(_options, _core) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            that._xmpp = _core._xmpp;\n            that._rest = _core._rest;\n            that._options = _options;\n            that._s2s = _core._s2s;\n            that._useXMPP = that._options.useXMPP;\n            that._useS2S = that._options.useS2S;\n            this._favoriteHandlerToken = [];\n            that._logger.log(\"info\", LOG_ID + \" \");\n            that._logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\n            let startDate = new Date().getTime();\n            this.attachHandlers();\n            //this.conversationService.favoriteService = this;\n            //this.attachHandlers();\n            let startDuration = Math.round(new Date().getTime() - startDate);\n            //stats.push({ service: 'favoriteService', startDuration: startDuration });\n            that._logger.log(\"info\", LOG_ID + `=== STARTED (${startDuration} ms) ===`);\n            this.ready = true;\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            that._logger.log(\"info\", LOG_ID + \"[stop] Stopping\");\n            //remove all saved call logs\n            this.started = false;\n            this._initialized = false;\n            that._xmpp = null;\n            that._rest = null;\n            delete that._favoriteEventHandler;\n            that._favoriteEventHandler = null;\n            if (that._favoriteHandlerToken) {\n                that._favoriteHandlerToken.forEach((token) => PubSub.unsubscribe(token));\n            }\n            that._favoriteHandlerToken = [];\n            /*this.$log.info('Stopping');\n            if (this._xmppManagementHandler) {\n                this.xmppService.deleteHandler(this._xmppManagementHandler);\n                this._xmppManagementHandler = null;\n            }\n            this.$log.info('Stopped');\n    \n             */\n            this.ready = false;\n            that._logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\n        });\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            yield this.getServerFavorites();\n            /*await setTimeoutPromised(3000).then(() => {\n                let startDate = new Date();\n                that.getCallLogHistoryPage()\n                    .then(() => {\n                        // @ts-ignore\n                        let duration = new Date() - startDate;\n                        let startDuration = Math.round(duration);\n                        that._logger.log(\"info\", LOG_ID + \" callLogService start duration : \",  startDuration);\n                        that._logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\n                        that.started = true;\n                    })\n                    .catch(() => {\n                        that._logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\n                    });\n            });\n    \n             */\n        });\n    }\n    attachHandlers() {\n        let that = this;\n        that._logger.log(\"info\", LOG_ID + \"[attachHandlers] attachHandlers\");\n        that._favoriteEventHandler = new favoriteEventHandler_1.FavoriteEventHandler(that._xmpp, that);\n        that._favoriteHandlerToken = [\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_MANAGEMENT, that._favoriteEventHandler.onManagementMessageReceived),\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._favoriteEventHandler.MESSAGE_ERROR, that._favoriteEventHandler.onErrorMessageReceived)\n        ];\n        /*\n        if (this._xmppManagementHandler) { this.xmppService.deleteHandler(this._xmppManagementHandler); }\n        this._xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, \"message\", \"management\");\n\n         */\n        /*\n        //if reconnection, update the call-logs\n        if (that.started && that.lastTimestamp) {\n            $interval(function () {\n                that.getCallLogHistoryPage(that.lastTimestamp);\n            }, 1000, 1, true);\n        }\n        // */\n    }\n    reconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getServerFavorites();\n            //this.conversationService.favoriteService = this;\n            this.attachHandlers();\n        });\n    }\n    getServerFavorites() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let that = this;\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    this._rest.getServerFavorites().then((favorite) => __awaiter(this, void 0, void 0, function* () {\n                        that._logger.log(\"info\", LOG_ID + \"(getServerFavorites) favorite tab length : \", favorite.length);\n                        if (favorite) {\n                            let promises = favorite.map((data) => __awaiter(this, void 0, void 0, function* () {\n                                return this.createFavoriteObj(data.id, data.peerId, data.type);\n                            }));\n                            let favorites = yield Promise.all(promises);\n                            this.favorites = favorites.filter((favorite) => {\n                                return favorite !== null;\n                            });\n                            that._logger.log(\"info\", LOG_ID + `getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n                        }\n                        resolve(this.favorites);\n                    })).catch((err) => {\n                        that._logger.log(\"error\", LOG_ID + \"(getServerFavorites) error.\");\n                        that._logger.log(\"internalerror\", LOG_ID + \"(getServerFavorites) error : \", err);\n                        return reject(err);\n                    });\n                    /*\n    //            let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\n      //          let response = await this.$http({ method: \"GET\", url: url, headers: this.authService.getRequestHeader() });\n                let promises = response.data.data.map(async (data: any) => { return this.createFavorite(data.id, data.peerId, data.type); });\n                let favorites = await Promise.all(promises);\n                this.favorites = favorites.filter((favorite) => { return favorite !== null; });\n                this.$log.info(`getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n                return this.favorites;\n                */\n                }));\n            }\n            catch (error) {\n                let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;\n                this._logger.log(\"error\", LOG_ID + `[getServerFavorites] CATCH Error !!! `);\n                this._logger.log(\"internalerror\", LOG_ID + `CATCH Error !!! : ${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    addServerFavorite(peerId, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            try {\n                let favorite = yield that._rest.addServerFavorite(peerId, type);\n                that._logger.log(\"internal\", LOG_ID + `addServerFavorite(${peerId}, ${type}) -- SUCCESS`, favorite);\n                return favorite;\n            }\n            catch (error) {\n                let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;\n                that._logger.log(\"error\", LOG_ID + `[addServerFavorite] Error.`);\n                that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    removeServerFavorite(favoriteId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            try {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    that._rest.removeServerFavorite(favoriteId).then((favoriteDeleted) => __awaiter(this, void 0, void 0, function* () {\n                        that._logger.log(\"info\", LOG_ID + \"(removeServerFavorite) -- SUCCESS.\");\n                        that._logger.log(\"internal\", LOG_ID + \"(removeServerFavorite) -- SUCCESS : \", favoriteDeleted);\n                        resolve(favoriteDeleted);\n                    })).catch((err) => {\n                        that._logger.log(\"error\", LOG_ID + \"(removeServerFavorite) error.\");\n                        that._logger.log(\"internalerror\", LOG_ID + \"(removeServerFavorite) error : \", err);\n                        return reject(err);\n                    });\n                }));\n            }\n            catch (error) {\n                let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;\n                that._logger.log(\"error\", LOG_ID + `[removeServerFavorite] Error.`);\n                that._logger.log(\"internalerror\", LOG_ID + `${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    toggleFavorite(conversation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n            let type = conversation.contact ? (conversation.contact.isBot ? 'bot' : 'user') : 'room';\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n            if (!favorite) {\n                return this.addServerFavorite(peerId, type);\n            }\n            else {\n                return this.removeServerFavorite(favorite.id);\n            }\n        });\n    }\n    updateFavorites(conversation) {\n        let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n        if (favorite) {\n            conversation.isFavorite = true;\n            favorite.conv = conversation;\n        }\n    }\n    getFavorite(peerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n            //let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);\n            //return await convGetter;\n        });\n    }\n    createFavoriteObj(id, peerId, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            try {\n                let favorite = new Favorite_1.Favorite(id, peerId, type);\n                /*\n                // Get peer object\n                if (type === 'room') { favorite.room = this.roomService.getRoomById(peerId); }\n                else { favorite.contact = await this.contactService.getContactByDBId(peerId); }\n    \n                // Fetch eventual conversation\n                let convId: string = favorite.room ? favorite.room.jid : favorite.contact.jid;\n                let conv: any = this.conversationService.getConversationById(convId);\n                if (conv) { conv.isFavorite = true; favorite.conv = conv; }\n    \n                 */\n                return favorite;\n            }\n            catch (error) {\n                that._logger.log(\"error\", LOG_ID + `[createFavorite] Error.`);\n                that._logger.log(\"internalerror\", LOG_ID + `createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);\n                return null;\n            }\n        });\n    }\n    onXmppEvent(stanza) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try { /*\n                let stanzaElem = $(stanza);\n                let favoriteElem = stanzaElem.find(\"favorite\");\n                if (favoriteElem) {\n                    let id = favoriteElem.attr(\"id\");\n                    let type = favoriteElem.attr(\"type\");\n                    let peerId = favoriteElem.attr(\"peer_id\");\n                    let action = favoriteElem.attr(\"action\");\n    \n                    if (action === 'create') {\n                        let favorite: Favorite = this.favorites.find((favoriteConv: any) => { return favoriteConv.peerId === peerId; });\n                        if (!favorite) {\n                            favorite = await this.createFavorite(id, peerId, type);\n                            this.favorites.push(favorite);\n                            this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n                        }\n                    }\n    \n                    if (action === 'delete') {\n                        let index = this.favorites.findIndex((fav) => { return fav.id === id; });\n                        if (index !== -1) {\n                            let favorite = this.favorites[index];\n                            if (favorite.conv) { favorite.conv.isFavorite = false; }\n                            this.favorites.splice(index, 1);\n                            this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n                        }\n                    }\n                }\n                return true;\n                */\n            }\n            catch (error) {\n                return true;\n            }\n        });\n    }\n    /*private sendEvent(eventName: string, detail: any): void {\n        let event = new CustomEvent(eventName, { detail });\n        window.dispatchEvent(event);\n    }\n\n     */\n    /**\n     * @public\n     * @since 1.56\n     * @method fetchAllFavorites()\n     * @instance\n     * @description\n     *   Fetch all the Favorites from the server in a form of an Array\n     * @return {Conversation[]} An array of Favorite objects\n     */\n    fetchAllFavorites() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            return new Promise((resolve, reject) => {\n                that.getServerFavorites()\n                    .then(function (favorites) {\n                    that._logger.log(\"debug\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites`);\n                    that._logger.log(\"internal\", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites : `, favorites);\n                    resolve(favorites);\n                })\n                    .catch(function (err) {\n                    that._logger.log(\"error\", LOG_ID + `[fetchAllFavorites] :: Error.`);\n                    that._logger.log(\"internalerror\", LOG_ID + `[fetchAllFavorites] :: ERROR : `, err);\n                    return reject(err);\n                });\n            });\n        });\n    }\n    ;\n    /**\n     * @public\n     * @since 1.56\n     * @method createFavorite()\n     * @instance\n     * @description\n     *   Add conversation/bubble/bot to Favorites Array\n     * @param {String} id of the conversation/bubble\n     * @param {String} type of Favorite (can be 'user' or 'bubble')\n     * @return {Promise<Favorite>} A Favorite object\n     */\n    createFavorite(id, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            return new Promise((resolve, reject) => {\n                if (!id) {\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                }\n                if (!type) {\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                }\n                if (type !== \"bubble\" && type !== \"user\") {\n                    that._logger.log(\"debug\", LOG_ID + \"[createFavorite] :: Error: type should be set to \\\"user\\\" or \\\"bubble\\\"\");\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                }\n                if (type === \"bubble\") {\n                    type = \"room\";\n                }\n                that.addServerFavorite(id, type).then((favorite) => {\n                    that._logger.log(\"debug\", LOG_ID + `[createFavorite] :: Successfully added ${type} to favorites`);\n                    return resolve(favorite);\n                }).catch(err => {\n                    that._logger.log(\"error\", LOG_ID + \"[createFavorite] :: Error.\");\n                    that._logger.log(\"internalerror\", LOG_ID + \"[createFavorite] :: Error : \", err);\n                    return reject(err);\n                });\n            });\n        });\n    }\n    ;\n    /**\n     * @public\n     * @since 1.56\n     * @method deleteFavorite()\n     * @instance\n     * @description\n     *   Delete conversation/bubble/bot from Favorites Array\n     * @param {String} id of the Favorite item\n     * @return {Favorite[]} A Favorite object\n     */\n    deleteFavorite(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            return new Promise((resolve, reject) => {\n                if (!id) {\n                    that._logger.log(\"debug\", LOG_ID + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n                    return reject(\"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n                }\n                that.removeServerFavorite(id)\n                    .then((favDeleted) => {\n                    return resolve(favDeleted);\n                })\n                    .catch(err => {\n                    that._logger.log(\"error\", LOG_ID + \"[deleteFavorite] :: Error.\");\n                    that._logger.log(\"internalerror\", LOG_ID + \"[deleteFavorite] :: Error : \", err);\n                    return reject(err);\n                });\n            });\n        });\n    }\n    // ******************* Event XMPP parsed in favoriteEventHandler ***************\n    onFavoriteCreated(fav) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === fav.peerId; });\n            if (!favorite) {\n                favorite = yield this.createFavoriteObj(fav.id, fav.peerId, fav.type);\n                this.favorites.push(favorite);\n                //that._logger.log(\"internal\", LOG_ID + \"[onFavoriteCreated] send event : \", favorite);\n                //this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n                that._eventEmitter.emit(\"evt_internal_favoritecreated\", favorite);\n            }\n        });\n    }\n    onFavoriteDeleted(fav) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            let index = this.favorites.findIndex((fav) => { return fav.id === fav.id; });\n            if (index !== -1) {\n                let favorite = this.favorites[index];\n                if (favorite.conv) {\n                    favorite.conv.isFavorite = false;\n                }\n                this.favorites.splice(index, 1);\n                //that._logger.log(\"debug\", LOG_ID + \"[onFavoriteDeleted] send event : \", { favoriteId: favorite.id });\n                //this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n                that._eventEmitter.emit(\"evt_internal_favoritedeleted\", fav);\n            }\n        });\n    }\n};\nFavoritesService = __decorate([\n    Utils_1.logEntryExit(LOG_ID),\n    Utils_2.isStarted([])\n    /**\n    * @module\n    * @name FavoritesService\n     * @version 1.67.1 \n     * @public\n    * @description\n    *      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\n    *      The main methods and events proposed in that service allow to: <br>\n    *      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\n    *      - Retrieve all information linked to that Favorite, <br>\n    */\n], FavoritesService);\nexports.FavoritesService = FavoritesService;\nmodule.exports.FavoritesService = FavoritesService;\n//# sourceMappingURL=FavoritesService.js.map"]},"metadata":{},"sourceType":"script"}