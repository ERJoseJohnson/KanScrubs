{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\n\nconst Utils = require(\"../../common/Utils\");\n\nconst GenericHandler = require(\"./genericHandler\"); //const Conversation = require(\"../../common/models/Conversation\");\n//const Call = require(\"../../common/models/Call\");\n\n\nconst Call_1 = require(\"../../common/models/Call\");\n\nconst Utils_1 = require(\"../../common/Utils\");\n\nconst NameUpdatePrio = require(\"../../common/models/Contact\").NameUpdatePrio;\n\nconst xml = require(\"@xmpp/xml\");\n\nconst PromiseQueue = require(\"../../common/promiseQueue\"); //const config = require(\"../../config/config\");\n\n\nconst config_1 = require(\"../../config/config\");\n\nconst LOG_ID = \"XMPP/HNDL/TEL - \";\n/*********************************************************************/\n\n/** PRIVATE CONSTRUCTOR                                             **/\n\n/*********************************************************************/\n\nconst CallFailureLabels = {\n  \"DESTNOTOBTAINABLE\": \"outOfService\",\n  \"DONOTDISTURB\": \"dnd\",\n  \"TRUNKSBUSY\": \"trunksbusy\"\n};\nlet TelephonyEventHandler = class TelephonyEventHandler extends GenericHandler {\n  constructor(xmppService, telephonyService, contactService, profileService) {\n    super(xmppService);\n    let that = this;\n    this.MESSAGE = \"jabber:client.message\";\n    this.IQ_RESULT = \"jabber:client.iq.result\";\n    this.IQ_ERROR = \"jabber:client.iq.error\";\n    /*this.MESSAGE_GROUPCHAT = \"jabber:client.message.groupchat\";\r\n    this.MESSAGE_WEBRTC = \"jabber:client.message.webrtc\";\r\n    this.MESSAGE_MANAGEMENT = \"jabber:client.message.management\";\r\n    this.MESSAGE_ERROR = \"jabber:client.message.error\";\r\n    this.MESSAGE_HEADLINE = \"jabber:client.message.headline\";\r\n    this.MESSAGE_CLOSE = \"jabber:client.message.headline\";\r\n    */\n\n    this.telephonyService = telephonyService;\n    this.contactService = contactService;\n    this.promiseQueue = PromiseQueue.createPromiseQueue(that.logger);\n    this._profiles = profileService;\n\n    this.onIqResultReceived = (msg, stanza) => {\n      let children = stanza.children;\n      children.forEach(node => {\n        switch (node.getName()) {\n          case \"pbxagentstatus\":\n            that.onIqGetPbxAgentStatusReceived(stanza, node);\n            break;\n\n          case \"default\":\n            //that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) not managed - 'stanza'\", node.getName());\n            break;\n\n          default: //that\n          //  .logger\n          //.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) child not managed for iq - 'stanza'\", node.getName());\n\n        }\n      });\n    }; // Private methods\n\n\n    this.onIqGetPbxAgentStatusReceived = (stanza, node) => {\n      let pbxagentstatus = {\n        \"phoneapi\": \"\",\n        \"xmppagent\": \"\",\n        \"version\": \"\"\n      };\n      let subchildren = node.children;\n      subchildren.forEach(function (item) {\n        if (typeof item === \"object\") {\n          let itemName = item.getName();\n\n          if (itemName) {\n            pbxagentstatus[itemName] = item.text();\n          }\n        }\n      });\n\n      if (pbxagentstatus.version) {\n        let phoneApi = pbxagentstatus.phoneapi;\n        let xmppAgent = pbxagentstatus.xmppagent;\n        let agentVersion = pbxagentstatus.version;\n        let agentStatus = {\n          \"phoneApi\": phoneApi,\n          \"xmppAgent\": xmppAgent,\n          \"agentVersion\": agentVersion\n        };\n        that.logger.log(\"info\", LOG_ID + \"(onIqGetPbxAgentStatusReceived)  - send rainbow_onpbxagentstatusreceived 'agentStatus'\", agentStatus);\n        that.eventEmitter.emit(\"rainbow_onpbxagentstatusreceived\", agentStatus);\n      }\n    };\n\n    this.onMessageReceived = (msg, stanza) => {\n      that.logger.log(\"internal\", LOG_ID + \"(onMessageReceived) _entering_ : \", msg, stanza);\n\n      try {\n        let stanzaElem = stanza; //let that = this;\n        // Ignore \"Offline\" message\n\n        let delay = stanzaElem.getChild(\"delay\");\n\n        if (delay && delay.text() === \"Offline Storage\") {\n          return true;\n        }\n\n        let from = stanza.attrs.from;\n        let to = stanza.attrs.to; // Treat WEBRTC Events\n\n        let actionElmPropose = stanzaElem.getChild(\"propose\");\n\n        if (actionElmPropose !== undefined) {\n          this.onProposeMessageReceived(actionElmPropose, from);\n          return true;\n        } // Treat Telephony (3PCC) Events\n\n\n        let actionElm = stanzaElem.getChild(\"callservice\");\n\n        if (actionElm === undefined) {\n          return true;\n        }\n\n        let actionElem = null;\n        let actionElemName = null;\n\n        for (let i = 0; i < actionElm.children.length; i++) {\n          if (!actionElemName) {\n            if (actionElm.children[i].name) {\n              actionElemName = actionElm.children[i].name.toLowerCase();\n              actionElem = actionElm.children[i];\n            }\n          }\n        }\n\n        if (actionElemName) {\n          that.logger.log(\"debug\", LOG_ID + \"(onMessageReceived) \", that.logger.colors.debug(\"-- event -- \", actionElemName)); // Handle the event\n\n          switch (actionElemName) {\n            case \"initiated\":\n              this.promiseQueue.add(function () {\n                return that.onInitiatedEvent(actionElem);\n              });\n              break;\n            // */\n\n            case \"originated\":\n              this.promiseQueue.add(function () {\n                return that.onOriginatedEvent(actionElem);\n              });\n              break;\n            // */\n\n            case \"delivered\":\n              this.promiseQueue.add(function () {\n                return that.onDeliveredEvent(actionElem);\n              });\n              break;\n\n            case \"established\":\n              this.promiseQueue.add(function () {\n                return that.onEstablishedEvent(actionElem);\n              });\n              break;\n\n            case \"retrievecall\":\n              this.promiseQueue.add(function () {\n                return that.onRetrieveCallEvent(actionElem);\n              });\n              break;\n\n            case \"queued\":\n              this.promiseQueue.add(function () {\n                return that.onQueuedEvent(actionElem);\n              });\n              break;\n\n            case \"holdcall\":\n            case \"held\":\n              this.promiseQueue.add(function () {\n                return that.onHeldEvent(actionElem);\n              });\n              break;\n            // OLD SYNTAX TO BE REMOVED\n\n            case \"diverted\":\n              this.promiseQueue.add(function () {\n                return that.onDivertedEvent(actionElem);\n              });\n              break;\n\n            case \"transfercall\":\n            case \"transferred\":\n              this.promiseQueue.add(function () {\n                return that.onTransferEvent(actionElem);\n              });\n              break;\n            // OLD SYNTAX TO BE REMOVED\n\n            case \"conferenced\":\n              this.promiseQueue.add(function () {\n                return that.onConferenceEvent(actionElem);\n              });\n              break;\n\n            case \"connectioncleared\":\n              this.promiseQueue.add(function () {\n                return that.onClearCallEvent(actionElem);\n              });\n              break;\n\n            case \"failed\":\n              this.promiseQueue.add(function () {\n                return that.onFailCallEvent(actionElem);\n              });\n              break;\n\n            case \"messaging\":\n              this.promiseQueue.add(function () {\n                return that.onVoiceMessageEvent(actionElem);\n              });\n              break;\n\n            case \"updatecall\":\n              this.promiseQueue.add(function () {\n                return that.onUpDateCallEvent(actionElem);\n              });\n              break;\n\n            case \"forwarded\":\n              this.promiseQueue.add(function () {\n                return that.onCallForwardedEvent(actionElem);\n              });\n              break;\n\n            case \"nomadicstatus\":\n              this.promiseQueue.add(function () {\n                return that.onNomadicStatusEvent(actionElem);\n              });\n              break;\n            // */\n\n            default:\n              that.logger.log(\"internal\", LOG_ID + \"(onMessageReceived) untreated actionElemName : \", actionElemName);\n          } // */\n\n\n          return true;\n        } else {\n          that.logger.log(\"error\", LOG_ID + \"(onMessageReceived) -- failure -- no name found in callservice children.\");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onMessageReceived) -- failure -- no name found in callservice children : \", stanzaElem);\n        }\n      } catch (error) {\n        that.logger.log(\"error\", LOG_ID + \"(onMessageReceived) CATCH Error !!! -- failure -- \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onMessageReceived) CATCH Error !!! -- failure -- : \", error); //return true;\n      }\n\n      that.logger.log(\"debug\", LOG_ID + \"(onMessageReceived) _exiting_\");\n      return true;\n    };\n\n    this.onProposeMessageReceived = (node, from) => __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"internal\", LOG_ID + \"(onProposeMessageReceived) node - \", node);\n      let descriptionElm = node.getChild(\"description\");\n      let media = descriptionElm.attrs.media;\n      let contact = yield that.contactService.getContactByJid(from);\n      that.eventEmitter.emit(\"evt_internal_propose\", {\n        contact,\n        media\n      });\n    });\n    /*********************************************************************/\n\n    /** INITIATED CALL STUFF                                           **/\n\n    /*********************************************************************/\n\n\n    this.onInitiatedEvent = function (initiatedElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onInitiatedEvent) _entering_ : \", initiatedElem);\n      return that.getCall(initiatedElem).then(function (call) {\n        try {\n          /*if (call.status === Call.Status.QUEUED_INCOMING) {\r\n              return Promise.resolve();\r\n          } // */\n          let deviceState = initiatedElem.attr(\"deviceState\"); //let devicetype = initiatedElem.attr(\"devicetype\");\n          //let callId = initiatedElem.attr(\"callId\");\n\n          if (deviceState && deviceState === \"LCI_INITIATED\") {\n            call.setStatus(Call_1.Call.Status.DIALING); // Update call info\n            //that.logger.log(\"internal\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\n\n            that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n          }\n\n          return Promise.resolve();\n        } catch (error) {\n          let errorMessage = \"onInitiatedEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onInitiatedEvent) Catch Error !!! \");\n          that.logger.log(\"error\", LOG_ID + \"(onInitiatedEvent) Catch Error !!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** ORIGINATED CALL STUFF                                           **/\n\n    /*********************************************************************/\n\n\n    this.onOriginatedEvent = function (originatedElem) {\n      that.logger.log(\"debug\", LOG_ID + \"(onOriginatedEvent) _entering_ : \", originatedElem);\n      return that.getCall(originatedElem).then(function (call) {\n        try {\n          let jid = originatedElem.attr(\"endpointIm\");\n          let phoneNumber = originatedElem.attr(\"endpointTel\");\n          let currentCalled = {\n            contactPhoneNumber: \"\",\n            contact: call.contact,\n            participantsPhoneNumbers: null,\n            participants: null\n          }; // PCG has some info\n\n          if (jid || phoneNumber) {\n            currentCalled.contactPhoneNumber = phoneNumber ? phoneNumber : \"\";\n          } // Unknown user\n          else if (call.contact && call.contact.temp) {\n              currentCalled.contactPhoneNumber = call.contact._id; //that is the only current known phoneNumber\n            }\n\n          call.setCurrentCalled(currentCalled);\n          /*let deviceState = call.deviceState;\r\n          //let devicetype = initiatedElem.attr(\"devicetype\");\r\n          //let callId = initiatedElem.attr(\"callId\");\r\n          if (deviceState && deviceState === \"LCI_CONNECTED\") {\r\n              call.setStatus(Call.Status.DIALING );\r\n              // Update call info\r\n              that.logger.log(\"debug\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\r\n              that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n          } */\n\n          return Promise.resolve();\n        } catch (error) {\n          let errorMessage = \"onOriginatedEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onOriginatedEvent) Catch Error !!! \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onOriginatedEvent) Catch Error !!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** DELIVERED STUFF                                                 **/\n\n    /*********************************************************************/\n\n\n    this.onDeliveredEvent = function (deliveredElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onDeliveredEvent) _entering_ : \", deliveredElem); //let that = this;\n\n      return that.getCall(deliveredElem).then(function (call) {\n        try {\n          if (call.status === Call_1.Call.Status.QUEUED_INCOMING) {\n            return Promise.resolve();\n          }\n\n          let type = deliveredElem.attr(\"type\");\n          let jid = deliveredElem.attr(\"endpointIm\");\n          let phoneNumber = deliveredElem.attr(\"endpointTel\"); // Update call info\n\n          call.setStatus(type === \"outgoing\" ? Call_1.Call.Status.RINGING_OUTGOING : Call_1.Call.Status.RINGING_INCOMING);\n          call.startDate = null;\n          call.vm = false;\n          that.logger.log(\"internal\", LOG_ID + \"(onDeliveredEvent) call : \", call); // Update contact info if necessary\n\n          return that.updateCallContact(jid, phoneNumber, \"delivered\", call);\n        } catch (error) {\n          let errorMessage = \"onDeliveredEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onDeliveredEvent) Catch Error !!! \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onDeliveredEvent) Catch Error !!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** ESTABLISHED STUFF                                               **/\n\n    /*********************************************************************/\n\n\n    this.onEstablishedEvent = function (establishedElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) _entering_ : \", establishedElem); //let that = this;\n\n      return that.getCall(establishedElem).then(function (call) {\n        try {\n          let jid = establishedElem.attr(\"endpointIm\");\n          let phoneNumber = establishedElem.attr(\"endpointTel\"); // Call already exists and IS NOT a conference, update contact info if necessary\n\n          if (call.contact && call.contact._id) {\n            call.setStatus(Call_1.Call.Status.ACTIVE); // Update contact info as necessary\n\n            return that.updateCallContact(jid, phoneNumber, \"established\", call);\n          } // Call already exists and IS a conference, update contact info if necessary\n          else if (call.participants && call.participants.length > 0) {\n              //recover former matching contact from participants\n              let contactRecovered = null;\n\n              for (let i = 0; i < call.participants.length && !contactRecovered; i++) {\n                if (call.participants[i].id === jid) {\n                  contactRecovered = call.participants[i];\n                } else if (call.currentCalled.participantsPhoneNumbers && call.currentCalled.participantsPhoneNumbers.length > 0 && call.currentCalled.participantsPhoneNumbers[i] === phoneNumber) {\n                  contactRecovered = call.participants[i];\n                }\n              } //clean former conf struct & update contact\n\n\n              call.participants = [];\n              call.isConference = false;\n              let currentCalled = call.getCurrentCalled();\n\n              if (contactRecovered) {\n                call.setContact(contactRecovered);\n                call.setStatus(Call_1.Call.Status.ACTIVE);\n                currentCalled = {\n                  contactPhoneNumber: phoneNumber,\n                  contact: contactRecovered\n                };\n                call.setCurrentCalled(currentCalled); //that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) send evt_internal_callupdated \", call);\n\n                that.eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n              } else {\n                // no matching contact strange but go ahead ...\n                if (!jid && !phoneNumber) {\n                  phoneNumber = \"****\";\n                }\n\n                return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n                  call.setContact(contact);\n                  call.setStatus(Call_1.Call.Status.ACTIVE);\n                  currentCalled = {\n                    contactPhoneNumber: phoneNumber,\n                    contact: contact\n                  };\n                  call.setCurrentCalled(currentCalled); //                                    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n                  //that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) send evt_internal_callupdated \", call);\n\n                  that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n                  return Promise.resolve();\n                });\n              }\n            } else {\n              that.logger.log(\"debug\", LOG_ID + \"(onEstablishedEvent) Neither contact, nor participant found!\");\n            }\n\n          return Promise.resolve();\n        } catch (error) {\n          let errorMessage = \"onEstablishedEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onEstablishedEvent) Catch Error!!! \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onEstablishedEvent) Catch Error!!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** RETRIEVE CALL STUFF                                             **/\n\n    /*********************************************************************/\n\n\n    this.onRetrieveCallEvent = function (retrieveElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onRetrieveCallEvent) _entering_ : \", retrieveElem);\n      return that.getCall(retrieveElem).then(function (call) {\n        call.setStatus(Call_1.Call.Status.ACTIVE); //that.logger.log(\"internal\", LOG_ID + \"(onRetrieveCallEvent) send evt_internal_callupdated \", call);\n\n        that.eventEmitter.emit(\"evt_internal_callupdated\", call); //    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** CLEAR CALL STUFF                                                **/\n\n    /*********************************************************************/\n\n\n    this.onClearCallEvent = function (clearElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onClearCallEvent) _entering_ : \", clearElem); //let that = this;\n\n      return that.getCall(clearElem).then(call => __awaiter(this, void 0, void 0, function* () {\n        if (call.status !== Call_1.Call.Status.ERROR) {\n          call.setStatus(Call_1.Call.Status.UNKNOWN);\n          let cause = clearElem.attr(\"cause\");\n          let deviceState = clearElem.attr(\"deviceState\");\n          call.cause = cause;\n          call.deviceState = deviceState; //that.logger.log(\"internal\", LOG_ID + \"(onClearCallEvent) send evt_internal_callupdated \", call);\n\n          that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n          yield that.telephonyService.clearCall(call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n        }\n      })); // */\n    };\n    /*********************************************************************/\n\n    /** HOLD CALL STUFF                                                 **/\n\n    /*********************************************************************/\n\n\n    this.onHeldEvent = function (heldElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onHeldEvent) _entering_ : \", heldElem);\n      return that.getCall(heldElem).then(function (call) {\n        try {\n          let connectionId = heldElem.attr(\"callId\");\n\n          if (!connectionId) {\n            connectionId = heldElem.attr(\"heldCallId\");\n          } // TODO: WHY and WHEN\n\n\n          let callDeviceId = Call_1.Call.getDeviceIdFromConnectionId(call.connectionId);\n          let holdDeviceId = Call_1.Call.getDeviceIdFromConnectionId(connectionId);\n\n          if (callDeviceId === holdDeviceId) {\n            call.setStatus(Call_1.Call.Status.HOLD);\n          } // Same callId but different equipmentId (We receive equipment id of user who put us in held)\n          else {\n              call.setStatus(Call_1.Call.Status.PUT_ON_HOLD);\n            } //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n          //that.logger.log(\"internal\", LOG_ID + \"(onHeldEvent) send evt_internal_callupdated \", call);\n\n\n          that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n          return Promise.resolve();\n        } catch (error) {\n          let errorMessage = \"onHeldEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onHeldEvent) Catch Error!!! \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onHeldEvent) Catch Error!!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** QUEUED STUFF                                                    **/\n\n    /*********************************************************************/\n\n\n    this.onQueuedEvent = function (queuedElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onQueuedEvent) _entering_ : \", queuedElem); //let that = this;\n\n      let cause = queuedElem.attr(\"cause\");\n\n      if (cause === \"PARK\") {\n        that.logger.log(\"warn\", LOG_ID + \"(onQueuedEvent) - ignore PARK cause\");\n        return Promise.resolve();\n      }\n\n      if (cause === \"NEWCALL\") {\n        that.logger.log(\"warn\", LOG_ID + \"(onQueuedEvent) - ignore NEWCALL cause\");\n        return Promise.resolve();\n      }\n\n      return that.getCall(queuedElem).then(function (call) {\n        try {\n          let type = queuedElem.attr(\"type\");\n          let jid = queuedElem.attr(\"endpointIm\");\n          let phoneNumber = queuedElem.attr(\"endpointTel\");\n          let status = type === \"outgoing\" ? Call_1.Call.Status.QUEUED_OUTGOING : Call_1.Call.Status.QUEUED_INCOMING;\n          call.setStatus(status);\n          call.startDate = null;\n          call.vm = false; // Update contact info if necessary\n\n          return that.updateCallContact(jid, phoneNumber, \"queued\", call);\n        } catch (error) {\n          let errorMessage = \"onQueuedEvent -- \" + error.message;\n          that.logger.log(\"error\", LOG_ID + \"(onHeldEvent) Catch Error!!! \");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onHeldEvent) Catch Error!!! : \", errorMessage);\n          return Promise.reject(new Error(errorMessage));\n        }\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** DIVERTED STUFF                                                  **/\n\n    /*********************************************************************/\n\n\n    this.onDivertedEvent = divertedElem => __awaiter(this, void 0, void 0, function* () {\n      that.logger.log(\"internal\", LOG_ID + \"(onDivertedEvent) _entering_ : \", divertedElem);\n      let oldConnectionId = divertedElem.attr(\"oldCallId\");\n      let oldCallId = Call_1.Call.getIdFromConnectionId(oldConnectionId);\n      let call = that.telephonyService.getCallFromCache(oldCallId);\n\n      if (!call) {\n        that.logger.log(\"warn\", LOG_ID + \"(onDivertedEvent) - receive divertedEvent on unknown call --- ignored\");\n        return Promise.resolve();\n      }\n\n      yield that.telephonyService.clearCall(call); //            $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n      //that.logger.log(\"internal\", LOG_ID + \"(onDivertedEvent) send evt_internal_callupdated \", call);\n\n      that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n      return Promise.resolve(); // */\n    });\n    /*********************************************************************/\n\n    /** TRANSFER STUFF                                                  **/\n\n    /*********************************************************************/\n\n\n    this.onTransferEvent = function (transferElem) {\n      return __awaiter(this, void 0, void 0, function* () {\n        that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) _entering_ : \", transferElem); // let that = this;\n        // Extract transfert call parameters\n\n        let activeConnectionId = transferElem.attr(\"activeCallId\");\n        let heldConnectionId = transferElem.attr(\"heldCallId\");\n        let newConnectionId = transferElem.attr(\"newCallId\"); // Get active call\n\n        let activeCallId = Call_1.Call.getIdFromConnectionId(activeConnectionId);\n        let activeCall = that.telephonyService.getCallFromCache(activeCallId);\n\n        if (heldConnectionId) {\n          that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) heldconnectionId found \", heldConnectionId); // Get the held call\n\n          let heldCallId = Call_1.Call.getIdFromConnectionId(heldConnectionId);\n          let heldCall = that.telephonyService.getCallFromCache(heldCallId); // Release both calls (active and held)\n\n          if (heldCall) {\n            heldCall.setStatus(Call_1.Call.Status.UNKNOWN); //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", heldCall);\n\n            that.eventEmitter.emit(\"evt_internal_callupdated\", heldCall);\n            yield that.telephonyService.clearCall(heldCall);\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no  heldCall found\");\n          }\n\n          if (activeCall) {\n            activeCall.setStatus(Call_1.Call.Status.UNKNOWN); //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", activeCall);\n\n            that.eventEmitter.emit(\"evt_internal_callupdated\", activeCall);\n            yield that.telephonyService.clearCall(activeCall);\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no activeCall found\");\n          } // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", heldCall);\n          // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", activeCall);\n\n        }\n\n        if (newConnectionId) {\n          that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) newConnectionId found \", newConnectionId);\n          let jid = transferElem.attr(\"newEndpointIm\");\n          let phoneNumber = transferElem.attr(\"newEndpointTel\");\n          let deviceState = transferElem.attr(\"deviceState\");\n\n          if (!deviceState) {\n            deviceState = transferElem.attr(\"deviceStatus\");\n          } // TO BE REMOVED\n\n\n          if (activeCall) {\n            // Release current call\n            activeCall.setStatus(Call_1.Call.Status.UNKNOWN); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", activeCall);\n            //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", activeCall);\n\n            that.eventEmitter.emit(\"evt_internal_callupdated\", activeCall);\n            yield that.telephonyService.clearCall(activeCall);\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no activeCall found\");\n          }\n\n          if (!jid && !phoneNumber) {\n            //secret identity\n            phoneNumber = \"****\";\n          }\n\n          let deviceType = transferElem.find(\"deviceType\");\n          return that.getOrCreateCall(newConnectionId, jid, deviceType, phoneNumber).then(function (newCall) {\n            let globalCallId = transferElem.attr(\"globalCallId\");\n\n            if (globalCallId) {\n              newCall.setGlobalCallId(globalCallId);\n            }\n\n            let correlatorData = transferElem.attr(\"correlatorData\");\n\n            if (correlatorData) {\n              newCall.correlatorData = correlatorData;\n            }\n\n            if (deviceState && deviceState === \"LCI_ALERTING\") {\n              newCall.setStatus(Call_1.Call.Status.RINGING_INCOMING);\n            } else {\n              newCall.setStatus(Call_1.Call.Status.ACTIVE);\n            } // Update contact info if necessary\n\n\n            return that.updateCallContact(jid, phoneNumber, \"transfercall\", newCall);\n          });\n        } else {\n          return Promise.resolve();\n        } // */\n\n      });\n    };\n    /*********************************************************************/\n\n    /** CONFERENCE STUFF                                                **/\n\n    /*********************************************************************/\n\n\n    this.onConferenceEvent = function (conferencedElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) _entering_ : \", conferencedElem); //let that = this;\n      // Get connectionsIds\n\n      let primaryOldConnectionId = conferencedElem.getChild(\"primaryOldCallId\") ? conferencedElem.getChild(\"primaryOldCallId\").getText() : \"\";\n      let secondaryOldConnectionId = conferencedElem.getChild(\"secondaryOldCallId\") ? conferencedElem.getChild(\"secondaryOldCallId\").getText() : \"\";\n      let newConnectionId = conferencedElem.getChild(\"newCallId\") ? conferencedElem.getChild(\"newCallId\").getText() : \"\";\n      that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) primaryOldConnectionId - \", primaryOldConnectionId);\n      that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) secondaryOldConnectionId - \", secondaryOldConnectionId);\n      that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) newConnectionId - \", newConnectionId); // Extract callIds\n\n      let primaryOldCallId = Call_1.Call.getIdFromConnectionId(primaryOldConnectionId);\n      let secondaryOldCallId = Call_1.Call.getIdFromConnectionId(secondaryOldConnectionId);\n      that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) primaryOldCallId - \", primaryOldCallId);\n      that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) secondaryOldCallId - \", secondaryOldCallId); // Get current calls\n\n      let primaryOldCall = that.telephonyService.getCallFromCache(primaryOldCallId);\n      let secondaryOldCall = that.telephonyService.getCallFromCache(secondaryOldCallId); // Prepare participant promises\n\n      let confParticipants = [];\n      let participantPromises = [];\n      let confParticipantsPhoneNumbers = [];\n      let confContactsInfos = [];\n      let participantsElmt = conferencedElem.getChild(\"participants\");\n      that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) participantsElmt - \", participantsElmt);\n      let participantElmts = participantsElmt.getChildren(\"participant\");\n      that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) participantElmts - \", participantElmts);\n      participantElmts.forEach(function (participantElem) {\n        //let participantElem = angular.element(this);\n        let endpointTel = participantElem.find(\"endpointTel\").getText();\n        that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) endpointTel - \", endpointTel);\n        let endpointIm = participantElem.find(\"endpointIm\").getText();\n        that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) endpointIm - \", endpointIm);\n        let callId = participantElem.find(\"callId\").getText();\n        that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) callId - \", callId);\n        let role = participantElem.find(\"role\").getText();\n        that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) role - \", role);\n        let contactInfos = {\n          endpointTel: endpointTel,\n          endpointIm: endpointIm,\n          callId: callId,\n          role: role\n        };\n        confContactsInfos.push(contactInfos);\n\n        if (!(endpointIm && contactService.isUserContactJid(endpointIm))) {\n          participantPromises.push(new Promise(function (resolve, reject) {\n            if (!endpointIm && !endpointTel) {\n              endpointTel = \"****\";\n            } //if no endpointIm try to extract contact info from primary or secondary calls\n\n\n            if (!endpointIm && primaryOldCall && primaryOldCall.contact && primaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\n              confParticipants.push(primaryOldCall.contact);\n              confParticipantsPhoneNumbers.push(endpointTel);\n              resolve();\n            } else if (!endpointIm && secondaryOldCall && secondaryOldCall.contact && secondaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\n              confParticipants.push(secondaryOldCall.contact);\n              confParticipantsPhoneNumbers.push(endpointTel);\n              resolve();\n            } else {\n              contactService.getOrCreateContact(endpointIm, endpointTel).then(function (contact) {\n                //manage Outlook Call Party identification\n\n                /*  let centralizedService = $injector.get(\"centralizedService\");\r\n                  centralizedService.outlook.updateContactFromOutlookInfos(contact, endpointTel)\r\n                      .then(\r\n                          function successCallback(updateStatus) {\r\n                              if (updateStatus) {\r\n                                  that.logger.log(\"debug\", LOG_ID + \" on conferenced, update from outlook for contact :\" + contact.displayNameMD5);\r\n                                  //that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\r\n                              } else {\r\n                                  that.logger.log(\"debug\", LOG_ID + \"on conferenced, no update from outlook for contact :\" + contact.displayNameMD5);\r\n                              }\r\n                          },\r\n                          function errorCallback() {\r\n                              that.logger.log(\"debug\", LOG_ID + \"on conferenced, no Outlook search available\");\r\n                          }\r\n                      )\r\n                      .finally(function () {\r\n                      */\n                confParticipants.push(contact);\n                confParticipantsPhoneNumbers.push(endpointTel);\n                resolve(); //});\n              }).catch(function (error) {\n                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) Impossible to get contact - \");\n                that.logger.log(\"internaldebug\", LOG_ID + \"(onConferenceEvent) Impossible to get contact - : \", error.message);\n                reject();\n              });\n            }\n          }));\n        }\n      }); // Get participants asynchronously\n\n      return Promise.all(participantPromises).then(() => __awaiter(this, void 0, void 0, function* () {\n        // Release previous calls\n        if (primaryOldCall) {\n          primaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\n          that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) release primaryOldCall - \", primaryOldCall);\n          primaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN); //let cause = clearElem.attr(\"cause\");\n          //let deviceState = clearElem.attr(\"deviceState\");\n          //call.cause = cause;\n          //call.deviceState = deviceState;\n          //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", primaryOldCall);\n\n          that.eventEmitter.emit(\"evt_internal_callupdated\", primaryOldCall);\n          yield that.telephonyService.clearCall(primaryOldCall); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", primaryOldCall);\n        }\n\n        if (secondaryOldCall) {\n          secondaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\n          that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) release secondaryOldCall - \", secondaryOldCall);\n          secondaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN); //let cause = clearElem.attr(\"cause\");\n          //let deviceState = clearElem.attr(\"deviceState\");\n          //call.cause = cause;\n          //call.deviceState = deviceState;\n          //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", secondaryOldCall);\n\n          that.eventEmitter.emit(\"evt_internal_callupdated\", secondaryOldCall);\n          yield that.telephonyService.clearCall(secondaryOldCall); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", secondaryOldCall);\n        } // Create the new conference call\n\n\n        let newConferenceCall = yield that.createConferenceCall(newConnectionId, confParticipants); //update currentcalled structure\n\n        let currentCalled = newConferenceCall.getCurrentCalled();\n        currentCalled.participants = confParticipants;\n        currentCalled.participantsPhoneNumbers = confParticipantsPhoneNumbers;\n        newConferenceCall.setCurrentCalled(currentCalled);\n        newConferenceCall.setStatus(Call_1.Call.Status.ACTIVE);\n        newConferenceCall.setDeviceType();\n        that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) create newConferenceCall - \", newConferenceCall);\n        that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) create newConferenceCall - stored :\", that.telephonyService.getCallFromCache(newConferenceCall.id)); //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", newConferenceCall);\n\n        let conferenceInfos = {\n          primaryOldCall: primaryOldCall,\n          secondaryOldCall: secondaryOldCall,\n          newConferenceCall: newConferenceCall,\n          participants: confContactsInfos\n        };\n        that.eventEmitter.emit(\"evt_internal_conferenced\", conferenceInfos);\n        that.eventEmitter.emit(\"evt_internal_callupdated\", newConferenceCall); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", newConferenceCall);\n      })); // */\n    };\n    /*********************************************************************/\n\n    /** VOICE MESSAGE STUFF                                            **/\n\n    /*********************************************************************/\n\n\n    this.onVoiceMessageEvent = function (messagingElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onVoiceMessageEvent) _entering_ : \", messagingElem); // Ignore forbidden requests\n\n      if (!that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_VOICE_MAIL)) {\n        that.logger.log(\"debug\", LOG_ID + \"(onVoiceMessageEvent) feature not enabled => IGNORED event\");\n        return Promise.resolve();\n      } // Look for a voiceMessageCounter child\n\n\n      let voiceMessageCounterValue = messagingElem.getChild(\"voiceMessageCounter\").text();\n\n      if (voiceMessageCounterValue) {\n        let ct = Number(voiceMessageCounterValue);\n\n        if (Number.isInteger(ct) && ct >= 0) {\n          that.telephonyService.voiceMail.setVMCounter(ct);\n          that.telephonyService.voiceMail.setVMFlag(ct > 0);\n          that.telephonyService.voiceMail.setInfoMsg(\"\"); //$rootScope.$broadcast(\"ON_VOICE_MESSAGE_UPDATE_EVENT\", ct);\n          //that.logger.log(\"internal\", LOG_ID + \"(onVoiceMessageEvent) send evt_internal_voicemessageupdated \", ct);\n\n          that.eventEmitter.emit(\"evt_internal_voicemessageupdated\", ct);\n        }\n      } // No voiceMessageCounter child look for voiceMessageWaiting child\n\n\n      let voiceMessageWaitingValue = \"\";\n      let voiceMessageWaiting = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(messagingElem, \"voiceMessageWaiting\");\n\n      if (voiceMessageWaiting) {\n        voiceMessageWaitingValue = voiceMessageWaiting.text();\n\n        if (voiceMessageWaitingValue === \"changed\") {\n          return that.telephonyService.getVoiceMessageCounter();\n        }\n      }\n\n      return Promise.resolve(); // */\n    };\n    /*********************************************************************/\n\n    /** UPDATECALL STUFF                                                **/\n\n    /*********************************************************************/\n\n\n    this.onUpDateCallEvent = function (updatecallElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) _entering_ : \", updatecallElem);\n      return that.getCall(updatecallElem).then(function (call) {\n        let jid = updatecallElem.attr(\"endpointIm\");\n        let phoneNumber = updatecallElem.attr(\"endpointTel\");\n        let firstName = \"\";\n        let lastName = \"\";\n        let identity = updatecallElem.getChild(\"identity\");\n        let identityFirstName = identity.attr(\"firstName\");\n        let identityLastName = updatecallElem.getChild(\"identity\").attr(\"lastName\");\n        let identityDisplayName = updatecallElem.getChild(\"identity\").attr(\"displayName\");\n        let contactUpdateDone = false;\n\n        if (!config_1.config.permitSearchFromPhoneBook) {\n          // <--- allow to permit search even if not the good profile\n          //check if phonebook is allowed by profile else no result\n          if (!that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_PHONE_BOOK)) {\n            that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) xnames not allowed for the user profile => IGNORED event\");\n            return Promise.resolve();\n          }\n        } //find Xnames from directories\n\n\n        if (identityLastName && identityLastName.length) {\n          lastName = identityLastName;\n\n          if (identityFirstName && identityFirstName.length) {\n            firstName = identityFirstName;\n          }\n\n          that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) received for call \", call.id, \" for phoneNumber:\", Utils.anonymizePhoneNumber(phoneNumber), \" with name : \", firstName.slice(0, 1), \"***\");\n        } else {\n          if (identityDisplayName && identityDisplayName.length && identityDisplayName !== phoneNumber) {\n            lastName = identityDisplayName; //Workaround last resort, only displayName is available, hack is to use it as lastName\n\n            that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) only displayName available\");\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) xnames not available => IGNORED event\");\n            return Promise.resolve();\n          }\n        } //debug+\n        //if (!call.currentCalled.contactPhoneNumber || call.currentCalled.contactPhoneNumber === \"\") {\n        //  $log.debug(\"[TelephonyServiceEventHandler] onUpDateCallEvent  call.currentCalled.contactPhoneNumber EMPTY !!!\");\n        //  $log.debug(\"[TelephonyServiceEventHandler] for call \" + call.id + \" conf = \" + call.isConference);\n        //}\n        //debug-\n        // update contact as necessary\n\n\n        return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n          if (contact.temp) {\n            //not a rainbow user\n            contact.updateName(firstName, lastName);\n\n            if (call.contact && call.contact._id) {\n              //not a conf\n              let currentCalled = {\n                contactPhoneNumber: phoneNumber,\n                contact: contact\n              };\n\n              if (call.contact._id !== contact._id || call.contact.displayName === phoneNumber || call.contact.getNameUpdatePrio() === NameUpdatePrio.OUTLOOK_UPDATE_PRIO) {\n                contact.setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\n\n                call.setContact(contact);\n                call.setCurrentCalled(currentCalled);\n                contactUpdateDone = true;\n                that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) xnames updated for \", phoneNumber, \"with contact : \", contact.displayNameMD5);\n              }\n            } else if (call.participants && call.participants.length > 0) {\n              let currentCalled = call.getCurrentCalled();\n\n              for (let i = 0; i < call.participants.length; i++) {\n                if (call.participants[i].temp) {\n                  if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) {\n                    //concerned participant\n                    that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) temp participant \", call.participants[i].displayNameMD5, \" updated with : \", contact.displayNameMD5);\n                    call.participants[i] = contact;\n                    call.participants[i].setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\n\n                    currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                    currentCalled.participants[i] = contact;\n                    contactUpdateDone = true;\n                  }\n                } else {\n                  //former participant is a rainbow user I don't know what to do !!!???\n                  that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) STRANGE former participant was a rainbow: \", call.participants[i].displayNameMD5);\n                }\n              }\n\n              call.setCurrentCalled(currentCalled);\n            }\n          } else {\n            //rainbow contact found\n            if (call.contact && call.contact._id) {\n              //not a conf\n              let currentCalled = {\n                contactPhoneNumber: phoneNumber,\n                contact: contact\n              };\n\n              if (call.contact._id !== contact._id) {\n                //update call.contact if not the good one\n                //workaround+ Because of msg crossing pb udate old temp contact before to set the new one\n                if (call.contact.temp) {\n                  call.contact.updateName(firstName, lastName);\n                  call.contact.setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\n                } //workaround-\n\n\n                call.setContact(contact);\n                call.setCurrentCalled(currentCalled);\n                contactUpdateDone = true;\n                that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) call update with rainbow contact : \", contact.displayNameMD5);\n              }\n            } else if (call.participants && call.participants.length > 0) {\n              let currentCalled = call.getCurrentCalled();\n\n              for (let i = 0; i < call.participants.length; i++) {\n                if (call.participants[i].temp) {\n                  if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) {\n                    //concerned participant\n                    that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) temp participant \", call.participants[i].displayNameMD5, \" updated with : \", contact.displayNameMD5);\n                    call.participants[i] = contact;\n                    call.setParticipants(call.participants); //to force an update of the avatars\n\n                    currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                    currentCalled.participants[i] = contact;\n                    contactUpdateDone = true;\n                  }\n                } else {\n                  //if former participant is the same rainbow user nothing to do except store phoneNumber and participant in call\n                  if (call.participants[i].jid === jid) {\n                    //concerned participant\n                    //call.participants[i] = contact;\n                    currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                    currentCalled.participants[i] = call.participants[i];\n                    contactUpdateDone = true; //??\n\n                    that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent)rainbow participant \", call.participants[i].displayNameMD5, \" updated with the same : \", contact.displayNameMD5);\n                  } else {\n                    //not the  good participant nothing to do\n                    that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) other participant not updated : \", call.participants[i].displayNameMD5, \" vs \", contact.displayNameMD5);\n                  }\n                }\n              }\n\n              call.setCurrentCalled(currentCalled);\n            }\n          }\n\n          if (contactUpdateDone) {\n            //that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) send evt_internal_callupdated \", call);\n            that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n            /*//CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\r\n            // with telescoping with incoming call popup\r\n            $interval(function () {\r\n                $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n            }, 300, 1);\r\n            // */\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent), no update needed for call : \", call.id);\n          }\n        });\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** FAILURE STUFF                                                   **/\n\n    /*********************************************************************/\n\n\n    this.onFailCallEvent = function (failedElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onFailCallEvent) _entering_ : \", failedElem);\n      let cause = failedElem.attr(\"cause\"); //let that = this;\n\n      return that.getCall(failedElem).then(function (call) {\n        return __awaiter(this, void 0, void 0, function* () {\n          call.setStatus(Call_1.Call.Status.ERROR);\n          call.errorMessage = CallFailureLabels[cause]; //call.autoClear = $interval(function () {\n\n          yield that.telephonyService.clearCall(call); //}, 5000, 1);\n\n          if (!call.errorMessage) {\n            call.errorMessage = cause;\n          } //that.logger.log(\"internal\", LOG_ID + \"(onFailCallEvent) send evt_internal_callupdated \", call);\n\n\n          that.eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n        });\n      }); // */\n    };\n    /*********************************************************************/\n\n    /** FORWARD CALL STUFF                                              **/\n\n    /*********************************************************************/\n\n\n    this.onCallForwardedEvent = function (forwardElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onCallForwardedEvent) _entering_ : \", forwardElem);\n      let call = {\n        \"forwardType\": forwardElem.attr(\"forwardType\"),\n        \"forwardTo\": forwardElem.attr(\"forwardTo\")\n      }; //that.logger.log(\"internal\", LOG_ID + \"(onCallForwardedEvent) send evt_internal_callforwarded \", call);\n\n      that.eventEmitter.emit(\"evt_internal_callforwarded\", call);\n      return Promise.resolve();\n      /* $rootScope.$broadcast(\"ON_CALL_FORWARDED_EVENT\", {\r\n           \"forwardType\": forwardElem.attr(\"forwardType\"),\r\n           \"forwardTo\": forwardElem.attr(\"forwardTo\")\r\n       });\r\n       return $q.when();\r\n       // */\n    };\n    /*\r\n    <message xmlns=\"jabber:client\" xml:lang=\"en\" to=\"38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/node_ztapimhe\" from=\"tel_38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/phone\">\r\n    <callservice xmlns=\"urn:xmpp:pbxagent:callservice:1\" xmlns:ns7=\"urn:xmpp:pbxagent:callservice:1\">\r\n    <nomadicStatus destination=\"23031\" featureActivated=\"true\" makeCallInitiatorIsMain=\"false\" modeActivated=\"true\"/>\r\n     */\n\n    /*********************************************************************/\n\n    /** NOMADIC STATUS STUFF                                              **/\n\n    /*********************************************************************/\n\n\n    this.onNomadicStatusEvent = function (eventElem) {\n      that.logger.log(\"internal\", LOG_ID + \"(onNomadicStatusEvent) _entering_ : \", eventElem);\n      let nomadicstate = {\n        \"featureActivated\": eventElem.attr(\"featureActivated\"),\n        \"modeActivated\": eventElem.attr(\"modeActivated\"),\n        \"destination\": eventElem.attr(\"destination\"),\n        \"makeCallInitiatorIsMain\": eventElem.attr(\"makeCallInitiatorIsMain\")\n      };\n      that.telephonyService.updateNomadicData(nomadicstate); //that.logger.log(\"debug\", LOG_ID + \"(onFailCallEvent) send onNomadicStatusEvent \", call);\n      //that.eventEmitter.emit(\"onNomadicStatusEvent\", call);\n\n      return Promise.resolve();\n      /* $rootScope.$broadcast(\"ON_CALL_FORWARDED_EVENT\", {\r\n           \"forwardType\": forwardElem.attr(\"forwardType\"),\r\n           \"forwardTo\": forwardElem.attr(\"forwardTo\")\r\n       });\r\n       return $q.when();\r\n       // */\n    };\n    /*********************************************************************/\n\n    /** PRIVATE UTILITY METHODS                                         **/\n\n    /*********************************************************************/\n\n\n    this.getCall = elem => __awaiter(this, void 0, void 0, function* () {\n      let jid = elem.getAttr(\"endpointIm\");\n      let phoneNumber = elem.getAttr(\"endpointTel\");\n      let connectionId = elem.getAttr(\"callId\");\n      let deviceType = elem.getAttr(\"deviceType\");\n      let cause = elem.attr(\"cause\");\n      let deviceState = elem.attr(\"deviceState\");\n      let type = elem.attr(\"type\");\n      let globalCallId = elem.attr(\"globalCallId\");\n      let correlatorData = elem.attr(\"correlatorData\");\n\n      if (!connectionId) {\n        connectionId = elem.getAttr(\"heldCallId\");\n      } // TODO: WHY and WHEN\n\n\n      that.logger.log(\"debug\", LOG_ID + \"(getCall)  - \", jid, \" - \", Utils.anonymizePhoneNumber(phoneNumber), \" - \", connectionId);\n      that.logger.log(\"internal\", LOG_ID + \"(getCall) jid : \", jid, \", phoneNumber : \", phoneNumber, \", connectionId : \", connectionId, \", deviceType : \", deviceType);\n      let callObj = yield that.getOrCreateCall(connectionId, jid, deviceType, phoneNumber);\n      let updatedinformations = {};\n\n      if (connectionId != null) {\n        updatedinformations.connectionId = connectionId;\n      }\n\n      if (jid != null) {\n        updatedinformations.jid = jid;\n      }\n\n      if (deviceType != null) {\n        updatedinformations.deviceType = deviceType;\n      }\n\n      if (phoneNumber != null) {\n        updatedinformations.phoneNumber = phoneNumber;\n      }\n\n      if (cause != null) {\n        updatedinformations.cause = cause;\n      }\n\n      if (deviceState != null) {\n        updatedinformations.deviceState = deviceState;\n      }\n\n      if (type != null) {\n        updatedinformations.cause = type;\n      }\n\n      if (globalCallId != null) {\n        updatedinformations.globalCallId = globalCallId;\n      }\n\n      if (correlatorData != null) {\n        updatedinformations.correlatorData = correlatorData;\n      }\n\n      callObj.updateCall(updatedinformations); // */\n\n      return callObj;\n    });\n\n    this.getOrCreateCall = function (connectionId, jid, deviceType, phoneNumber) {\n      // let that = this;\n      let callId = Call_1.Call.getIdFromConnectionId(connectionId);\n      let call = that.telephonyService.getCallFromCache(callId);\n\n      if (call) {\n        return Promise.resolve(call);\n      }\n\n      return new Promise(function (resolve) {\n        if (jid || phoneNumber) {\n          that.contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n            resolve(that.telephonyService.getOrCreateCall(Call_1.Call.Status.UNKNOWN, connectionId, deviceType, contact));\n          });\n        } else {\n          resolve(that.telephonyService.getOrCreateCall(Call_1.Call.Status.UNKNOWN, connectionId, deviceType, null));\n        }\n      }); // */\n    };\n\n    this.createConferenceCall = function (connectionId, participants) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let conferenceCall = yield that.getOrCreateCall(connectionId, undefined, undefined, undefined);\n        that.logger.log(\"internal\", LOG_ID + \"(createConferenceCall) conferenceCall : \", conferenceCall);\n        conferenceCall.isConference = true;\n        conferenceCall.setParticipants(participants); //that.telephonyService.addOrUpdateCallToCache(conferenceCall)\n\n        that.logger.log(\"debug\", LOG_ID + \"(createConferenceCall) conferenceCall stored : \", that.telephonyService.getCallFromCache(conferenceCall.id));\n        return conferenceCall;\n        /*\r\n        // Create and configure the conference call\r\n        let conferenceCall = Call.create(Call.Status.UNKNOWN, null, Call.Type.PHONE);\r\n        conferenceCall.setConnectionId(connectionId);\r\n        conferenceCall.isConference = true;\r\n        conferenceCall.setParticipants(participants);\r\n        this.telephonyService._calls[conferenceCall.id] = conferenceCall;\r\n        return conferenceCall;\r\n        // */\n      });\n    };\n  }\n  /*********************************************************************/\n\n  /** CALL UPDATE STUFF                                               **/\n\n  /*********************************************************************/\n\n  /**\r\n   * Method analyzeContactChange\r\n   * Analyse if a setContact has to be done following situation\r\n   * @public\r\n   * @param jid [required] jid from PCG\r\n   * @param phoneNumber [required] phone number from PCG\r\n   * @param call [required] the call to update\r\n   * @returns object:{ updateContactToBeDone : boolean, searchOutlookToBeDone :boolean}\r\n   *  updateContactToBeDone true if the contact has to be updated in the call (by setContact)\r\n   *  searchOutlookToBeDone true if an outlook search has to be performed to resolve call identity\r\n   * @memberof TelephonyServiceEventHandler\r\n   */\n\n\n  analyzeContactChange(jid, phoneNumber, call) {\n    let updateContact = false;\n\n    if (!jid && !phoneNumber) {\n      //nothing could be analysed then updated\n      return null;\n    } // One2One Call (not a conference) only call.contact is impacted\n\n\n    if (!call.isConference) {\n      // No contact... Whatever situation set contact\n      if (!call.contact) {\n        return {\n          updateContactToBeDone: true\n        }; //return { updateContactToBeDone: true, searchOutlookToBeDone: false };  //OUTLOOK NOT YET DELIVERED\n      } // PCG known the distant as a rainbow user (no outlook search is necessary)\n\n\n      if (jid !== \"\") {\n        // Only change if not the same from previous call setting\n        if (call.contact._id !== jid) {\n          updateContact = true;\n        }\n      } // No jid available\n      else {\n          // call.contact not known as rainbow user, contact._id contain former phoneNumber\n          if (call.contact.temp) {\n            if (call.contact._id !== phoneNumber) //called change\n              {\n                updateContact = true;\n              } else if (call.contact.displayName === phoneNumber) {\n              //no change but name not known\n              updateContact = false; //searchOutlook = false; //OUTLOOK NOT YET DELIVERED\n            }\n          } // call.contact known as rainbow user update only if phoneNumber change (except ringing empty case)\n          else if (call.getCurrentCalled().contactPhoneNumber !== \"\" && phoneNumber !== \"\") {\n              if (call.getCurrentCalled().contactPhoneNumber !== phoneNumber) {\n                updateContact = true;\n              }\n            }\n        }\n\n      return updateContact ? {\n        updateContactToBeDone: updateContact\n      } : null;\n    }\n  }\n  /**\r\n   * Method updateCallContact\r\n   * @public\r\n   * @param jid [required] jid from PCG\r\n   * @param phoneNumber [required] phone number from PCG\r\n   * @param actionElemName [required] name of the action event\r\n   * @param call [required] the call to update\r\n   * @returns {ng.IPromise<{}>} status promise\r\n   * @memberof TelephonyServiceEventHandler\r\n   */\n\n\n  updateCallContact(jid, phoneNumber, actionElemName, call) {\n    let that = this;\n\n    try {\n      // Determine if the contact has to be updated from event information\n      let updateAnalyse = that.analyzeContactChange(jid, phoneNumber, call); // Whatever the contact change, for simple call, after analyse, update at least the call current phoneNumber\n\n      if (!call.isConference && phoneNumber !== \"\") {\n        call.setCurrentCalledContactNumber(phoneNumber);\n      }\n\n      if (updateAnalyse) {\n        return that.contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n          that.logger.log(\"internal\", LOG_ID + \"(updateCallContact)  on \", actionElemName, \", update contact :\", contact.displayNameMD5);\n          that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n          return Promise.resolve();\n        });\n      } else {\n        //that.logger.log(\"internal\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\n        that.eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n        return Promise.resolve();\n      }\n    } catch (error) {\n      let errorMessage = \"updateCallContact -- \" + error.message;\n      that.logger.log(\"error\", LOG_ID + \"(updateCallContact) Catch Error !!! \");\n      that.logger.log(\"internalerror\", LOG_ID + \"(updateCallContact) Catch Error !!! : \", errorMessage);\n      return Promise.reject(new Error(errorMessage));\n    }\n  }\n\n  makeUpdateContact(call, contact, phoneNumber, actionElemName) {\n    let that = this;\n    call.setContact(contact);\n    let currentCalled = {\n      contactPhoneNumber: phoneNumber,\n      contact: contact\n    };\n    call.setCurrentCalled(currentCalled); //that.logger.log(\"internal\", LOG_ID + \"(makeUpdateContact) send evt_internal_callupdated \", call);\n\n    that.eventEmitter.emit(\"evt_internal_callupdated\", call);\n    /* if (actionElemName === \"delivered\" && call.status === Call.Status.RINGING_INCOMING) {\r\n         //CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\r\n         // with telescoping with incoming call popup\r\n         $interval(function () {\r\n             $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n         }, 300, 1);\r\n     }\r\n     else {\r\n         //$interval(function() { $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call); }, 300, 1);\r\n         $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n     }\r\n     // */\n  }\n\n};\nTelephonyEventHandler = __decorate([Utils_1.logEntryExit(LOG_ID)], TelephonyEventHandler);\nexports.TelephonyEventHandler = TelephonyEventHandler;\nmodule.exports.TelephonyEventHandler = TelephonyEventHandler;","map":{"version":3,"sources":["../../../src/lib/connection/XMPPServiceHandler/telephonyEventHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\r\nconst Utils = require(\"../../common/Utils\");\r\nconst GenericHandler = require(\"./genericHandler\");\r\n//const Conversation = require(\"../../common/models/Conversation\");\r\n//const Call = require(\"../../common/models/Call\");\r\nconst Call_1 = require(\"../../common/models/Call\");\r\nconst Utils_1 = require(\"../../common/Utils\");\r\nconst NameUpdatePrio = require(\"../../common/models/Contact\").NameUpdatePrio;\r\nconst xml = require(\"@xmpp/xml\");\r\nconst PromiseQueue = require(\"../../common/promiseQueue\");\r\n//const config = require(\"../../config/config\");\r\nconst config_1 = require(\"../../config/config\");\r\nconst LOG_ID = \"XMPP/HNDL/TEL - \";\r\n/*********************************************************************/\r\n/** PRIVATE CONSTRUCTOR                                             **/\r\n/*********************************************************************/\r\nconst CallFailureLabels = {\r\n    \"DESTNOTOBTAINABLE\": \"outOfService\",\r\n    \"DONOTDISTURB\": \"dnd\",\r\n    \"TRUNKSBUSY\": \"trunksbusy\"\r\n};\r\nlet TelephonyEventHandler = class TelephonyEventHandler extends GenericHandler {\r\n    constructor(xmppService, telephonyService, contactService, profileService) {\r\n        super(xmppService);\r\n        let that = this;\r\n        this.MESSAGE = \"jabber:client.message\";\r\n        this.IQ_RESULT = \"jabber:client.iq.result\";\r\n        this.IQ_ERROR = \"jabber:client.iq.error\";\r\n        /*this.MESSAGE_GROUPCHAT = \"jabber:client.message.groupchat\";\r\n        this.MESSAGE_WEBRTC = \"jabber:client.message.webrtc\";\r\n        this.MESSAGE_MANAGEMENT = \"jabber:client.message.management\";\r\n        this.MESSAGE_ERROR = \"jabber:client.message.error\";\r\n        this.MESSAGE_HEADLINE = \"jabber:client.message.headline\";\r\n        this.MESSAGE_CLOSE = \"jabber:client.message.headline\";\r\n        */\r\n        this.telephonyService = telephonyService;\r\n        this.contactService = contactService;\r\n        this.promiseQueue = PromiseQueue.createPromiseQueue(that.logger);\r\n        this._profiles = profileService;\r\n        this.onIqResultReceived = (msg, stanza) => {\r\n            let children = stanza.children;\r\n            children.forEach((node) => {\r\n                switch (node.getName()) {\r\n                    case \"pbxagentstatus\":\r\n                        that.onIqGetPbxAgentStatusReceived(stanza, node);\r\n                        break;\r\n                    case \"default\":\r\n                        //that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) not managed - 'stanza'\", node.getName());\r\n                        break;\r\n                    default:\r\n                    //that\r\n                    //  .logger\r\n                    //.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) child not managed for iq - 'stanza'\", node.getName());\r\n                }\r\n            });\r\n        };\r\n        // Private methods\r\n        this.onIqGetPbxAgentStatusReceived = (stanza, node) => {\r\n            let pbxagentstatus = {\r\n                \"phoneapi\": \"\",\r\n                \"xmppagent\": \"\",\r\n                \"version\": \"\"\r\n            };\r\n            let subchildren = node.children;\r\n            subchildren.forEach(function (item) {\r\n                if (typeof item === \"object\") {\r\n                    let itemName = item.getName();\r\n                    if (itemName) {\r\n                        pbxagentstatus[itemName] = item.text();\r\n                    }\r\n                }\r\n            });\r\n            if (pbxagentstatus.version) {\r\n                let phoneApi = pbxagentstatus.phoneapi;\r\n                let xmppAgent = pbxagentstatus.xmppagent;\r\n                let agentVersion = pbxagentstatus.version;\r\n                let agentStatus = { \"phoneApi\": phoneApi, \"xmppAgent\": xmppAgent, \"agentVersion\": agentVersion };\r\n                that.logger.log(\"info\", LOG_ID + \"(onIqGetPbxAgentStatusReceived)  - send rainbow_onpbxagentstatusreceived 'agentStatus'\", agentStatus);\r\n                that.eventEmitter.emit(\"rainbow_onpbxagentstatusreceived\", agentStatus);\r\n            }\r\n        };\r\n        this.onMessageReceived = (msg, stanza) => {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onMessageReceived) _entering_ : \", msg, stanza);\r\n            try {\r\n                let stanzaElem = stanza;\r\n                //let that = this;\r\n                // Ignore \"Offline\" message\r\n                let delay = stanzaElem.getChild(\"delay\");\r\n                if (delay && delay.text() === \"Offline Storage\") {\r\n                    return true;\r\n                }\r\n                let from = stanza.attrs.from;\r\n                let to = stanza.attrs.to;\r\n                // Treat WEBRTC Events\r\n                let actionElmPropose = stanzaElem.getChild(\"propose\");\r\n                if (actionElmPropose !== undefined) {\r\n                    this.onProposeMessageReceived(actionElmPropose, from);\r\n                    return true;\r\n                }\r\n                // Treat Telephony (3PCC) Events\r\n                let actionElm = stanzaElem.getChild(\"callservice\");\r\n                if (actionElm === undefined) {\r\n                    return true;\r\n                }\r\n                let actionElem = null;\r\n                let actionElemName = null;\r\n                for (let i = 0; i < actionElm.children.length; i++) {\r\n                    if (!actionElemName) {\r\n                        if (actionElm.children[i].name) {\r\n                            actionElemName = actionElm.children[i].name.toLowerCase();\r\n                            actionElem = actionElm.children[i];\r\n                        }\r\n                    }\r\n                }\r\n                if (actionElemName) {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onMessageReceived) \", that.logger.colors.debug(\"-- event -- \", actionElemName));\r\n                    // Handle the event\r\n                    switch (actionElemName) {\r\n                        case \"initiated\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onInitiatedEvent(actionElem);\r\n                            });\r\n                            break; // */\r\n                        case \"originated\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onOriginatedEvent(actionElem);\r\n                            });\r\n                            break; // */\r\n                        case \"delivered\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onDeliveredEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"established\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onEstablishedEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"retrievecall\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onRetrieveCallEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"queued\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onQueuedEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"holdcall\":\r\n                        case \"held\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onHeldEvent(actionElem);\r\n                            });\r\n                            break; // OLD SYNTAX TO BE REMOVED\r\n                        case \"diverted\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onDivertedEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"transfercall\":\r\n                        case \"transferred\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onTransferEvent(actionElem);\r\n                            });\r\n                            break; // OLD SYNTAX TO BE REMOVED\r\n                        case \"conferenced\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onConferenceEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"connectioncleared\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onClearCallEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"failed\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onFailCallEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"messaging\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onVoiceMessageEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"updatecall\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onUpDateCallEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"forwarded\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onCallForwardedEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        case \"nomadicstatus\":\r\n                            this.promiseQueue.add(function () {\r\n                                return that.onNomadicStatusEvent(actionElem);\r\n                            });\r\n                            break;\r\n                        // */\r\n                        default:\r\n                            that.logger.log(\"internal\", LOG_ID + \"(onMessageReceived) untreated actionElemName : \", actionElemName);\r\n                    }\r\n                    // */\r\n                    return true;\r\n                }\r\n                else {\r\n                    that.logger.log(\"error\", LOG_ID + \"(onMessageReceived) -- failure -- no name found in callservice children.\");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onMessageReceived) -- failure -- no name found in callservice children : \", stanzaElem);\r\n                }\r\n            }\r\n            catch (error) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onMessageReceived) CATCH Error !!! -- failure -- \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onMessageReceived) CATCH Error !!! -- failure -- : \", error);\r\n                //return true;\r\n            }\r\n            that.logger.log(\"debug\", LOG_ID + \"(onMessageReceived) _exiting_\");\r\n            return true;\r\n        };\r\n        this.onProposeMessageReceived = (node, from) => __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"internal\", LOG_ID + \"(onProposeMessageReceived) node - \", node);\r\n            let descriptionElm = node.getChild(\"description\");\r\n            let media = descriptionElm.attrs.media;\r\n            let contact = yield that.contactService.getContactByJid(from);\r\n            that.eventEmitter.emit(\"evt_internal_propose\", { contact, media });\r\n        });\r\n        /*********************************************************************/\r\n        /** INITIATED CALL STUFF                                           **/\r\n        /*********************************************************************/\r\n        this.onInitiatedEvent = function (initiatedElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onInitiatedEvent) _entering_ : \", initiatedElem);\r\n            return that.getCall(initiatedElem)\r\n                .then(function (call) {\r\n                try {\r\n                    /*if (call.status === Call.Status.QUEUED_INCOMING) {\r\n                        return Promise.resolve();\r\n                    } // */\r\n                    let deviceState = initiatedElem.attr(\"deviceState\");\r\n                    //let devicetype = initiatedElem.attr(\"devicetype\");\r\n                    //let callId = initiatedElem.attr(\"callId\");\r\n                    if (deviceState && deviceState === \"LCI_INITIATED\") {\r\n                        call.setStatus(Call_1.Call.Status.DIALING);\r\n                        // Update call info\r\n                        //that.logger.log(\"internal\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    }\r\n                    return Promise.resolve();\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onInitiatedEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onInitiatedEvent) Catch Error !!! \");\r\n                    that.logger.log(\"error\", LOG_ID + \"(onInitiatedEvent) Catch Error !!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** ORIGINATED CALL STUFF                                           **/\r\n        /*********************************************************************/\r\n        this.onOriginatedEvent = function (originatedElem) {\r\n            that.logger.log(\"debug\", LOG_ID + \"(onOriginatedEvent) _entering_ : \", originatedElem);\r\n            return that.getCall(originatedElem)\r\n                .then(function (call) {\r\n                try {\r\n                    let jid = originatedElem.attr(\"endpointIm\");\r\n                    let phoneNumber = originatedElem.attr(\"endpointTel\");\r\n                    let currentCalled = {\r\n                        contactPhoneNumber: \"\",\r\n                        contact: call.contact,\r\n                        participantsPhoneNumbers: null,\r\n                        participants: null\r\n                    };\r\n                    // PCG has some info\r\n                    if (jid || phoneNumber) {\r\n                        currentCalled.contactPhoneNumber = (phoneNumber ? phoneNumber : \"\");\r\n                    }\r\n                    // Unknown user\r\n                    else if (call.contact && call.contact.temp) {\r\n                        currentCalled.contactPhoneNumber = call.contact._id; //that is the only current known phoneNumber\r\n                    }\r\n                    call.setCurrentCalled(currentCalled);\r\n                    /*let deviceState = call.deviceState;\r\n                    //let devicetype = initiatedElem.attr(\"devicetype\");\r\n                    //let callId = initiatedElem.attr(\"callId\");\r\n                    if (deviceState && deviceState === \"LCI_CONNECTED\") {\r\n                        call.setStatus(Call.Status.DIALING );\r\n                        // Update call info\r\n                        that.logger.log(\"debug\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    } */\r\n                    return Promise.resolve();\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onOriginatedEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onOriginatedEvent) Catch Error !!! \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onOriginatedEvent) Catch Error !!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** DELIVERED STUFF                                                 **/\r\n        /*********************************************************************/\r\n        this.onDeliveredEvent = function (deliveredElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onDeliveredEvent) _entering_ : \", deliveredElem);\r\n            //let that = this;\r\n            return that.getCall(deliveredElem).then(function (call) {\r\n                try {\r\n                    if (call.status === Call_1.Call.Status.QUEUED_INCOMING) {\r\n                        return Promise.resolve();\r\n                    }\r\n                    let type = deliveredElem.attr(\"type\");\r\n                    let jid = deliveredElem.attr(\"endpointIm\");\r\n                    let phoneNumber = deliveredElem.attr(\"endpointTel\");\r\n                    // Update call info\r\n                    call.setStatus((type === \"outgoing\") ? Call_1.Call.Status.RINGING_OUTGOING : Call_1.Call.Status.RINGING_INCOMING);\r\n                    call.startDate = null;\r\n                    call.vm = false;\r\n                    that.logger.log(\"internal\", LOG_ID + \"(onDeliveredEvent) call : \", call);\r\n                    // Update contact info if necessary\r\n                    return that.updateCallContact(jid, phoneNumber, \"delivered\", call);\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onDeliveredEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onDeliveredEvent) Catch Error !!! \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onDeliveredEvent) Catch Error !!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            }); // */\r\n        };\r\n        /*********************************************************************/\r\n        /** ESTABLISHED STUFF                                               **/\r\n        /*********************************************************************/\r\n        this.onEstablishedEvent = function (establishedElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) _entering_ : \", establishedElem);\r\n            //let that = this;\r\n            return that.getCall(establishedElem).then(function (call) {\r\n                try {\r\n                    let jid = establishedElem.attr(\"endpointIm\");\r\n                    let phoneNumber = establishedElem.attr(\"endpointTel\");\r\n                    // Call already exists and IS NOT a conference, update contact info if necessary\r\n                    if (call.contact && call.contact._id) {\r\n                        call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                        // Update contact info as necessary\r\n                        return that.updateCallContact(jid, phoneNumber, \"established\", call);\r\n                    }\r\n                    // Call already exists and IS a conference, update contact info if necessary\r\n                    else if (call.participants && call.participants.length > 0) {\r\n                        //recover former matching contact from participants\r\n                        let contactRecovered = null;\r\n                        for (let i = 0; (i < call.participants.length && !contactRecovered); i++) {\r\n                            if (call.participants[i].id === jid) {\r\n                                contactRecovered = call.participants[i];\r\n                            }\r\n                            else if (call.currentCalled.participantsPhoneNumbers &&\r\n                                call.currentCalled.participantsPhoneNumbers.length > 0 &&\r\n                                call.currentCalled.participantsPhoneNumbers[i] === phoneNumber) {\r\n                                contactRecovered = call.participants[i];\r\n                            }\r\n                        }\r\n                        //clean former conf struct & update contact\r\n                        call.participants = [];\r\n                        call.isConference = false;\r\n                        let currentCalled = call.getCurrentCalled();\r\n                        if (contactRecovered) {\r\n                            call.setContact(contactRecovered);\r\n                            call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                            currentCalled = { contactPhoneNumber: phoneNumber, contact: contactRecovered };\r\n                            call.setCurrentCalled(currentCalled);\r\n                            //that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) send evt_internal_callupdated \", call);\r\n                            that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                            //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                        }\r\n                        else { // no matching contact strange but go ahead ...\r\n                            if (!jid && !phoneNumber) {\r\n                                phoneNumber = \"****\";\r\n                            }\r\n                            return contactService.getOrCreateContact(jid, phoneNumber)\r\n                                .then(function (contact) {\r\n                                call.setContact(contact);\r\n                                call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                                currentCalled = { contactPhoneNumber: phoneNumber, contact: contact };\r\n                                call.setCurrentCalled(currentCalled);\r\n                                //                                    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                                //that.logger.log(\"internal\", LOG_ID + \"(onEstablishedEvent) send evt_internal_callupdated \", call);\r\n                                that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                                return Promise.resolve();\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onEstablishedEvent) Neither contact, nor participant found!\");\r\n                    }\r\n                    return Promise.resolve();\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onEstablishedEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onEstablishedEvent) Catch Error!!! \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onEstablishedEvent) Catch Error!!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            }); // */\r\n        };\r\n        /*********************************************************************/\r\n        /** RETRIEVE CALL STUFF                                             **/\r\n        /*********************************************************************/\r\n        this.onRetrieveCallEvent = function (retrieveElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onRetrieveCallEvent) _entering_ : \", retrieveElem);\r\n            return that.getCall(retrieveElem).then(function (call) {\r\n                call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                //that.logger.log(\"internal\", LOG_ID + \"(onRetrieveCallEvent) send evt_internal_callupdated \", call);\r\n                that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                //    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** CLEAR CALL STUFF                                                **/\r\n        /*********************************************************************/\r\n        this.onClearCallEvent = function (clearElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onClearCallEvent) _entering_ : \", clearElem);\r\n            //let that = this;\r\n            return that.getCall(clearElem).then((call) => __awaiter(this, void 0, void 0, function* () {\r\n                if (call.status !== Call_1.Call.Status.ERROR) {\r\n                    call.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                    let cause = clearElem.attr(\"cause\");\r\n                    let deviceState = clearElem.attr(\"deviceState\");\r\n                    call.cause = cause;\r\n                    call.deviceState = deviceState;\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onClearCallEvent) send evt_internal_callupdated \", call);\r\n                    that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    yield that.telephonyService.clearCall(call);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                }\r\n            })); // */\r\n        };\r\n        /*********************************************************************/\r\n        /** HOLD CALL STUFF                                                 **/\r\n        /*********************************************************************/\r\n        this.onHeldEvent = function (heldElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onHeldEvent) _entering_ : \", heldElem);\r\n            return that.getCall(heldElem).then(function (call) {\r\n                try {\r\n                    let connectionId = heldElem.attr(\"callId\");\r\n                    if (!connectionId) {\r\n                        connectionId = heldElem.attr(\"heldCallId\");\r\n                    } // TODO: WHY and WHEN\r\n                    let callDeviceId = Call_1.Call.getDeviceIdFromConnectionId(call.connectionId);\r\n                    let holdDeviceId = Call_1.Call.getDeviceIdFromConnectionId(connectionId);\r\n                    if (callDeviceId === holdDeviceId) {\r\n                        call.setStatus(Call_1.Call.Status.HOLD);\r\n                    }\r\n                    // Same callId but different equipmentId (We receive equipment id of user who put us in held)\r\n                    else {\r\n                        call.setStatus(Call_1.Call.Status.PUT_ON_HOLD);\r\n                    }\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onHeldEvent) send evt_internal_callupdated \", call);\r\n                    that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    return Promise.resolve();\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onHeldEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onHeldEvent) Catch Error!!! \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onHeldEvent) Catch Error!!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            }); // */\r\n        };\r\n        /*********************************************************************/\r\n        /** QUEUED STUFF                                                    **/\r\n        /*********************************************************************/\r\n        this.onQueuedEvent = function (queuedElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onQueuedEvent) _entering_ : \", queuedElem);\r\n            //let that = this;\r\n            let cause = queuedElem.attr(\"cause\");\r\n            if (cause === \"PARK\") {\r\n                that.logger.log(\"warn\", LOG_ID + \"(onQueuedEvent) - ignore PARK cause\");\r\n                return Promise.resolve();\r\n            }\r\n            if (cause === \"NEWCALL\") {\r\n                that.logger.log(\"warn\", LOG_ID + \"(onQueuedEvent) - ignore NEWCALL cause\");\r\n                return Promise.resolve();\r\n            }\r\n            return that.getCall(queuedElem).then(function (call) {\r\n                try {\r\n                    let type = queuedElem.attr(\"type\");\r\n                    let jid = queuedElem.attr(\"endpointIm\");\r\n                    let phoneNumber = queuedElem.attr(\"endpointTel\");\r\n                    let status = (type === \"outgoing\") ? Call_1.Call.Status.QUEUED_OUTGOING : Call_1.Call.Status.QUEUED_INCOMING;\r\n                    call.setStatus(status);\r\n                    call.startDate = null;\r\n                    call.vm = false;\r\n                    // Update contact info if necessary\r\n                    return that.updateCallContact(jid, phoneNumber, \"queued\", call);\r\n                }\r\n                catch (error) {\r\n                    let errorMessage = \"onQueuedEvent -- \" + error.message;\r\n                    that.logger.log(\"error\", LOG_ID + \"(onHeldEvent) Catch Error!!! \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onHeldEvent) Catch Error!!! : \", errorMessage);\r\n                    return Promise.reject(new Error(errorMessage));\r\n                }\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** DIVERTED STUFF                                                  **/\r\n        /*********************************************************************/\r\n        this.onDivertedEvent = (divertedElem) => __awaiter(this, void 0, void 0, function* () {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onDivertedEvent) _entering_ : \", divertedElem);\r\n            let oldConnectionId = divertedElem.attr(\"oldCallId\");\r\n            let oldCallId = Call_1.Call.getIdFromConnectionId(oldConnectionId);\r\n            let call = that.telephonyService.getCallFromCache(oldCallId);\r\n            if (!call) {\r\n                that.logger.log(\"warn\", LOG_ID + \"(onDivertedEvent) - receive divertedEvent on unknown call --- ignored\");\r\n                return Promise.resolve();\r\n            }\r\n            yield that.telephonyService.clearCall(call);\r\n            //            $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n            //that.logger.log(\"internal\", LOG_ID + \"(onDivertedEvent) send evt_internal_callupdated \", call);\r\n            that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n            return Promise.resolve();\r\n            // */\r\n        });\r\n        /*********************************************************************/\r\n        /** TRANSFER STUFF                                                  **/\r\n        /*********************************************************************/\r\n        this.onTransferEvent = function (transferElem) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) _entering_ : \", transferElem);\r\n                // let that = this;\r\n                // Extract transfert call parameters\r\n                let activeConnectionId = transferElem.attr(\"activeCallId\");\r\n                let heldConnectionId = transferElem.attr(\"heldCallId\");\r\n                let newConnectionId = transferElem.attr(\"newCallId\");\r\n                // Get active call\r\n                let activeCallId = Call_1.Call.getIdFromConnectionId(activeConnectionId);\r\n                let activeCall = that.telephonyService.getCallFromCache(activeCallId);\r\n                if (heldConnectionId) {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) heldconnectionId found \", heldConnectionId);\r\n                    // Get the held call\r\n                    let heldCallId = Call_1.Call.getIdFromConnectionId(heldConnectionId);\r\n                    let heldCall = that.telephonyService.getCallFromCache(heldCallId);\r\n                    // Release both calls (active and held)\r\n                    if (heldCall) {\r\n                        heldCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                        //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", heldCall);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", heldCall);\r\n                        yield that.telephonyService.clearCall(heldCall);\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no  heldCall found\");\r\n                    }\r\n                    if (activeCall) {\r\n                        activeCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                        //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", activeCall);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", activeCall);\r\n                        yield that.telephonyService.clearCall(activeCall);\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no activeCall found\");\r\n                    }\r\n                    // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", heldCall);\r\n                    // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", activeCall);\r\n                }\r\n                if (newConnectionId) {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) newConnectionId found \", newConnectionId);\r\n                    let jid = transferElem.attr(\"newEndpointIm\");\r\n                    let phoneNumber = transferElem.attr(\"newEndpointTel\");\r\n                    let deviceState = transferElem.attr(\"deviceState\");\r\n                    if (!deviceState) {\r\n                        deviceState = transferElem.attr(\"deviceStatus\");\r\n                    } // TO BE REMOVED\r\n                    if (activeCall) {\r\n                        // Release current call\r\n                        activeCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", activeCall);\r\n                        //that.logger.log(\"internal\", LOG_ID + \"(onTransferEvent) send evt_internal_callupdated \", activeCall);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", activeCall);\r\n                        yield that.telephonyService.clearCall(activeCall);\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onTransferEvent) no activeCall found\");\r\n                    }\r\n                    if (!jid && !phoneNumber) { //secret identity\r\n                        phoneNumber = \"****\";\r\n                    }\r\n                    let deviceType = transferElem.find(\"deviceType\");\r\n                    return that.getOrCreateCall(newConnectionId, jid, deviceType, phoneNumber)\r\n                        .then(function (newCall) {\r\n                        let globalCallId = transferElem.attr(\"globalCallId\");\r\n                        if (globalCallId) {\r\n                            newCall.setGlobalCallId(globalCallId);\r\n                        }\r\n                        let correlatorData = transferElem.attr(\"correlatorData\");\r\n                        if (correlatorData) {\r\n                            newCall.correlatorData = correlatorData;\r\n                        }\r\n                        if (deviceState && deviceState === \"LCI_ALERTING\") {\r\n                            newCall.setStatus(Call_1.Call.Status.RINGING_INCOMING);\r\n                        }\r\n                        else {\r\n                            newCall.setStatus(Call_1.Call.Status.ACTIVE);\r\n                        }\r\n                        // Update contact info if necessary\r\n                        return that.updateCallContact(jid, phoneNumber, \"transfercall\", newCall);\r\n                    });\r\n                }\r\n                else {\r\n                    return Promise.resolve();\r\n                }\r\n                // */\r\n            });\r\n        };\r\n        /*********************************************************************/\r\n        /** CONFERENCE STUFF                                                **/\r\n        /*********************************************************************/\r\n        this.onConferenceEvent = function (conferencedElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) _entering_ : \", conferencedElem);\r\n            //let that = this;\r\n            // Get connectionsIds\r\n            let primaryOldConnectionId = conferencedElem.getChild(\"primaryOldCallId\") ? conferencedElem.getChild(\"primaryOldCallId\").getText() : \"\";\r\n            let secondaryOldConnectionId = conferencedElem.getChild(\"secondaryOldCallId\") ? conferencedElem.getChild(\"secondaryOldCallId\").getText() : \"\";\r\n            let newConnectionId = conferencedElem.getChild(\"newCallId\") ? conferencedElem.getChild(\"newCallId\").getText() : \"\";\r\n            that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) primaryOldConnectionId - \", primaryOldConnectionId);\r\n            that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) secondaryOldConnectionId - \", secondaryOldConnectionId);\r\n            that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) newConnectionId - \", newConnectionId);\r\n            // Extract callIds\r\n            let primaryOldCallId = Call_1.Call.getIdFromConnectionId(primaryOldConnectionId);\r\n            let secondaryOldCallId = Call_1.Call.getIdFromConnectionId(secondaryOldConnectionId);\r\n            that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) primaryOldCallId - \", primaryOldCallId);\r\n            that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) secondaryOldCallId - \", secondaryOldCallId);\r\n            // Get current calls\r\n            let primaryOldCall = that.telephonyService.getCallFromCache(primaryOldCallId);\r\n            let secondaryOldCall = that.telephonyService.getCallFromCache(secondaryOldCallId);\r\n            // Prepare participant promises\r\n            let confParticipants = [];\r\n            let participantPromises = [];\r\n            let confParticipantsPhoneNumbers = [];\r\n            let confContactsInfos = [];\r\n            let participantsElmt = conferencedElem.getChild(\"participants\");\r\n            that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) participantsElmt - \", participantsElmt);\r\n            let participantElmts = participantsElmt.getChildren(\"participant\");\r\n            that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) participantElmts - \", participantElmts);\r\n            participantElmts.forEach(function (participantElem) {\r\n                //let participantElem = angular.element(this);\r\n                let endpointTel = participantElem.find(\"endpointTel\").getText();\r\n                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) endpointTel - \", endpointTel);\r\n                let endpointIm = participantElem.find(\"endpointIm\").getText();\r\n                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) endpointIm - \", endpointIm);\r\n                let callId = participantElem.find(\"callId\").getText();\r\n                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) callId - \", callId);\r\n                let role = participantElem.find(\"role\").getText();\r\n                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) role - \", role);\r\n                let contactInfos = {\r\n                    endpointTel: endpointTel,\r\n                    endpointIm: endpointIm,\r\n                    callId: callId,\r\n                    role: role\r\n                };\r\n                confContactsInfos.push(contactInfos);\r\n                if (!(endpointIm && contactService.isUserContactJid(endpointIm))) {\r\n                    participantPromises.push(new Promise(function (resolve, reject) {\r\n                        if (!endpointIm && !endpointTel) {\r\n                            endpointTel = \"****\";\r\n                        }\r\n                        //if no endpointIm try to extract contact info from primary or secondary calls\r\n                        if (!endpointIm && primaryOldCall && primaryOldCall.contact &&\r\n                            primaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\r\n                            confParticipants.push(primaryOldCall.contact);\r\n                            confParticipantsPhoneNumbers.push(endpointTel);\r\n                            resolve();\r\n                        }\r\n                        else if (!endpointIm && secondaryOldCall && secondaryOldCall.contact &&\r\n                            secondaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\r\n                            confParticipants.push(secondaryOldCall.contact);\r\n                            confParticipantsPhoneNumbers.push(endpointTel);\r\n                            resolve();\r\n                        }\r\n                        else {\r\n                            contactService.getOrCreateContact(endpointIm, endpointTel)\r\n                                .then(function (contact) {\r\n                                //manage Outlook Call Party identification\r\n                                /*  let centralizedService = $injector.get(\"centralizedService\");\r\n                                  centralizedService.outlook.updateContactFromOutlookInfos(contact, endpointTel)\r\n                                      .then(\r\n                                          function successCallback(updateStatus) {\r\n                                              if (updateStatus) {\r\n                                                  that.logger.log(\"debug\", LOG_ID + \" on conferenced, update from outlook for contact :\" + contact.displayNameMD5);\r\n                                                  //that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\r\n                                              } else {\r\n                                                  that.logger.log(\"debug\", LOG_ID + \"on conferenced, no update from outlook for contact :\" + contact.displayNameMD5);\r\n                                              }\r\n                                          },\r\n                                          function errorCallback() {\r\n                                              that.logger.log(\"debug\", LOG_ID + \"on conferenced, no Outlook search available\");\r\n                                          }\r\n                                      )\r\n                                      .finally(function () {\r\n                                      */\r\n                                confParticipants.push(contact);\r\n                                confParticipantsPhoneNumbers.push(endpointTel);\r\n                                resolve();\r\n                                //});\r\n                            })\r\n                                .catch(function (error) {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onConferenceEvent) Impossible to get contact - \");\r\n                                that.logger.log(\"internaldebug\", LOG_ID + \"(onConferenceEvent) Impossible to get contact - : \", error.message);\r\n                                reject();\r\n                            });\r\n                        }\r\n                    }));\r\n                }\r\n            });\r\n            // Get participants asynchronously\r\n            return Promise.all(participantPromises)\r\n                .then(() => __awaiter(this, void 0, void 0, function* () {\r\n                // Release previous calls\r\n                if (primaryOldCall) {\r\n                    primaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                    that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) release primaryOldCall - \", primaryOldCall);\r\n                    primaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                    //let cause = clearElem.attr(\"cause\");\r\n                    //let deviceState = clearElem.attr(\"deviceState\");\r\n                    //call.cause = cause;\r\n                    //call.deviceState = deviceState;\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", primaryOldCall);\r\n                    that.eventEmitter.emit(\"evt_internal_callupdated\", primaryOldCall);\r\n                    yield that.telephonyService.clearCall(primaryOldCall);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", primaryOldCall);\r\n                }\r\n                if (secondaryOldCall) {\r\n                    secondaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                    that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) release secondaryOldCall - \", secondaryOldCall);\r\n                    secondaryOldCall.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                    //let cause = clearElem.attr(\"cause\");\r\n                    //let deviceState = clearElem.attr(\"deviceState\");\r\n                    //call.cause = cause;\r\n                    //call.deviceState = deviceState;\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", secondaryOldCall);\r\n                    that.eventEmitter.emit(\"evt_internal_callupdated\", secondaryOldCall);\r\n                    yield that.telephonyService.clearCall(secondaryOldCall);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", secondaryOldCall);\r\n                }\r\n                // Create the new conference call\r\n                let newConferenceCall = yield that.createConferenceCall(newConnectionId, confParticipants);\r\n                //update currentcalled structure\r\n                let currentCalled = newConferenceCall.getCurrentCalled();\r\n                currentCalled.participants = confParticipants;\r\n                currentCalled.participantsPhoneNumbers = confParticipantsPhoneNumbers;\r\n                newConferenceCall.setCurrentCalled(currentCalled);\r\n                newConferenceCall.setStatus(Call_1.Call.Status.ACTIVE);\r\n                newConferenceCall.setDeviceType();\r\n                that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) create newConferenceCall - \", newConferenceCall);\r\n                that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) create newConferenceCall - stored :\", that.telephonyService.getCallFromCache(newConferenceCall.id));\r\n                //that.logger.log(\"internal\", LOG_ID + \"(onConferenceEvent) send evt_internal_callupdated \", newConferenceCall);\r\n                let conferenceInfos = {\r\n                    primaryOldCall: primaryOldCall,\r\n                    secondaryOldCall: secondaryOldCall,\r\n                    newConferenceCall: newConferenceCall,\r\n                    participants: confContactsInfos\r\n                };\r\n                that.eventEmitter.emit(\"evt_internal_conferenced\", conferenceInfos);\r\n                that.eventEmitter.emit(\"evt_internal_callupdated\", newConferenceCall);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", newConferenceCall);\r\n            }));\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** VOICE MESSAGE STUFF                                            **/\r\n        /*********************************************************************/\r\n        this.onVoiceMessageEvent = function (messagingElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onVoiceMessageEvent) _entering_ : \", messagingElem);\r\n            // Ignore forbidden requests\r\n            if (!that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_VOICE_MAIL)) {\r\n                that.logger.log(\"debug\", LOG_ID + \"(onVoiceMessageEvent) feature not enabled => IGNORED event\");\r\n                return Promise.resolve();\r\n            }\r\n            // Look for a voiceMessageCounter child\r\n            let voiceMessageCounterValue = messagingElem.getChild(\"voiceMessageCounter\").text();\r\n            if (voiceMessageCounterValue) {\r\n                let ct = Number(voiceMessageCounterValue);\r\n                if (Number.isInteger(ct) && (ct >= 0)) {\r\n                    that.telephonyService.voiceMail.setVMCounter(ct);\r\n                    that.telephonyService.voiceMail.setVMFlag((ct > 0));\r\n                    that.telephonyService.voiceMail.setInfoMsg(\"\");\r\n                    //$rootScope.$broadcast(\"ON_VOICE_MESSAGE_UPDATE_EVENT\", ct);\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onVoiceMessageEvent) send evt_internal_voicemessageupdated \", ct);\r\n                    that.eventEmitter.emit(\"evt_internal_voicemessageupdated\", ct);\r\n                }\r\n            }\r\n            // No voiceMessageCounter child look for voiceMessageWaiting child\r\n            let voiceMessageWaitingValue = \"\";\r\n            let voiceMessageWaiting = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(messagingElem, \"voiceMessageWaiting\");\r\n            if (voiceMessageWaiting) {\r\n                voiceMessageWaitingValue = voiceMessageWaiting.text();\r\n                if (voiceMessageWaitingValue === \"changed\") {\r\n                    return that.telephonyService.getVoiceMessageCounter();\r\n                }\r\n            }\r\n            return Promise.resolve();\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** UPDATECALL STUFF                                                **/\r\n        /*********************************************************************/\r\n        this.onUpDateCallEvent = function (updatecallElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) _entering_ : \", updatecallElem);\r\n            return that.getCall(updatecallElem).then(function (call) {\r\n                let jid = updatecallElem.attr(\"endpointIm\");\r\n                let phoneNumber = updatecallElem.attr(\"endpointTel\");\r\n                let firstName = \"\";\r\n                let lastName = \"\";\r\n                let identity = updatecallElem.getChild(\"identity\");\r\n                let identityFirstName = identity.attr(\"firstName\");\r\n                let identityLastName = updatecallElem.getChild(\"identity\").attr(\"lastName\");\r\n                let identityDisplayName = updatecallElem.getChild(\"identity\").attr(\"displayName\");\r\n                let contactUpdateDone = false;\r\n                if (!config_1.config.permitSearchFromPhoneBook) { // <--- allow to permit search even if not the good profile\r\n                    //check if phonebook is allowed by profile else no result\r\n                    if (!that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_PHONE_BOOK)) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) xnames not allowed for the user profile => IGNORED event\");\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n                //find Xnames from directories\r\n                if (identityLastName && identityLastName.length) {\r\n                    lastName = identityLastName;\r\n                    if (identityFirstName && identityFirstName.length) {\r\n                        firstName = identityFirstName;\r\n                    }\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) received for call \", call.id, \" for phoneNumber:\", Utils.anonymizePhoneNumber(phoneNumber), \" with name : \", firstName.slice(0, 1), \"***\");\r\n                }\r\n                else {\r\n                    if (identityDisplayName && identityDisplayName.length && identityDisplayName !== phoneNumber) {\r\n                        lastName = identityDisplayName; //Workaround last resort, only displayName is available, hack is to use it as lastName\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) only displayName available\");\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent) xnames not available => IGNORED event\");\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n                //debug+\r\n                //if (!call.currentCalled.contactPhoneNumber || call.currentCalled.contactPhoneNumber === \"\") {\r\n                //  $log.debug(\"[TelephonyServiceEventHandler] onUpDateCallEvent  call.currentCalled.contactPhoneNumber EMPTY !!!\");\r\n                //  $log.debug(\"[TelephonyServiceEventHandler] for call \" + call.id + \" conf = \" + call.isConference);\r\n                //}\r\n                //debug-\r\n                // update contact as necessary\r\n                return contactService.getOrCreateContact(jid, phoneNumber)\r\n                    .then(function (contact) {\r\n                    if (contact.temp) { //not a rainbow user\r\n                        contact.updateName(firstName, lastName);\r\n                        if (call.contact && call.contact._id) { //not a conf\r\n                            let currentCalled = { contactPhoneNumber: phoneNumber, contact: contact };\r\n                            if (call.contact._id !== contact._id || call.contact.displayName === phoneNumber || call.contact.getNameUpdatePrio() === NameUpdatePrio.OUTLOOK_UPDATE_PRIO) {\r\n                                contact.setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\r\n                                call.setContact(contact);\r\n                                call.setCurrentCalled(currentCalled);\r\n                                contactUpdateDone = true;\r\n                                that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) xnames updated for \", phoneNumber, \"with contact : \", contact.displayNameMD5);\r\n                            }\r\n                        }\r\n                        else if (call.participants && call.participants.length > 0) {\r\n                            let currentCalled = call.getCurrentCalled();\r\n                            for (let i = 0; i < call.participants.length; i++) {\r\n                                if (call.participants[i].temp) {\r\n                                    if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) { //concerned participant\r\n                                        that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) temp participant \", call.participants[i].displayNameMD5, \" updated with : \", contact.displayNameMD5);\r\n                                        call.participants[i] = contact;\r\n                                        call.participants[i].setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\r\n                                        currentCalled.participantsPhoneNumbers[i] = phoneNumber;\r\n                                        currentCalled.participants[i] = contact;\r\n                                        contactUpdateDone = true;\r\n                                    }\r\n                                }\r\n                                else { //former participant is a rainbow user I don't know what to do !!!???\r\n                                    that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) STRANGE former participant was a rainbow: \", call.participants[i].displayNameMD5);\r\n                                }\r\n                            }\r\n                            call.setCurrentCalled(currentCalled);\r\n                        }\r\n                    }\r\n                    else { //rainbow contact found\r\n                        if (call.contact && call.contact._id) { //not a conf\r\n                            let currentCalled = { contactPhoneNumber: phoneNumber, contact: contact };\r\n                            if (call.contact._id !== contact._id) { //update call.contact if not the good one\r\n                                //workaround+ Because of msg crossing pb udate old temp contact before to set the new one\r\n                                if (call.contact.temp) {\r\n                                    call.contact.updateName(firstName, lastName);\r\n                                    call.contact.setNameUpdatePrio(NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\r\n                                }\r\n                                //workaround-\r\n                                call.setContact(contact);\r\n                                call.setCurrentCalled(currentCalled);\r\n                                contactUpdateDone = true;\r\n                                that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) call update with rainbow contact : \", contact.displayNameMD5);\r\n                            }\r\n                        }\r\n                        else if (call.participants && call.participants.length > 0) {\r\n                            let currentCalled = call.getCurrentCalled();\r\n                            for (let i = 0; i < call.participants.length; i++) {\r\n                                if (call.participants[i].temp) {\r\n                                    if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) { //concerned participant\r\n                                        that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) temp participant \", call.participants[i].displayNameMD5, \" updated with : \", contact.displayNameMD5);\r\n                                        call.participants[i] = contact;\r\n                                        call.setParticipants(call.participants); //to force an update of the avatars\r\n                                        currentCalled.participantsPhoneNumbers[i] = phoneNumber;\r\n                                        currentCalled.participants[i] = contact;\r\n                                        contactUpdateDone = true;\r\n                                    }\r\n                                }\r\n                                else { //if former participant is the same rainbow user nothing to do except store phoneNumber and participant in call\r\n                                    if (call.participants[i].jid === jid) { //concerned participant\r\n                                        //call.participants[i] = contact;\r\n                                        currentCalled.participantsPhoneNumbers[i] = phoneNumber;\r\n                                        currentCalled.participants[i] = call.participants[i];\r\n                                        contactUpdateDone = true; //??\r\n                                        that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent)rainbow participant \", call.participants[i].displayNameMD5, \" updated with the same : \", contact.displayNameMD5);\r\n                                    }\r\n                                    else { //not the  good participant nothing to do\r\n                                        that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) other participant not updated : \", call.participants[i].displayNameMD5, \" vs \", contact.displayNameMD5);\r\n                                    }\r\n                                }\r\n                            }\r\n                            call.setCurrentCalled(currentCalled);\r\n                        }\r\n                    }\r\n                    if (contactUpdateDone) {\r\n                        //that.logger.log(\"internal\", LOG_ID + \"(onUpDateCallEvent) send evt_internal_callupdated \", call);\r\n                        that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                        /*//CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\r\n                        // with telescoping with incoming call popup\r\n                        $interval(function () {\r\n                            $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                        }, 300, 1);\r\n                        // */\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUpDateCallEvent), no update needed for call : \", call.id);\r\n                    }\r\n                });\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** FAILURE STUFF                                                   **/\r\n        /*********************************************************************/\r\n        this.onFailCallEvent = function (failedElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onFailCallEvent) _entering_ : \", failedElem);\r\n            let cause = failedElem.attr(\"cause\");\r\n            //let that = this;\r\n            return that.getCall(failedElem).then(function (call) {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    call.setStatus(Call_1.Call.Status.ERROR);\r\n                    call.errorMessage = CallFailureLabels[cause];\r\n                    //call.autoClear = $interval(function () {\r\n                    yield that.telephonyService.clearCall(call);\r\n                    //}, 5000, 1);\r\n                    if (!call.errorMessage) {\r\n                        call.errorMessage = cause;\r\n                    }\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(onFailCallEvent) send evt_internal_callupdated \", call);\r\n                    that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                });\r\n            });\r\n            // */\r\n        };\r\n        /*********************************************************************/\r\n        /** FORWARD CALL STUFF                                              **/\r\n        /*********************************************************************/\r\n        this.onCallForwardedEvent = function (forwardElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onCallForwardedEvent) _entering_ : \", forwardElem);\r\n            let call = {\r\n                \"forwardType\": forwardElem.attr(\"forwardType\"),\r\n                \"forwardTo\": forwardElem.attr(\"forwardTo\")\r\n            };\r\n            //that.logger.log(\"internal\", LOG_ID + \"(onCallForwardedEvent) send evt_internal_callforwarded \", call);\r\n            that.eventEmitter.emit(\"evt_internal_callforwarded\", call);\r\n            return Promise.resolve();\r\n            /* $rootScope.$broadcast(\"ON_CALL_FORWARDED_EVENT\", {\r\n                 \"forwardType\": forwardElem.attr(\"forwardType\"),\r\n                 \"forwardTo\": forwardElem.attr(\"forwardTo\")\r\n             });\r\n             return $q.when();\r\n             // */\r\n        };\r\n        /*\r\n <message xmlns=\"jabber:client\" xml:lang=\"en\" to=\"38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/node_ztapimhe\" from=\"tel_38db98d2907a4c4095742a237b84557c@vberder-all-in-one-dev-1.opentouch.cloud/phone\">\r\n <callservice xmlns=\"urn:xmpp:pbxagent:callservice:1\" xmlns:ns7=\"urn:xmpp:pbxagent:callservice:1\">\r\n <nomadicStatus destination=\"23031\" featureActivated=\"true\" makeCallInitiatorIsMain=\"false\" modeActivated=\"true\"/>\r\n         */\r\n        /*********************************************************************/\r\n        /** NOMADIC STATUS STUFF                                              **/\r\n        /*********************************************************************/\r\n        this.onNomadicStatusEvent = function (eventElem) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(onNomadicStatusEvent) _entering_ : \", eventElem);\r\n            let nomadicstate = {\r\n                \"featureActivated\": eventElem.attr(\"featureActivated\"),\r\n                \"modeActivated\": eventElem.attr(\"modeActivated\"),\r\n                \"destination\": eventElem.attr(\"destination\"),\r\n                \"makeCallInitiatorIsMain\": eventElem.attr(\"makeCallInitiatorIsMain\")\r\n            };\r\n            that.telephonyService.updateNomadicData(nomadicstate);\r\n            //that.logger.log(\"debug\", LOG_ID + \"(onFailCallEvent) send onNomadicStatusEvent \", call);\r\n            //that.eventEmitter.emit(\"onNomadicStatusEvent\", call);\r\n            return Promise.resolve();\r\n            /* $rootScope.$broadcast(\"ON_CALL_FORWARDED_EVENT\", {\r\n                 \"forwardType\": forwardElem.attr(\"forwardType\"),\r\n                 \"forwardTo\": forwardElem.attr(\"forwardTo\")\r\n             });\r\n             return $q.when();\r\n             // */\r\n        };\r\n        /*********************************************************************/\r\n        /** PRIVATE UTILITY METHODS                                         **/\r\n        /*********************************************************************/\r\n        this.getCall = (elem) => __awaiter(this, void 0, void 0, function* () {\r\n            let jid = elem.getAttr(\"endpointIm\");\r\n            let phoneNumber = elem.getAttr(\"endpointTel\");\r\n            let connectionId = elem.getAttr(\"callId\");\r\n            let deviceType = elem.getAttr(\"deviceType\");\r\n            let cause = elem.attr(\"cause\");\r\n            let deviceState = elem.attr(\"deviceState\");\r\n            let type = elem.attr(\"type\");\r\n            let globalCallId = elem.attr(\"globalCallId\");\r\n            let correlatorData = elem.attr(\"correlatorData\");\r\n            if (!connectionId) {\r\n                connectionId = elem.getAttr(\"heldCallId\");\r\n            } // TODO: WHY and WHEN\r\n            that.logger.log(\"debug\", LOG_ID + \"(getCall)  - \", jid, \" - \", Utils.anonymizePhoneNumber(phoneNumber), \" - \", connectionId);\r\n            that.logger.log(\"internal\", LOG_ID + \"(getCall) jid : \", jid, \", phoneNumber : \", phoneNumber, \", connectionId : \", connectionId, \", deviceType : \", deviceType);\r\n            let callObj = yield that.getOrCreateCall(connectionId, jid, deviceType, phoneNumber);\r\n            let updatedinformations = {};\r\n            if (connectionId != null) {\r\n                updatedinformations.connectionId = connectionId;\r\n            }\r\n            if (jid != null) {\r\n                updatedinformations.jid = jid;\r\n            }\r\n            if (deviceType != null) {\r\n                updatedinformations.deviceType = deviceType;\r\n            }\r\n            if (phoneNumber != null) {\r\n                updatedinformations.phoneNumber = phoneNumber;\r\n            }\r\n            if (cause != null) {\r\n                updatedinformations.cause = cause;\r\n            }\r\n            if (deviceState != null) {\r\n                updatedinformations.deviceState = deviceState;\r\n            }\r\n            if (type != null) {\r\n                updatedinformations.cause = type;\r\n            }\r\n            if (globalCallId != null) {\r\n                updatedinformations.globalCallId = globalCallId;\r\n            }\r\n            if (correlatorData != null) {\r\n                updatedinformations.correlatorData = correlatorData;\r\n            }\r\n            callObj.updateCall(updatedinformations);\r\n            // */\r\n            return callObj;\r\n        });\r\n        this.getOrCreateCall = function (connectionId, jid, deviceType, phoneNumber) {\r\n            // let that = this;\r\n            let callId = Call_1.Call.getIdFromConnectionId(connectionId);\r\n            let call = that.telephonyService.getCallFromCache(callId);\r\n            if (call) {\r\n                return Promise.resolve(call);\r\n            }\r\n            return new Promise(function (resolve) {\r\n                if (jid || phoneNumber) {\r\n                    that.contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\r\n                        resolve(that.telephonyService.getOrCreateCall(Call_1.Call.Status.UNKNOWN, connectionId, deviceType, contact));\r\n                    });\r\n                }\r\n                else {\r\n                    resolve(that.telephonyService.getOrCreateCall(Call_1.Call.Status.UNKNOWN, connectionId, deviceType, null));\r\n                }\r\n            });\r\n            // */\r\n        };\r\n        this.createConferenceCall = function (connectionId, participants) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let conferenceCall = yield that.getOrCreateCall(connectionId, undefined, undefined, undefined);\r\n                that.logger.log(\"internal\", LOG_ID + \"(createConferenceCall) conferenceCall : \", conferenceCall);\r\n                conferenceCall.isConference = true;\r\n                conferenceCall.setParticipants(participants);\r\n                //that.telephonyService.addOrUpdateCallToCache(conferenceCall)\r\n                that.logger.log(\"debug\", LOG_ID + \"(createConferenceCall) conferenceCall stored : \", that.telephonyService.getCallFromCache(conferenceCall.id));\r\n                return conferenceCall;\r\n                /*\r\n                // Create and configure the conference call\r\n                let conferenceCall = Call.create(Call.Status.UNKNOWN, null, Call.Type.PHONE);\r\n                conferenceCall.setConnectionId(connectionId);\r\n                conferenceCall.isConference = true;\r\n                conferenceCall.setParticipants(participants);\r\n                this.telephonyService._calls[conferenceCall.id] = conferenceCall;\r\n                return conferenceCall;\r\n                // */\r\n            });\r\n        };\r\n    }\r\n    /*********************************************************************/\r\n    /** CALL UPDATE STUFF                                               **/\r\n    /*********************************************************************/\r\n    /**\r\n     * Method analyzeContactChange\r\n     * Analyse if a setContact has to be done following situation\r\n     * @public\r\n     * @param jid [required] jid from PCG\r\n     * @param phoneNumber [required] phone number from PCG\r\n     * @param call [required] the call to update\r\n     * @returns object:{ updateContactToBeDone : boolean, searchOutlookToBeDone :boolean}\r\n     *  updateContactToBeDone true if the contact has to be updated in the call (by setContact)\r\n     *  searchOutlookToBeDone true if an outlook search has to be performed to resolve call identity\r\n     * @memberof TelephonyServiceEventHandler\r\n     */\r\n    analyzeContactChange(jid, phoneNumber, call) {\r\n        let updateContact = false;\r\n        if (!jid && !phoneNumber) { //nothing could be analysed then updated\r\n            return null;\r\n        }\r\n        // One2One Call (not a conference) only call.contact is impacted\r\n        if (!call.isConference) {\r\n            // No contact... Whatever situation set contact\r\n            if (!call.contact) {\r\n                return { updateContactToBeDone: true };\r\n                //return { updateContactToBeDone: true, searchOutlookToBeDone: false };  //OUTLOOK NOT YET DELIVERED\r\n            }\r\n            // PCG known the distant as a rainbow user (no outlook search is necessary)\r\n            if (jid !== \"\") {\r\n                // Only change if not the same from previous call setting\r\n                if (call.contact._id !== jid) {\r\n                    updateContact = true;\r\n                }\r\n            }\r\n            // No jid available\r\n            else {\r\n                // call.contact not known as rainbow user, contact._id contain former phoneNumber\r\n                if (call.contact.temp) {\r\n                    if ((call.contact._id !== phoneNumber) //called change\r\n                    ) {\r\n                        updateContact = true;\r\n                    }\r\n                    else if (call.contact.displayName === phoneNumber) { //no change but name not known\r\n                        updateContact = false;\r\n                        //searchOutlook = false; //OUTLOOK NOT YET DELIVERED\r\n                    }\r\n                }\r\n                // call.contact known as rainbow user update only if phoneNumber change (except ringing empty case)\r\n                else if (call.getCurrentCalled().contactPhoneNumber !== \"\" && phoneNumber !== \"\") {\r\n                    if (call.getCurrentCalled().contactPhoneNumber !== phoneNumber) {\r\n                        updateContact = true;\r\n                    }\r\n                }\r\n            }\r\n            return (updateContact) ? {\r\n                updateContactToBeDone: updateContact,\r\n            } : null;\r\n        }\r\n    }\r\n    /**\r\n     * Method updateCallContact\r\n     * @public\r\n     * @param jid [required] jid from PCG\r\n     * @param phoneNumber [required] phone number from PCG\r\n     * @param actionElemName [required] name of the action event\r\n     * @param call [required] the call to update\r\n     * @returns {ng.IPromise<{}>} status promise\r\n     * @memberof TelephonyServiceEventHandler\r\n     */\r\n    updateCallContact(jid, phoneNumber, actionElemName, call) {\r\n        let that = this;\r\n        try {\r\n            // Determine if the contact has to be updated from event information\r\n            let updateAnalyse = that.analyzeContactChange(jid, phoneNumber, call);\r\n            // Whatever the contact change, for simple call, after analyse, update at least the call current phoneNumber\r\n            if (!call.isConference && phoneNumber !== \"\") {\r\n                call.setCurrentCalledContactNumber(phoneNumber);\r\n            }\r\n            if (updateAnalyse) {\r\n                return that.contactService.getOrCreateContact(jid, phoneNumber)\r\n                    .then(function (contact) {\r\n                    that.logger.log(\"internal\", LOG_ID + \"(updateCallContact)  on \", actionElemName, \", update contact :\", contact.displayNameMD5);\r\n                    that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\r\n                    return Promise.resolve();\r\n                });\r\n            }\r\n            else {\r\n                //that.logger.log(\"internal\", LOG_ID + \"(updateCallContact) send evt_internal_callupdated \", call);\r\n                that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                return Promise.resolve();\r\n            }\r\n        }\r\n        catch (error) {\r\n            let errorMessage = \"updateCallContact -- \" + error.message;\r\n            that.logger.log(\"error\", LOG_ID + \"(updateCallContact) Catch Error !!! \");\r\n            that.logger.log(\"internalerror\", LOG_ID + \"(updateCallContact) Catch Error !!! : \", errorMessage);\r\n            return Promise.reject(new Error(errorMessage));\r\n        }\r\n    }\r\n    makeUpdateContact(call, contact, phoneNumber, actionElemName) {\r\n        let that = this;\r\n        call.setContact(contact);\r\n        let currentCalled = { contactPhoneNumber: phoneNumber, contact: contact };\r\n        call.setCurrentCalled(currentCalled);\r\n        //that.logger.log(\"internal\", LOG_ID + \"(makeUpdateContact) send evt_internal_callupdated \", call);\r\n        that.eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n        /* if (actionElemName === \"delivered\" && call.status === Call.Status.RINGING_INCOMING) {\r\n             //CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\r\n             // with telescoping with incoming call popup\r\n             $interval(function () {\r\n                 $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n             }, 300, 1);\r\n         }\r\n         else {\r\n             //$interval(function() { $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call); }, 300, 1);\r\n             $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n         }\r\n         // */\r\n    }\r\n};\r\nTelephonyEventHandler = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID)\r\n], TelephonyEventHandler);\r\nexports.TelephonyEventHandler = TelephonyEventHandler;\r\nmodule.exports.TelephonyEventHandler = TelephonyEventHandler;\r\n//# sourceMappingURL=telephonyEventHandler.js.map"]},"metadata":{},"sourceType":"script"}