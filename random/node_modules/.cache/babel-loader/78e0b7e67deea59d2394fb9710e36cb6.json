{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Call_1 = require(\"../common/models/Call\");\n\nconst VoiceMail = require(\"../common/models/VoiceMail\");\n\nconst utils = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst telephonyEventHandler_1 = require(\"../connection/XMPPServiceHandler/telephonyEventHandler\");\n\nconst LOG_ID = \"TELEPHONY/SVCE - \";\nlet Telephony =\n/**\r\n * @module\r\n * @name Telephony\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This services manages PBX phone calls in a conversation. so it manages PBX calls between your PABX associated phone and a recipient's phone. If you don't have this service activated for your Rainbow user, all these methods will return an error when called. <br/><br>\r\n *      The main methods and events proposed in that service allow to: <br>\r\n *      - Know if this service is activated or not for the connected user, <br/>\r\n *      - Know the version of the agent (deployed on the PBX) that monitors your line, <br>\r\n *      - Handle the basic telephony services: Make a call, take a call, hold a call, retrieve a call and release a call,<br/>\r\n *      - Listen to the call state change <br><br>\r\n *      Depending the agent version deployed, some services can return an error (unavailable service) when called\r\n *\r\n */\nclass Telephony {\n  constructor(_eventEmitter, logger, _startConfig) {\n    this.ready = false;\n    let that = this;\n    this._startConfig = _startConfig;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._contacts = null;\n    this._eventEmitter = _eventEmitter;\n    this._logger = logger;\n    this._calls = [];\n    this.voiceMail = null; //VoiceMail.createVoiceMail();\n\n    this.userJidTel = \"TOBEFILLED\"; //authService.jidTel;\n\n    this.started = false;\n    this.agentStatus = {};\n    this.voicemailNumber = null;\n    this.pbxId = null;\n    this.forwardObject = {};\n    this.nomadicObject = {};\n    this.nomadicAnswerNotTakedIntoAccount = false;\n    this.isBasicCallAllowed = false;\n    this.isSecondCallAllowed = false;\n    this.isTransferAllowed = false;\n    this.isConferenceAllowed = false;\n    this.isVMDeflectCallAllowed = false;\n    this.voiceMailFeatureEnabled = false;\n    this.isForwardEnabled = false;\n    this.isNomadicEnabled = false;\n    this.ready = false;\n\n    that._eventEmitter.on(\"evt_internal_presencechanged\", that.onTelPresenceChange.bind(that));\n\n    that._eventEmitter.on(\"evt_internal_callupdated\", that.onCallUpdated.bind(that)); //        that._eventEmitter.on(\"rainbow_onpbxagentstatusreceived\", that.onPbxAgentStatusChange.bind(that));\n\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    this.telephonyHandlerToken = [];\n    this.telephonyHistoryHandlerToken = [];\n    this.voiceMail = VoiceMail.createVoiceMail(_core._profiles);\n    that.startDate = new Date();\n    return new Promise((resolve, reject) => {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._contacts = _core.contacts;\n        that._bubbles = _core.bubbles;\n        that._profiles = _core.profiles;\n        that.attachHandlers();\n        this.ready = true;\n        resolve();\n      } catch (err) {\n        that._logger.log(\"error\", LOG_ID + \"(start) Catch ErrorManager !!! \");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(start) Catch ErrorManager !!! : \", err.message);\n\n        return reject();\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      try {\n        that._xmpp = null;\n        that._rest = null;\n        delete that._telephonyEventHandler;\n        that._telephonyEventHandler = null;\n\n        if (that.telephonyHandlerToken) {\n          that.telephonyHandlerToken.forEach(token => PubSub.unsubscribe(token));\n        }\n\n        that.telephonyHandlerToken = [];\n\n        if (that.telephonyHistoryHandlerToken) {\n          that.telephonyHistoryHandlerToken.forEach(token => PubSub.unsubscribe(token));\n        }\n\n        that.telephonyHistoryHandlerToken = [];\n        this.ready = false;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n    that._telephonyEventHandler = new telephonyEventHandler_1.TelephonyEventHandler(that._xmpp, that, that._contacts, that._profiles);\n    that.telephonyHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._telephonyEventHandler.MESSAGE, that._telephonyEventHandler.onMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._telephonyEventHandler.IQ_RESULT, that._telephonyEventHandler.onIqResultReceived)];\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      let that = this;\n      that._calls = []; //that.started = false;\n\n      that.agentStatus = {\n        phoneApi: \"disconnected\",\n        xmppAgent: \"stopped\",\n        agentVersion: \"unknown\"\n      };\n      that.voicemailNumber = that._contacts.userContact.voicemailNumber;\n      that.pbxId = that._contacts.userContact.pbxId;\n      that.makingCall = false;\n      that.starting = false; //that.voiceMail = VoiceMail.create();\n\n      that.forwardObject = {};\n      that.nomadicObject = {};\n      that.nomadicAnswerNotTakedIntoAccount = false;\n      that.isBasicCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_BASIC_CALL);\n      that.isSecondCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_SECOND_CALL);\n      that.isTransferAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_TRANSFER_CALL);\n      that.isConferenceAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_CONFERENCE_CALL);\n      that.isVMDeflectCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_DEFLECT_CALL);\n      that.voiceMailFeatureEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_VOICE_MAIL);\n      that.isForwardEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_CALL_FORWARD);\n      that.isNomadicEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_NOMADIC); // Store the user jid tel\n      //that.userJidTel = authService.jidTel;\n\n      that.userJidTel = that._rest.loggedInUser.jid_tel;\n      that.started = false;\n\n      try {\n        that._xmpp.getAgentStatus().then(data => {\n          that._logger.log(\"info\", LOG_ID + \"[init] getAgentStatus  -- \", data);\n\n          resolve();\n        });\n      } catch (err) {\n        that._logger.log(\"warn\", LOG_ID + \"[init] getAgentStatus failed : \", err);\n\n        resolve();\n      }\n    });\n  }\n  /* onPbxAgentStatusChange(data) {\r\n      let that = this;\r\n      that.agentStatus = data;\r\n  } // */\n\n  /**\r\n   * @private\r\n   * @method onTelPresenceChange\r\n   * @instance\r\n   * @description\r\n   *      Method called when receiving an update on user presence\r\n   */\n\n\n  onTelPresenceChange(__event, attr) {\n    let that = this;\n\n    if (that._contacts.isTelJid(__event.fulljid)) {\n      if (that._contacts.getRessourceFromJid(__event.fulljid) !== \"phone\") {\n        return true;\n      }\n\n      let jid_im = that._contacts.getImJid(__event.fulljid);\n\n      if (!jid_im) {\n        return true;\n      }\n\n      let status = __event.status;\n\n      if (that._contacts.isUserContactJid(jid_im)) {\n        // Receive unavailable status\n        if (status === \"unavailable\" || status === \"offline\" || status === \"\") {\n          that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] received my telephony presence -- \" + status);\n\n          that.started = false;\n          that._calls = [];\n\n          that._logger.log(\"debug\", LOG_ID + \"(onTelPresenceChange) send evt_internal_telephonystatuschanged \", \"stopped\");\n\n          that._eventEmitter.emit(\"evt_internal_telephonystatuschanged\", \"stopped\"); //$rootScope.$broadcast(\"ON_TELEPHONY_STATUS_CHANGED_EVENT\", \"stopped\");\n\n\n          that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] === STOPPED ===\");\n        } // Service is not started, try to fetch agent status\n        else if (!that.started && !that.starting) {\n            that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] received my telephony presence -- \" + status);\n\n            that.starting = true;\n            that.getAgentStatus().then(function () {\n              // that.attachHandlers();\n              return that.getTelephonyState(false);\n            }).then(function () {\n              if (that.isNomadicEnabled) {\n                that.getNomadicStatus().then(function () {\n                  if (that.nomadicObject.featureActivated && that.nomadicObject.modeActivated && !that.nomadicObject.makeCallInitiatorIsMain) {\n                    return that.getTelephonyState(true);\n                  } //return Promise.resolve();\n\n                });\n              } //return Promise.resolve();\n\n            }).then(function () {\n              if (that.isForwardEnabled) {\n                return that.getForwardStatus();\n              } //return Promise.resolve();\n\n            }).then(function () {\n              // @ts-ignore\n              let startDuration = Math.round(new Date() - that.startDate); // that.stats.push({ service: \"telephonyService\", startDuration: startDuration });\n\n              that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] === STARTED (\" + startDuration + \" ms) ===\");\n\n              that.started = true;\n              that.starting = false;\n\n              that._logger.log(\"debug\", LOG_ID + \"(onTelPresenceChange) send evt_internal_telephonystatuschanged \", \"started\");\n\n              that._eventEmitter.emit(\"evt_internal_telephonystatuschanged\", \"started\"); //$rootScope.$broadcast(\"ON_TELEPHONY_STATUS_CHANGED_EVENT\", \"started\");\n\n            }).catch(function (error) {\n              that.starting = false;\n\n              that._logger.log(\"error\", LOG_ID + \"[onTelPresenceChange] receive telephony presence but no agent response - \");\n\n              that._logger.log(\"internalerror\", LOG_ID + \"[onTelPresenceChange] receive telephony presence but no agent response - : \" + error.message);\n            });\n          }\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * @private\r\n   * @method onCallUpdated\r\n   * @instance\r\n   * @description\r\n   *      Method called when receiving an update on a call\r\n   */\n\n\n  onCallUpdated(callInfo) {\n    let that = this;\n    let status = callInfo.status;\n    if (!status || !callInfo.id) return;\n    /*\r\n    switch (status.key) {\r\n        case Call.Status.UNKNOWN:\r\n            // Delete ended call call\r\n            if (callInfo.cause === \"NORMALCLEARING\") {\r\n                that._logger.log(\"debug\", LOG_ID + \"(onCallUpdated) clearing the call : \", callInfo.id);\r\n                delete this._calls[callInfo.id];\r\n            } else {\r\n                that._logger.log(\"debug\", LOG_ID + \"(onCallUpdated) Not a normal stop of call, so clearing the call : \", callInfo.id);\r\n                delete this._calls[callInfo.id];\r\n            }\r\n            break;\r\n        case Call.Status.DIALING:\r\n        case Call.Status.QUEUED_OUTGOING:\r\n        case Call.Status.ACTIVE:\r\n        case Call.Status.RELEASING:\r\n        case Call.Status.ANSWERING:\r\n        case Call.Status.PUT_ON_HOLD:\r\n        case Call.Status.CONNECTING:\r\n        case Call.Status.RINGING_OUTGOING:\r\n        case Call.Status.QUEUED_INCOMING:\r\n        case Call.Status.ERROR:\r\n        case Call.Status.HOLD:\r\n        case Call.Status.RINGING_INCOMING:\r\n            if ( that._calls[callInfo.id] ) {\r\n                that._calls[callInfo.id].updateCall(callInfo);\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n       */\n  }\n  /**\r\n   * @public\r\n   * @method isTelephonyAvailable\r\n   * @instance\r\n   * @description\r\n   *    Check if the telephony service can be used or not (if the connected user has a phone monitored by a PBX)\r\n   * @return {boolean} Return true if the telephony service is configured\r\n   */\n\n\n  isTelephonyAvailable() {\n    return this.started;\n  }\n  /**\r\n   * @public\r\n   * @method getAgentVersion\r\n   * @instance\r\n   * @description\r\n   *    Get the associated PBX agent version\r\n   * @return {string} Return the version of the agent or \"unknown\"\r\n   */\n\n\n  getAgentVersion() {\n    let that = this;\n    return that.agentStatus.agentVersion || \"unknown\";\n  }\n  /**\r\n   * @public\r\n   * @method getXMPPAgentStatus\r\n   * @instance\r\n   * @description\r\n   *    Get the status of the XMPP connection to the PBX Agent\r\n   * @return {string} Return the status of the connections to the agent or \"unknown\"\r\n   */\n\n\n  getXMPPAgentStatus() {\n    let that = this;\n    return that.agentStatus.xmppAgent || \"unknown\";\n  }\n  /**\r\n   * @public\r\n   * @method getPhoneAPIStatus\r\n   * @instance\r\n   * @description\r\n   *    Get the status of the Phone API status for the PBX Agent\r\n   * @return {string} Return the Phone API status for to this Agent or \"unknown\"\r\n   */\n\n\n  getPhoneAPIStatus() {\n    let that = this;\n    return that.agentStatus.phoneApi || \"unknown\";\n  }\n\n  getAgentStatus() {\n    let that = this; //return that.agentStatus;\n\n    return that._xmpp.getAgentStatus().then(data => {\n      that._logger.log(\"info\", LOG_ID + \"[getAgentStatus] -- \", data);\n\n      that.agentStatus = data;\n      return data;\n    }); // */\n  }\n  /**\r\n   * @private\r\n   * @method getTelephonyState\r\n   * @param second\r\n   */\n\n\n  getTelephonyState(second) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._xmpp.getTelephonyState(second).then(data => {\n        let existingCalls = data;\n\n        if (existingCalls && that.getTabSize(existingCalls) > 0) {\n          // Traverse existing call\n          let getCallPromises = [];\n          existingCalls.forEach(child => {\n            getCallPromises.push(that.createCallFromConnectionElem(child));\n          }); // Send all getContactPromise\n\n          Promise.all(getCallPromises).then(function () {\n            that._logger.log(\"debug\", LOG_ID + \"getTelephonyState -- success\");\n\n            resolve();\n          }).catch(function (error) {\n            that._logger.log(\"error\", LOG_ID + \"getTelephonyState -- failure -- \");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"getTelephonyState -- failure -- : \", error.message);\n\n            return reject(error);\n          });\n        } //return data;\n\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @param connectionElemObj\r\n   */\n\n\n  createCallFromConnectionElem(connectionElemObj) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Extract information\n      //let connectionElem = angular.element(connectionElemObj);\n      let connectionElem = connectionElemObj;\n      let jid = connectionElem.attr(\"endpointIm\");\n      let phoneNumber = connectionElem.attr(\"endpointTel\");\n      let connectionId = connectionElem.attr(\"callId\");\n      let endpointLci = connectionElem.attr(\"endpointLci\");\n      let lci = connectionElem.attr(\"lci\");\n      let participantsElem = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(connectionElem, \"participants\"); // connectionElem.find(\"participant\");\n\n      let identityElem = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(connectionElem, \"identity\");\n      let identityFirstName = identityElem.attr(\"firstName\");\n      let identityLastName = identityElem.attr(\"lastName\");\n      let firstName = \"\";\n      let lastName = \"\";\n\n      if (!jid && !phoneNumber) {\n        phoneNumber = \"****\";\n      } //manage name resolution\n\n\n      if (that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_PHONE_BOOK)) {\n        //find Xnames, here for simple call only\n        if (participantsElem.length === 0 && identityLastName && identityLastName.length) {\n          lastName = identityLastName;\n\n          if (identityFirstName && identityFirstName.length) {\n            firstName = identityFirstName;\n          }\n\n          that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - name resolution for: \" + connectionId + \" for phoneNumber:\" + utils.anonymizePhoneNumber(phoneNumber) + \" with firstname : \" + firstName.slice(0, 1) + \"***\");\n        }\n      } // Ignore useless info\n\n\n      if (lci === \"LCI_INITIATED\") {\n        resolve();\n      } //service.getSnapshotCall(connectionId);\n      // Define getParticipants promise\n\n\n      let getParticipants = function () {\n        if (participantsElem.children.length === 0) {\n          return that._contacts.getOrCreateContact(jid, phoneNumber);\n        }\n\n        return that.getParticipantsFromParticipantsElem(participantsElem);\n      }; // Call the promise\n\n\n      getParticipants().then(function (response) {\n        // Extract call status\n        let callStatus = Call_1.Call.Status.ACTIVE;\n\n        if (lci === \"LCI_HELD\" && endpointLci === \"LCI_CONNECTED\") {\n          callStatus = Call_1.Call.Status.HOLD;\n        }\n\n        if (lci === \"LCI_CONNECTED\" && endpointLci === \"LCI_HELD\") {\n          callStatus = Call_1.Call.Status.PUT_ON_HOLD;\n        }\n\n        if (lci === \"LCI_CONNECTED\" && endpointLci === \"LCI_QUEUED\") {\n          callStatus = Call_1.Call.Status.QUEUED_OUTGOING;\n        }\n\n        if (lci === \"LCI_QUEUED\" && endpointLci === \"LCI_CONNECTED\") {\n          callStatus = Call_1.Call.Status.QUEUED_INCOMING;\n        } // Create the call object\n\n\n        let call = null;\n        let deviceType = connectionElem.find(\"deviceType\");\n\n        if (participantsElem.children.length === 0) {\n          if (response && response.temp && lastName !== \"\") {\n            response.updateName(firstName, lastName);\n          }\n\n          call = that.getOrCreateCall(callStatus, connectionId, deviceType, response);\n\n          that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - create call for user: \" + response.id + \" with callId: \" + connectionId + \" \" + lci);\n        } else {\n          call = that.getOrCreateCall(callStatus, connectionId, deviceType, null);\n          call.setParticipants(response);\n          call.isConference = true;\n\n          that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - create conference call with callId: \" + connectionId + \" \" + lci);\n        }\n\n        call.relevantEquipmentId = Call_1.Call.getDeviceIdFromConnectionId(connectionId); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n        // Send call update event\n        //that._logger.log(\"internal\", LOG_ID + \"(createCallFromConnectionElem) send evt_internal_callupdated \", call);\n\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\n\n        resolve(call);\n      }).catch(function (error) {\n        that._logger.log(\"error\", LOG_ID + \" createCallFromConnectionElem - failure - \");\n\n        that._logger.log(\"internalerror\", LOG_ID + \" createCallFromConnectionElem - failure - : \", error.message);\n\n        return reject(error);\n      });\n    });\n  }\n\n  /**\r\n   * @private\r\n   * @method getParticipantsFromParticipantsElem\r\n   * @param participants\r\n   */\n  getParticipantsFromParticipantsElem(participants) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      let confParticipants = []; // Create getParticipantPromise\n\n      let participantPromises = [];\n      participants.each(function (elemt) {\n        let participantElem = elemt;\n        let endpointTel = participantElem.find(\"endpointTel\").text();\n        let endpointIm = participantElem.find(\"endpointIm\").text();\n\n        if (!(endpointIm && that._contacts.isUserContactJid(endpointIm))) {\n          participantPromises.push(new Promise(function (resolvePromise, rejectPromise) {\n            if (!endpointIm && !endpointTel) {\n              endpointTel = \"****\";\n            }\n\n            that._contacts.getOrCreateContact(endpointIm, endpointTel).then(function (contact) {\n              confParticipants.push(contact);\n              resolvePromise();\n            }).catch(function (error) {\n              rejectPromise(error);\n            });\n          }));\n        }\n      }); // Get participants asynchronously\n\n      Promise.all(participantPromises).then(function success() {\n        resolve(confParticipants);\n      }, function failure(error) {\n        return reject(error);\n      });\n    });\n  }\n\n  /**\r\n   * @public\r\n   * @method getVoiceMessageCounter\r\n   * @description\r\n   *      Get the number of voice message\r\n   * @return {Promise<integer>} Return resolved promise if succeed with the number of messages, and a rejected else.\r\n   */\n  getVoiceMessageCounter() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      //reject not allowed operations\n      if (!that.voiceMailFeatureEnabled) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"getVoiceMessageCounter failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(getVoiceMessageCounter) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getVoiceMessageCounter) error : \", profileError.msg);\n\n        return reject(profileError);\n      }\n\n      that._xmpp.voiceMessageQuery(that.userJidTel).then(function (data) {\n        console.error(data);\n        resolve(data);\n      }).catch(function (error) {\n        let errorMessage = \"getVoiceMessageCounter failure : \" + error.message;\n\n        that._logger.log(\"error\", LOG_ID + \"(getVoiceMessageCounter) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getVoiceMessageCounter) Error : \", errorMessage);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n      });\n    });\n  }\n  /*********************************************************/\n\n  /**                   CALL HANDLERS                     **/\n\n  /*********************************************************/\n\n  /**\r\n   * @public\r\n   * @method getCallToHangOut\r\n   * @description\r\n   *      Get the call which can be hang out\r\n   * @return {Call} The call with the ability to be hang out.\r\n   */\n\n\n  getCallToHangOut() {\n    let that = this;\n    let calls = that.getActiveCalls();\n\n    if (!calls || that.getTabSize(calls) === 0) {\n      return null;\n    }\n\n    let callStatus = calls[0].status;\n\n    if (that.getTabSize(calls) === 1 || callStatus === Call_1.Call.Status.DIALING || callStatus === Call_1.Call.Status.ACTIVE || callStatus === Call_1.Call.Status.PUT_ON_HOLD) {\n      return calls[0];\n    }\n\n    return calls[1];\n  }\n  /**\r\n   * @public\r\n   * @method getActiveCall\r\n   * @description\r\n   *      get the active call\r\n   * @return {Call} The active call\r\n   */\n\n\n  getActiveCall() {\n    let that = this;\n    let activeCall = null;\n    Object.keys(that._calls || []).forEach(function (key) {\n      let call = that._calls[key];\n\n      if (call.status === Call_1.Call.Status.ACTIVE) {\n        activeCall = call;\n      }\n    });\n    return activeCall;\n  }\n  /**\r\n   * @public\r\n   * @method getActiveCalls\r\n   * @description\r\n   *      get active calls\r\n   * @return {Call} The active call\r\n   */\n\n\n  getActiveCalls() {\n    let that = this;\n    let calls = [];\n    Object.keys(that._calls || []).forEach(function (key) {\n      if (that._calls[key].status === Call_1.Call.Status.DIALING || that._calls[key].status === Call_1.Call.Status.RINGING_OUTGOING || that._calls[key].status === Call_1.Call.Status.QUEUED_OUTGOING || that._calls[key].status === Call_1.Call.Status.ACTIVE || that._calls[key].status === Call_1.Call.Status.HOLD || that._calls[key].status === Call_1.Call.Status.PUT_ON_HOLD || that._calls[key].status === Call_1.Call.Status.ERROR) {\n        calls.push(that._calls[key]);\n      }\n    });\n    return calls;\n  }\n  /**\r\n   * @public\r\n   * @method getCalls\r\n   * @description\r\n   *      get calls\r\n   * @return {Call} The calls\r\n   */\n\n\n  getCalls() {\n    let that = this;\n    let calls = [];\n    Object.keys(that._calls || []).forEach(function (key) {\n      calls.push(that._calls[key]);\n    });\n    return calls;\n  }\n  /**\r\n   * @public\r\n   * @method getCallsSize\r\n   * @description\r\n   *      get calls tab size. Warning do not use length on the getCalls method result because it is the last index id +1\r\n   * @return {Call} The calls tab size\r\n   */\n\n\n  getCallsSize() {\n    return this.getTabSize(this.getCalls());\n  }\n  /**\r\n   * @private\r\n   * @param {Array} tab The tab which need to be sized\r\n   */\n\n\n  getTabSize(tab) {\n    return Object.keys(tab).length;\n  }\n  /**\r\n   * @public\r\n   * @method getActiveCall\r\n   * @param {Contact} contact The contact with an active call with us.\r\n   * @description\r\n   *      get the active call for a contact\r\n   * @return {Call} The active call\r\n   */\n\n\n  getActiveCallsForContact(contact) {\n    let that = this;\n    let calls = [];\n\n    if (contact && contact.jid) {\n      Object.keys(that._calls || []).forEach(function (key) {\n        if (that._calls[key].contact && that._calls[key].contact.jid === contact.jid && (that._calls[key].status === Call_1.Call.Status.DIALING || that._calls[key].status === Call_1.Call.Status.RINGING_OUTGOING || that._calls[key].status === Call_1.Call.Status.ACTIVE || that._calls[key].status === Call_1.Call.Status.HOLD || that._calls[key].status === Call_1.Call.Status.PUT_ON_HOLD)) {\n          calls.push(that._calls[key]);\n        }\n      });\n    }\n\n    return calls;\n  }\n  /*************************************************************/\n\n  /*                    MAKE CALL STUFF                        */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method makeCall\r\n   * @instance\r\n   * @description\r\n   *    Call a number <br/>\r\n   *    Contacts and numbers are allowed\r\n   *    Return a promise\r\n   * @param {Contact} contact - contact object that you want to call\r\n   * @param {String} phoneNumber The number to call\r\n   * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n   * @return {Promise<Call>} Return a promise with the call created\r\n   */\n\n\n  makeCall(contact, phoneNumber, correlatorData) {\n    let that = this;\n    let activeCall = that.getActiveCall();\n\n    if (that.makingCall && !that.isSecondCallAllowed) {\n      that._logger.log(\"debug\", LOG_ID + \"(makeCall) makeCall failure - makeCall already making a call, is second call allowed ? \", that.isSecondCallAllowed);\n\n      return Promise.reject();\n    }\n\n    if (!contact) {\n      contact = {};\n    } // Set makingCall flag\n\n\n    that.makingCall = true; // Handle simpleCall\n\n    if (!activeCall) {\n      return that.makeSimpleCall(contact, phoneNumber, correlatorData);\n    } // Handle consultationCall\n\n\n    return that.makeConsultationCall(contact, phoneNumber, activeCall.connectionId, correlatorData);\n  }\n  /**\r\n   * @private\r\n   * @method makeSimpleCall\r\n   * @param contact\r\n   * @param phoneNumber\r\n   * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n   */\n\n\n  makeSimpleCall(contact, phoneNumber, correlatorData) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) to \" + (contact ? contact.displayName : phoneNumber)); //reject not allowed operations\n\n\n      if (!that.isBasicCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"makeSimpleCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(makeSimpleCall) Error.\");\n\n        that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) Error : \", profileError.msg); // Release makingCall flag\n\n\n        that.makingCall = false;\n        return reject(profileError);\n      }\n\n      let phoneInfo = that.getPhoneInfo(contact, phoneNumber, correlatorData);\n\n      that._rest.makeCall(contact, phoneInfo).then(function success(response) {\n        // Create the call object\n        let callInfos = {\n          status: Call_1.Call.Status.DIALING,\n          id: Call_1.Call.getIdFromConnectionId(response.callId),\n          type: Call_1.Call.Type.PHONE,\n          contact,\n          deviceType: undefined,\n          connectionId: response.callId\n        }; //let call = Call.CallFactory()(callInfos);\n        //let call = Call.create(Call.Status.DIALING, null, Call.Type.PHONE, contact, undefined);\n        //call.setConnectionId(response.callId);\n        // Release makinCall flag\n\n        that.makingCall = false;\n        let call = that.addOrUpdateCallToCache(callInfos); // Indicate whether it is a call to own voicemail\n\n        call.setIsVm(phoneNumber === that.voicemailNumber);\n\n        that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) success : \" + utils.anonymizePhoneNumber(phoneNumber) + \" Call (\" + call + \")\"); // Send call update event\n\n        /* TREATED BY EVENTS\r\n        that._logger.log(\"debug\", LOG_ID + \"(makeSimpleCall) send evt_internal_callupdated \", call);\r\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n         */\n        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n\n        resolve(call);\n      }, response => __awaiter(this, void 0, void 0, function* () {\n        that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) failed : \", response); //let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, contact, undefined);\n\n\n        let id = 0;\n\n        if (contact && contact.id) {\n          id = contact.id;\n        } else {\n          let min = Math.ceil(1);\n          let max = Math.floor(9999);\n          id = 9999 + Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n\n        let callInfos = {\n          status: Call_1.Call.Status.ERROR,\n          id: id + \"\",\n          type: Call_1.Call.Type.PHONE,\n          contact,\n          deviceType: undefined,\n          connectionId: id + \"#00\",\n          cause: \"error\"\n        }; //let call = Call.CallFactory()(callInfos);\n        //call.cause = \"error\";\n        //that._calls[call.contact.id] = call;\n        //this._calls.push(call);\n\n        let call = this.addOrUpdateCallToCache(callInfos);\n\n        that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) that._calls.length : \", that._calls.length); // call.autoClear = $interval(function () {\n\n\n        yield that.clearCall(call); //}, 5000, 1);\n        // Release makinCall flag\n\n        that.makingCall = false; // Send call update event\n        //that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) send evt_internal_callupdated \", call);\n\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        return reject(error); //that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) Error.\");\n        //that._logger.log(\"internalerror\", LOG_ID + \"(makeSimpleCall) Error : \", error);\n      }));\n    });\n  }\n  /**\r\n   * @private\r\n   * @method makeConsultationCall\r\n   * @param contact\r\n   * @param phoneNumber\r\n   * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n   * @param callId\r\n   */\n\n\n  makeConsultationCall(contact, phoneNumber, callId, correlatorData) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      //reject not allowed operations\n      if (!that.isSecondCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"makeConsultationCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(makeConsultationCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(makeConsultationCall) Error : \", profileError.msg); // Release makingCall flag\n\n\n        that.makingCall = false;\n        return reject(profileError);\n      }\n\n      let phoneInfo = that.getPhoneInfo(contact, phoneNumber, correlatorData);\n\n      that._rest.makeConsultationCall(callId, contact, phoneInfo).then(function success(response) {\n        // Create the call object\n        //let call = Call.create(Call.Status.DIALING, null, Call.Type.PHONE, contact, undefined);\n        let callInfos = {\n          status: Call_1.Call.Status.DIALING,\n          id: \"\",\n          type: Call_1.Call.Type.PHONE,\n          contact,\n          deviceType: undefined\n        };\n\n        if (response && response.data && response.data.data) {\n          callInfos.id = Call_1.Call.getIdFromConnectionId(response.data.data.callId);\n        } else {\n          that._logger.log(\"internal\", LOG_ID + \"(makeConsultationCall) makeConsultationCall response.data.data empty, can not find callId, get it directly in response : \", response);\n\n          callInfos.id = Call_1.Call.getIdFromConnectionId(response.callId);\n        } //let call = Call.CallFactory()(callInfos);\n        //call.setConnectionId(response.data.data.callId);\n        //that._calls[call.id] = call;\n        //this._calls.push(call);\n\n\n        let call = that.addOrUpdateCallToCache(callInfos);\n\n        that._logger.log(\"internal\", LOG_ID + \"(makeConsultationCall) makeConsultationCall success : \" + utils.anonymizePhoneNumber(phoneNumber) + \" Call (\" + call + \")\"); // Release makinCall flag\n\n\n        that.makingCall = false; // Indicate whether it is a call to own voicemail\n\n        call.setIsVm(phoneNumber === that.voicemailNumber); // Send call update event\n\n        /* TREATED BY EVENTS\r\n        that._logger.log(\"debug\", LOG_ID + \"(makeConsultationCall) send evt_internal_callupdated \", call);\r\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n         */\n        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n        resolve(call.id);\n      }, function failure(response) {\n        return __awaiter(this, void 0, void 0, function* () {\n          //let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, contact, undefined);\n          let callInfos = {\n            status: Call_1.Call.Status.ERROR,\n            id: contact.id + \"\",\n            type: Call_1.Call.Type.PHONE,\n            contact,\n            deviceType: undefined,\n            connectionId: contact.id + \"#00\",\n            cause: \"error\"\n          }; //let call = Call.CallFactory()(callInfos);\n          //call.cause = \"error\";\n          //that._calls[call.contact.id] = call;\n          //this._calls.push(call);\n\n          let call = that.addOrUpdateCallToCache(callInfos); //call.autoClear = $interval(function () {\n\n          yield that.clearCall(call); //}, 5000, 1);\n          // Release makinCall flag\n\n          that.makingCall = false; // Send call update event\n          //that._logger.log(\"debug\", LOG_ID + \"(makeConsultationCall) send evt_internal_callupdated \", call);\n\n          that._eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          return reject(error); //that._logger.log(\"error\", LOG_ID + \"(makeConsultationCall) Error\");\n          //that._logger.log(\"internalerror\", LOG_ID + \"(makeConsultationCall) Error : \", error);\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method makeCall\r\n   * @instance\r\n   * @description\r\n   *    Call a number <br/>\r\n   *    Return a promise\r\n   * @param {String} phoneNumber The number to call\r\n   * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n   * @return {Promise<Call>} Return a promise with the call created\r\n   */\n\n\n  makeCallByPhoneNumber(phoneNumber, correlatorData) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) calling : \" + utils.anonymizePhoneNumber(phoneNumber));\n\n      if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\n        let errorMessage = \"makeCallByPhoneNumber) failure: impossible to call its own phone number\";\n\n        that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) Error : \", errorMessage);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n      }\n\n      let myContact = null;\n\n      that._contacts.getOrCreateContact(null, phoneNumber).then(contact => {\n        myContact = contact;\n        return that.makeCall(contact, phoneNumber, correlatorData);\n      }).then(data => {\n        that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) after makeCall resolve result : \", data);\n\n        resolve(data);\n      }).catch(error => {\n        that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) Error : \", error);\n\n        return reject(error);\n        /* let _errorMessage = \"makeCallByPhoneNumber failure \" + (error ? error.message : \"\");\r\n         that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) - Error.\" );\r\n         that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) - Error : \", _errorMessage);\r\n        //                    let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, myContact, undefined);\r\n         let callInfos = {status : Call.Status.ERROR, id : undefined, type : Call.Type.PHONE, contact : myContact, deviceType : undefined} ;\r\n         let call = Call.CallFactory()(callInfos);\r\n         call.cause = \"invalidPhoneNumber\";\r\n         that._calls[call.contact.id] = call;\r\n         await that.clearCall(call);\r\n         //that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) send evt_internal_callupdated \", call);\r\n         that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n        //                    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n           reject(ErrorManager.getErrorManager().OTHERERROR(call.cause, _errorMessage)); // */\n      });\n    });\n  }\n  /* TO DO */\n\n  /*\t\tservice.makeCallWithMobile = function(mobileRessource, phoneNumber) {\r\n                let defer = $q.defer();\r\n                if (contactService.userContact.mobilePro === phoneNumber || contactService.userContact.mobilePerso === phoneNumber) {\r\n                  let errorMessage = \"makeCallWithMobile failure: impossible to call its own mobile phone number\";\r\n                  that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) \" + errorMessage);\r\n                  defer.reject(ErrorManager.getErrorManager().OTHERERROR(errorMessage));\r\n                  return defer.promise;\r\n              }\r\n                // Forge request IQ\r\n              let makeMobileCallMsg = $iq({ type: \"set\", to: mobileRessource })\r\n                  .c(\"call\", { xmlns: \"urn:xmpp:call\", phoneNumber: phoneNumber, directCall: false });\r\n                xmppService.sendIQ(makeMobileCallMsg)\r\n                  .then(function() {\r\n                      defer.resolve();\r\n                  })\r\n                  .catch(function(error) {\r\n                      let errorMessageMobile = \"makeCallWithMobile failure : \" + error.message;\r\n                      that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) - callService - \" + errorMessageMobile);\r\n                      defer.reject(ErrorManager.getErrorManager().OTHERERROR(errorMessageMobile));\r\n                  });\r\n                // Return the promise\r\n              return defer.promise;\r\n          };\r\n  */\n\n  /**\r\n   * @private\r\n   * @method getPhoneInfo\r\n   * @param contact\r\n   * @param phoneNumber\r\n   * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n   */\n\n\n  getPhoneInfo(contact, phoneNumber, correlatorData) {\n    let that = this;\n    let longNumber = phoneNumber;\n    let shortNumber = \"\";\n    let internalNumber = \"\"; //#29475\n\n    let pbxId = \"\";\n\n    if (contact) {\n      if (phoneNumber === contact.phonePro || phoneNumber === contact.phoneProCan) {\n        longNumber = contact.phoneProCan ? contact.phoneProCan : \"\"; //if (!longNumber && contact.phonePro) { longNumber = contact.phonePro; }\n\n        shortNumber = contact.phonePbx;\n        pbxId = contact.pbxId;\n        internalNumber = contact.phoneInternalNumber; //#29475\n      } else if (phoneNumber === contact.phonePbx) {\n        longNumber = \"\";\n        shortNumber = contact.phonePbx;\n        pbxId = contact.pbxId;\n        internalNumber = contact.phoneInternalNumber; //#29475\n      }\n    }\n\n    return {\n      longNumber: longNumber,\n      shortNumber: shortNumber,\n      pbxId: pbxId,\n      internalNumber: internalNumber,\n      correlatorData: correlatorData\n    }; //#29475\n  }\n  /*getErrorMessage(data, actionLabel) {\r\n      let that = this;\r\n      let errorMessage = actionLabel + \" failure : \";\r\n        if (angular.element(data).attr(\"type\") === \"error\") {\r\n            let error = angular.element(data).find(\"error\");\r\n          if (error) {\r\n              let errorType = error.attr(\"type\");\r\n              let errorCode = error.attr(\"code\");\r\n              if (errorType) {\r\n                  errorMessage += (errorType + \" : \");\r\n                    if (errorType === \"modify\") {\r\n                      errorMessage += error.find(\"text\").text();\r\n                  }\r\n              }\r\n              if (errorCode) {\r\n                  if (errorCode === \"503\") {\r\n                      errorMessage += \"Agent error : service unavailable\";\r\n                  }\r\n              }\r\n                that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) \" + errorMessage);\r\n            }\r\n          else {\r\n              errorMessage += \"Unknown error\";\r\n          }\r\n            return errorMessage;\r\n      }\r\n      return null;\r\n  } // */\n\n  /*************************************************************/\n\n  /*                    RELEASE CALL STUFF                     */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method releaseCall\r\n   * @instance\r\n   * @description\r\n   *    Release a call <br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to release\r\n   * @return {Promise<Call>} Return a promise with the call released\r\n   */\n\n\n  releaseCall(call) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._logger.log(\"internal\", LOG_ID + \"(releaseCall) call : \", call);\n\n      that._logger.log(\"debug\", LOG_ID + \"(releaseCall) call id : \", call.id); //reject not allowed operations\n\n\n      if (!that.isBasicCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"releaseCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(releaseCall) Error : \", profileError);\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(releaseCall) Error : \", profileError);\n\n        return reject(profileError);\n      }\n\n      that._rest.releaseCall(call).then(() => __awaiter(this, void 0, void 0, function* () {\n        // Update call status\n        that._logger.log(\"debug\", LOG_ID + \"(releaseCall) releaseCall \" + call.id + \" - success\"); // SHOULD BE TREATED BY EVENTS. But server dos not send the event if it is the end of a conference\n\n\n        call.setStatus(Call_1.Call.Status.UNKNOWN);\n        call.startDate = null;\n        call.vm = false; // Send call update event\n        //that._logger.log(\"internal\", LOG_ID + \"(releaseCall) send evt_internal_callupdated \", call);\n\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n        // Clean the call array\n        // service.calls = []; //// MCO OULALALALA\n        //delete that.calls[call.id];\n        // Keep the delete of released Call because the server do not raise the end call event on one participant of an OXE conference.\n\n\n        yield that.removeCallFromCache(call.id); // */\n\n        resolve(call);\n      }), response => {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(releaseCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(releaseCall) Error : \", error, \", response : \", response);\n\n        return reject(error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /*                     ANSWER CALL STUFF                     */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method answerCall\r\n   * @instance\r\n   * @description\r\n   *    Answer a call <br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to answer\r\n   * @return {Promise<Call>} Return a promise with the answered call.\r\n   */\n\n\n  answerCall(call) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (call.contact) {\n        that._logger.log(\"internal\", LOG_ID + \"(answerCall) : \" + utils.anonymizePhoneNumber(call.contact.phone) + \"(\" + call.contact.displayNameForLog() + \")\");\n      } else {\n        that._logger.log(\"internal\", LOG_ID + \"(answerCall) : \", call);\n      } // First hold the current active call\n\n\n      let activeCall = that.getActiveCall(); //reject not allowed operations\n\n      if (!that.isBasicCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"answerCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(answerCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) Error : \", profileError.msg);\n\n        return reject(profileError);\n      }\n\n      if (call.status === Call_1.Call.Status.QUEUED_INCOMING && activeCall) {\n        that.holdCall(activeCall).then(function () {\n          return that.answerCall(call);\n        }).then(function (thecall) {\n          resolve(thecall);\n        }).catch(function (error) {\n          let errorMessage = \"answerCall failure : \" + error.message;\n\n          that._logger.log(\"error\", LOG_ID + \"(answerCall) - callService - Error\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) - callService - Error : \", errorMessage);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        });\n      } else {\n        that._rest.answerCall(call).then(function success(response) {\n          // Update call status\n          call.setConnectionId(response.callId);\n          call.setStatus(Call_1.Call.Status.ACTIVE);\n\n          that._logger.log(\"internal\", LOG_ID + \"(answerCall) answerCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \")\");\n          /* TREATED BY EVENTS\r\n              // Send call update event\r\n              that._logger.log(\"debug\", LOG_ID + \"(answerCall) send evt_internal_callupdated \", call);\r\n              that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n              //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n             */\n\n\n          resolve(call);\n        }, function failure(response) {\n          // Send call update event\n          //that._logger.log(\"internal\", LOG_ID + \"(answerCall) send evt_internal_callupdated \", call);\n          that._eventEmitter.emit(\"evt_internal_callupdated\", call); //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\n\n\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(answerCall) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) Error : \", error);\n\n          return reject(error);\n        });\n      }\n    });\n  }\n  /*************************************************************/\n\n  /*                      HOLD CALL STUFF                      */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method holdCall\r\n   * @instance\r\n   * @description\r\n   *    Hold a call <br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to hold\r\n   * @return {Call} Return a promise with the held call.\r\n   */\n\n\n  holdCall(call) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      // Ignore call already hold\n      if (!call || call.status === Call_1.Call.Status.HOLD) {\n        return resolve(call);\n      } //reject not allowed operations\n\n\n      if (!that.isSecondCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"holdCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(holdCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(holdCall) \", profileError.msg);\n\n        return reject(profileError);\n      }\n      /* $http({\r\n          method: \"PUT\",\r\n          url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/hold\",\r\n          headers: authService.getRequestHeader()\r\n      }) // */\n\n\n      that._rest.holdCall(call).then(function success(response) {\n        that._logger.log(\"info\", LOG_ID + \"(holdCall) holdCall success.\");\n\n        that._logger.log(\"internal\", LOG_ID + \"(holdCall) holdCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \"), response : \", response); // Update call status\n\n\n        if (response && response.data && response.data.data) {\n          call.setConnectionId(response.data.data.callId);\n        } else {\n          that._logger.log(\"internal\", LOG_ID + \"(holdCall) holdCall response.data.data empty, can not find callId, get it directly in response : \", response);\n\n          call.setConnectionId(response.callId);\n        }\n\n        call.setStatus(Call_1.Call.Status.HOLD);\n        /* TREATED BY EVENTS\r\n        // Send call update event\r\n        that._logger.log(\"debug\", LOG_ID + \"(holdCall) send evt_internal_callupdated \", call);\r\n        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n         */\n\n        resolve(call);\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        reject(error);\n\n        that._logger.log(\"error\", LOG_ID + \"(holdCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(holdCall) Error : \", error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /*                     RETRIEVE CALL STUFF                     */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method retrieveCall\r\n   * @instance\r\n   * @description\r\n   *    Retrieve a call <br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to retrieve\r\n   * @return {Promise<Call>} Return a promise with the call retrieved\r\n   */\n\n\n  retrieveCall(call) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall : \" + call.contact.displayNameForLog()); //reject not allowed operations\n\n\n      if (!that.isSecondCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"retrieveCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(retrieveCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) Error : \", profileError.msg);\n\n        return reject(profileError);\n      } // First hold the current active call\n\n\n      let activeCall = that.getActiveCall();\n\n      if (activeCall) {\n        that.holdCall(activeCall).then(function () {\n          return that.retrieveCall(call);\n        }).then(function (thecall) {\n          resolve(thecall);\n        }).catch(function (error) {\n          let errorMessage = \"retrieveCall failure : \" + error.message;\n\n          that._logger.log(\"error\", LOG_ID + \"(retrieveCall) - callService -  Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) - callService - Error : \", errorMessage);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        });\n      } else {\n        /*$http({\r\n            method: \"PUT\",\r\n            url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/retrieve\",\r\n            headers: authService.getRequestHeader()\r\n        })// */\n        that._rest.retrieveCall(call).then(function success(response) {\n          that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \")\"); // Update call status\n\n\n          if (response && response.data && response.data.data) {\n            call.setConnectionId(response.data.data.callId);\n          } else {\n            that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall response.data.data empty, can not find callId, get it directly in response : \", response);\n\n            call.setConnectionId(response.callId);\n          }\n\n          call.setStatus(Call_1.Call.Status.ACTIVE);\n          /* TREATED BY EVENTS\r\n              // Send call update event\r\n              that._logger.log(\"debug\", LOG_ID + \"(retrieveCall) send evt_internal_callupdated \", call);\r\n              that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n              //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n             */\n\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(retrieveCall) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) Error : \", error);\n\n          return reject(error);\n        });\n      }\n    });\n  }\n  /*************************************************************/\n\n  /*                     DEFLECT CALL STUFF                    */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method deflectCallToVM\r\n   * @instance\r\n   * @description\r\n   *    Deflect a call to the voice mail <br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to deflect\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  deflectCallToVM(call) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Ignore wrong request\n      if (!call) {\n        return resolve(call);\n      } //reject not allowed operations\n\n\n      if (!that.isVMDeflectCallAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"deflectCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(deflectCallToVM) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(deflectCallToVM) Error : \" + profileError.msg);\n\n        return reject(profileError);\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(deflectCallToVM) deflectCallToVM \", call.contact.displayNameForLog());\n      /*$http({\r\n          method: \"PUT\",\r\n          url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/deflect\",\r\n          headers: authService.getRequestHeader(),\r\n          data: {\r\n              calleeExtNumber: \"\",\r\n              calleeIntNumber: service.voicemailNumber,\r\n              calleeShortNumber: service.voicemailNumber,\r\n              calleePbxId: service.pbxId\r\n          }\r\n      }) // */\n\n\n      let data = {\n        calleeExtNumber: \"\",\n        calleeIntNumber: that.voicemailNumber,\n        calleeShortNumber: that.voicemailNumber,\n        calleePbxId: that.pbxId\n      };\n\n      that._rest.deflectCallToVM(call, data).then(function success() {\n        that._logger.log(\"debug\", LOG_ID + \"(deflectCallToVM) deflectCall success\");\n\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(deflectCallToVM) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(deflectCallToVM) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /*                     DEFLECT CALL STUFF                    */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method deflectCall\r\n   * @instance\r\n   * @description\r\n   *    Deflect a call to an other telephone number<br/>\r\n   *    Return a promise\r\n   * @param {Call} call The call to deflect\r\n   * @param {Object} callee The callee phone number informations where the call shopuld be deflecte'd.\r\n   * @param {string} callee.calleeExtNumber : The phone number where the call is deflected, the format could be anything the user can type, it will be transformed in E164 format.,\r\n   * @param {string} callee.calleeIntNumber : Internal number if available,\r\n   * @param {string} callee.calleePbxId : The pbx id if available,\r\n   * @param {string} [callee.calleeShortNumber] : Short number,\r\n   * @param {string} [callee.calleeDisplayName] : The displayed name,\r\n   * @param {string} [callee.calleeCountry] : The contry whe the call will be deflected.\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  deflectCall(call, callee) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Ignore wrong request\n      if (!call || !callee) {\n        resolve();\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(deflectCall) deflectCall \" + call.contact.displayNameForLog());\n\n      let data = {\n        \"calleeExtNumber\": callee.calleeExtNumber,\n        \"calleeIntNumber\": callee.calleeIntNumber,\n        \"calleePbxId\": callee.calleePbxId,\n        \"calleeShortNumber\": callee.calleeShortNumber,\n        \"calleeDisplayName\": callee.calleeDisplayName,\n        \"calleeCountry\": callee.calleeCountry\n      };\n\n      that._rest.deflectCall(call, data).then(function success() {\n        that._logger.log(\"debug\", LOG_ID + \"(deflectCall) deflectCall success\");\n\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(deflectCall) Error. \");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(deflectCall) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /*                   TRANSFERT CALL STUFF                    */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method transfertCall\r\n   * @instance\r\n   * @description\r\n   *    Transfer a held call to the active call <br/>\r\n   *    User should have transfer rights <br/>\r\n   *    Return a promise\r\n   * @param {Call} activeCall The active call\r\n   * @param {Call} heldCall The held call to transfer to the activeCall\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  transfertCall(activeCall, heldCall) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Ignore wrong request\n      if (!activeCall || !heldCall) {\n        return resolve();\n      } //reject not allowed operations\n\n\n      if (!that.isTransferAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"transferCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(transfertCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(transfertCall) Error : \" + profileError.msg);\n\n        return reject(profileError);\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(transfertCall) transfertCall held(\" + heldCall.contact.displayName + \") to active(\" + activeCall.contact.displayName + \")\");\n      /*$http({\r\n          method: \"PUT\",\r\n          url: service.portalURL + \"calls/\" + encodeURIComponent(activeCall.connectionId) + \"/transfer/\" + encodeURIComponent(heldCall.connectionId),\r\n          headers: authService.getRequestHeader()\r\n      })\r\n          // */\n\n\n      that._rest.transfertCall(activeCall, heldCall).then(function success() {\n        return __awaiter(this, void 0, void 0, function* () {\n          that._logger.log(\"debug\", LOG_ID + \"(transfertCall) transferCall success\"); // Release makinCall flag\n\n\n          that.makingCall = false;\n          yield that.clearCall(activeCall);\n          yield that.clearCall(heldCall);\n          resolve();\n        });\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(transfertCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(transfertCall) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /* MAKE CONFERENCE CALL STUFF                                */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method conferenceCall\r\n   * @instance\r\n   * @description\r\n   *    Create a conference with a held call and the active call <br/>\r\n   *    User should have conference rights <br/>\r\n   *    Return a promise\r\n   * @param {Call} activeCall The active call\r\n   * @param {Call} heldCall The held call to transfer to the activeCall\r\n   * @return {Promise} Return a resolved promise .\r\n   */\n\n\n  conferenceCall(activeCall, heldCall) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Ignore wrong request\n      if (!activeCall || !heldCall) {\n        return resolve();\n      } //reject not allowed operations\n\n\n      if (!that.isConferenceAllowed) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"conferenceCall failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(conferenceCall) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(conferenceCall) Error : \" + profileError.msg);\n\n        return reject(profileError);\n      }\n\n      if (activeCall && activeCall.contact && heldCall && heldCall.contact) {\n        that._logger.log(\"internal\", LOG_ID + \"(conferenceCall) conferenceCall \" + activeCall.contact.displayName + \" and \" + heldCall.contact.displayName);\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(conferenceCall) conferenceCall activeCall : \", activeCall, \",\\n\\n(conferenceCall) conferenceCall heldCall : \", heldCall);\n      /* $http({\r\n          method: \"PUT\",\r\n          url: service.portalURL + \"calls/\" + encodeURIComponent(activeCall.connectionId) + \"/conference/\" + encodeURIComponent(heldCall.connectionId),\r\n          headers: authService.getRequestHeader()\r\n      }) // */\n\n\n      that._rest.conferenceCall(activeCall, heldCall).then(function success() {\n        that._logger.log(\"debug\", LOG_ID + \"(conferenceCall) conferenceCall success\");\n\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        return reject(error);\n\n        that._logger.log(\"error\", LOG_ID + \"(conferenceCall) error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(conferenceCall) Error : \", error);\n      });\n    });\n  }\n  /*************************************************************/\n\n  /* FORWARD CALL STUFF               \t\t                 */\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method forwardToDevice\r\n   * @instance\r\n   * @description\r\n   *    Activate the forward to a number <br/>\r\n   *    Return a promise\r\n   * @param {String} phoneNumber The number to call\r\n   * @return {Promise} Return a promise resolved.\r\n  */\n\n\n  forwardToDevice(phoneNumber) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      that._logger.log(\"internal\", LOG_ID + \"(forwardToDevice) forwardToDevice : \" + phoneNumber);\n\n      if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\n        let errorMessage = \"forwardToDevice failure: impossible to forward its own phone number\";\n\n        that._logger.log(\"error\", LOG_ID + \"(forwardToDevice) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(forwardToDevice) Error : \", errorMessage);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n      }\n\n      that._contacts.getOrCreateContact(null, phoneNumber).then(function (contact) {\n        let phoneInfo = that.getPhoneInfo(contact, phoneNumber, undefined);\n        /*$http({\r\n            method: \"PUT\",\r\n            url: service.portalURL + \"forward\",\r\n            headers: authService.getRequestHeader(),\r\n            data: {\r\n                calleeExtNumber: phoneInfo.longNumber,\r\n                calleeIntNumber: phoneInfo.internalNumber,\r\n                calleeShortNumber: phoneInfo.shortNumber,\r\n                calleePbxId: phoneInfo.pbxId,\r\n                calleeDisplayName: contact.displayName\r\n            }\r\n        }) // */\n\n        that._rest.forwardToDevice(contact, phoneInfo).then(function success() {\n          // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          return reject(error);\n\n          that._logger.log(\"error\", LOG_ID + \"(forwardToDevice) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(forwardToDevice) Error : \", error);\n        });\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method forwardToVoicemail\r\n   * @instance\r\n   * @description\r\n   *    Activate the forward to VM <br/>\r\n   *    Return a promise\r\n   * @return {Promise} Return a promise resolved.\r\n     */\n\n\n  forwardToVoicemail() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!that.voiceMailFeatureEnabled) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"forwardToVoicemail failure - voicemail feature not enabled\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"404\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(forwardToVoicemail) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(forwardToVoicemail) Error : \", profileError.msg);\n\n        return reject(profileError);\n      }\n      /*$http({\r\n          method: \"PUT\",\r\n          url: service.portalURL + \"forward\",\r\n          headers: authService.getRequestHeader(),\r\n          data: {\r\n              calleeExtNumber: \"\",\r\n              calleeIntNumber: service.voicemailNumber,\r\n              calleePbxId: service.pbxId\r\n          }\r\n      })\r\n      // */\n\n\n      let phoneInfo = {\n        longNumber: \"\",\n        internalNumber: that.voicemailNumber,\n        pbxId: that.pbxId\n      };\n\n      that._rest.forwardToDevice({}, phoneInfo).then(function success() {\n        // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(forwardToVoicemail) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(forwardToVoicemail) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method cancelForward\r\n   * @instance\r\n   * @description\r\n   *    Cancel the forward <br/>\r\n   *    Return a promise\r\n   * @return {Promise<Call>} Return a promise with the canceled forward call.\r\n   */\n\n\n  cancelForward() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (that._contacts.userContact.phonePbx) {\n        /* $http({\r\n            method: \"PUT\",\r\n            url: service.portalURL + \"forward\",\r\n            headers: authService.getRequestHeader(),\r\n            data: {\r\n                calleeExtNumber: \"\",\r\n                calleeIntNumber: \"CANCELFORWARD\",\r\n                calleePbxId: service.pbxId\r\n            }\r\n        }) // */\n        let phoneInfo = {\n          longNumber: \"\",\n          internalNumber: \"CANCELFORWARD\",\n          pbxId: that.pbxId\n        };\n\n        that._rest.forwardToDevice({}, phoneInfo).then(function success() {\n          that._logger.log(\"debug\", LOG_ID + \"(cancelForward) cancelForward success\");\n\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(cancelForward) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(cancelForward) Error : \", error);\n\n          return reject(error);\n        });\n      } else {\n        return reject();\n      }\n    });\n  }\n\n  getForwardStatus() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      if (that._contacts.userContact && that._contacts.userContact.phonePbx) {\n        /*$http({\r\n            method: \"GET\",\r\n            url: service.portalURL + \"forward\",\r\n            headers: authService.getRequestHeader()\r\n        }) // */\n        that._rest.getForwardStatus().then(function success() {\n          // Nothing much to do here, the real call forward status will arrive by XMPP (see ON_CALL_FORWARDED_EVENT)\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(getForwardStatus) error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(getForwardStatus) Error : \", error);\n\n          return reject(error);\n        });\n      } else {\n        return reject();\n      }\n    });\n  }\n  /*************************************************************/\n\n  /* NOMADIC CALL STUFF               \t\t                 */\n\n  /*************************************************************/\n\n\n  nomadicLogin(phoneNumber, NotTakeIntoAccount) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      //reject not allowed operations\n      if (!that.isNomadicEnabled || !that.nomadicObject.featureActivated) {\n        let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"nomadicLogin failure - Not Allowed\"); // @ts-ignore\n\n        profileError.status = profileError.errorDetailsCode = \"403\"; // @ts-ignore\n\n        that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \" + profileError.msg);\n\n        return reject(profileError);\n      }\n\n      if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\n        let errorMessage = \"nomadicLogin failure: impossible to use its own phone number like nomadic phone\";\n\n        that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \", errorMessage);\n\n        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(nomadicLogin) phoneNumber : \" + phoneNumber);\n\n      NotTakeIntoAccount = NotTakeIntoAccount || false;\n      that.nomadicAnswerNotTakedIntoAccount = NotTakeIntoAccount;\n\n      that._contacts.getOrCreateContact(null, phoneNumber).then(function (contact) {\n        let phoneInfo = that.getPhoneInfo(contact, phoneNumber, undefined);\n        /*$http({\r\n            method: \"PUT\",\r\n            url: that.portalURL + \"nomadic/login\",\r\n            headers: authService.getRequestHeader(),\r\n            data: {\r\n                destinationExtNumber: phoneInfo.longNumber,\r\n                destinationIntNumber: phoneInfo.internalNumber,\r\n                destinationShortNumber: phoneInfo.shortNumber,\r\n                destinationPbxId: phoneInfo.pbxId,\r\n                destinationDisplayName: contact.displayName,\r\n                destinationCountry: contact.country\r\n            }\r\n        })// */\n\n        let data = {\n          destinationExtNumber: phoneInfo.longNumber,\n          destinationIntNumber: phoneInfo.internalNumber,\n          destinationShortNumber: phoneInfo.shortNumber,\n          destinationPbxId: phoneInfo.pbxId,\n          destinationDisplayName: contact.displayName,\n          destinationCountry: contact.country\n        };\n\n        that._rest.nomadicLogin(data).then(function success() {\n          //service.forwardToDevice(phoneNumberReceived);\n          // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\n          that._logger.log(\"info\", LOG_ID + \"(nomadicLogin) nomadicLogin success\"); //service.isMakeCallInitiatorIsMain = false;\n\n\n          resolve(\"success\");\n        }, function failure(response) {\n          let errorMessage = \"nomadicLogin failure, nomadicDevice: \" + response.message;\n\n          that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \" + errorMessage);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n        });\n      });\n    });\n  }\n\n  /*\r\n      nomadicLoginOnOfficePhone () {\r\n          return $q(function(resolve, reject) {\r\n  \r\n              //reject not allowed operations\r\n              if (!service.isNomadicEnabled || !service.nomadicObject.featureActivated) {\r\n                  let profileError = ErrorManager.getErrorManager().OTHERERROR(\"nomadicLoginOnOfficePhone failure - Not Allowed\");\r\n                  profileError.status = profileError.errorDetailsCode = \"403\";\r\n                  $log.error(\"(nomadicLoginOnOfficePhone) \" + profileError.message);\r\n                  reject(profileError);\r\n              }\r\n  \r\n              $log.info(\"(nomadicLoginOnOfficePhone) nomadicLoginOnOfficePhone\");\r\n  \r\n              $http({\r\n                  method: \"PUT\",\r\n                  url: service.portalURL + \"nomadic/login\",\r\n                  headers: authService.getRequestHeader()\r\n              }).then(\r\n                  function success() {\r\n                      //service.cancelForward();\r\n                      // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\r\n                      $log.info(\"(nomadicLoginOnOfficePhone) nomadicLoginOnOfficePhone success\");\r\n                      //service.isMakeCallInitiatorIsMain = true;\r\n                      resolve();\r\n                  },\r\n                  function failure(response) {\r\n                      let error = errorHelperService.handleError(response);\r\n                      reject(error);\r\n                      $log.error(\"(nomadicLoginOnOfficePhone) \" + errorHelperService.getErrorFullMessage(response, \"nomadicDevice\"));\r\n                  });\r\n          });\r\n      };\r\n  \r\n      nomadicLogout () {\r\n          let that = this;\r\n          return new Promise(function(resolve, reject) {\r\n  \r\n              //reject not allowed operations\r\n              if (!that.isNomadicEnabled || !that.nomadicObject.featureActivated) {\r\n                  let profileError = ErrorManager.getErrorManager().OTHERERROR(\"nomadicLogout failure - Not Allowed\");\r\n                  profileError.status = profileError.errorDetailsCode = \"403\";\r\n                  $log.error(\"(nomadicLogout) \" + profileError.message);\r\n                  reject(profileError);\r\n              }\r\n  \r\n              $log.info(\"(nomadicLogout) nomadicLogout\");\r\n  \r\n              $http({\r\n                  method: \"PUT\",\r\n                  url: service.portalURL + \"nomadic/logout\",\r\n                  headers: authService.getRequestHeader()\r\n              }).then(\r\n                  function success() {\r\n                      //service.cancelForward();\r\n                      // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\r\n                      $log.info(\"(nomadicLogout) nomadicLogout success\");\r\n                      //service.isMakeCallInitiatorIsMain = true;\r\n                      resolve();\r\n                  },\r\n                  function failure(response) {\r\n                      let error = errorHelperService.handleError(response);\r\n                      reject(error);\r\n                      $log.error(\"(nomadicLogout) \" + errorHelperService.getErrorFullMessage(response, \"nomadicDevice\"));\r\n                  });\r\n          });\r\n      };\r\n  // */\n  getNomadicStatus() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      //reject not allowed operations\n      if (!that.isNomadicEnabled) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(\"403\", \"getNomadicStatus failure - Not Allowed\", \"getNomadicStatus failure - Not Allowed\"); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) Error : \", error);\n\n        return reject(error);\n      }\n\n      if (that._contacts.userContact && that._contacts.userContact.phonePbx) {\n        that._rest.getNomadicStatus().then(function success(response) {\n          that._logger.log(\"info\", LOG_ID + \"(getNomadicStatus) nomadicStatus success\");\n\n          that.updateNomadicData(response);\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) Error\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) Error : \", error);\n\n          return reject(error);\n        });\n      } else {\n        //let error = ErrorManager.getErrorManager().ERROR();// errorHelperService.handleError(response);\n        let error = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERROR\", \"(getNomadicStatus) user logged in pbx info not filled!\"); //error.msg += \"(getNomadicStatus) user logged in pbx info not filled!\";\n\n        that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) user logged in pbx info not filled!\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) user logged in pbx info not filled! Error : \", error);\n\n        return reject(error);\n      }\n    });\n  }\n\n  /*\r\n      service.setNomadicState = function() {\r\n          return $q(function(resolve, reject) {\r\n  \r\n              $log.info(\"(setNomadicState) setNomadicState\");\r\n  \r\n              $http({\r\n                  method: \"PUT\",\r\n                  url: service.portalURL + \"nomadic/state\",\r\n                  headers: authService.getRequestHeader(),\r\n                  data: {\r\n                      makeCallInitiatorIsMain: \"true\"\r\n                  }\r\n              }).then(\r\n                  function success() {\r\n                      $log.info(\" setNomadicState success\");\r\n                      resolve();\r\n                  },\r\n                  function failure(response) {\r\n                      let error = errorHelperService.handleError(response);\r\n                      reject(error);\r\n                      $log.error(\" \" + errorHelperService.getErrorFullMessage(response, \"setNomadicState\"));\r\n                  });\r\n          });\r\n      };\r\n  */\n\n  /**\r\n   * @private\r\n    * @param response\r\n   */\n  updateNomadicData(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      that._logger.log(\"internal\", LOG_ID + \"(updateNomadicData) destination:\" + response.destination + \" featureActivated:\" + response.featureActivated + \" makeCallInitiatorIsMain:\" + response.makeCallInitiatorIsMain + \" modeActivated:\" + response.modeActivated);\n\n      that.nomadicObject.featureActivated = response.featureActivated === \"true\";\n      that.nomadicObject.modeActivated = response.modeActivated === \"true\";\n      that.nomadicObject.destination = response.destination;\n      that.nomadicObject.makeCallInitiatorIsMain = response.makeCallInitiatorIsMain === \"true\";\n\n      if (!that.nomadicAnswerNotTakedIntoAccount) {\n        //$rootScope.$broadcast(\"ON_CALL_NOMADIC_EVENT\", service.nomadicObject);\n        //that._logger.log(\"internal\", LOG_ID + \"(updateNomadicData) send evt_internal_nomadicstatusevent \", that.nomadicObject);\n        that._eventEmitter.emit(\"evt_internal_nomadicstatusevent\", that.nomadicObject);\n      }\n\n      that.nomadicAnswerNotTakedIntoAccount = false; // By default if mobilepro or mobileperso exist, then add it on destination\n\n      /*if (service.nomadicObject.featureActivated && (service.nomadicObject.destination === \"\" || service.nomadicObject.destination === undefined) && (contactService.userContact.mobileProCan || contactService.userContact.mobilePerso)) {\r\n          let defaultNumber = contactService.userContact.mobileProCan ? contactService.userContact.mobileProCan : contactService.userContact.mobilePerso;\r\n          service.nomadicLogin(defaultNumber)\r\n              .then(function() {\r\n                  service.nomadicLoginOnOfficePhone();\r\n              });\r\n      }*/\n      // By default, in monodevice, if mobilepro or mobileperso exist, then add it on destination\n\n      if (that._contacts.userContact.isVirtualTerm && that.nomadicObject.featureActivated && (that.nomadicObject.destination === \"\" || that.nomadicObject.destination === undefined) && (that._contacts.userContact.mobileProCan || that._contacts.userContact.mobilePerso)) {\n        let defaultNumber = that._contacts.userContact.mobileProCan ? that._contacts.userContact.mobileProCan : that._contacts.userContact.mobilePerso;\n        yield that.nomadicLogin(defaultNumber);\n      }\n    });\n  }\n\n  getNomadicObject() {\n    return this.nomadicObject;\n  }\n\n  getNomadicDestination() {\n    return this.nomadicObject.destination;\n  }\n  /*************************************************************/\n\n  /* DTMF             \t\t                 \t\t\t\t*/\n\n  /*************************************************************/\n\n  /**\r\n   * @public\r\n   * @method sendDtmf\r\n   * @description\r\n   *      send dtmf to the remote party\r\n   * @param {string} connectionId\r\n   * @param {string} dtmf\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  sendDtmf(connectionId, dtmf) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      let callId = Call_1.Call.getIdFromConnectionId(connectionId);\n      let deviceId = Call_1.Call.getDeviceIdFromConnectionId(connectionId);\n\n      if (callId && deviceId && dtmf) {\n        /* $http({\r\n            method: \"PUT\",\r\n            url: service.portalURL + \"calls/\" + callId + \"%23\" + deviceId + \"/dtmf\",\r\n            headers: authService.getRequestHeader(),\r\n            data: {\r\n                callId: connectionId,\r\n                dtmf: dtmf\r\n            }\r\n        }) // */\n        let data = {\n          callId: connectionId,\n          dtmf: dtmf\n        };\n\n        that._rest.sendDtmf(callId, deviceId, data).then(function success() {\n          resolve();\n        }, function failure(response) {\n          let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n          that._logger.log(\"error\", LOG_ID + \"(sendDtmf) Error.\");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(sendDtmf) Error : \", error);\n\n          return reject(error);\n        });\n      } else {\n        return reject();\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @method clearCall\r\n   * @param Call call the call to reset.\r\n   * @return nothing.\r\n   */\n\n\n  clearCall(call) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      call.setStatus(Call_1.Call.Status.UNKNOWN);\n      /* TREATED BY EVENTS\r\n      // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n      that._logger.log(\"debug\", LOG_ID + \"(clearCall) send evt_internal_callupdated \", call);\r\n      that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n      */\n      //if (call.contact) {\n      //delete that.calls[call.contact.id];\n      //}\n\n      let callIdToDelete = Call_1.Call.getIdFromConnectionId(call.connectionId); //delete that._calls[callIdToDelete];\n\n      yield that.removeCallFromCache(callIdToDelete);\n\n      if (call.getCurrentCalled()) {\n        call.setCurrentCalled(null);\n      }\n    });\n  }\n\n  startAsPhoneNumber(phoneNumber) {\n    let cleanPhoneNumber = phoneNumber.trim().split(\".\").join(\"\");\n    let pattern1 = /^(\\+|\\d|#|\\*|\\(|\\)|\\.|-|\\s|\\/)*$/;\n    let match = cleanPhoneNumber.match(pattern1);\n\n    if (!match) {\n      return false;\n    }\n\n    return match[0] === cleanPhoneNumber;\n  }\n  /**\r\n   * @private\r\n   * @method getOrCreateCall\r\n   * @param status\r\n   * @param connectionId\r\n   * @param deviceType\r\n   * @param contact\r\n   */\n\n\n  getOrCreateCall(status, connectionId, deviceType, contact) {\n    let that = this; // Extract callid from connectionid\n\n    let callId = Call_1.Call.getIdFromConnectionId(connectionId);\n\n    that._logger.log(\"debug\", LOG_ID + \"(getOrCreateCall) callId \", callId);\n\n    let callInfos = {\n      \"status\": status,\n      \"id\": callId,\n      \"connectionId\": connectionId,\n      \"type\": Call_1.Call.Type.PHONE,\n      \"contact\": contact,\n      \"deviceType\": deviceType\n    };\n\n    that._logger.log(\"internal\", LOG_ID + \"(getOrCreateCall) callInfos : \", callInfos);\n\n    if (!callId) {\n      let call = Call_1.Call.CallFactory()(callInfos);\n      call.setConnectionId(connectionId);\n\n      that._logger.log(\"internal\", LOG_ID + \"(getOrCreateCall) no callId found, so return a call which is not stored in calls tab. call : \", call);\n\n      return call;\n    }\n\n    let call = that.addOrUpdateCallToCache(callInfos);\n    /*\r\n      // Get eventual existing call\r\n    let call = that.getCallFromCache(callId);\r\n    if (call) {\r\n        call.setConnectionId(connectionId);\r\n        call.startDate = new Date();\r\n    }\r\n    else {\r\n        //call = Call.create(status, null, Call.Type.PHONE, contact, deviceType);\r\n        let callInfos = {status, id : undefined, type : Call.Type.PHONE, contact, deviceType} ;\r\n        call = that.addOrUpdateCallToCache(callInfos);\r\n       */\n\n    /*call = Call.CallFactory()(callInfos);\r\n    call.setConnectionId(connectionId);\r\n    that._calls[callId] = call;\r\n       */\n    //}\n\n    return call;\n  }\n  /**\r\n   * @private\r\n   * @param callId\r\n   * @description\r\n   *      GET A CALL FROM CACHE\r\n   */\n\n\n  getCallFromCache(callId) {\n    let that = this;\n    let callFound = null;\n\n    that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) search id : \", callId);\n\n    if (!callId) return callFound;\n    let iter = 0;\n\n    if (that._calls) {\n      let callFoundindex = that._calls.findIndex(call => {\n        iter++;\n\n        if (!call) {// Warning : do not uncomment these line because when an error happens for a big number it is stored in that._calls at the indice of the called number\n          // So the size of the tab is egal this big number. And then freeze the SDK when iter the tab.\n          //this._logger.log(\"error\", LOG_ID + \"(getCallFromCache) !!! A call is undefined in the cache.\");\n          //this._logger.log(\"internalerror\", LOG_ID + \"(getCallFromCache) !!! A call is undefined in the cache : \", call);\n        } else {\n          return call.id === callId;\n        }\n      });\n\n      that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) that._calls findIndex iter : \", iter);\n\n      if (callFoundindex != -1) {\n        that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) call found : \", that._calls[callFoundindex], \" with id : \", callId);\n\n        return that._calls[callFoundindex];\n      }\n    }\n\n    that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) call found : \", callFound, \" with id : \", callId);\n\n    return callFound;\n  }\n\n  addOrUpdateCallToCache(call) {\n    let callObj = Call_1.Call.CallFactory()(call);\n\n    let callFoundindex = this._calls.findIndex(callIter => {\n      return callIter.id === call.id;\n    });\n\n    if (callFoundindex != -1) {\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) update in cache with call : \", call, \", at callFoundindex : \", callFoundindex); //this._channels.splice(callFoundindex,1,callObj);\n      //channelCached = callObj;\n\n\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) in update this.calls : \", this._calls);\n\n      this._calls[callFoundindex].updateCall(call);\n\n      callObj = this._calls[callFoundindex];\n    } else {\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) add in cache callObj : \", callObj);\n\n      this._calls.push(callObj);\n    }\n\n    return callObj;\n  }\n\n  removeCallFromCache(callId) {\n    let that = this;\n\n    this._logger.log(\"debug\", LOG_ID + \"(removeCallFromCache) should remove callId : \", callId);\n\n    return new Promise((resolve, reject) => {\n      // Get the channel to remove\n      let callToRemove = this.getCallFromCache(callId);\n\n      if (callToRemove) {\n        // Remove from channels\n        let callIdToRemove = callToRemove.id;\n\n        this._logger.log(\"internal\", LOG_ID + \"(removeCallFromCache) remove from cache callIdToRemove : \", callIdToRemove);\n\n        this._calls = this._calls.filter(function (call) {\n          return !(call.id === callIdToRemove);\n        });\n        resolve(callToRemove);\n      } else {\n        resolve(null);\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method logon\r\n   * @param {String} endpointTel The endpoint device phone number.\r\n   * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n   * @param {String} password optionnel Password or authorization code.\r\n   * @param {String} groupId optionnel CCD Agent's group number\r\n   * @description\r\n   *      This api allows an CCD Agent to logon into the CCD system.\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  logon(endpointTel, agentId, password, groupId) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!endpointTel) {\n        that._logger.log(\"warn\", LOG_ID + \"(logon) bad or empty 'endpointTel' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(logon) bad or empty 'endpointTel' parameter\", endpointTel);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.logon(endpointTel, agentId, password, groupId).then(function success() {\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(logon) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(logon) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method logoff\r\n   * @param {String} endpointTel The endpoint device phone number.\r\n   * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n   * @param {String} password optionnel Password or authorization code.\r\n   * @param {String} groupId optionnel CCD Agent's group number\r\n   * @description\r\n   *      This api allows an CCD Agent logoff logon from the CCD system.\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  logoff(endpointTel, agentId, password, groupId) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!endpointTel) {\n        that._logger.log(\"warn\", LOG_ID + \"(logoff) bad or empty 'endpointTel' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(logoff) bad or empty 'endpointTel' parameter\", endpointTel);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.logoff(endpointTel, agentId, password, groupId).then(function success() {\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(logoff) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(logoff) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method withdrawal\r\n   * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n   * @param {String} groupId optionnel CCD Agent's group number\r\n   * @param {String} status optionnel Used to deactivate the withdrawal state. Values: 'on', 'off'; 'on' is optional.\r\n   * @description\r\n   *      This api allows an CCD Agent to change to the state 'Not Ready' on the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  withdrawal(agentId, groupId, status) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!agentId) {\n        that._logger.log(\"warn\", LOG_ID + \"(withdrawal) bad or empty 'agentId' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) bad or empty 'agentId' parameter\", agentId);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      if (!groupId) {\n        that._logger.log(\"warn\", LOG_ID + \"(withdrawal) bad or empty 'groupId' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) bad or empty 'groupId' parameter\", groupId);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.withdrawal(agentId, groupId, status).then(function success() {\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(withdrawal) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method wrapup\r\n   * @param {String} agentId CCD Agent identifier (agent device number).\r\n   * @param {String} groupId CCD Agent's group number\r\n   * @param {String} password optionnel Password or authorization code.\r\n   * @param {String} status optionnel Used to deactivate the WrapUp state. Values: 'on', 'off'; 'on' is optional.\r\n   * @description\r\n   *      This api allows an CCD Agent to change to the state Working After Call in the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'.\r\n   * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n   */\n\n\n  wrapup(agentId, groupId, password, status) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!agentId) {\n        that._logger.log(\"warn\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\", agentId);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      if (!agentId) {\n        that._logger.log(\"warn\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\", agentId);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      that._rest.wrapup(agentId, groupId, password, status).then(function success() {\n        resolve();\n      }, function failure(response) {\n        let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\n\n        that._logger.log(\"error\", LOG_ID + \"(wrapup) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) Error : \", error);\n\n        return reject(error);\n      });\n    });\n  }\n\n};\nTelephony = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n * @module\r\n * @name Telephony\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This services manages PBX phone calls in a conversation. so it manages PBX calls between your PABX associated phone and a recipient's phone. If you don't have this service activated for your Rainbow user, all these methods will return an error when called. <br/><br>\r\n *      The main methods and events proposed in that service allow to: <br>\r\n *      - Know if this service is activated or not for the connected user, <br/>\r\n *      - Know the version of the agent (deployed on the PBX) that monitors your line, <br>\r\n *      - Handle the basic telephony services: Make a call, take a call, hold a call, retrieve a call and release a call,<br/>\r\n *      - Listen to the call state change <br><br>\r\n *      Depending the agent version deployed, some services can return an error (unavailable service) when called\r\n *\r\n */\n], Telephony);\nexports.TelephonyService = Telephony;\nmodule.exports.Telephony = Telephony;","map":{"version":3,"sources":["../../src/lib/services/TelephonyService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Call_1 = require(\"../common/models/Call\");\r\nconst VoiceMail = require(\"../common/models/VoiceMail\");\r\nconst utils = require(\"../common/Utils\");\r\nconst PubSub = require(\"pubsub-js\");\r\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst telephonyEventHandler_1 = require(\"../connection/XMPPServiceHandler/telephonyEventHandler\");\r\nconst LOG_ID = \"TELEPHONY/SVCE - \";\r\nlet Telephony = \r\n/**\r\n * @module\r\n * @name Telephony\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This services manages PBX phone calls in a conversation. so it manages PBX calls between your PABX associated phone and a recipient's phone. If you don't have this service activated for your Rainbow user, all these methods will return an error when called. <br/><br>\r\n *      The main methods and events proposed in that service allow to: <br>\r\n *      - Know if this service is activated or not for the connected user, <br/>\r\n *      - Know the version of the agent (deployed on the PBX) that monitors your line, <br>\r\n *      - Handle the basic telephony services: Make a call, take a call, hold a call, retrieve a call and release a call,<br/>\r\n *      - Listen to the call state change <br><br>\r\n *      Depending the agent version deployed, some services can return an error (unavailable service) when called\r\n *\r\n */\r\nclass Telephony {\r\n    constructor(_eventEmitter, logger, _startConfig) {\r\n        this.ready = false;\r\n        let that = this;\r\n        this._startConfig = _startConfig;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._contacts = null;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._logger = logger;\r\n        this._calls = [];\r\n        this.voiceMail = null; //VoiceMail.createVoiceMail();\r\n        this.userJidTel = \"TOBEFILLED\"; //authService.jidTel;\r\n        this.started = false;\r\n        this.agentStatus = {};\r\n        this.voicemailNumber = null;\r\n        this.pbxId = null;\r\n        this.forwardObject = {};\r\n        this.nomadicObject = {};\r\n        this.nomadicAnswerNotTakedIntoAccount = false;\r\n        this.isBasicCallAllowed = false;\r\n        this.isSecondCallAllowed = false;\r\n        this.isTransferAllowed = false;\r\n        this.isConferenceAllowed = false;\r\n        this.isVMDeflectCallAllowed = false;\r\n        this.voiceMailFeatureEnabled = false;\r\n        this.isForwardEnabled = false;\r\n        this.isNomadicEnabled = false;\r\n        this.ready = false;\r\n        that._eventEmitter.on(\"evt_internal_presencechanged\", that.onTelPresenceChange.bind(that));\r\n        that._eventEmitter.on(\"evt_internal_callupdated\", that.onCallUpdated.bind(that));\r\n        //        that._eventEmitter.on(\"rainbow_onpbxagentstatusreceived\", that.onPbxAgentStatusChange.bind(that));\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        let that = this;\r\n        this.telephonyHandlerToken = [];\r\n        this.telephonyHistoryHandlerToken = [];\r\n        this.voiceMail = VoiceMail.createVoiceMail(_core._profiles);\r\n        that.startDate = new Date();\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                that._xmpp = _core._xmpp;\r\n                that._rest = _core._rest;\r\n                that._options = _options;\r\n                that._s2s = _core._s2s;\r\n                that._useXMPP = that._options.useXMPP;\r\n                that._useS2S = that._options.useS2S;\r\n                that._contacts = _core.contacts;\r\n                that._bubbles = _core.bubbles;\r\n                that._profiles = _core.profiles;\r\n                that.attachHandlers();\r\n                this.ready = true;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                that._logger.log(\"error\", LOG_ID + \"(start) Catch ErrorManager !!! \");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(start) Catch ErrorManager !!! : \", err.message);\r\n                return reject();\r\n            }\r\n        });\r\n    }\r\n    stop() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                that._xmpp = null;\r\n                that._rest = null;\r\n                delete that._telephonyEventHandler;\r\n                that._telephonyEventHandler = null;\r\n                if (that.telephonyHandlerToken) {\r\n                    that.telephonyHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n                }\r\n                that.telephonyHandlerToken = [];\r\n                if (that.telephonyHistoryHandlerToken) {\r\n                    that.telephonyHistoryHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n                }\r\n                that.telephonyHistoryHandlerToken = [];\r\n                this.ready = false;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    attachHandlers() {\r\n        let that = this;\r\n        that._telephonyEventHandler = new telephonyEventHandler_1.TelephonyEventHandler(that._xmpp, that, that._contacts, that._profiles);\r\n        that.telephonyHandlerToken = [\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._telephonyEventHandler.MESSAGE, that._telephonyEventHandler.onMessageReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._telephonyEventHandler.IQ_RESULT, that._telephonyEventHandler.onIqResultReceived)\r\n        ];\r\n    }\r\n    init() {\r\n        return new Promise((resolve, reject) => {\r\n            let that = this;\r\n            that._calls = [];\r\n            //that.started = false;\r\n            that.agentStatus = { phoneApi: \"disconnected\", xmppAgent: \"stopped\", agentVersion: \"unknown\" };\r\n            that.voicemailNumber = that._contacts.userContact.voicemailNumber;\r\n            that.pbxId = that._contacts.userContact.pbxId;\r\n            that.makingCall = false;\r\n            that.starting = false;\r\n            //that.voiceMail = VoiceMail.create();\r\n            that.forwardObject = {};\r\n            that.nomadicObject = {};\r\n            that.nomadicAnswerNotTakedIntoAccount = false;\r\n            that.isBasicCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_BASIC_CALL);\r\n            that.isSecondCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_SECOND_CALL);\r\n            that.isTransferAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_TRANSFER_CALL);\r\n            that.isConferenceAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_CONFERENCE_CALL);\r\n            that.isVMDeflectCallAllowed = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_DEFLECT_CALL);\r\n            that.voiceMailFeatureEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_VOICE_MAIL);\r\n            that.isForwardEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_CALL_FORWARD);\r\n            that.isNomadicEnabled = that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_NOMADIC);\r\n            // Store the user jid tel\r\n            //that.userJidTel = authService.jidTel;\r\n            that.userJidTel = that._rest.loggedInUser.jid_tel;\r\n            that.started = false;\r\n            try {\r\n                that._xmpp.getAgentStatus().then((data) => {\r\n                    that._logger.log(\"info\", LOG_ID + \"[init] getAgentStatus  -- \", data);\r\n                    resolve();\r\n                });\r\n            }\r\n            catch (err) {\r\n                that._logger.log(\"warn\", LOG_ID + \"[init] getAgentStatus failed : \", err);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    /* onPbxAgentStatusChange(data) {\r\n        let that = this;\r\n        that.agentStatus = data;\r\n    } // */\r\n    /**\r\n     * @private\r\n     * @method onTelPresenceChange\r\n     * @instance\r\n     * @description\r\n     *      Method called when receiving an update on user presence\r\n     */\r\n    onTelPresenceChange(__event, attr) {\r\n        let that = this;\r\n        if (that._contacts.isTelJid(__event.fulljid)) {\r\n            if (that._contacts.getRessourceFromJid(__event.fulljid) !== \"phone\") {\r\n                return true;\r\n            }\r\n            let jid_im = that._contacts.getImJid(__event.fulljid);\r\n            if (!jid_im) {\r\n                return true;\r\n            }\r\n            let status = __event.status;\r\n            if (that._contacts.isUserContactJid(jid_im)) {\r\n                // Receive unavailable status\r\n                if (status === \"unavailable\" || status === \"offline\" || status === \"\") {\r\n                    that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] received my telephony presence -- \" + status);\r\n                    that.started = false;\r\n                    that._calls = [];\r\n                    that._logger.log(\"debug\", LOG_ID + \"(onTelPresenceChange) send evt_internal_telephonystatuschanged \", \"stopped\");\r\n                    that._eventEmitter.emit(\"evt_internal_telephonystatuschanged\", \"stopped\");\r\n                    //$rootScope.$broadcast(\"ON_TELEPHONY_STATUS_CHANGED_EVENT\", \"stopped\");\r\n                    that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] === STOPPED ===\");\r\n                }\r\n                // Service is not started, try to fetch agent status\r\n                else if (!that.started && !that.starting) {\r\n                    that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] received my telephony presence -- \" + status);\r\n                    that.starting = true;\r\n                    that.getAgentStatus()\r\n                        .then(function () {\r\n                        // that.attachHandlers();\r\n                        return that.getTelephonyState(false);\r\n                    })\r\n                        .then(function () {\r\n                        if (that.isNomadicEnabled) {\r\n                            that.getNomadicStatus()\r\n                                .then(function () {\r\n                                if (that.nomadicObject.featureActivated && that.nomadicObject.modeActivated && !that.nomadicObject.makeCallInitiatorIsMain) {\r\n                                    return that.getTelephonyState(true);\r\n                                }\r\n                                //return Promise.resolve();\r\n                            });\r\n                        }\r\n                        //return Promise.resolve();\r\n                    })\r\n                        .then(function () {\r\n                        if (that.isForwardEnabled) {\r\n                            return that.getForwardStatus();\r\n                        }\r\n                        //return Promise.resolve();\r\n                    })\r\n                        .then(function () {\r\n                        // @ts-ignore\r\n                        let startDuration = Math.round(new Date() - that.startDate);\r\n                        // that.stats.push({ service: \"telephonyService\", startDuration: startDuration });\r\n                        that._logger.log(\"info\", LOG_ID + \"[onTelPresenceChange] === STARTED (\" + startDuration + \" ms) ===\");\r\n                        that.started = true;\r\n                        that.starting = false;\r\n                        that._logger.log(\"debug\", LOG_ID + \"(onTelPresenceChange) send evt_internal_telephonystatuschanged \", \"started\");\r\n                        that._eventEmitter.emit(\"evt_internal_telephonystatuschanged\", \"started\");\r\n                        //$rootScope.$broadcast(\"ON_TELEPHONY_STATUS_CHANGED_EVENT\", \"started\");\r\n                    })\r\n                        .catch(function (error) {\r\n                        that.starting = false;\r\n                        that._logger.log(\"error\", LOG_ID + \"[onTelPresenceChange] receive telephony presence but no agent response - \");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"[onTelPresenceChange] receive telephony presence but no agent response - : \" + error.message);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @private\r\n     * @method onCallUpdated\r\n     * @instance\r\n     * @description\r\n     *      Method called when receiving an update on a call\r\n     */\r\n    onCallUpdated(callInfo) {\r\n        let that = this;\r\n        let status = callInfo.status;\r\n        if (!status || !callInfo.id)\r\n            return;\r\n        /*\r\n        switch (status.key) {\r\n            case Call.Status.UNKNOWN:\r\n                // Delete ended call call\r\n                if (callInfo.cause === \"NORMALCLEARING\") {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(onCallUpdated) clearing the call : \", callInfo.id);\r\n                    delete this._calls[callInfo.id];\r\n                } else {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(onCallUpdated) Not a normal stop of call, so clearing the call : \", callInfo.id);\r\n                    delete this._calls[callInfo.id];\r\n                }\r\n                break;\r\n            case Call.Status.DIALING:\r\n            case Call.Status.QUEUED_OUTGOING:\r\n            case Call.Status.ACTIVE:\r\n            case Call.Status.RELEASING:\r\n            case Call.Status.ANSWERING:\r\n            case Call.Status.PUT_ON_HOLD:\r\n            case Call.Status.CONNECTING:\r\n            case Call.Status.RINGING_OUTGOING:\r\n            case Call.Status.QUEUED_INCOMING:\r\n            case Call.Status.ERROR:\r\n            case Call.Status.HOLD:\r\n            case Call.Status.RINGING_INCOMING:\r\n                if ( that._calls[callInfo.id] ) {\r\n                    that._calls[callInfo.id].updateCall(callInfo);\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n         */\r\n    }\r\n    /**\r\n     * @public\r\n     * @method isTelephonyAvailable\r\n     * @instance\r\n     * @description\r\n     *    Check if the telephony service can be used or not (if the connected user has a phone monitored by a PBX)\r\n     * @return {boolean} Return true if the telephony service is configured\r\n     */\r\n    isTelephonyAvailable() {\r\n        return this.started;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getAgentVersion\r\n     * @instance\r\n     * @description\r\n     *    Get the associated PBX agent version\r\n     * @return {string} Return the version of the agent or \"unknown\"\r\n     */\r\n    getAgentVersion() {\r\n        let that = this;\r\n        return that.agentStatus.agentVersion || \"unknown\";\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getXMPPAgentStatus\r\n     * @instance\r\n     * @description\r\n     *    Get the status of the XMPP connection to the PBX Agent\r\n     * @return {string} Return the status of the connections to the agent or \"unknown\"\r\n     */\r\n    getXMPPAgentStatus() {\r\n        let that = this;\r\n        return that.agentStatus.xmppAgent || \"unknown\";\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getPhoneAPIStatus\r\n     * @instance\r\n     * @description\r\n     *    Get the status of the Phone API status for the PBX Agent\r\n     * @return {string} Return the Phone API status for to this Agent or \"unknown\"\r\n     */\r\n    getPhoneAPIStatus() {\r\n        let that = this;\r\n        return that.agentStatus.phoneApi || \"unknown\";\r\n    }\r\n    getAgentStatus() {\r\n        let that = this;\r\n        //return that.agentStatus;\r\n        return that._xmpp.getAgentStatus().then((data) => {\r\n            that._logger.log(\"info\", LOG_ID + \"[getAgentStatus] -- \", data);\r\n            that.agentStatus = data;\r\n            return data;\r\n        }); // */\r\n    }\r\n    /**\r\n     * @private\r\n     * @method getTelephonyState\r\n     * @param second\r\n     */\r\n    getTelephonyState(second) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._xmpp.getTelephonyState(second).then((data) => {\r\n                let existingCalls = data;\r\n                if (existingCalls && that.getTabSize(existingCalls) > 0) {\r\n                    // Traverse existing call\r\n                    let getCallPromises = [];\r\n                    existingCalls.forEach((child) => {\r\n                        getCallPromises.push(that.createCallFromConnectionElem(child));\r\n                    });\r\n                    // Send all getContactPromise\r\n                    Promise.all(getCallPromises)\r\n                        .then(function () {\r\n                        that._logger.log(\"debug\", LOG_ID + \"getTelephonyState -- success\");\r\n                        resolve();\r\n                    })\r\n                        .catch(function (error) {\r\n                        that._logger.log(\"error\", LOG_ID + \"getTelephonyState -- failure -- \");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"getTelephonyState -- failure -- : \", error.message);\r\n                        return reject(error);\r\n                    });\r\n                }\r\n                //return data;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @param connectionElemObj\r\n     */\r\n    createCallFromConnectionElem(connectionElemObj) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Extract information\r\n            //let connectionElem = angular.element(connectionElemObj);\r\n            let connectionElem = connectionElemObj;\r\n            let jid = connectionElem.attr(\"endpointIm\");\r\n            let phoneNumber = connectionElem.attr(\"endpointTel\");\r\n            let connectionId = connectionElem.attr(\"callId\");\r\n            let endpointLci = connectionElem.attr(\"endpointLci\");\r\n            let lci = connectionElem.attr(\"lci\");\r\n            let participantsElem = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(connectionElem, \"participants\"); // connectionElem.find(\"participant\");\r\n            let identityElem = XMPPUtils_1.XMPPUTils.getXMPPUtils().findChild(connectionElem, \"identity\");\r\n            let identityFirstName = identityElem.attr(\"firstName\");\r\n            let identityLastName = identityElem.attr(\"lastName\");\r\n            let firstName = \"\";\r\n            let lastName = \"\";\r\n            if (!jid && !phoneNumber) {\r\n                phoneNumber = \"****\";\r\n            }\r\n            //manage name resolution\r\n            if (that._profiles.isFeatureEnabled(that._profiles.getFeaturesEnum().TELEPHONY_PHONE_BOOK)) {\r\n                //find Xnames, here for simple call only\r\n                if (participantsElem.length === 0 && identityLastName && identityLastName.length) {\r\n                    lastName = identityLastName;\r\n                    if (identityFirstName && identityFirstName.length) {\r\n                        firstName = identityFirstName;\r\n                    }\r\n                    that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - name resolution for: \" + connectionId + \" for phoneNumber:\" + utils.anonymizePhoneNumber(phoneNumber) +\r\n                        \" with firstname : \" + firstName.slice(0, 1) + \"***\");\r\n                }\r\n            }\r\n            // Ignore useless info\r\n            if (lci === \"LCI_INITIATED\") {\r\n                resolve();\r\n            }\r\n            //service.getSnapshotCall(connectionId);\r\n            // Define getParticipants promise\r\n            let getParticipants = function () {\r\n                if (participantsElem.children.length === 0) {\r\n                    return that._contacts.getOrCreateContact(jid, phoneNumber);\r\n                }\r\n                return that.getParticipantsFromParticipantsElem(participantsElem);\r\n            };\r\n            // Call the promise\r\n            getParticipants().then(function (response) {\r\n                // Extract call status\r\n                let callStatus = Call_1.Call.Status.ACTIVE;\r\n                if (lci === \"LCI_HELD\" && endpointLci === \"LCI_CONNECTED\") {\r\n                    callStatus = Call_1.Call.Status.HOLD;\r\n                }\r\n                if (lci === \"LCI_CONNECTED\" && endpointLci === \"LCI_HELD\") {\r\n                    callStatus = Call_1.Call.Status.PUT_ON_HOLD;\r\n                }\r\n                if (lci === \"LCI_CONNECTED\" && endpointLci === \"LCI_QUEUED\") {\r\n                    callStatus = Call_1.Call.Status.QUEUED_OUTGOING;\r\n                }\r\n                if (lci === \"LCI_QUEUED\" && endpointLci === \"LCI_CONNECTED\") {\r\n                    callStatus = Call_1.Call.Status.QUEUED_INCOMING;\r\n                }\r\n                // Create the call object\r\n                let call = null;\r\n                let deviceType = connectionElem.find(\"deviceType\");\r\n                if (participantsElem.children.length === 0) {\r\n                    if (response && response.temp && lastName !== \"\") {\r\n                        response.updateName(firstName, lastName);\r\n                    }\r\n                    call = that.getOrCreateCall(callStatus, connectionId, deviceType, response);\r\n                    that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - create call for user: \" + response.id + \" with callId: \" + connectionId + \" \" + lci);\r\n                }\r\n                else {\r\n                    call = that.getOrCreateCall(callStatus, connectionId, deviceType, null);\r\n                    call.setParticipants(response);\r\n                    call.isConference = true;\r\n                    that._logger.log(\"internal\", LOG_ID + \" createCallFromConnectionElem - create conference call with callId: \" + connectionId + \" \" + lci);\r\n                }\r\n                call.relevantEquipmentId = Call_1.Call.getDeviceIdFromConnectionId(connectionId);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                // Send call update event\r\n                //that._logger.log(\"internal\", LOG_ID + \"(createCallFromConnectionElem) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                resolve(call);\r\n            })\r\n                .catch(function (error) {\r\n                that._logger.log(\"error\", LOG_ID + \" createCallFromConnectionElem - failure - \");\r\n                that._logger.log(\"internalerror\", LOG_ID + \" createCallFromConnectionElem - failure - : \", error.message);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * @private\r\n     * @method getParticipantsFromParticipantsElem\r\n     * @param participants\r\n     */\r\n    getParticipantsFromParticipantsElem(participants) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            let confParticipants = [];\r\n            // Create getParticipantPromise\r\n            let participantPromises = [];\r\n            participants.each(function (elemt) {\r\n                let participantElem = elemt;\r\n                let endpointTel = participantElem.find(\"endpointTel\").text();\r\n                let endpointIm = participantElem.find(\"endpointIm\").text();\r\n                if (!(endpointIm && that._contacts.isUserContactJid(endpointIm))) {\r\n                    participantPromises.push(new Promise(function (resolvePromise, rejectPromise) {\r\n                        if (!endpointIm && !endpointTel) {\r\n                            endpointTel = \"****\";\r\n                        }\r\n                        that._contacts.getOrCreateContact(endpointIm, endpointTel)\r\n                            .then(function (contact) { confParticipants.push(contact); resolvePromise(); })\r\n                            .catch(function (error) { rejectPromise(error); });\r\n                    }));\r\n                }\r\n            });\r\n            // Get participants asynchronously\r\n            Promise.all(participantPromises).then(function success() { resolve(confParticipants); }, function failure(error) { return reject(error); });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method getVoiceMessageCounter\r\n     * @description\r\n     *      Get the number of voice message\r\n     * @return {Promise<integer>} Return resolved promise if succeed with the number of messages, and a rejected else.\r\n     */\r\n    getVoiceMessageCounter() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            //reject not allowed operations\r\n            if (!that.voiceMailFeatureEnabled) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"getVoiceMessageCounter failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(getVoiceMessageCounter) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getVoiceMessageCounter) error : \", profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            that._xmpp.voiceMessageQuery(that.userJidTel).then(function (data) {\r\n                console.error(data);\r\n                resolve(data);\r\n            })\r\n                .catch(function (error) {\r\n                let errorMessage = \"getVoiceMessageCounter failure : \" + error.message;\r\n                that._logger.log(\"error\", LOG_ID + \"(getVoiceMessageCounter) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getVoiceMessageCounter) Error : \", errorMessage);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n            });\r\n        });\r\n    }\r\n    /*********************************************************/\r\n    /**                   CALL HANDLERS                     **/\r\n    /*********************************************************/\r\n    /**\r\n     * @public\r\n     * @method getCallToHangOut\r\n     * @description\r\n     *      Get the call which can be hang out\r\n     * @return {Call} The call with the ability to be hang out.\r\n     */\r\n    getCallToHangOut() {\r\n        let that = this;\r\n        let calls = that.getActiveCalls();\r\n        if (!calls || that.getTabSize(calls) === 0) {\r\n            return null;\r\n        }\r\n        let callStatus = calls[0].status;\r\n        if (that.getTabSize(calls) === 1 || (callStatus === Call_1.Call.Status.DIALING || callStatus === Call_1.Call.Status.ACTIVE || callStatus === Call_1.Call.Status.PUT_ON_HOLD)) {\r\n            return calls[0];\r\n        }\r\n        return calls[1];\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getActiveCall\r\n     * @description\r\n     *      get the active call\r\n     * @return {Call} The active call\r\n     */\r\n    getActiveCall() {\r\n        let that = this;\r\n        let activeCall = null;\r\n        Object.keys(that._calls || []).forEach(function (key) {\r\n            let call = that._calls[key];\r\n            if (call.status === Call_1.Call.Status.ACTIVE) {\r\n                activeCall = call;\r\n            }\r\n        });\r\n        return activeCall;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getActiveCalls\r\n     * @description\r\n     *      get active calls\r\n     * @return {Call} The active call\r\n     */\r\n    getActiveCalls() {\r\n        let that = this;\r\n        let calls = [];\r\n        Object.keys(that._calls || []).forEach(function (key) {\r\n            if (that._calls[key].status === Call_1.Call.Status.DIALING ||\r\n                that._calls[key].status === Call_1.Call.Status.RINGING_OUTGOING ||\r\n                that._calls[key].status === Call_1.Call.Status.QUEUED_OUTGOING ||\r\n                that._calls[key].status === Call_1.Call.Status.ACTIVE ||\r\n                that._calls[key].status === Call_1.Call.Status.HOLD ||\r\n                that._calls[key].status === Call_1.Call.Status.PUT_ON_HOLD ||\r\n                that._calls[key].status === Call_1.Call.Status.ERROR) {\r\n                calls.push(that._calls[key]);\r\n            }\r\n        });\r\n        return calls;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getCalls\r\n     * @description\r\n     *      get calls\r\n     * @return {Call} The calls\r\n     */\r\n    getCalls() {\r\n        let that = this;\r\n        let calls = [];\r\n        Object.keys(that._calls || []).forEach(function (key) {\r\n            calls.push(that._calls[key]);\r\n        });\r\n        return calls;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getCallsSize\r\n     * @description\r\n     *      get calls tab size. Warning do not use length on the getCalls method result because it is the last index id +1\r\n     * @return {Call} The calls tab size\r\n     */\r\n    getCallsSize() {\r\n        return this.getTabSize(this.getCalls());\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {Array} tab The tab which need to be sized\r\n     */\r\n    getTabSize(tab) {\r\n        return Object.keys(tab).length;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getActiveCall\r\n     * @param {Contact} contact The contact with an active call with us.\r\n     * @description\r\n     *      get the active call for a contact\r\n     * @return {Call} The active call\r\n     */\r\n    getActiveCallsForContact(contact) {\r\n        let that = this;\r\n        let calls = [];\r\n        if (contact && contact.jid) {\r\n            Object.keys(that._calls || []).forEach(function (key) {\r\n                if ((that._calls[key].contact && that._calls[key].contact.jid === contact.jid) &&\r\n                    (that._calls[key].status === Call_1.Call.Status.DIALING ||\r\n                        that._calls[key].status === Call_1.Call.Status.RINGING_OUTGOING ||\r\n                        that._calls[key].status === Call_1.Call.Status.ACTIVE ||\r\n                        that._calls[key].status === Call_1.Call.Status.HOLD ||\r\n                        that._calls[key].status === Call_1.Call.Status.PUT_ON_HOLD)) {\r\n                    calls.push(that._calls[key]);\r\n                }\r\n            });\r\n        }\r\n        return calls;\r\n    }\r\n    /*************************************************************/\r\n    /*                    MAKE CALL STUFF                        */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method makeCall\r\n     * @instance\r\n     * @description\r\n     *    Call a number <br/>\r\n     *    Contacts and numbers are allowed\r\n     *    Return a promise\r\n     * @param {Contact} contact - contact object that you want to call\r\n     * @param {String} phoneNumber The number to call\r\n     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n     * @return {Promise<Call>} Return a promise with the call created\r\n     */\r\n    makeCall(contact, phoneNumber, correlatorData) {\r\n        let that = this;\r\n        let activeCall = that.getActiveCall();\r\n        if (that.makingCall && !that.isSecondCallAllowed) {\r\n            that._logger.log(\"debug\", LOG_ID + \"(makeCall) makeCall failure - makeCall already making a call, is second call allowed ? \", that.isSecondCallAllowed);\r\n            return Promise.reject();\r\n        }\r\n        if (!contact) {\r\n            contact = {};\r\n        }\r\n        // Set makingCall flag\r\n        that.makingCall = true;\r\n        // Handle simpleCall\r\n        if (!activeCall) {\r\n            return that.makeSimpleCall(contact, phoneNumber, correlatorData);\r\n        }\r\n        // Handle consultationCall\r\n        return that.makeConsultationCall(contact, phoneNumber, activeCall.connectionId, correlatorData);\r\n    }\r\n    /**\r\n     * @private\r\n     * @method makeSimpleCall\r\n     * @param contact\r\n     * @param phoneNumber\r\n     * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n     */\r\n    makeSimpleCall(contact, phoneNumber, correlatorData) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) to \" + (contact ? contact.displayName : phoneNumber));\r\n            //reject not allowed operations\r\n            if (!that.isBasicCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"makeSimpleCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(makeSimpleCall) Error.\");\r\n                that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) Error : \", profileError.msg);\r\n                // Release makingCall flag\r\n                that.makingCall = false;\r\n                return reject(profileError);\r\n            }\r\n            let phoneInfo = that.getPhoneInfo(contact, phoneNumber, correlatorData);\r\n            that._rest.makeCall(contact, phoneInfo).then(function success(response) {\r\n                // Create the call object\r\n                let callInfos = {\r\n                    status: Call_1.Call.Status.DIALING,\r\n                    id: Call_1.Call.getIdFromConnectionId(response.callId),\r\n                    type: Call_1.Call.Type.PHONE,\r\n                    contact,\r\n                    deviceType: undefined,\r\n                    connectionId: response.callId\r\n                };\r\n                //let call = Call.CallFactory()(callInfos);\r\n                //let call = Call.create(Call.Status.DIALING, null, Call.Type.PHONE, contact, undefined);\r\n                //call.setConnectionId(response.callId);\r\n                // Release makinCall flag\r\n                that.makingCall = false;\r\n                let call = that.addOrUpdateCallToCache(callInfos);\r\n                // Indicate whether it is a call to own voicemail\r\n                call.setIsVm(phoneNumber === that.voicemailNumber);\r\n                that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) success : \" + utils.anonymizePhoneNumber(phoneNumber) + \" Call (\" + call + \")\");\r\n                // Send call update event\r\n                /* TREATED BY EVENTS\r\n                that._logger.log(\"debug\", LOG_ID + \"(makeSimpleCall) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                 */\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                resolve(call);\r\n            }, (response) => __awaiter(this, void 0, void 0, function* () {\r\n                that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) failed : \", response);\r\n                //let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, contact, undefined);\r\n                let id = 0;\r\n                if (contact && contact.id) {\r\n                    id = contact.id;\r\n                }\r\n                else {\r\n                    let min = Math.ceil(1);\r\n                    let max = Math.floor(9999);\r\n                    id = 9999 + Math.floor(Math.random() * (max - min + 1)) + min;\r\n                }\r\n                let callInfos = {\r\n                    status: Call_1.Call.Status.ERROR,\r\n                    id: id + \"\",\r\n                    type: Call_1.Call.Type.PHONE,\r\n                    contact,\r\n                    deviceType: undefined,\r\n                    connectionId: id + \"#00\",\r\n                    cause: \"error\"\r\n                };\r\n                //let call = Call.CallFactory()(callInfos);\r\n                //call.cause = \"error\";\r\n                //that._calls[call.contact.id] = call;\r\n                //this._calls.push(call);\r\n                let call = this.addOrUpdateCallToCache(callInfos);\r\n                that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) that._calls.length : \", that._calls.length);\r\n                // call.autoClear = $interval(function () {\r\n                yield that.clearCall(call);\r\n                //}, 5000, 1);\r\n                // Release makinCall flag\r\n                that.makingCall = false;\r\n                // Send call update event\r\n                //that._logger.log(\"internal\", LOG_ID + \"(makeSimpleCall) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                return reject(error);\r\n                //that._logger.log(\"error\", LOG_ID + \"(makeSimpleCall) Error.\");\r\n                //that._logger.log(\"internalerror\", LOG_ID + \"(makeSimpleCall) Error : \", error);\r\n            }));\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method makeConsultationCall\r\n     * @param contact\r\n     * @param phoneNumber\r\n     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n     * @param callId\r\n     */\r\n    makeConsultationCall(contact, phoneNumber, callId, correlatorData) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            //reject not allowed operations\r\n            if (!that.isSecondCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"makeConsultationCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(makeConsultationCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(makeConsultationCall) Error : \", profileError.msg);\r\n                // Release makingCall flag\r\n                that.makingCall = false;\r\n                return reject(profileError);\r\n            }\r\n            let phoneInfo = that.getPhoneInfo(contact, phoneNumber, correlatorData);\r\n            that._rest.makeConsultationCall(callId, contact, phoneInfo).then(function success(response) {\r\n                // Create the call object\r\n                //let call = Call.create(Call.Status.DIALING, null, Call.Type.PHONE, contact, undefined);\r\n                let callInfos = {\r\n                    status: Call_1.Call.Status.DIALING,\r\n                    id: \"\",\r\n                    type: Call_1.Call.Type.PHONE,\r\n                    contact,\r\n                    deviceType: undefined,\r\n                };\r\n                if (response && response.data && response.data.data) {\r\n                    callInfos.id = Call_1.Call.getIdFromConnectionId(response.data.data.callId);\r\n                }\r\n                else {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(makeConsultationCall) makeConsultationCall response.data.data empty, can not find callId, get it directly in response : \", response);\r\n                    callInfos.id = Call_1.Call.getIdFromConnectionId(response.callId);\r\n                }\r\n                //let call = Call.CallFactory()(callInfos);\r\n                //call.setConnectionId(response.data.data.callId);\r\n                //that._calls[call.id] = call;\r\n                //this._calls.push(call);\r\n                let call = that.addOrUpdateCallToCache(callInfos);\r\n                that._logger.log(\"internal\", LOG_ID + \"(makeConsultationCall) makeConsultationCall success : \" + utils.anonymizePhoneNumber(phoneNumber) + \" Call (\" + call + \")\");\r\n                // Release makinCall flag\r\n                that.makingCall = false;\r\n                // Indicate whether it is a call to own voicemail\r\n                call.setIsVm(phoneNumber === that.voicemailNumber);\r\n                // Send call update event\r\n                /* TREATED BY EVENTS\r\n                that._logger.log(\"debug\", LOG_ID + \"(makeConsultationCall) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                 */\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                resolve(call.id);\r\n            }, function failure(response) {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    //let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, contact, undefined);\r\n                    let callInfos = {\r\n                        status: Call_1.Call.Status.ERROR,\r\n                        id: contact.id + \"\",\r\n                        type: Call_1.Call.Type.PHONE,\r\n                        contact,\r\n                        deviceType: undefined,\r\n                        connectionId: contact.id + \"#00\",\r\n                        cause: \"error\"\r\n                    };\r\n                    //let call = Call.CallFactory()(callInfos);\r\n                    //call.cause = \"error\";\r\n                    //that._calls[call.contact.id] = call;\r\n                    //this._calls.push(call);\r\n                    let call = that.addOrUpdateCallToCache(callInfos);\r\n                    //call.autoClear = $interval(function () {\r\n                    yield that.clearCall(call);\r\n                    //}, 5000, 1);\r\n                    // Release makinCall flag\r\n                    that.makingCall = false;\r\n                    // Send call update event\r\n                    //that._logger.log(\"debug\", LOG_ID + \"(makeConsultationCall) send evt_internal_callupdated \", call);\r\n                    that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    return reject(error);\r\n                    //that._logger.log(\"error\", LOG_ID + \"(makeConsultationCall) Error\");\r\n                    //that._logger.log(\"internalerror\", LOG_ID + \"(makeConsultationCall) Error : \", error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method makeCall\r\n     * @instance\r\n     * @description\r\n     *    Call a number <br/>\r\n     *    Return a promise\r\n     * @param {String} phoneNumber The number to call\r\n     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n     * @return {Promise<Call>} Return a promise with the call created\r\n     */\r\n    makeCallByPhoneNumber(phoneNumber, correlatorData) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) calling : \" + utils.anonymizePhoneNumber(phoneNumber));\r\n            if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\r\n                let errorMessage = \"makeCallByPhoneNumber) failure: impossible to call its own phone number\";\r\n                that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) Error : \", errorMessage);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n            }\r\n            let myContact = null;\r\n            that._contacts.getOrCreateContact(null, phoneNumber)\r\n                .then((contact) => {\r\n                myContact = contact;\r\n                return that.makeCall(contact, phoneNumber, correlatorData);\r\n            })\r\n                .then((data) => {\r\n                that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) after makeCall resolve result : \", data);\r\n                resolve(data);\r\n            })\r\n                .catch((error) => {\r\n                that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) Error : \", error);\r\n                return reject(error);\r\n                /* let _errorMessage = \"makeCallByPhoneNumber failure \" + (error ? error.message : \"\");\r\n                 that._logger.log(\"error\", LOG_ID + \"(makeCallByPhoneNumber) - Error.\" );\r\n                 that._logger.log(\"internalerror\", LOG_ID + \"(makeCallByPhoneNumber) - Error : \", _errorMessage);\r\n\r\n//                    let call = Call.create(Call.Status.ERROR, null, Call.Type.PHONE, myContact, undefined);\r\n                 let callInfos = {status : Call.Status.ERROR, id : undefined, type : Call.Type.PHONE, contact : myContact, deviceType : undefined} ;\r\n                 let call = Call.CallFactory()(callInfos);\r\n                 call.cause = \"invalidPhoneNumber\";\r\n                 that._calls[call.contact.id] = call;\r\n                 await that.clearCall(call);\r\n                 //that._logger.log(\"internal\", LOG_ID + \"(makeCallByPhoneNumber) send evt_internal_callupdated \", call);\r\n                 that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n\r\n//                    $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n\r\n                 reject(ErrorManager.getErrorManager().OTHERERROR(call.cause, _errorMessage)); // */\r\n            });\r\n        });\r\n    }\r\n    /* TO DO */\r\n    /*\t\tservice.makeCallWithMobile = function(mobileRessource, phoneNumber) {\r\n\r\n                let defer = $q.defer();\r\n\r\n                if (contactService.userContact.mobilePro === phoneNumber || contactService.userContact.mobilePerso === phoneNumber) {\r\n                    let errorMessage = \"makeCallWithMobile failure: impossible to call its own mobile phone number\";\r\n                    that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) \" + errorMessage);\r\n                    defer.reject(ErrorManager.getErrorManager().OTHERERROR(errorMessage));\r\n                    return defer.promise;\r\n                }\r\n\r\n                // Forge request IQ\r\n                let makeMobileCallMsg = $iq({ type: \"set\", to: mobileRessource })\r\n                    .c(\"call\", { xmlns: \"urn:xmpp:call\", phoneNumber: phoneNumber, directCall: false });\r\n\r\n                xmppService.sendIQ(makeMobileCallMsg)\r\n                    .then(function() {\r\n                        defer.resolve();\r\n                    })\r\n                    .catch(function(error) {\r\n                        let errorMessageMobile = \"makeCallWithMobile failure : \" + error.message;\r\n                        that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) - callService - \" + errorMessageMobile);\r\n                        defer.reject(ErrorManager.getErrorManager().OTHERERROR(errorMessageMobile));\r\n                    });\r\n\r\n                // Return the promise\r\n                return defer.promise;\r\n            };\r\n    */\r\n    /**\r\n     * @private\r\n     * @method getPhoneInfo\r\n     * @param contact\r\n     * @param phoneNumber\r\n     * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call\r\n     */\r\n    getPhoneInfo(contact, phoneNumber, correlatorData) {\r\n        let that = this;\r\n        let longNumber = phoneNumber;\r\n        let shortNumber = \"\";\r\n        let internalNumber = \"\"; //#29475\r\n        let pbxId = \"\";\r\n        if (contact) {\r\n            if (phoneNumber === contact.phonePro || phoneNumber === contact.phoneProCan) {\r\n                longNumber = contact.phoneProCan ? contact.phoneProCan : \"\";\r\n                //if (!longNumber && contact.phonePro) { longNumber = contact.phonePro; }\r\n                shortNumber = contact.phonePbx;\r\n                pbxId = contact.pbxId;\r\n                internalNumber = contact.phoneInternalNumber; //#29475\r\n            }\r\n            else if (phoneNumber === contact.phonePbx) {\r\n                longNumber = \"\";\r\n                shortNumber = contact.phonePbx;\r\n                pbxId = contact.pbxId;\r\n                internalNumber = contact.phoneInternalNumber; //#29475\r\n            }\r\n        }\r\n        return { longNumber: longNumber, shortNumber: shortNumber, pbxId: pbxId, internalNumber: internalNumber, correlatorData: correlatorData }; //#29475\r\n    }\r\n    /*getErrorMessage(data, actionLabel) {\r\n        let that = this;\r\n        let errorMessage = actionLabel + \" failure : \";\r\n\r\n        if (angular.element(data).attr(\"type\") === \"error\") {\r\n\r\n            let error = angular.element(data).find(\"error\");\r\n            if (error) {\r\n                let errorType = error.attr(\"type\");\r\n                let errorCode = error.attr(\"code\");\r\n                if (errorType) {\r\n                    errorMessage += (errorType + \" : \");\r\n\r\n                    if (errorType === \"modify\") {\r\n                        errorMessage += error.find(\"text\").text();\r\n                    }\r\n                }\r\n                if (errorCode) {\r\n                    if (errorCode === \"503\") {\r\n                        errorMessage += \"Agent error : service unavailable\";\r\n                    }\r\n                }\r\n\r\n                that._logger.log(\"error\", LOG_ID + \"(makeCallWithMobile) \" + errorMessage);\r\n\r\n            }\r\n            else {\r\n                errorMessage += \"Unknown error\";\r\n            }\r\n\r\n            return errorMessage;\r\n        }\r\n        return null;\r\n    } // */\r\n    /*************************************************************/\r\n    /*                    RELEASE CALL STUFF                     */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method releaseCall\r\n     * @instance\r\n     * @description\r\n     *    Release a call <br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to release\r\n     * @return {Promise<Call>} Return a promise with the call released\r\n     */\r\n    releaseCall(call) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._logger.log(\"internal\", LOG_ID + \"(releaseCall) call : \", call);\r\n            that._logger.log(\"debug\", LOG_ID + \"(releaseCall) call id : \", call.id);\r\n            //reject not allowed operations\r\n            if (!that.isBasicCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"releaseCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(releaseCall) Error : \", profileError);\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(releaseCall) Error : \", profileError);\r\n                return reject(profileError);\r\n            }\r\n            that._rest.releaseCall(call).then(() => __awaiter(this, void 0, void 0, function* () {\r\n                // Update call status\r\n                that._logger.log(\"debug\", LOG_ID + \"(releaseCall) releaseCall \" + call.id + \" - success\");\r\n                // SHOULD BE TREATED BY EVENTS. But server dos not send the event if it is the end of a conference\r\n                call.setStatus(Call_1.Call.Status.UNKNOWN);\r\n                call.startDate = null;\r\n                call.vm = false;\r\n                // Send call update event\r\n                //that._logger.log(\"internal\", LOG_ID + \"(releaseCall) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                // Clean the call array\r\n                // service.calls = []; //// MCO OULALALALA\r\n                //delete that.calls[call.id];\r\n                // Keep the delete of released Call because the server do not raise the end call event on one participant of an OXE conference.\r\n                yield that.removeCallFromCache(call.id);\r\n                // */\r\n                resolve(call);\r\n            }), (response) => {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(releaseCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(releaseCall) Error : \", error, \", response : \", response);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                     ANSWER CALL STUFF                     */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method answerCall\r\n     * @instance\r\n     * @description\r\n     *    Answer a call <br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to answer\r\n     * @return {Promise<Call>} Return a promise with the answered call.\r\n     */\r\n    answerCall(call) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (call.contact) {\r\n                that._logger.log(\"internal\", LOG_ID + \"(answerCall) : \" + utils.anonymizePhoneNumber(call.contact.phone) + \"(\" + call.contact.displayNameForLog() + \")\");\r\n            }\r\n            else {\r\n                that._logger.log(\"internal\", LOG_ID + \"(answerCall) : \", call);\r\n            }\r\n            // First hold the current active call\r\n            let activeCall = that.getActiveCall();\r\n            //reject not allowed operations\r\n            if (!that.isBasicCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"answerCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(answerCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) Error : \", profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            if (call.status === Call_1.Call.Status.QUEUED_INCOMING && activeCall) {\r\n                that.holdCall(activeCall)\r\n                    .then(function () {\r\n                    return that.answerCall(call);\r\n                })\r\n                    .then(function (thecall) {\r\n                    resolve(thecall);\r\n                })\r\n                    .catch(function (error) {\r\n                    let errorMessage = \"answerCall failure : \" + error.message;\r\n                    that._logger.log(\"error\", LOG_ID + \"(answerCall) - callService - Error\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) - callService - Error : \", errorMessage);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                });\r\n            }\r\n            else {\r\n                that._rest.answerCall(call).then(function success(response) {\r\n                    // Update call status\r\n                    call.setConnectionId(response.callId);\r\n                    call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                    that._logger.log(\"internal\", LOG_ID + \"(answerCall) answerCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \")\");\r\n                    /* TREATED BY EVENTS\r\n                        // Send call update event\r\n                        that._logger.log(\"debug\", LOG_ID + \"(answerCall) send evt_internal_callupdated \", call);\r\n                        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n\r\n                     */\r\n                    resolve(call);\r\n                }, function failure(response) {\r\n                    // Send call update event\r\n                    //that._logger.log(\"internal\", LOG_ID + \"(answerCall) send evt_internal_callupdated \", call);\r\n                    that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                    //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(answerCall) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(answerCall) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                      HOLD CALL STUFF                      */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method holdCall\r\n     * @instance\r\n     * @description\r\n     *    Hold a call <br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to hold\r\n     * @return {Call} Return a promise with the held call.\r\n     */\r\n    holdCall(call) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            // Ignore call already hold\r\n            if (!call || call.status === Call_1.Call.Status.HOLD) {\r\n                return resolve(call);\r\n            }\r\n            //reject not allowed operations\r\n            if (!that.isSecondCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"holdCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(holdCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(holdCall) \", profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            /* $http({\r\n                method: \"PUT\",\r\n                url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/hold\",\r\n                headers: authService.getRequestHeader()\r\n            }) // */\r\n            that._rest.holdCall(call).then(function success(response) {\r\n                that._logger.log(\"info\", LOG_ID + \"(holdCall) holdCall success.\");\r\n                that._logger.log(\"internal\", LOG_ID + \"(holdCall) holdCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \"), response : \", response);\r\n                // Update call status\r\n                if (response && response.data && response.data.data) {\r\n                    call.setConnectionId(response.data.data.callId);\r\n                }\r\n                else {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(holdCall) holdCall response.data.data empty, can not find callId, get it directly in response : \", response);\r\n                    call.setConnectionId(response.callId);\r\n                }\r\n                call.setStatus(Call_1.Call.Status.HOLD);\r\n                /* TREATED BY EVENTS\r\n                // Send call update event\r\n                that._logger.log(\"debug\", LOG_ID + \"(holdCall) send evt_internal_callupdated \", call);\r\n                that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n                 */\r\n                resolve(call);\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                reject(error);\r\n                that._logger.log(\"error\", LOG_ID + \"(holdCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(holdCall) Error : \", error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                     RETRIEVE CALL STUFF                     */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method retrieveCall\r\n     * @instance\r\n     * @description\r\n     *    Retrieve a call <br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to retrieve\r\n     * @return {Promise<Call>} Return a promise with the call retrieved\r\n     */\r\n    retrieveCall(call) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall : \" + call.contact.displayNameForLog());\r\n            //reject not allowed operations\r\n            if (!that.isSecondCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"retrieveCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(retrieveCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) Error : \", profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            // First hold the current active call\r\n            let activeCall = that.getActiveCall();\r\n            if (activeCall) {\r\n                that.holdCall(activeCall)\r\n                    .then(function () {\r\n                    return that.retrieveCall(call);\r\n                })\r\n                    .then(function (thecall) {\r\n                    resolve(thecall);\r\n                })\r\n                    .catch(function (error) {\r\n                    let errorMessage = \"retrieveCall failure : \" + error.message;\r\n                    that._logger.log(\"error\", LOG_ID + \"(retrieveCall) - callService -  Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) - callService - Error : \", errorMessage);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                });\r\n            }\r\n            else {\r\n                /*$http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/retrieve\",\r\n                    headers: authService.getRequestHeader()\r\n                })// */\r\n                that._rest.retrieveCall(call).then(function success(response) {\r\n                    that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall success : \" + utils.anonymizePhoneNumber(call.contact.phone) + \" Call (\" + call + \")\");\r\n                    // Update call status\r\n                    if (response && response.data && response.data.data) {\r\n                        call.setConnectionId(response.data.data.callId);\r\n                    }\r\n                    else {\r\n                        that._logger.log(\"internal\", LOG_ID + \"(retrieveCall) retrieveCall response.data.data empty, can not find callId, get it directly in response : \", response);\r\n                        call.setConnectionId(response.callId);\r\n                    }\r\n                    call.setStatus(Call_1.Call.Status.ACTIVE);\r\n                    /* TREATED BY EVENTS\r\n                        // Send call update event\r\n                        that._logger.log(\"debug\", LOG_ID + \"(retrieveCall) send evt_internal_callupdated \", call);\r\n                        that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n                        //$rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n\r\n                     */\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(retrieveCall) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(retrieveCall) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                     DEFLECT CALL STUFF                    */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method deflectCallToVM\r\n     * @instance\r\n     * @description\r\n     *    Deflect a call to the voice mail <br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to deflect\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    deflectCallToVM(call) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Ignore wrong request\r\n            if (!call) {\r\n                return resolve(call);\r\n            }\r\n            //reject not allowed operations\r\n            if (!that.isVMDeflectCallAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"deflectCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(deflectCallToVM) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(deflectCallToVM) Error : \" + profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(deflectCallToVM) deflectCallToVM \", call.contact.displayNameForLog());\r\n            /*$http({\r\n                method: \"PUT\",\r\n                url: service.portalURL + \"calls/\" + encodeURIComponent(call.connectionId) + \"/deflect\",\r\n                headers: authService.getRequestHeader(),\r\n                data: {\r\n                    calleeExtNumber: \"\",\r\n                    calleeIntNumber: service.voicemailNumber,\r\n                    calleeShortNumber: service.voicemailNumber,\r\n                    calleePbxId: service.pbxId\r\n                }\r\n            }) // */\r\n            let data = {\r\n                calleeExtNumber: \"\",\r\n                calleeIntNumber: that.voicemailNumber,\r\n                calleeShortNumber: that.voicemailNumber,\r\n                calleePbxId: that.pbxId\r\n            };\r\n            that._rest.deflectCallToVM(call, data).then(function success() {\r\n                that._logger.log(\"debug\", LOG_ID + \"(deflectCallToVM) deflectCall success\");\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(deflectCallToVM) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(deflectCallToVM) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                     DEFLECT CALL STUFF                    */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method deflectCall\r\n     * @instance\r\n     * @description\r\n     *    Deflect a call to an other telephone number<br/>\r\n     *    Return a promise\r\n     * @param {Call} call The call to deflect\r\n     * @param {Object} callee The callee phone number informations where the call shopuld be deflecte'd.\r\n     * @param {string} callee.calleeExtNumber : The phone number where the call is deflected, the format could be anything the user can type, it will be transformed in E164 format.,\r\n     * @param {string} callee.calleeIntNumber : Internal number if available,\r\n     * @param {string} callee.calleePbxId : The pbx id if available,\r\n     * @param {string} [callee.calleeShortNumber] : Short number,\r\n     * @param {string} [callee.calleeDisplayName] : The displayed name,\r\n     * @param {string} [callee.calleeCountry] : The contry whe the call will be deflected.\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    deflectCall(call, callee) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Ignore wrong request\r\n            if (!call || !callee) {\r\n                resolve();\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(deflectCall) deflectCall \" + call.contact.displayNameForLog());\r\n            let data = {\r\n                \"calleeExtNumber\": callee.calleeExtNumber,\r\n                \"calleeIntNumber\": callee.calleeIntNumber,\r\n                \"calleePbxId\": callee.calleePbxId,\r\n                \"calleeShortNumber\": callee.calleeShortNumber,\r\n                \"calleeDisplayName\": callee.calleeDisplayName,\r\n                \"calleeCountry\": callee.calleeCountry\r\n            };\r\n            that._rest.deflectCall(call, data).then(function success() {\r\n                that._logger.log(\"debug\", LOG_ID + \"(deflectCall) deflectCall success\");\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(deflectCall) Error. \");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(deflectCall) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /*                   TRANSFERT CALL STUFF                    */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method transfertCall\r\n     * @instance\r\n     * @description\r\n     *    Transfer a held call to the active call <br/>\r\n     *    User should have transfer rights <br/>\r\n     *    Return a promise\r\n     * @param {Call} activeCall The active call\r\n     * @param {Call} heldCall The held call to transfer to the activeCall\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    transfertCall(activeCall, heldCall) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Ignore wrong request\r\n            if (!activeCall || !heldCall) {\r\n                return resolve();\r\n            }\r\n            //reject not allowed operations\r\n            if (!that.isTransferAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"transferCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(transfertCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(transfertCall) Error : \" + profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(transfertCall) transfertCall held(\" + heldCall.contact.displayName + \") to active(\" + activeCall.contact.displayName + \")\");\r\n            /*$http({\r\n                method: \"PUT\",\r\n                url: service.portalURL + \"calls/\" + encodeURIComponent(activeCall.connectionId) + \"/transfer/\" + encodeURIComponent(heldCall.connectionId),\r\n                headers: authService.getRequestHeader()\r\n            })\r\n                // */\r\n            that._rest.transfertCall(activeCall, heldCall).then(function success() {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(transfertCall) transferCall success\");\r\n                    // Release makinCall flag\r\n                    that.makingCall = false;\r\n                    yield that.clearCall(activeCall);\r\n                    yield that.clearCall(heldCall);\r\n                    resolve();\r\n                });\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(transfertCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(transfertCall) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /* MAKE CONFERENCE CALL STUFF                                */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method conferenceCall\r\n     * @instance\r\n     * @description\r\n     *    Create a conference with a held call and the active call <br/>\r\n     *    User should have conference rights <br/>\r\n     *    Return a promise\r\n     * @param {Call} activeCall The active call\r\n     * @param {Call} heldCall The held call to transfer to the activeCall\r\n     * @return {Promise} Return a resolved promise .\r\n     */\r\n    conferenceCall(activeCall, heldCall) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            // Ignore wrong request\r\n            if (!activeCall || !heldCall) {\r\n                return resolve();\r\n            }\r\n            //reject not allowed operations\r\n            if (!that.isConferenceAllowed) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"conferenceCall failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(conferenceCall) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(conferenceCall) Error : \" + profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            if (activeCall && activeCall.contact && heldCall && heldCall.contact) {\r\n                that._logger.log(\"internal\", LOG_ID + \"(conferenceCall) conferenceCall \" + activeCall.contact.displayName + \" and \" + heldCall.contact.displayName);\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(conferenceCall) conferenceCall activeCall : \", activeCall, \",\\n\\n(conferenceCall) conferenceCall heldCall : \", heldCall);\r\n            /* $http({\r\n                method: \"PUT\",\r\n                url: service.portalURL + \"calls/\" + encodeURIComponent(activeCall.connectionId) + \"/conference/\" + encodeURIComponent(heldCall.connectionId),\r\n                headers: authService.getRequestHeader()\r\n            }) // */\r\n            that._rest.conferenceCall(activeCall, heldCall).then(function success() {\r\n                that._logger.log(\"debug\", LOG_ID + \"(conferenceCall) conferenceCall success\");\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                return reject(error);\r\n                that._logger.log(\"error\", LOG_ID + \"(conferenceCall) error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(conferenceCall) Error : \", error);\r\n            });\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /* FORWARD CALL STUFF               \t\t                 */\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method forwardToDevice\r\n     * @instance\r\n     * @description\r\n     *    Activate the forward to a number <br/>\r\n     *    Return a promise\r\n     * @param {String} phoneNumber The number to call\r\n     * @return {Promise} Return a promise resolved.\r\n    */\r\n    forwardToDevice(phoneNumber) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            that._logger.log(\"internal\", LOG_ID + \"(forwardToDevice) forwardToDevice : \" + phoneNumber);\r\n            if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\r\n                let errorMessage = \"forwardToDevice failure: impossible to forward its own phone number\";\r\n                that._logger.log(\"error\", LOG_ID + \"(forwardToDevice) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(forwardToDevice) Error : \", errorMessage);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n            }\r\n            that._contacts.getOrCreateContact(null, phoneNumber)\r\n                .then(function (contact) {\r\n                let phoneInfo = that.getPhoneInfo(contact, phoneNumber, undefined);\r\n                /*$http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"forward\",\r\n                    headers: authService.getRequestHeader(),\r\n                    data: {\r\n                        calleeExtNumber: phoneInfo.longNumber,\r\n                        calleeIntNumber: phoneInfo.internalNumber,\r\n                        calleeShortNumber: phoneInfo.shortNumber,\r\n                        calleePbxId: phoneInfo.pbxId,\r\n                        calleeDisplayName: contact.displayName\r\n                    }\r\n                }) // */\r\n                that._rest.forwardToDevice(contact, phoneInfo).then(function success() {\r\n                    // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    return reject(error);\r\n                    that._logger.log(\"error\", LOG_ID + \"(forwardToDevice) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(forwardToDevice) Error : \", error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method forwardToVoicemail\r\n     * @instance\r\n     * @description\r\n     *    Activate the forward to VM <br/>\r\n     *    Return a promise\r\n     * @return {Promise} Return a promise resolved.\r\n\r\n     */\r\n    forwardToVoicemail() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!that.voiceMailFeatureEnabled) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"forwardToVoicemail failure - voicemail feature not enabled\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"404\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(forwardToVoicemail) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(forwardToVoicemail) Error : \", profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            /*$http({\r\n                method: \"PUT\",\r\n                url: service.portalURL + \"forward\",\r\n                headers: authService.getRequestHeader(),\r\n                data: {\r\n                    calleeExtNumber: \"\",\r\n                    calleeIntNumber: service.voicemailNumber,\r\n                    calleePbxId: service.pbxId\r\n                }\r\n            })\r\n            // */\r\n            let phoneInfo = {\r\n                longNumber: \"\",\r\n                internalNumber: that.voicemailNumber,\r\n                pbxId: that.pbxId\r\n            };\r\n            that._rest.forwardToDevice({}, phoneInfo).then(function success() {\r\n                // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(forwardToVoicemail) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(forwardToVoicemail) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method cancelForward\r\n     * @instance\r\n     * @description\r\n     *    Cancel the forward <br/>\r\n     *    Return a promise\r\n     * @return {Promise<Call>} Return a promise with the canceled forward call.\r\n     */\r\n    cancelForward() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (that._contacts.userContact.phonePbx) {\r\n                /* $http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"forward\",\r\n                    headers: authService.getRequestHeader(),\r\n                    data: {\r\n                        calleeExtNumber: \"\",\r\n                        calleeIntNumber: \"CANCELFORWARD\",\r\n                        calleePbxId: service.pbxId\r\n                    }\r\n                }) // */\r\n                let phoneInfo = {\r\n                    longNumber: \"\",\r\n                    internalNumber: \"CANCELFORWARD\",\r\n                    pbxId: that.pbxId\r\n                };\r\n                that._rest.forwardToDevice({}, phoneInfo).then(function success() {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(cancelForward) cancelForward success\");\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(cancelForward) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(cancelForward) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n            else {\r\n                return reject();\r\n            }\r\n        });\r\n    }\r\n    getForwardStatus() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (that._contacts.userContact && that._contacts.userContact.phonePbx) {\r\n                /*$http({\r\n                    method: \"GET\",\r\n                    url: service.portalURL + \"forward\",\r\n                    headers: authService.getRequestHeader()\r\n                }) // */\r\n                that._rest.getForwardStatus().then(function success() {\r\n                    // Nothing much to do here, the real call forward status will arrive by XMPP (see ON_CALL_FORWARDED_EVENT)\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(getForwardStatus) error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(getForwardStatus) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n            else {\r\n                return reject();\r\n            }\r\n        });\r\n    }\r\n    /*************************************************************/\r\n    /* NOMADIC CALL STUFF               \t\t                 */\r\n    /*************************************************************/\r\n    nomadicLogin(phoneNumber, NotTakeIntoAccount) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //reject not allowed operations\r\n            if (!that.isNomadicEnabled || !that.nomadicObject.featureActivated) {\r\n                let profileError = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"NOT_ALLOWED\", \"nomadicLogin failure - Not Allowed\");\r\n                // @ts-ignore\r\n                profileError.status = profileError.errorDetailsCode = \"403\";\r\n                // @ts-ignore\r\n                that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \" + profileError.msg);\r\n                return reject(profileError);\r\n            }\r\n            if (that._contacts.userContact.phonePro === phoneNumber || that._contacts.userContact.phoneProCan === phoneNumber || that._contacts.userContact.phonePbx === phoneNumber) {\r\n                let errorMessage = \"nomadicLogin failure: impossible to use its own phone number like nomadic phone\";\r\n                that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \", errorMessage);\r\n                return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(nomadicLogin) phoneNumber : \" + phoneNumber);\r\n            NotTakeIntoAccount = NotTakeIntoAccount || false;\r\n            that.nomadicAnswerNotTakedIntoAccount = NotTakeIntoAccount;\r\n            that._contacts.getOrCreateContact(null, phoneNumber)\r\n                .then(function (contact) {\r\n                let phoneInfo = that.getPhoneInfo(contact, phoneNumber, undefined);\r\n                /*$http({\r\n                    method: \"PUT\",\r\n                    url: that.portalURL + \"nomadic/login\",\r\n                    headers: authService.getRequestHeader(),\r\n                    data: {\r\n                        destinationExtNumber: phoneInfo.longNumber,\r\n                        destinationIntNumber: phoneInfo.internalNumber,\r\n                        destinationShortNumber: phoneInfo.shortNumber,\r\n                        destinationPbxId: phoneInfo.pbxId,\r\n                        destinationDisplayName: contact.displayName,\r\n                        destinationCountry: contact.country\r\n                    }\r\n                })// */\r\n                let data = {\r\n                    destinationExtNumber: phoneInfo.longNumber,\r\n                    destinationIntNumber: phoneInfo.internalNumber,\r\n                    destinationShortNumber: phoneInfo.shortNumber,\r\n                    destinationPbxId: phoneInfo.pbxId,\r\n                    destinationDisplayName: contact.displayName,\r\n                    destinationCountry: contact.country\r\n                };\r\n                that._rest.nomadicLogin(data).then(function success() {\r\n                    //service.forwardToDevice(phoneNumberReceived);\r\n                    // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\r\n                    that._logger.log(\"info\", LOG_ID + \"(nomadicLogin) nomadicLogin success\");\r\n                    //service.isMakeCallInitiatorIsMain = false;\r\n                    resolve(\"success\");\r\n                }, function failure(response) {\r\n                    let errorMessage = \"nomadicLogin failure, nomadicDevice: \" + response.message;\r\n                    that._logger.log(\"error\", LOG_ID + \"(nomadicLogin) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(nomadicLogin) Error : \" + errorMessage);\r\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                });\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /*\r\n        nomadicLoginOnOfficePhone () {\r\n            return $q(function(resolve, reject) {\r\n    \r\n                //reject not allowed operations\r\n                if (!service.isNomadicEnabled || !service.nomadicObject.featureActivated) {\r\n                    let profileError = ErrorManager.getErrorManager().OTHERERROR(\"nomadicLoginOnOfficePhone failure - Not Allowed\");\r\n                    profileError.status = profileError.errorDetailsCode = \"403\";\r\n                    $log.error(\"(nomadicLoginOnOfficePhone) \" + profileError.message);\r\n                    reject(profileError);\r\n                }\r\n    \r\n                $log.info(\"(nomadicLoginOnOfficePhone) nomadicLoginOnOfficePhone\");\r\n    \r\n                $http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"nomadic/login\",\r\n                    headers: authService.getRequestHeader()\r\n                }).then(\r\n                    function success() {\r\n                        //service.cancelForward();\r\n                        // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\r\n                        $log.info(\"(nomadicLoginOnOfficePhone) nomadicLoginOnOfficePhone success\");\r\n                        //service.isMakeCallInitiatorIsMain = true;\r\n                        resolve();\r\n                    },\r\n                    function failure(response) {\r\n                        let error = errorHelperService.handleError(response);\r\n                        reject(error);\r\n                        $log.error(\"(nomadicLoginOnOfficePhone) \" + errorHelperService.getErrorFullMessage(response, \"nomadicDevice\"));\r\n                    });\r\n            });\r\n        };\r\n    \r\n        nomadicLogout () {\r\n            let that = this;\r\n            return new Promise(function(resolve, reject) {\r\n    \r\n                //reject not allowed operations\r\n                if (!that.isNomadicEnabled || !that.nomadicObject.featureActivated) {\r\n                    let profileError = ErrorManager.getErrorManager().OTHERERROR(\"nomadicLogout failure - Not Allowed\");\r\n                    profileError.status = profileError.errorDetailsCode = \"403\";\r\n                    $log.error(\"(nomadicLogout) \" + profileError.message);\r\n                    reject(profileError);\r\n                }\r\n    \r\n                $log.info(\"(nomadicLogout) nomadicLogout\");\r\n    \r\n                $http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"nomadic/logout\",\r\n                    headers: authService.getRequestHeader()\r\n                }).then(\r\n                    function success() {\r\n                        //service.cancelForward();\r\n                        // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\r\n                        $log.info(\"(nomadicLogout) nomadicLogout success\");\r\n                        //service.isMakeCallInitiatorIsMain = true;\r\n                        resolve();\r\n                    },\r\n                    function failure(response) {\r\n                        let error = errorHelperService.handleError(response);\r\n                        reject(error);\r\n                        $log.error(\"(nomadicLogout) \" + errorHelperService.getErrorFullMessage(response, \"nomadicDevice\"));\r\n                    });\r\n            });\r\n        };\r\n    // */\r\n    getNomadicStatus() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //reject not allowed operations\r\n            if (!that.isNomadicEnabled) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(\"403\", \"getNomadicStatus failure - Not Allowed\", \"getNomadicStatus failure - Not Allowed\"); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) Error : \", error);\r\n                return reject(error);\r\n            }\r\n            if (that._contacts.userContact && that._contacts.userContact.phonePbx) {\r\n                that._rest.getNomadicStatus().then(function success(response) {\r\n                    that._logger.log(\"info\", LOG_ID + \"(getNomadicStatus) nomadicStatus success\");\r\n                    that.updateNomadicData(response);\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) Error\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n            else {\r\n                //let error = ErrorManager.getErrorManager().ERROR();// errorHelperService.handleError(response);\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERROR\", \"(getNomadicStatus) user logged in pbx info not filled!\");\r\n                //error.msg += \"(getNomadicStatus) user logged in pbx info not filled!\";\r\n                that._logger.log(\"error\", LOG_ID + \"(getNomadicStatus) user logged in pbx info not filled!\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(getNomadicStatus) user logged in pbx info not filled! Error : \", error);\r\n                return reject(error);\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    /*\r\n        service.setNomadicState = function() {\r\n            return $q(function(resolve, reject) {\r\n    \r\n                $log.info(\"(setNomadicState) setNomadicState\");\r\n    \r\n                $http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"nomadic/state\",\r\n                    headers: authService.getRequestHeader(),\r\n                    data: {\r\n                        makeCallInitiatorIsMain: \"true\"\r\n                    }\r\n                }).then(\r\n                    function success() {\r\n                        $log.info(\" setNomadicState success\");\r\n                        resolve();\r\n                    },\r\n                    function failure(response) {\r\n                        let error = errorHelperService.handleError(response);\r\n                        reject(error);\r\n                        $log.error(\" \" + errorHelperService.getErrorFullMessage(response, \"setNomadicState\"));\r\n                    });\r\n            });\r\n        };\r\n    */\r\n    /**\r\n     * @private\r\n      * @param response\r\n     */\r\n    updateNomadicData(response) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._logger.log(\"internal\", LOG_ID + \"(updateNomadicData) destination:\" + response.destination + \" featureActivated:\" + response.featureActivated + \" makeCallInitiatorIsMain:\" + response.makeCallInitiatorIsMain + \" modeActivated:\" + response.modeActivated);\r\n            that.nomadicObject.featureActivated = response.featureActivated === \"true\";\r\n            that.nomadicObject.modeActivated = response.modeActivated === \"true\";\r\n            that.nomadicObject.destination = response.destination;\r\n            that.nomadicObject.makeCallInitiatorIsMain = response.makeCallInitiatorIsMain === \"true\";\r\n            if (!that.nomadicAnswerNotTakedIntoAccount) {\r\n                //$rootScope.$broadcast(\"ON_CALL_NOMADIC_EVENT\", service.nomadicObject);\r\n                //that._logger.log(\"internal\", LOG_ID + \"(updateNomadicData) send evt_internal_nomadicstatusevent \", that.nomadicObject);\r\n                that._eventEmitter.emit(\"evt_internal_nomadicstatusevent\", that.nomadicObject);\r\n            }\r\n            that.nomadicAnswerNotTakedIntoAccount = false;\r\n            // By default if mobilepro or mobileperso exist, then add it on destination\r\n            /*if (service.nomadicObject.featureActivated && (service.nomadicObject.destination === \"\" || service.nomadicObject.destination === undefined) && (contactService.userContact.mobileProCan || contactService.userContact.mobilePerso)) {\r\n                let defaultNumber = contactService.userContact.mobileProCan ? contactService.userContact.mobileProCan : contactService.userContact.mobilePerso;\r\n                service.nomadicLogin(defaultNumber)\r\n                    .then(function() {\r\n                        service.nomadicLoginOnOfficePhone();\r\n                    });\r\n            }*/\r\n            // By default, in monodevice, if mobilepro or mobileperso exist, then add it on destination\r\n            if (that._contacts.userContact.isVirtualTerm && that.nomadicObject.featureActivated && (that.nomadicObject.destination === \"\" || that.nomadicObject.destination === undefined) && (that._contacts.userContact.mobileProCan || that._contacts.userContact.mobilePerso)) {\r\n                let defaultNumber = that._contacts.userContact.mobileProCan ? that._contacts.userContact.mobileProCan : that._contacts.userContact.mobilePerso;\r\n                yield that.nomadicLogin(defaultNumber);\r\n            }\r\n        });\r\n    }\r\n    getNomadicObject() {\r\n        return this.nomadicObject;\r\n    }\r\n    getNomadicDestination() {\r\n        return this.nomadicObject.destination;\r\n    }\r\n    /*************************************************************/\r\n    /* DTMF             \t\t                 \t\t\t\t*/\r\n    /*************************************************************/\r\n    /**\r\n     * @public\r\n     * @method sendDtmf\r\n     * @description\r\n     *      send dtmf to the remote party\r\n     * @param {string} connectionId\r\n     * @param {string} dtmf\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    sendDtmf(connectionId, dtmf) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            let callId = Call_1.Call.getIdFromConnectionId(connectionId);\r\n            let deviceId = Call_1.Call.getDeviceIdFromConnectionId(connectionId);\r\n            if (callId && deviceId && dtmf) {\r\n                /* $http({\r\n                    method: \"PUT\",\r\n                    url: service.portalURL + \"calls/\" + callId + \"%23\" + deviceId + \"/dtmf\",\r\n                    headers: authService.getRequestHeader(),\r\n                    data: {\r\n                        callId: connectionId,\r\n                        dtmf: dtmf\r\n                    }\r\n                }) // */\r\n                let data = {\r\n                    callId: connectionId,\r\n                    dtmf: dtmf\r\n                };\r\n                that._rest.sendDtmf(callId, deviceId, data)\r\n                    .then(function success() {\r\n                    resolve();\r\n                }, function failure(response) {\r\n                    let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                    that._logger.log(\"error\", LOG_ID + \"(sendDtmf) Error.\");\r\n                    that._logger.log(\"internalerror\", LOG_ID + \"(sendDtmf) Error : \", error);\r\n                    return reject(error);\r\n                });\r\n            }\r\n            else {\r\n                return reject();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @method clearCall\r\n     * @param Call call the call to reset.\r\n     * @return nothing.\r\n     */\r\n    clearCall(call) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            call.setStatus(Call_1.Call.Status.UNKNOWN);\r\n            /* TREATED BY EVENTS\r\n    \r\n    // $rootScope.$broadcast(\"ON_CALL_UPDATED_EVENT\", call);\r\n    that._logger.log(\"debug\", LOG_ID + \"(clearCall) send evt_internal_callupdated \", call);\r\n    that._eventEmitter.emit(\"evt_internal_callupdated\", call);\r\n    */\r\n            //if (call.contact) {\r\n            //delete that.calls[call.contact.id];\r\n            //}\r\n            let callIdToDelete = Call_1.Call.getIdFromConnectionId(call.connectionId);\r\n            //delete that._calls[callIdToDelete];\r\n            yield that.removeCallFromCache(callIdToDelete);\r\n            if (call.getCurrentCalled()) {\r\n                call.setCurrentCalled(null);\r\n            }\r\n        });\r\n    }\r\n    startAsPhoneNumber(phoneNumber) {\r\n        let cleanPhoneNumber = phoneNumber.trim().split(\".\").join(\"\");\r\n        let pattern1 = /^(\\+|\\d|#|\\*|\\(|\\)|\\.|-|\\s|\\/)*$/;\r\n        let match = cleanPhoneNumber.match(pattern1);\r\n        if (!match) {\r\n            return false;\r\n        }\r\n        return (match[0] === cleanPhoneNumber);\r\n    }\r\n    /**\r\n     * @private\r\n     * @method getOrCreateCall\r\n     * @param status\r\n     * @param connectionId\r\n     * @param deviceType\r\n     * @param contact\r\n     */\r\n    getOrCreateCall(status, connectionId, deviceType, contact) {\r\n        let that = this;\r\n        // Extract callid from connectionid\r\n        let callId = Call_1.Call.getIdFromConnectionId(connectionId);\r\n        that._logger.log(\"debug\", LOG_ID + \"(getOrCreateCall) callId \", callId);\r\n        let callInfos = { \"status\": status, \"id\": callId, \"connectionId\": connectionId, \"type\": Call_1.Call.Type.PHONE, \"contact\": contact, \"deviceType\": deviceType };\r\n        that._logger.log(\"internal\", LOG_ID + \"(getOrCreateCall) callInfos : \", callInfos);\r\n        if (!callId) {\r\n            let call = Call_1.Call.CallFactory()(callInfos);\r\n            call.setConnectionId(connectionId);\r\n            that._logger.log(\"internal\", LOG_ID + \"(getOrCreateCall) no callId found, so return a call which is not stored in calls tab. call : \", call);\r\n            return call;\r\n        }\r\n        let call = that.addOrUpdateCallToCache(callInfos);\r\n        /*\r\n\r\n        // Get eventual existing call\r\n        let call = that.getCallFromCache(callId);\r\n        if (call) {\r\n            call.setConnectionId(connectionId);\r\n            call.startDate = new Date();\r\n        }\r\n        else {\r\n            //call = Call.create(status, null, Call.Type.PHONE, contact, deviceType);\r\n            let callInfos = {status, id : undefined, type : Call.Type.PHONE, contact, deviceType} ;\r\n            call = that.addOrUpdateCallToCache(callInfos);\r\n\r\n         */\r\n        /*call = Call.CallFactory()(callInfos);\r\n        call.setConnectionId(connectionId);\r\n        that._calls[callId] = call;\r\n\r\n         */\r\n        //}\r\n        return call;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param callId\r\n     * @description\r\n     *      GET A CALL FROM CACHE\r\n     */\r\n    getCallFromCache(callId) {\r\n        let that = this;\r\n        let callFound = null;\r\n        that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) search id : \", callId);\r\n        if (!callId)\r\n            return callFound;\r\n        let iter = 0;\r\n        if (that._calls) {\r\n            let callFoundindex = that._calls.findIndex((call) => {\r\n                iter++;\r\n                if (!call) {\r\n                    // Warning : do not uncomment these line because when an error happens for a big number it is stored in that._calls at the indice of the called number\r\n                    // So the size of the tab is egal this big number. And then freeze the SDK when iter the tab.\r\n                    //this._logger.log(\"error\", LOG_ID + \"(getCallFromCache) !!! A call is undefined in the cache.\");\r\n                    //this._logger.log(\"internalerror\", LOG_ID + \"(getCallFromCache) !!! A call is undefined in the cache : \", call);\r\n                }\r\n                else {\r\n                    return call.id === callId;\r\n                }\r\n            });\r\n            that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) that._calls findIndex iter : \", iter);\r\n            if (callFoundindex != -1) {\r\n                that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) call found : \", that._calls[callFoundindex], \" with id : \", callId);\r\n                return that._calls[callFoundindex];\r\n            }\r\n        }\r\n        that._logger.log(\"internal\", LOG_ID + \"(getCallFromCache) call found : \", callFound, \" with id : \", callId);\r\n        return callFound;\r\n    }\r\n    addOrUpdateCallToCache(call) {\r\n        let callObj = Call_1.Call.CallFactory()(call);\r\n        let callFoundindex = this._calls.findIndex((callIter) => {\r\n            return callIter.id === call.id;\r\n        });\r\n        if (callFoundindex != -1) {\r\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) update in cache with call : \", call, \", at callFoundindex : \", callFoundindex);\r\n            //this._channels.splice(callFoundindex,1,callObj);\r\n            //channelCached = callObj;\r\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) in update this.calls : \", this._calls);\r\n            this._calls[callFoundindex].updateCall(call);\r\n            callObj = this._calls[callFoundindex];\r\n        }\r\n        else {\r\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateCallToCache) add in cache callObj : \", callObj);\r\n            this._calls.push(callObj);\r\n        }\r\n        return callObj;\r\n    }\r\n    removeCallFromCache(callId) {\r\n        let that = this;\r\n        this._logger.log(\"debug\", LOG_ID + \"(removeCallFromCache) should remove callId : \", callId);\r\n        return new Promise((resolve, reject) => {\r\n            // Get the channel to remove\r\n            let callToRemove = this.getCallFromCache(callId);\r\n            if (callToRemove) {\r\n                // Remove from channels\r\n                let callIdToRemove = callToRemove.id;\r\n                this._logger.log(\"internal\", LOG_ID + \"(removeCallFromCache) remove from cache callIdToRemove : \", callIdToRemove);\r\n                this._calls = this._calls.filter(function (call) {\r\n                    return !(call.id === callIdToRemove);\r\n                });\r\n                resolve(callToRemove);\r\n            }\r\n            else {\r\n                resolve(null);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method logon\r\n     * @param {String} endpointTel The endpoint device phone number.\r\n     * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n     * @param {String} password optionnel Password or authorization code.\r\n     * @param {String} groupId optionnel CCD Agent's group number\r\n     * @description\r\n     *      This api allows an CCD Agent to logon into the CCD system.\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    logon(endpointTel, agentId, password, groupId) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!endpointTel) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(logon) bad or empty 'endpointTel' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(logon) bad or empty 'endpointTel' parameter\", endpointTel);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.logon(endpointTel, agentId, password, groupId).then(function success() {\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(logon) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(logon) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method logoff\r\n     * @param {String} endpointTel The endpoint device phone number.\r\n     * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n     * @param {String} password optionnel Password or authorization code.\r\n     * @param {String} groupId optionnel CCD Agent's group number\r\n     * @description\r\n     *      This api allows an CCD Agent logoff logon from the CCD system.\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    logoff(endpointTel, agentId, password, groupId) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!endpointTel) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(logoff) bad or empty 'endpointTel' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(logoff) bad or empty 'endpointTel' parameter\", endpointTel);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.logoff(endpointTel, agentId, password, groupId).then(function success() {\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(logoff) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(logoff) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method withdrawal\r\n     * @param {String} agentId optionnel CCD Agent identifier (agent device number).\r\n     * @param {String} groupId optionnel CCD Agent's group number\r\n     * @param {String} status optionnel Used to deactivate the withdrawal state. Values: 'on', 'off'; 'on' is optional.\r\n     * @description\r\n     *      This api allows an CCD Agent to change to the state 'Not Ready' on the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    withdrawal(agentId, groupId, status) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!agentId) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(withdrawal) bad or empty 'agentId' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) bad or empty 'agentId' parameter\", agentId);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            if (!groupId) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(withdrawal) bad or empty 'groupId' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) bad or empty 'groupId' parameter\", groupId);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.withdrawal(agentId, groupId, status).then(function success() {\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(withdrawal) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(withdrawal) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method wrapup\r\n     * @param {String} agentId CCD Agent identifier (agent device number).\r\n     * @param {String} groupId CCD Agent's group number\r\n     * @param {String} password optionnel Password or authorization code.\r\n     * @param {String} status optionnel Used to deactivate the WrapUp state. Values: 'on', 'off'; 'on' is optional.\r\n     * @description\r\n     *      This api allows an CCD Agent to change to the state Working After Call in the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'.\r\n     * @return {Promise} Return resolved promise if succeed, and a rejected else.\r\n     */\r\n    wrapup(agentId, groupId, password, status) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!agentId) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\", agentId);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            if (!agentId) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) bad or empty 'agentId' parameter\", agentId);\r\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\r\n                return;\r\n            }\r\n            that._rest.wrapup(agentId, groupId, password, status).then(function success() {\r\n                resolve();\r\n            }, function failure(response) {\r\n                let error = ErrorManager_1.ErrorManager.getErrorManager().CUSTOMERROR(response.code, response.msg, response.details); // errorHelperService.handleError(response);\r\n                that._logger.log(\"error\", LOG_ID + \"(wrapup) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(wrapup) Error : \", error);\r\n                return reject(error);\r\n            });\r\n        });\r\n    }\r\n};\r\nTelephony = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n     * @module\r\n     * @name Telephony\r\n     * @version 1.67.1 \r\n     * @public\r\n     * @description\r\n     *      This services manages PBX phone calls in a conversation. so it manages PBX calls between your PABX associated phone and a recipient's phone. If you don't have this service activated for your Rainbow user, all these methods will return an error when called. <br/><br>\r\n     *      The main methods and events proposed in that service allow to: <br>\r\n     *      - Know if this service is activated or not for the connected user, <br/>\r\n     *      - Know the version of the agent (deployed on the PBX) that monitors your line, <br>\r\n     *      - Handle the basic telephony services: Make a call, take a call, hold a call, retrieve a call and release a call,<br/>\r\n     *      - Listen to the call state change <br><br>\r\n     *      Depending the agent version deployed, some services can return an error (unavailable service) when called\r\n     *\r\n     */\r\n], Telephony);\r\nexports.TelephonyService = Telephony;\r\nmodule.exports.Telephony = Telephony;\r\n//# sourceMappingURL=TelephonyService.js.map"]},"metadata":{},"sourceType":"script"}