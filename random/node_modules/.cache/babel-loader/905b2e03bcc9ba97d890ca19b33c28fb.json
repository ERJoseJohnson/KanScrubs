{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Channel_1 = require(\"../common/models/Channel\");\n\nconst channelEventHandler_1 = require(\"../connection/XMPPServiceHandler/channelEventHandler\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst fs = require(\"fs\");\n\nconst mimetypes = require(\"mime-types\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst LOG_ID = \"CHANNELS/SVCE - \";\nlet Channels =\n/**\n * @module\n * @name Channels\n * @version 1.67.1 \n * @public\n * @description\n *      This service manages Channels. This service is in Beta.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Create a new channel <br>\n *      - Manage a channel: update, delete <br>\n *      - Manage users in a channel <br>\n */\nclass Channels {\n  constructor(_eventEmitter, _logger, _startConfig) {\n    this.invitationCounter = 0;\n    this.ready = false;\n    this.LIST_EVENT_TYPE = {\n      ADD: {\n        code: 0,\n        label: \"ADD\"\n      },\n      UPDATE: {\n        code: 1,\n        label: \"UPDATE\"\n      },\n      REMOVE: {\n        code: 2,\n        label: \"REMOVE\"\n      },\n      DELETE: {\n        code: 3,\n        label: \"DELETE\"\n      },\n      SUBSCRIBE: {\n        code: 4,\n        label: \"SUBSCRIBE\"\n      },\n      UNSUBSCRIBE: {\n        code: 5,\n        label: \"UNSUBSCRIBE\"\n      },\n      CREATE: {\n        code: 6,\n        label: \"CREATE\"\n      }\n    };\n    this.USER_ROLE = {\n      NONE: \"none\",\n      OWNER: \"owner\",\n      PUBLISHER: \"publisher\",\n      MEMBER: \"member\"\n    };\n    this._startConfig = _startConfig;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._channels = null;\n    this._channelsList = null;\n    this._eventEmitter = _eventEmitter;\n    this._logger = _logger;\n    this.MAX_ITEMS = 100;\n    this.MAX_PAYLOAD_SIZE = 60000;\n    this.PUBLIC_VISIBILITY = \"company\";\n    this.PRIVATE_VISIBILITY = \"private\";\n    this.CLOSED_VISIBILITY = \"closed\";\n    this.ready = false;\n\n    this._eventEmitter.on(\"evt_internal_channelitemreceived\", this._onChannelMessageReceived.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_addtochannel\", this.onAddToChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_updatetochannel\", this.onUpdateToChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_removefromchannel\", this.onRemovedFromChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_subscribetochannel\", this.onSubscribeToChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_unsubscribetochannel\", this.onUnsubscribeToChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_deletechannel\", this.onDeleteChannel.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_usersubscribechannel\", this.onUserSubscribeEvent.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_userunsubscribechannel\", this.onUserUnsubscribeEvent.bind(this));\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._channels = [];\n        that._channelsList = [];\n        that.attachHandlers();\n        this.ready = true;\n        resolve();\n      } catch (err) {\n        this._logger.log(\"error\", LOG_ID + \"(start) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(start) error : \", err);\n\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      try {\n        this._xmpp = null;\n        this._rest = null;\n        this._channels = null;\n        this._channelsList = null; //                this._eventEmitter.removeListener(\"rainbow_onchannelmessagereceived\", this._onChannelMessageReceived);\n\n        if (that.channelHandlerToken) {\n          that.channelHandlerToken.forEach(token => PubSub.unsubscribe(token));\n        }\n\n        that.channelHandlerToken = [];\n        this.ready = false;\n        resolve();\n      } catch (err) {\n        this._logger.log(\"error\", LOG_ID + \"(stop) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(stop) error : \", err);\n\n        return reject(err);\n      }\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n    that.channelEventHandler = new channelEventHandler_1.ChannelEventHandler(that._xmpp, that);\n    that.channelHandlerToken = [//            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_CHAT, that.conversationEventHandler.onChatMessageReceived),\n    //            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_GROUPCHAT, that.conversationEventHandler.onChatMessageReceived),\n    //            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_WEBRTC, that.conversationEventHandler.onWebRTCMessageReceived),\n    PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_MANAGEMENT, that.channelEventHandler.onManagementMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_ERROR, that.channelEventHandler.onErrorMessageReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_HEADLINE, that.channelEventHandler.onHeadlineMessageReceived)];\n  }\n  /**\n   * @public\n   * @method createChannel\n   * @instance\n   * @async\n   * @param {string} name  The name of the channel to create (max-length=255)\n   * @param {string} [channelTopic]  The description of the channel to create (max-length=255)\n   * @return {Promise<Channel>} New Channel\n   * @description\n   *  Create a new public channel with a visibility limited to my company\n   */\n\n\n  createChannel(name, channelTopic) {\n    return this.createPublicChannel(name, channelTopic, \"globalnews\");\n  }\n  /**\n   * @public\n   * @method createPublicChannel\n   * @instance\n   * @async\n   * @param {string} name  The name of the channel to create (max-length=255)\n   * @param {string} [channelTopic]  The description of the channel to create (max-length=255)\n   * @param {String} [category=\"\"] The category of the channel\n   * @return {Promise<Channel>} New Channel\n   * @description\n   *  Create a new public channel with a visibility limited to my company\n   */\n\n\n  createPublicChannel(name, channelTopic, category) {\n    return new Promise((resolve, reject) => {\n      if (!name) {\n        this._logger.log(\"warn\", LOG_ID + \"(createPublicChannel) bad or empty 'name' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(createPublicChannel) bad or empty 'name' parameter : \", name);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      this._rest.createPublicChannel(name, channelTopic, category, this.PUBLIC_VISIBILITY, this.MAX_ITEMS, this.MAX_PAYLOAD_SIZE).then(channel => {\n        this._logger.log(\"debug\", LOG_ID + \"(createPublicChannel) creation successfull\"); //let channelObj : Channel = this.addOrUpdateChannelToCache(channel);\n\n\n        let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(createPublicChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(createPublicChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method createClosedChannel (ex: createPrivateChannel)\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the createClosedChannel method instead,\n   * @param {string} name  The name of the channel to create (max-length=255)\n   * @param {string} [description]  The description of the channel to create (max-length=255)\n   * @return {Promise<Channel>} New Channel\n   * @description\n   *  Create a new private channel\n   */\n\n\n  createPrivateChannel(name, description) {\n    return this.createClosedChannel(name, description, \"globalnews\");\n  }\n  /**\n   * @public\n   * @method createClosedChannel (ex: createPrivateChannel)\n   * @instance\n   * @async\n   * @param {string} name  The name of the channel to create (max-length=255)\n   * @param {string} [description]  The description of the channel to create (max-length=255)\n   * @param {String} [category=\"\"] The category of the channel\n   * @return {Promise<Channel>} New Channel\n   * @description\n   *  Create a new closed channel\n   */\n\n\n  createClosedChannel(name, description, category) {\n    return new Promise((resolve, reject) => {\n      if (!name) {\n        this._logger.log(\"warn\", LOG_ID + \"(createClosedChannel) bad or empty 'name' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(createClosedChannel) bad or empty 'name' parameter : \", name);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      this._rest.createPublicChannel(name, description, category, this.PRIVATE_VISIBILITY, this.MAX_ITEMS, this.MAX_PAYLOAD_SIZE).then(channel => {\n        this._logger.log(\"debug\", LOG_ID + \"(createClosedChannel) creation successfull\"); //let channelObj : Channel = this.addOrUpdateChannelToCache(channel);\n\n\n        let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(createClosedChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(createClosedChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method deleteChannel\n   * @instance\n   * @async\n   * @param {Channel} channel  The channel to delete\n   * @return {Promise<CHannel>} Promise object represents The channel deleted\n   * @description\n   *  Delete a owned channel\n   */\n\n\n  deleteChannel(channel) {\n    return new Promise((resolve, reject) => {\n      if (!channel || !channel.id) {\n        this._logger.log(\"warn\", LOG_ID + \"(deleteChannel) bad or empty 'channel' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) bad or empty 'channel' parameter : \", channel);\n\n        reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        return;\n      }\n\n      this._rest.deleteChannel(channel.id).then(status => __awaiter(this, void 0, void 0, function* () {\n        this._logger.log(\"debug\", LOG_ID + \"(deleteChannel) channel deleted status : \", status);\n        /*let channelRemoved = this._channels.splice(this._channels.findIndex((el) => {\n            return el.id === channel.id;\n        }), 1); // */\n\n\n        let channelRemoved = yield this.removeChannelFromCache(channel.id);\n\n        this._logger.log(\"internal\", LOG_ID + \"(deleteChannel) channel deleted : \", channelRemoved);\n\n        if (channelRemoved) {\n          resolve(channelRemoved);\n        } else {\n          this._logger.log(\"warn\", LOG_ID + \"(deleteChannel) the channel deleted was unknown from SDK cache \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) the channel deleted was unknown from SDK cache : \", channel);\n\n          resolve(channel);\n        }\n      })).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(deleteChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method findChannelsByName\n   * @instance\n   * @async\n   * @param {String} name Search this provided substring in the channel name (case insensitive).\n   * @return {Promise<Channel[]>} Channels found\n   * @description\n   *  Find channels by name. Only channels with visibility equals to 'company' can be found. First 100 results are returned.\n   */\n\n\n  findChannelsByName(name) {\n    if (!name) {\n      this._logger.log(\"warn\", LOG_ID + \"(findChannelsByName) bad or empty 'name' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(findChannelsByName) bad or empty 'name' parameter : \", name);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return this._findChannels(name, null);\n  }\n  /**\n   * @public\n   * @method findChannelsByTopic\n   * @instance\n   * @async\n   * @param {String} topic Search this provided substring in the channel topic (case insensitive).\n   * @return {Promise<Channel[]>} Channels found\n   * @description\n   *  Find channels by topic. Only channels with visibility equals to 'company' can be found. First 100 results are returned.\n   */\n\n\n  findChannelsByTopic(topic) {\n    if (!topic) {\n      this._logger.log(\"warn\", LOG_ID + \"(findChannelsByTopic) bad or empty 'topic' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(findChannelsByTopic) bad or empty 'topic' parameter : \", topic);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return this._findChannels(null, topic);\n  }\n  /**\n   * @private\n   * @method findChannels\n   */\n\n\n  _findChannels(name, topic) {\n    //hack\n    let getChannel = id => {\n      return new Promise(resolve => {\n        this.fetchChannel(id).then(channel => {\n          resolve(channel);\n        }).catch(err => {\n          this._logger.log(\"error\", LOG_ID + \"(_findChannels) error getChannel \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(_findChannels) error getChannel : \", err);\n\n          resolve(null);\n        });\n      });\n    };\n\n    return new Promise((resolve, reject) => {\n      this._rest.findChannels(name, topic, null, null, null, null, null).then(channels => {\n        this._logger.log(\"info\", LOG_ID + \"(_findChannels) findChannels channels found \");\n\n        this._logger.log(\"internal\", LOG_ID + \"(_findChannels) findChannels channels found : \", channels);\n\n        let promises = [];\n        channels.forEach(channel => {\n          promises.push(getChannel(channel.id));\n        });\n        Promise.all(promises).then(listOfChannels => {\n          resolve(listOfChannels);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(_findChannels) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(_findChannels) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method getChannelById\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the fetchChannel method instead,\n   * @param {String} id The id of the channel)\n   * @param {boolean} [force=false] True to force a request to the server\n   * @return {Promise<Channel>} The channel found\n   * @description\n   * Find a channel by its id (locally if exists or by sending a request to Rainbow)\n   */\n\n\n  getChannelById(id, force) {\n    return this.fetchChannel(id, force);\n  }\n  /**\n   * @public\n   * @method fetchChannel\n   * @instance\n   * @async\n   * @param {String} id The id of the channel)\n   * @param {boolean} [force=false] True to force a request to the server\n   * @return {Promise<Channel>} The channel found\n   * @description\n   * Find a channel by its id (locally if exists or by sending a request to Rainbow)\n   */\n\n\n  fetchChannel(id, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (!id) {\n          this._logger.log(\"warn\", LOG_ID + \"(fetchChannel) bad or empty 'jid' parameter\");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannel) bad or empty 'jid' parameter : \", id);\n\n          return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        } else {\n          let channelFound = this.getChannelFromCache(id);\n\n          if (channelFound && !force) {\n            this._logger.log(\"info\", LOG_ID + \"(fetchChannel) channel found locally\");\n\n            this._logger.log(\"internal\", LOG_ID + \"(fetchChannel) channel found locally : \", channelFound);\n\n            resolve(channelFound);\n          } else {\n            this._logger.log(\"debug\", LOG_ID + \"(fetchChannel) channel not found locally. Ask the server...\");\n\n            let channel = yield this.getChannel(id);\n            let channelObj = this.addOrUpdateChannelToCache(channel);\n            resolve(channelObj);\n          }\n        }\n      }));\n    });\n  }\n  /**\n   * @public\n   * @method fetchChannelsByFilter\n   * @since 1.55\n   * @instance\n   * @description\n   *    Find channels using a filter (on name, topic)<br/>\n   *    Result may be filtered with result limit, offet and sortField or SortOrder\n   *    Return a promise.\n   * @param {Object} filter The filter with at least [filter.name] or [filter.topic] defined\n   *      {String} [filter.name] search by channel names (case insensitive substring).\n   *      {String} [filter.topic] search by channel topics (case insensitive substring).\n   *      {Number} [filter.limit=100] allow to specify the number of channels to retrieve.\n   *      {Number} [filter.offset] allow to specify the position of first channel to retrieve (first channel if not specified). Warning: if offset > total, no results are returned.\n   *      {String} [filter.sortField=\"name\"] sort channel list based on the given field.\n   *      {Number} [filter.sortOrder=\"1\"] specify order ascending/descending. 1 for ascending, -1 for descending.\n   * @return {Promise<Channel[]>} Result of the find with\n   *      {Array}   found channels informations with an array of { id, name, topic, creatorId, visibility, users_count }\n   */\n\n\n  fetchChannelsByFilter(filter) {\n    let getChannel = id => {\n      return new Promise(resolve => {\n        this.fetchChannel(id).then(channel => {\n          resolve(channel);\n        }).catch(err => {\n          this._logger.log(\"error\", LOG_ID + \"(fetchChannelsByFilter) error getChannel \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelsByFilter) error getChannel : \", err);\n\n          resolve(null);\n        });\n      });\n    };\n\n    if (!filter) {\n      this._logger.log(\"debug\", LOG_ID + \"(fetchChannelsByFilter) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internal\", LOG_ID + \"(fetchChannelsByFilter) bad or empty 'channel' parameter : \", filter);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.findChannels(filter.name, filter.topic, filter.category, filter.limit, filter.offset, filter.sortField, filter.sortOrder && filter.sortOrder === 1 ? \"1\" : \"-1\").then(channels => {\n        this._logger.log(\"info\", LOG_ID + \"(fetchChannelsByFilter) channels found\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(fetchChannelsByFilter) channels found : \", channels);\n\n        let promises = [];\n        channels.forEach(channel => {\n          promises.push(getChannel(channel.id));\n        });\n        Promise.all(promises).then(listOfChannels => {\n          resolve(listOfChannels);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(fetchChannelsByFilter) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelsByFilter) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  /**\n   * @public\n   * @method getChannels\n   * @since 1.38\n   * @instance\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the fetchMyChannels method instead,\n   * @description\n   *    Get the channels you own, are subscribed to, are publisher<br/>\n   *    Return a promise.\n   * @return {{Promise<Channel[]>} } Return Promise with a list of channels or an empty array if no channel has been found\n   */\n  getChannels() {\n    return this.fetchMyChannels();\n  }\n  /**\n   * @public\n   * @method fetchMyChannels\n   * @since 1.38\n   * @instance\n   * @description\n   *    Get the channels you own, are subscribed to, are publisher<br/>\n   *    Return a promise.\n   * @return {Promise<Channel[]>} Return Promise with a list of channels or an empty array if no channel has been found\n   */\n\n\n  fetchMyChannels() {\n    let getChannel = id => {\n      return new Promise(resolve => {\n        this.fetchChannel(id).then(channel => {\n          resolve(channel);\n        }).catch(err => {\n          this._logger.log(\"error\", LOG_ID + \"(fetchMyChannels) error fetchChannel \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(fetchMyChannels) error fetchChannel : \", err);\n\n          resolve(null);\n        });\n      });\n    };\n\n    return new Promise(resolve => {\n      this._rest.getChannels().then(listOfChannels => {\n        // Hack waiting server change\n        let promises = [];\n\n        if (Array.isArray(listOfChannels)) {\n          listOfChannels.forEach(channel => {\n            promises.push(getChannel(channel.id));\n          });\n        } else {\n          if (\"owner\" in listOfChannels) {\n            listOfChannels.owner.forEach(channel => {\n              promises.push(getChannel(channel.id));\n            });\n          }\n\n          if (\"publisher\" in listOfChannels) {\n            listOfChannels.publisher.forEach(channel => {\n              promises.push(getChannel(channel.id));\n            });\n          }\n\n          if (\"member\" in listOfChannels) {\n            listOfChannels.member.forEach(channel => {\n              promises.push(getChannel(channel.id));\n            });\n          }\n        }\n\n        this._logger.log(\"info\", LOG_ID + \"(fetchMyChannels) hack start get channel data individually from server...\");\n\n        Promise.all(promises).then(channels => {\n          this._logger.log(\"internal\", LOG_ID + \"(fetchMyChannels) hack done : \", channels);\n\n          this._channels = [];\n\n          if (channels) {\n            channels.forEach(channel => {\n              this.addOrUpdateChannelToCache(channel);\n            });\n          } //this._logger.log(\"internal\", LOG_ID + \"(fetchMyChannels) get successfully and updated the channels cache : \", this._channels);\n\n\n          resolve(this._channels);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(fetchMyChannels) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(fetchMyChannels) error : \", err); // Do not block the startup on VM without channels API\n\n\n        this._channels = [];\n        resolve(this._channels);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method getAllChannels\n   * @instance\n   * @return {Channel[]} An array of channels (owned, invited, subscribed)\n   * @description\n   *  Return the list of channels (owned, invited, subscribed)\n   */\n\n\n  getAllChannels() {\n    return this._channels;\n  }\n  /**\n   * @public\n   * @method getAllOwnedChannel\n   * @instance\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the getAllOwnedChannels method instead,\n   * @return {Channel[]} An array of channels (owned only)\n   * @description\n   *  Return the list of owned channels only\n   */\n\n\n  getAllOwnedChannel() {\n    return this.getAllOwnedChannels();\n  }\n  /**\n   * @public\n   * @method getAllOwnedChannels\n   * @instance\n   * @return {Channel[]} An array of channels (owned only)\n   * @description\n   *  Return the list of owned channels only\n   */\n\n\n  getAllOwnedChannels() {\n    return this._channels.filter(channel => {\n      return channel.creatorId === this._rest.userId;\n    });\n  }\n  /**\n   * @public\n   * @method getAllSubscribedChannel\n   * @instance\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the getAllSubscribedChannels method instead,\n   * @return {Channel[]} An array of channels (subscribed only)\n   * @description\n   *  Return the list of subscribed channels only\n   */\n\n\n  getAllSubscribedChannel() {\n    return this.getAllSubscribedChannels();\n  }\n  /**\n   * @public\n   * @method getAllSubscribedChannels\n   * @instance\n   * @return {Channel[]} An array of channels (subscribed only)\n   * @description\n   *  Return the list of subscribed channels only\n   */\n\n\n  getAllSubscribedChannels() {\n    return this._channels.filter(channel => {\n      return channel.creatorId !== this._rest.userId;\n    });\n  }\n  /**\n   * @public\n   * @method getAllPendingChannels\n   * @instance\n   * @return {Channel[]} An array of channels (invited only)\n   * @description\n   *  Return the list of invited channels only\n   */\n\n\n  getAllPendingChannels() {\n    return this._channels.filter(channel => {\n      return channel.invited;\n    });\n  }\n  /**\n   * @public\n   * @method publishMessageToChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel where to publish the message\n   * @param {String} message Message content\n   * @param {String} [title = \"\", limit=256] Message title\n   * @param {String} [url = \"\"] An URL\n   * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow\n   * @param {String} [type=\"basic\"] An optional message content type (could be basic, markdown, html or data)\n   * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull\n   * @description\n   *  Publish to a channel\n   */\n\n\n  publishMessageToChannel(channel, message, title, url, imagesIds, type) {\n    return this.createItem(channel, message, title, url, imagesIds, type);\n  }\n  /**\n   * @public\n   * @method createItem\n   * @instance\n   * @async\n   * @param {Channel} channel The channel where to publish the message\n   * @param {String} message Message content\n   * @param {String} [title = \"\", limit=256] Message title\n   * @param {String} [url = \"\"] An URL\n   * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow\n   * @param {String} [type=\"basic\"] An optional message content type (could be basic, markdown, html or data)\n   * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull\n   * @description\n   *  Publish to a channel\n   */\n\n\n  createItem(channel, message, title, url, imagesIds, type) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!message) {\n      this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'title' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'title' parameter : \", title);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (imagesIds && typeof imagesIds !== \"object\" && imagesIds.length < 1) {\n      this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'imagesIds' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'imagesIds' parameter : \", imagesIds);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (type && [\"basic\", \"markdown\", \"html\", \"data\"].indexOf(type) === -1) {\n      this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'type' parameter \", type, \" \\\"Parameter 'type' could be 'basic', 'markdown', 'html' or 'data'\\\"\");\n\n      return Promise.reject(ErrorManager_1.ErrorManager);\n    }\n\n    return new Promise((resolve, reject) => {\n      type = type ? \"urn:xmpp:channels:\" + type : \"urn:xmpp:channels:basic\";\n\n      this._rest.publishMessage(channel.id, message, title, url, imagesIds, type).then(status => {\n        this._logger.log(\"info\", LOG_ID + \"(createItem) message published\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(createItem) message published : \", status);\n\n        resolve(ErrorManager_1.ErrorManager.getErrorManager().OK);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(createItem) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(createItem) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method subscribeToChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel to subscribe\n   * @return {Promise<Channel>} The channel updated with the new subscription\n   * @description\n   *  Subscribe to a public channel\n   */\n\n\n  subscribeToChannel(channel) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(subscribeToChannel) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.subscribeToChannel(channel.id).then(status => {\n        this._logger.log(\"info\", LOG_ID + \"(subscribeToChannel) channel subscribed : \", status);\n\n        this.fetchChannel(channel.id, true).then(channelUpdated => {\n          resolve(channelUpdated);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(subscribeToChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method\n   * @since 1.47\n   * @instance\n   * @description\n   *    Subscribe to a channel using its id<br/>\n   *    Return a promise.\n   * @param {String} id The id of the channel\n   * @return {Object} Nothing or an error object depending on the result\n   */\n\n\n  subscribeToChannelById(id) {\n    let that = this;\n\n    if (!id) {\n      this._logger.log(\"warn\", LOG_ID + \"(subscribeToChannel) bad or empty 'id' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) bad or empty 'id' parameter : \", id);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      let channel = that.getChannelFromCache(id);\n\n      if (!channel) {\n        that.getChannel(id).then(function (channelFound) {\n          if (channelFound) {\n            that.subscribeToChannel(channelFound).then(function () {\n              that._logger.log(\"debug\", LOG_ID + \"(subscribeToChannel) subscribed : \", id);\n\n              resolve({\n                code: \"OK\",\n                label: \"OK\"\n              });\n            }).catch(function (err) {\n              return reject(err);\n            });\n          } else {\n            return reject({\n              code: \"ERRORBADREQUEST\",\n              label: \"No channel found with id \" + id\n            });\n          }\n        });\n      } else {\n        that.subscribeToChannel(channel).then(function () {\n          that._logger.log(\"debug\", LOG_ID + \"(subscribeToChannel) subscribed : \", id);\n\n          resolve({\n            code: \"OK\",\n            label: \"OK\"\n          });\n        }).catch(function (err) {\n          return reject(err);\n        });\n      }\n    });\n  }\n\n  /**\n   * @public\n   * @method unsubscribeFromChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel to unsubscribe\n   * @return {Promise<String>} The status of the unsubscribe.\n   * @description\n   *  Unsubscribe from a public channel\n   */\n  unsubscribeFromChannel(channel) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(unsubscribeFromChannel) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(unsubscribeFromChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.unsubscribeToChannel(channel.id).then(status => {\n        this._logger.log(\"info\", LOG_ID + \"(unsubscribeFromChannel) channel unsubscribed : \", status);\n\n        resolve(status);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(unsubscribeFromChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(unsubscribeFromChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method updateChannelTopic\n   * @instance\n   * @async\n   * @param {Channel} channel The channel to update\n   * @param {string} description  The description of the channel to update (max-length=255)\n   * @return {Promise<Channel>} Updated channel\n   * @description\n   *  TODO\n   */\n\n\n  updateChannelTopic(channel, description) {\n    return this.updateChannelDescription(channel, description);\n  }\n  /**\n   * @public\n   * @method updateChannelDescription\n   * @instance\n   * @async\n   * @param {Channel} channel The channel to update\n   * @param {string} description  The description of the channel to update (max-length=255)\n   * @return {Promise<Channel>} Updated channel\n   * @description\n   *  TODO\n   */\n\n\n  updateChannelDescription(channel, description) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel.id' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel.id' parameter : \", channel.id);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!description) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'description' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'description' parameter : \", description);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.updateChannel(channel.id, description, null, null, null, null, null).then(channelUpdated => {\n        this._logger.log(\"info\", LOG_ID + \"(updateChannelDescription) channel updated\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(updateChannelDescription) channel updated : \", channelUpdated);\n\n        let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n        /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n        let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n        this._channels[foundIndex] = channelObj; // */\n\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(updateChannelDescription) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method\n   * @since 1.46\n   * @instance\n   * @description\n   *    Update a channel name<br/>\n   *    Return a promise.\n   * @param {Channel} channel The channel to update\n   * @param {String} channelName The name of the channel\n   * @return {Channel} Return the channel updated or an error\n   */\n\n\n  updateChannelName(channel, channelName) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channel.id' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channel.id' parameter : \", channel.id);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!channelName) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channelName' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channelName' parameter : \", channelName);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.updateChannel(channel.id, null, null, null, null, channelName, null).then(channelUpdated => {\n        this._logger.log(\"info\", LOG_ID + \"(updateChannelName) channel updated \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) channel updated : \", channelUpdated);\n\n        let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n        /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n        let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n        this._channels[foundIndex] = channelObj; */\n\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(updateChannelName) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  /**\n   * @public\n   * @method\n   * @since 1.38\n   * @instance\n   * @description\n   *    Update a channel<br/>\n   *      May be updated: name, topic, visibility, max_items and max_payload<br/>\n   *      Please put null to not update a property.<br/>\n   *    Return a promise.\n   * @param {String} id The id of the channel\n   * @param {String} [channelTopic=\"\"] The topic of the channel\n   * @param {String} [visibility=public] public/company/closed group visibility for search\n   * @param {Number} [max_items=30] max # of items to persist in the channel\n   * @param {Number} [max_payload_size=60000] max # of items to persist in the channel\n   * @param {String} [channelName=\"\"] The name of the channel\n   * @param {String} [category=\"\"] The category of the channel\n   * @return {Promise<Channel>} Return the channel created or an error\n   */\n  updateChannel(id, channelTopic, visibility, max_items, max_payload_size, channelName, category) {\n    let that = this;\n\n    if (!id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannel) bad or empty 'id' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannel) bad or empty 'id' parameter : \", id);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else {\n      let options = {};\n\n      if (channelTopic != null) {\n        options.topic = channelTopic;\n      }\n\n      if (visibility != null) {\n        options.mode = visibility === \"company\" ? \"company_public\" : \"company_closed\";\n      }\n\n      if (max_items != null) {\n        options.max_items = max_items;\n      }\n\n      if (max_payload_size != null) {\n        options.max_payload_size = max_payload_size;\n      }\n\n      if (channelName != null) {\n        options.name = channelName;\n      }\n\n      if (category != null) {\n        options.cateogry = category;\n      }\n\n      return new Promise((resolve, reject) => {\n        that._rest.updateChannel(id, options.topic, null, options.max_items, options.max_payload_size, options.name, options.mode).then(channelUpdated => {\n          this._logger.log(\"internal\", LOG_ID + \"(updateChannel) channel channelUpdated : \", channelUpdated);\n\n          let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n\n          this._logger.log(\"internal\", LOG_ID + \"(updateChannel) channel updated, channelObj : \", channelObj);\n\n          resolve(channelObj);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }\n\n  /**\n   * @public\n   * @method updateChannelVisibility\n   * @since 1.55\n   * @instance\n   * @description\n   *    Update a channel visibility<br/>\n   *    Return a promise.\n   * @param {String} channel The channel to update\n   * @param {String} visibility  The new channel visibility (closed or company)\n   * @return {Promise<Channel>} Return the channel updated or an error\n   */\n  updateChannelVisibility(channel, visibility) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel.id' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel.id' parameter : \", channel.id);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!visibility) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'visibility' parameter \");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'visibility' parameter : \", visibility);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let mode = visibility === \"company\" ? \"company_public\" : \"company_closed\";\n    let name = channel.name;\n    return new Promise((resolve, reject) => {\n      this._rest.updateChannel(channel.id, null, null, null, null, name, mode).then(channelUpdated => {\n        this._logger.log(\"internal\", LOG_ID + \"(updateChannelVisibility) channel updated : \", channelUpdated);\n\n        let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n        /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n        let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n        this._channels[foundIndex] = channelObj;\n        */\n\n        this._logger.log(\"internal\", LOG_ID + \"(updateChannelVisibility) channel updated : \", channelObj);\n\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(updateChannelVisibility) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  /**\n   * @public\n   * @method updateChannelVisibilityToPublic\n   * @since 1.55\n   * @instance\n   * @description\n   *    Set the channel visibility to company (visible for users in that company)<br/>\n   *    Return a promise.\n   * @param {String} channel The channel to update\n   * @return {Channel} Return the channel updated or an error\n   */\n  updateChannelVisibilityToPublic(channel) {\n    return this.updateChannelVisibility(channel, \"company\");\n  }\n  /**\n   * @public\n   * @method updateChannelVisibilityToClosed\n   * @since 1.55\n   * @instance\n   * @description\n   *    Set the channel visibility to closed (not visible by users)<br/>\n   *    Return a promise.\n   * @param {String} channel The channel to update\n   * @return {Channel} Return the channel updated or an error\n   */\n\n\n  updateChannelVisibilityToClosed(channel) {\n    //channel.name = channel.name + \"_updateToClosed\";\n    return this.updateChannelVisibility(channel, \"closed\");\n  }\n  /**\n   * @public\n   * @method\n   * @since 1.43\n   * @instance\n   * @description\n   *    Update a channel avatar<br/>\n   *    Return a promise.\n   * @param {Channel} channel The Channel to update\n   * @param {string} urlAvatar  The avatar Url.  It must be resized to 512 pixels before calling this API.\n   * @return {Channel} Return the channel updated or an error\n   */\n\n\n  updateChannelAvatar(channel, urlAvatar) {\n    let that = this;\n\n    if (!channel || !channel.id) {\n      that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter \");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else if (!urlAvatar) {\n      that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'urlAvatar' parameter \");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'urlAvatar' parameter : \", urlAvatar);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else {\n      return new Promise((resolve, reject) => {\n        try {\n          that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n\n          let id = channel.id;\n          let fileStats = fs.statSync(urlAvatar);\n          let fd = fs.openSync(urlAvatar, \"r+\");\n          let buf = new Buffer(fileStats.size);\n          fs.readSync(fd, buf, 0, fileStats.size, null);\n          let fileType = mimetypes.lookup(urlAvatar);\n\n          that._rest.uploadChannelAvatar(id, buf, fileStats.size\n          /* should resize the picture to 512*/\n          , fileType).then(function () {\n            that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n\n            resolve({\n              code: \"OK\",\n              label: \"OK\"\n            });\n          }).catch(function (err) {\n            that._logger.log(\"error\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \", err, \", for channel : \", channel);\n\n            return reject(err);\n          });\n        } catch (err2) {\n          that._logger.log(\"error\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \");\n\n          that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \", err2, \", for channel : \", channel);\n\n          return reject(err2);\n        }\n      });\n    }\n  }\n\n  /**\n   * @public\n   * @method\n   * @since 1.43\n   * @instance\n   * @description\n   *    Delete a channel avatar<br/>\n   *    Return a promise.\n   * @param {Channel} channel The channel to update\n   * @return {Channel} Return the channel updated or an error\n   */\n  deleteChannelAvatar(channel) {\n    let that = this;\n\n    if (!channel || !channel.id) {\n      that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter \");\n\n      that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    } else {\n      return new Promise((resolve, reject) => {\n        let id = channel.id;\n\n        that._rest.deleteChannelAvatar(id).then(function () {\n          that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n\n          resolve({\n            code: \"OK\",\n            label: \"OK\"\n          });\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }\n\n  /**\n   * @public\n   * @method fetchChannelUsers\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the fetchChannelUsers method instead,\n   * @param {Channel} channel The channel\n   * @param {Object} [options] A filter parameter\n   * @param {Number} [options.page = 0] Display a specific page of results\n   * @param {Number} [options.limit=100] Number of results per page (max 1000)\n   * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only\n   * @param {Boolean} [options.onlyOwners=false] Filter to owners only\n   * @return {Promise<Users[]>} An array of users who belong to this channel\n   * @description\n   *  Get a pagined list of users who belongs to a channel\n   */\n  getUsersFromChannel(channel, options) {\n    return this.fetchChannelUsers(channel, options);\n  }\n  /**\n   * @public\n   * @method fetchChannelUsers\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @param {Object} [options] A filter parameter\n   * @param {Number} [options.page = 0] Display a specific page of results\n   * @param {Number} [options.limit=100] Number of results per page (max 1000)\n   * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only\n   * @param {Boolean} [options.onlyOwners=false] Filter to owners only\n   * @return {Promise<Users[]>} An array of users who belong to this channel\n   * @description\n   *  Get a pagined list of users who belongs to a channel\n   */\n\n\n  fetchChannelUsers(channel, options) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(fetchChannelUsers) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelUsers) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let json = {\n      \"limit\": 100,\n      \"page\": null,\n      \"type\": null\n    };\n\n    if (options) {\n      if (\"page\" in options) {\n        json.page = Number(options.page);\n      }\n\n      if (\"limit\" in options) {\n        json.limit = Number(options.limit);\n      }\n\n      if (\"onlyPublishers\" in options && options.onlyPublishers) {\n        json.type = \"publisher\";\n      }\n\n      if (\"onlyOwners\" in options && options.onlyOwners) {\n        json.type = \"owner\";\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.getChannelUsers(channel.id, json).then(users => {\n        this._logger.log(\"info\", LOG_ID + \"(fetchChannelUsers) channel has users \");\n\n        this._logger.log(\"internal\", LOG_ID + \"(fetchChannelUsers) channel has users : \", users.length);\n\n        resolve(users);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(fetchChannelUsers) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelUsers) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method removeAllUsersFromChannel\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the deleteAllUsersFromChannel method instead,\n   * @param {String} channel The channel\n   * @return {Promise<Channel>} The channel updated\n   * @description\n   *  Remove all users from a channel\n   */\n\n\n  removeAllUsersFromChannel(channel) {\n    return this.deleteAllUsersFromChannel(channel);\n  }\n  /**\n   * @public\n   * @method deleteAllUsersFromChannel\n   * @instance\n   * @async\n   * @param {String} channel The channel\n   * @return {Promise<Channel>} The channel updated\n   * @description\n   *  Remove all users from a channel\n   */\n\n\n  deleteAllUsersFromChannel(channel) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(deleteAllUsersFromChannel) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllUsersFromChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.deleteAllUsersFromChannel(channel.id).then(result => {\n        this._logger.log(\"info\", LOG_ID + \"(deleteAllUsersFromChannel) channel users deletion\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(deleteAllUsersFromChannel) channel users deletion : \", result);\n\n        this._rest.getChannel(channel.id).then(updatedChannel => {\n          // Update local channel\n          let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n          /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n          let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n          this._channels[foundIndex] = channelObj;\n           */\n\n          resolve(channelObj);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(deleteAllUsersFromChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllUsersFromChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method updateChannelUsers\n   * @instance\n   * @async\n   * @param {String} channelId The Id of the channel\n   * @param {ChannelUser[]} users The users of the channel\n   * @return {Promise<Channel>} Update Channel Users status\n   * @description\n   *  TODO\n   */\n\n\n  updateChannelUsers(channel, users) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(updateChannelUsers) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelUsers) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let channelId = channel.id;\n    return new Promise((resolve, reject) => {\n      //this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) this._channels : \", this._channels);\n      this._rest.updateChannelUsers(channelId, users).then(res => {\n        this._logger.log(\"info\", LOG_ID + \"(updateChannelUsers) channel users updated\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) channel users updated : \", res);\n\n        this._rest.getChannel(channelId).then(updatedChannel => {\n          // Update local channel\n          let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n          /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n          let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n          this._channels[foundIndex] = channelObj;\n           */\n\n          this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) channel updated : \", channelObj);\n\n          resolve(channelObj);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(updateChannelUsers) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelUsers) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method addOwnersToChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @param owners\n   * @return {Promise<Channel>} The updated channel\n   * @description\n   *  Add a list of owners to the channel\n   */\n\n\n  addOwnersToChannel(channel, owners) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(addOwnersToChannel) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(addOwnersToChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!owners) {\n      this._logger.log(\"warn\", LOG_ID + \"(addOwnersToChannel) bad or empty 'owners' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(addOwnersToChannel) bad or empty 'owners' parameter : \", owners);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let usersId = [];\n    owners.forEach(user => {\n      usersId.push({\n        \"id\": user.id,\n        \"type\": \"owner\"\n      });\n    });\n    let updated = this.updateChannelUsers(channel, usersId);\n    return updated;\n  }\n  /**\n   * @public\n   * @method addPublishersToChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @param {User[]} users An array of users to add\n   * @return {Promise<Channel>} The updated channel\n   * @description\n   *  Add a list of publishers to the channel\n   */\n\n\n  addPublishersToChannel(channel, publishers) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(addPublishersToChannel) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(addPublishersToChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!publishers || !(publishers.length > 0)) {\n      this._logger.log(\"warn\", LOG_ID + \"(addPublishersToChannel) bad or empty 'publishers' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(addPublishersToChannel) bad or empty 'publishers' parameter : \", publishers);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let usersId = [];\n    publishers.forEach(user => {\n      usersId.push({\n        \"id\": user.id,\n        \"type\": \"publisher\"\n      });\n    });\n    let updated = this.updateChannelUsers(channel, usersId);\n    return updated;\n  }\n  /**\n   * @public\n   * @method addMembersToChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @param {User[]} users An array of users to add\n   * @return {Promise<Channel>} The updated channel\n   * @description\n   *  Add a list of members to the channel\n   */\n\n\n  addMembersToChannel(channel, members) {\n    return __awaiter(this, void 0, void 0, function* () {\n      //this._logger.log(\"internal\", LOG_ID + \"(addMembersToChannel) this._channels : \", this._channels);\n      if (!channel || !channel.id) {\n        this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'channel' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'channel' parameter : \", channel);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      if (!members) {\n        this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter : \", members);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      let usersId = [];\n      members.forEach(user => {\n        if (user) {\n          usersId.push({\n            \"id\": user.id,\n            \"type\": \"member\"\n          });\n        }\n      });\n\n      if (!(usersId.length > 0)) {\n        this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter : \", members);\n\n        return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n      }\n\n      let updated = this.updateChannelUsers(channel, usersId);\n      return updated;\n    });\n  }\n  /**\n   * @public\n   * @method removeUsersFromChannel1\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the deleteUsersFromChannel method instead,\n   * @param {Channel} channel The channel\n   * @param {User[]} users An array of users to remove\n   * @return {Promise<Channel>} The updated channel\n   * @description\n   *  Remove a list of users from a channel\n   */\n\n\n  removeUsersFromChannel1(channel, users) {\n    return this.deleteUsersFromChannel(channel, users);\n  }\n  /**\n   * @public\n   * @method deleteUsersFromChannel\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @param {User[]} users An array of users to remove\n   * @return {Promise<Channel>} The updated channel\n   * @description\n   *  Remove a list of users from a channel\n   */\n\n\n  deleteUsersFromChannel(channel, users) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!users) {\n      this._logger.log(\"warn\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'publishers' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'publishers' parameter : \", users);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    let usersId = [];\n    users.forEach(user => {\n      usersId.push({\n        \"id\": user.id,\n        \"type\": \"none\"\n      });\n    });\n    let updated = this.updateChannelUsers(channel, usersId);\n    return updated;\n  }\n  /**\n   * @public\n   * @method getMessagesFromChannel\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the fetchChannelItems method instead,\n   * @param {Channel} channel The channel\n   * @return {Promise<Object[]>} The list of messages received\n   * @description\n   *  Retrieve the last messages from a channel\n   */\n\n\n  getMessagesFromChannel(channel) {\n    return this.fetchChannelItems(channel);\n  }\n  /**\n   * @public\n   * @method fetchChannelItems\n   * @instance\n   * @async\n   * @param {Channel} channel The channel\n   * @return {Promise<Object[]>} The list of messages received\n   * @description\n   *  Retrieve the last messages from a channel\n   */\n\n\n  fetchChannelItems(channel) {\n    if (!channel || !channel.id) {\n      this._logger.log(\"warn\", LOG_ID + \"(fetchChannelItems) bad or empty 'channel' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelItems) bad or empty 'channel' parameter : \", channel);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.getChannelMessages(channel.id).then(res => {\n        this._logger.log(\"info\", LOG_ID + \"(fetchChannelItems) messages retrieved\", res);\n\n        let messages = res.items;\n        let listOfMessages = [];\n        messages.forEach(item => {\n          let message = {\n            id: item.item.$.id ? item.item.$.id : \"\",\n            title: item.item.entry.title ? item.item.entry.title : \"\",\n            message: item.item.entry.message ? item.item.entry.message : \"\",\n            url: item.item.entry.url ? item.item.entry.url : \"\",\n            images: []\n          };\n\n          if (Array.isArray(item.item.entry.images)) {\n            item.item.entry.images.forEach(image => {\n              message.images.push(image.id);\n            });\n          } else {\n            // when there is only one image, the server give us a single object and not an Array.\n            if (item.item.entry.images) {\n              message.images.push(item.item.entry.images.id);\n            }\n          }\n\n          listOfMessages.push(message);\n        });\n        resolve(listOfMessages);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(fetchChannelItems) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelItems) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * @public\n   * @method deleteMessageFromChannel\n   * @instance\n   * @async\n   * @deprecated [#1] since version 1.55 [#2].\n   * [#3] Will be deleted in future version\n   * [#4] In case you need similar behavior use the deleteItemFromChannel method instead,\n   * @param  {String} channelId The Id of the channel\n   * @param  {String} messageId The Id of the message\n   * @return {Promise<Channel>} The channel updated\n   * @description\n   *  Delete a message from a channel\n   */\n\n\n  deleteMessageFromChannel(channelId, messageId) {\n    return this.deleteItemFromChannel(channelId, messageId);\n  }\n  /**\n   * @public\n   * @method deleteItemFromChannel\n   * @instance\n   * @async\n   * @param  {String} channelId The Id of the channel\n   * @param  {String} itemId The Id of the item\n   * @return {Promise<Channel>} The channel updated\n   * @description\n   *  Delete a message from a channel\n   */\n\n\n  deleteItemFromChannel(channelId, itemId) {\n    if (!channelId) {\n      this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'channelId' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'channelId' parameter : \", channelId);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    if (!itemId) {\n      this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'itemId' parameter\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'itemId' parameter : \", itemId);\n\n      return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rest.deleteChannelMessage(channelId, itemId).then(result => {\n        this._logger.log(\"info\", LOG_ID + \"(deleteItemFromChannel) channel message deletion\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(deleteItemFromChannel) channel message deletion : \", result);\n\n        this._rest.getChannel(channelId).then(updatedChannel => {\n          // Update local channel\n          let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n          /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n          let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n          this._channels[foundIndex] = channelObj;\n           */\n\n          resolve(channelObj);\n        }).catch(err => {\n          this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) error getChannel \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) error getChannel : \", err);\n\n          return reject(err);\n        });\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  _onChannelMessageReceived(message) {\n    this.fetchChannel(message.channelId).then(channel => {\n      message.channel = channel;\n      delete message.channelId;\n\n      this._eventEmitter.emit(\"evt_internal_channelmessagereceived\", message);\n    });\n  }\n  /**\n   * @private\n   * @param channelId\n   * @description\n   *      GET A CHANNEL\n   */\n\n\n  getChannel(channelId) {\n    return new Promise((resolve, reject) => {\n      this._rest.getChannel(channelId).then(channel => {\n        this._logger.log(\"info\", LOG_ID + \"(getChannel) channel found on the server\");\n\n        this._logger.log(\"internal\", LOG_ID + \"(getChannel) channel found on the server : \", channel);\n\n        let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n        resolve(channelObj);\n      }).catch(err => {\n        this._logger.log(\"error\", LOG_ID + \"(getChannel) error \");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(getChannel) error : \", err);\n\n        return reject(err);\n      });\n    });\n  }\n\n  /**\n   * @private\n   * @param channelId\n   * @description\n   *      GET A CHANNEL FROM CACHE\n   */\n  getChannelFromCache(channelId) {\n    let channelFound = null;\n\n    this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) search id : \", channelId);\n\n    if (this._channels) {\n      let channelFoundindex = this._channels.findIndex(channel => {\n        return channel.id === channelId;\n      });\n\n      if (channelFoundindex != -1) {\n        this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) channel found : \", this._channels[channelFoundindex], \" with id : \", channelId);\n\n        return this._channels[channelFoundindex];\n      }\n    }\n\n    this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) channel found : \", channelFound, \" with id : \", channelId);\n\n    return channelFound;\n  }\n\n  updateChannelsList() {\n    //this._logger.log(\"debug\", LOG_ID + \"(updateChannelsList) keys : \", Object.keys(this._channels));\n    this._channelsList = this._channels.map(chnl => {\n      return chnl.id;\n    });\n\n    this._logger.log(\"internal\", LOG_ID + \"(updateChannelsList) this._channelsList : \", this._channelsList);\n  }\n\n  addOrUpdateChannelToCache(channel) {\n    let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n\n    let channelFoundindex = this._channels.findIndex(channelIter => {\n      return channelIter.id === channel.id;\n    });\n\n    if (channelFoundindex != -1) {\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) update in cache with channel : \", channel, \", at channelFoundindex : \", channelFoundindex); //this._channels.splice(channelFoundindex,1,channelObj);\n      //channelCached = channelObj;\n\n\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) in update this._channels : \", this._channels);\n\n      this._channels[channelFoundindex].updateChannel(channel);\n\n      channelObj = this._channels[channelFoundindex];\n    } else {\n      this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) add in cache channelObj : \", channelObj);\n\n      this._channels.push(channelObj);\n    }\n\n    this.updateChannelsList();\n    return channelObj;\n  }\n\n  removeChannelFromCache(channelId) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      // Get the channel to remove\n      let channelToRemove = this.getChannelFromCache(channelId);\n\n      if (channelToRemove) {\n        // Store channel name\n        //let channelName = channelToRemove.name;\n        // Handle invitation channel\n        if (channelToRemove.invited) {\n          this.decrementInvitationCounter();\n        } // Remove from channels\n\n\n        let channelId = channelToRemove.id;\n\n        this._logger.log(\"internal\", LOG_ID + \"(removeChannelFromCache) remove from cache channelId : \", channelId);\n\n        this._channels = this._channels.filter(function (chnl) {\n          return !(chnl.id === channelId);\n        });\n        this.updateChannelsList(); // Update messagesList\n        //this.feedChannel.messages = [];\n\n        this.retrieveLatests().then(() => {\n          resolve(channelToRemove);\n        }).catch(err => {\n          this._logger.log(\"error\", LOG_ID + \"(removeChannelFromCache) error retrieveLatests \");\n\n          this._logger.log(\"internalerror\", LOG_ID + \"(removeChannelFromCache) error retrieveLatests : \", err);\n\n          return reject(err);\n        });\n      } else {\n        resolve(null);\n      }\n    });\n  }\n\n  retrieveLatests(beforeDate = null) {\n    return this._rest.getLatestMessages(10, beforeDate, null).then(messages => {\n      // TODO : this.feedChannel.messages.push.apply(this.feedChannel.messages, messages);\n      return messages.length;\n    });\n  }\n\n  incrementInvitationCounter() {\n    this.invitationCounter += 1;\n  }\n\n  decrementInvitationCounter() {\n    this.invitationCounter -= 1;\n  }\n  /****************************************************************/\n\n  /*** MANAGEMENT EVENT HANDLER                                 ***/\n\n  /****************************************************************/\n\n\n  onAvatarChange(channelId, avatar) {\n    /*\n    let action = avatar.attr(\"action\");\n    let updateDate: Date = avatar.attr(\"lastAvatarUpdateDate\") ? new Date(avatar.attr(\"lastAvatarUpdateDate\")) : null;\n    this.$log.info(\"[channelService] onChannelManagementReceived -- \" + action + \" avatar for \" + channelId);\n    if (action === \"delete\" || action === \"update\") {\n        let channel: Channel = this.getChannelFromCache(channelId);\n        channel.lastAvatarUpdateDate = updateDate;\n        if (updateDate !== null) {\n            channel.avatar = config.restServerUrl + \"/api/channel-avatar/\" + channelId + \"?size=256&ts=\" + new Date(updateDate).getTime();\n        }\n    }\n      */\n  }\n\n  onUpdateToChannel(channelInfo) {\n    let that = this;\n    let channelId = channelInfo.id;\n\n    this._logger.log(\"debug\", LOG_ID + \"(onUpdateToChannel) channelId : \", channelId); // Get channel from cache\n    //let channel = this.getChannelFromCache(channelId);\n    // Get channel from server\n\n\n    this.getChannel(channelId).then(newChannel => {\n      let channelObj = this.addOrUpdateChannelToCache(newChannel);\n      /*if (newChannel.invited) {\n          let channelObj : Channel = this.addOrUpdateChannelToCache(newChannel);\n          that._eventEmitter.emit(\"rainbow_channelcreated\", {'id': newChannel.id});\n          //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n      } else { // */\n\n      that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n        \"id\": channelObj.id,\n        \"kind\": that.LIST_EVENT_TYPE.ADD.code,\n        \"label\": that.LIST_EVENT_TYPE.ADD.label\n      }); //}\n\n    });\n  }\n\n  onAddToChannel(channelInfo) {\n    let that = this;\n    let channelId = channelInfo.id;\n\n    this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) channelId : \", channelId); //this._logger.log(\"internal\", LOG_ID + \"(onAddToChannel) this._channels : \", this._channels);\n    // Get channel from cache\n\n\n    let channel = this.getChannelFromCache(channelId); // Get channel from server\n\n    this.getChannel(channelId).then(newChannel => {\n      // Handle channel creation\n      if (!channel && !newChannel.invited) {\n        let channelObj = this.addOrUpdateChannelToCache(newChannel); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n        //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) rainbow_channelcreated : \", channelObj.id);\n\n        that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n          'id': channelObj.id,\n          \"kind\": that.LIST_EVENT_TYPE.ADD.code,\n          \"label\": that.LIST_EVENT_TYPE.ADD.label\n        });\n      } // Handle channel invitation\n      else if (!channel && newChannel.invited) {\n          let channelObj = this.addOrUpdateChannelToCache(newChannel);\n          this.incrementInvitationCounter(); //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) evt_internal_channelupdated : \", channelObj.id, \"kind : \", that.LIST_EVENT_TYPE.SUBSCRIBE);\n\n          that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n            'id': channelObj.id,\n            \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code,\n            \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label\n          }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, newChannel.id);\n\n        } // Handle change role\n        else if (channel && newChannel.userRole !== this.USER_ROLE.NONE) {\n            channel.userRole = newChannel.userRole; // TODO : this.feedChannel.messages = [];\n\n            this.retrieveLatests().then(() => {\n              //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) retrieveLatests evt_internal_channelupdated : \", channelId, \"kind : \", that.LIST_EVENT_TYPE.SUBSCRIBE);\n              that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n                'id': channelId,\n                \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code,\n                \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label\n              }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n\n            });\n          }\n    });\n  }\n\n  onRemovedFromChannel(channelInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let channelId = channelInfo.id;\n\n      this._logger.log(\"debug\", LOG_ID + \"(onRemovedFromChannel) channelId : \", channelId);\n\n      let channelDeleted = yield that.removeChannelFromCache(channelId);\n      let channelIdDeleted = channelDeleted ? channelDeleted.id : channelInfo.id;\n\n      that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n        'id': channelIdDeleted,\n        \"kind\": that.LIST_EVENT_TYPE.DELETE.code,\n        \"label\": that.LIST_EVENT_TYPE.DELETE.label\n      }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId);\n\n    });\n  }\n\n  onSubscribeToChannel(channelInfo) {\n    let that = this;\n    let channelId = channelInfo.id;\n    let subscribersInfo = channelInfo.subscribers;\n\n    this._logger.log(\"internal\", LOG_ID + \"(onSubscribeToChannel) channelId : \", channelId, \", subscribersInfo : \", subscribersInfo); // Handle invitation case\n\n\n    let channel = this.getChannelFromCache(channelId);\n    let subscribers = Number.parseInt(subscribersInfo);\n\n    if (channel) {\n      channel.invited = false;\n      channel.subscribed = true;\n      channel.subscribers_count = subscribers; //this.feedChannel.messages = [];\n\n      this.retrieveLatests().then(() => {\n        that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n          'id': channelId,\n          \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code,\n          \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label\n        }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n\n      });\n    } // Handle self subscription case\n    else {\n        this.getChannel(channelId).then(newChannel => {\n          let channelObj = this.addOrUpdateChannelToCache(newChannel); //this.feedChannel.messages = [];\n\n          return this.retrieveLatests();\n        }).then(() => {\n          that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n            'id': channelId,\n            \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code,\n            \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label\n          }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n\n        });\n      }\n  }\n\n  onUnsubscribeToChannel(channelInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let channelId = channelInfo.id;\n      let subscribersInfo = channelInfo.subscribers;\n\n      this._logger.log(\"internal\", LOG_ID + \"(onUnsubscribeToChannel) channelId : \", channelId, \", subscribersInfo : \", subscribersInfo);\n\n      let subscribers = Number.parseInt(subscribersInfo);\n      let channel = yield this.fetchChannel(channelId);\n\n      if (channel) {\n        channel.subscribers_count = subscribers;\n        channel.subscribed = false;\n      } // Update messagesList\n      //this.feedChannel.messages = [];\n\n\n      this.retrieveLatests().then(() => {\n        that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n          'id': channelId,\n          \"kind\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.code,\n          \"label\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.label\n        }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId);\n\n      });\n    });\n  }\n\n  onDeleteChannel(channelInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let channelId = channelInfo.id;\n\n      this._logger.log(\"debug\", LOG_ID + \"(onDeleteChannel) channelId : \", channelId);\n\n      let channelDeleted = yield that.removeChannelFromCache(channelId);\n      let channelIdDeleted = channelDeleted ? channelDeleted.id : channelInfo.id;\n\n      that._eventEmitter.emit(\"evt_internal_channelupdated\", {\n        'id': channelIdDeleted,\n        \"kind\": that.LIST_EVENT_TYPE.DELETE.code,\n        \"label\": that.LIST_EVENT_TYPE.DELETE.label\n      }); //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId);\n\n    });\n  }\n\n  onUserSubscribeEvent(info) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      this._logger.log(\"internal\", LOG_ID + \"(onUserSubscribeEvent) channelId : \", info.id, \", subscribersInfo : \", info.subscribers);\n\n      let channel = yield this.fetchChannel(info.id);\n\n      if (channel) {\n        channel.subscribers_count = info.subscribers;\n      }\n\n      that._eventEmitter.emit(\"evt_internal_channelusersubscription\", {\n        'id': info.id,\n        'userId': info.userId,\n        \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code,\n        \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label\n      }); //this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId, userId);\n\n    });\n  }\n\n  onUserUnsubscribeEvent(info) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      this._logger.log(\"internal\", LOG_ID + \"(onUserUnsubscribeEvent) channelId : \", info.id, \", subscribersInfo : \", info.subscribers);\n\n      let channel = yield this.fetchChannel(info.id);\n\n      if (channel) {\n        channel.subscribers_count = info.subscribers;\n      }\n\n      that._eventEmitter.emit(\"evt_internal_channelusersubscription\", {\n        'id': info.id,\n        'userId': info.userId,\n        \"kind\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.code,\n        \"label\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.label\n      }); //this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId, userId);\n\n    });\n  }\n\n};\nChannels = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_1.isStarted([])\n/**\n * @module\n * @name Channels\n * @version 1.67.1 \n * @public\n * @description\n *      This service manages Channels. This service is in Beta.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Create a new channel <br>\n *      - Manage a channel: update, delete <br>\n *      - Manage users in a channel <br>\n */\n], Channels);\nexports.ChannelsService = Channels;\nmodule.exports.ChannelsService = Channels;","map":{"version":3,"sources":["../../src/lib/services/ChannelsService.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,MAAA,cAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AAGA,MAAA,MAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAKA,MAAM,MAAM,GAAG,kBAAf;AAiBA,IAAM,QAAQ;AAbd;;;;;;;;;;;;;AAaA,MAAM,QAAN,CAAc;AA8CV,EAAA,WAAA,CAAY,aAAZ,EAA0C,OAA1C,EAA4D,YAA5D,EAAwE;AA5BjE,SAAA,iBAAA,GAA4B,CAA5B;AACA,SAAA,KAAA,GAAiB,KAAjB;AASA,SAAA,eAAA,GAAkB;AACrB,MAAA,GAAG,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OADgB;AAErB,MAAA,MAAM,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OAFa;AAGrB,MAAA,MAAM,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OAHa;AAIrB,MAAA,MAAM,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OAJa;AAKrB,MAAA,SAAS,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OALU;AAMrB,MAAA,WAAW,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB,OANQ;AAOrB,MAAA,MAAM,EAAE;AAAC,QAAA,IAAI,EAAG,CAAR;AAAW,QAAA,KAAK,EAAG;AAAnB;AAPa,KAAlB;AAUA,SAAA,SAAA,GAAY;AACf,MAAA,IAAI,EAAE,MADS;AAEf,MAAA,KAAK,EAAE,OAFQ;AAGf,MAAA,SAAS,EAAE,WAHI;AAIf,MAAA,MAAM,EAAE;AAJO,KAAZ;AASH,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,QAAL,GAAgB,EAAhB;AACA,SAAK,QAAL,GAAgB,KAAhB;AACA,SAAK,OAAL,GAAe,KAAf;AACA,SAAK,SAAL,GAAiB,IAAjB;AACA,SAAK,aAAL,GAAqB,IAArB;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,SAAL,GAAiB,GAAjB;AACA,SAAK,gBAAL,GAAwB,KAAxB;AACA,SAAK,iBAAL,GAAyB,SAAzB;AACA,SAAK,kBAAL,GAA0B,SAA1B;AACA,SAAK,iBAAL,GAAyB,QAAzB;AACA,SAAK,KAAL,GAAa,KAAb;;AAEA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,kCAAtB,EAA0D,KAAK,yBAAL,CAA+B,IAA/B,CAAoC,IAApC,CAA1D;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,2BAAtB,EAAmD,KAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB,CAAnD;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,8BAAtB,EAAsD,KAAK,iBAAL,CAAuB,IAAvB,CAA4B,IAA5B,CAAtD;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,gCAAtB,EAAwD,KAAK,oBAAL,CAA0B,IAA1B,CAA+B,IAA/B,CAAxD;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,iCAAtB,EAAyD,KAAK,oBAAL,CAA0B,IAA1B,CAA+B,IAA/B,CAAzD;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,mCAAtB,EAA2D,KAAK,sBAAL,CAA4B,IAA5B,CAAiC,IAAjC,CAA3D;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,4BAAtB,EAAoD,KAAK,eAAL,CAAqB,IAArB,CAA0B,IAA1B,CAApD;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,mCAAtB,EAA2D,KAAK,oBAAL,CAA0B,IAA1B,CAA+B,IAA/B,CAA3D;;AACA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,qCAAtB,EAA6D,KAAK,sBAAL,CAA4B,IAA5B,CAAiC,IAAjC,CAA7D;AAEH;;AAnDD,MAAI,WAAJ,GAAe;AACX,WAAO,KAAK,YAAZ;AACH;;AAmDD,EAAA,KAAK,CAAC,QAAD,EAAU,KAAV,EAAsB;AACvB,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,QAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB;AACA,QAAA,IAAI,CAAC,IAAL,GAAY,KAAK,CAAC,IAAlB;AACA,QAAA,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,QAAL,CAAc,OAA9B;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,IAAI,CAAC,QAAL,CAAc,MAA7B;AACA,QAAA,IAAI,CAAC,SAAL,GAAiB,EAAjB;AACA,QAAA,IAAI,CAAC,aAAL,GAAqB,EAArB;AACA,QAAA,IAAI,CAAC,cAAL;AACA,aAAK,KAAL,GAAa,IAAb;AACA,QAAA,OAAO;AACV,OAZD,CAaA,OAAO,GAAP,EAAY;AACR,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,gBAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kBAA3C,EAA+D,GAA/D;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAnBM,CAAP;AAoBH;;AAED,EAAA,IAAI,GAAA;AACA,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI;AACA,aAAK,KAAL,GAAa,IAAb;AACA,aAAK,KAAL,GAAa,IAAb;AACA,aAAK,SAAL,GAAiB,IAAjB;AACA,aAAK,aAAL,GAAqB,IAArB,CAJA,CAKhB;;AACgB,YAAI,IAAI,CAAC,mBAAT,EAA8B;AAC1B,UAAA,IAAI,CAAC,mBAAL,CAAyB,OAAzB,CAAkC,KAAD,IAAW,MAAM,CAAC,WAAP,CAAmB,KAAnB,CAA5C;AACH;;AACD,QAAA,IAAI,CAAC,mBAAL,GAA2B,EAA3B;AACA,aAAK,KAAL,GAAa,KAAb;AACA,QAAA,OAAO;AACV,OAZD,CAYE,OAAO,GAAP,EAAY;AACV,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,eAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iBAA3C,EAA8D,GAA9D;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAlBM,CAAP;AAmBH;;AAED,EAAA,cAAc,GAAA;AACV,QAAI,IAAI,GAAG,IAAX;AACA,IAAA,IAAI,CAAC,mBAAL,GAA2B,IAAI,qBAAA,CAAA,mBAAJ,CAAwB,IAAI,CAAC,KAA7B,EAAoC,IAApC,CAA3B;AACA,IAAA,IAAI,CAAC,mBAAL,GAA2B,CACnC;AACA;AACA;AACY,IAAA,MAAM,CAAC,SAAP,CAAkB,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,GAAlB,GAAwB,IAAI,CAAC,mBAAL,CAAyB,kBAAnE,EAAuF,IAAI,CAAC,mBAAL,CAAyB,2BAAhH,CAJuB,EAKvB,MAAM,CAAC,SAAP,CAAkB,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,GAAlB,GAAwB,IAAI,CAAC,mBAAL,CAAyB,aAAnE,EAAkF,IAAI,CAAC,mBAAL,CAAyB,sBAA3G,CALuB,EAMvB,MAAM,CAAC,SAAP,CAAkB,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,GAAlB,GAAwB,IAAI,CAAC,mBAAL,CAAyB,gBAAnE,EAAqF,IAAI,CAAC,mBAAL,CAAyB,yBAA9G,CANuB,CAA3B;AAUH;AAED;;;;;;;;;;;;;AAWA,EAAA,aAAa,CAAC,IAAD,EAAO,YAAP,EAAmB;AAC5B,WAAO,KAAK,mBAAL,CAAyB,IAAzB,EAA+B,YAA/B,EAA6C,YAA7C,CAAP;AACH;AAED;;;;;;;;;;;;;;AAYA,EAAA,mBAAmB,CAAC,IAAD,EAAO,YAAP,EAAqB,QAArB,EAA6B;AAC5C,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,UAAI,CAAC,IAAL,EAAW;AACP,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,qDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wDAA3C,EAAqG,IAArG;;AACA,QAAA,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAN;AACA;AACH;;AACD,WAAK,KAAL,CAAW,mBAAX,CAA+B,IAA/B,EAAqC,YAArC,EAAmD,QAAnD,EAA6D,KAAK,iBAAlE,EAAqF,KAAK,SAA1F,EAAqG,KAAK,gBAA1G,EAA4H,IAA5H,CAAkI,OAAD,IAAY;AACzI,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4CAAnC,EADyI,CAEzI;;;AACA,YAAI,UAAU,GAAa,SAAA,CAAA,OAAA,CAAQ,cAAR,GAAyB,OAAzB,EAAkC,KAAK,KAAL,CAAW,IAAX,CAAgB,SAAlD,CAA3B;AACA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OALD,EAKG,KALH,CAKU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,8BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gCAA3C,EAA6E,GAA7E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OATD;AAUH,KAlBM,CAAP;AAmBH;AAED;;;;;;;;;;;;;;;;AAcA,EAAA,oBAAoB,CAAC,IAAD,EAAO,WAAP,EAAkB;AAClC,WAAO,KAAK,mBAAL,CAAyB,IAAzB,EAA+B,WAA/B,EAA4C,YAA5C,CAAP;AACH;AAED;;;;;;;;;;;;;;AAYA,EAAA,mBAAmB,CAAC,IAAD,EAAO,WAAP,EAAoB,QAApB,EAA4B;AAE3C,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,UAAI,CAAC,IAAL,EAAW;AACP,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,qDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wDAA3C,EAAqG,IAArG;;AACA,QAAA,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAN;AACA;AACH;;AACD,WAAK,KAAL,CAAW,mBAAX,CAA+B,IAA/B,EAAqC,WAArC,EAAkD,QAAlD,EAA4D,KAAK,kBAAjE,EAAqF,KAAK,SAA1F,EAAqG,KAAK,gBAA1G,EAA4H,IAA5H,CAAkI,OAAD,IAAY;AACzI,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4CAAnC,EADyI,CAEzI;;;AACA,YAAI,UAAU,GAAa,SAAA,CAAA,OAAA,CAAQ,cAAR,GAAyB,OAAzB,EAAkC,KAAK,KAAL,CAAW,IAAX,CAAgB,SAAlD,CAA3B;AACA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OALD,EAKG,KALH,CAKU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,8BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gCAA3C,EAA6E,GAA7E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OATD;AAUH,KAlBM,CAAP;AAmBH;AAED;;;;;;;;;;;;AAUA,EAAA,aAAa,CAAC,OAAD,EAAQ;AAEjB,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,qDAA3C,EAAkG,OAAlG;;AACA,QAAA,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAN;AACA;AACH;;AAED,WAAK,KAAL,CAAW,aAAX,CAAyB,OAAO,CAAC,EAAjC,EAAqC,IAArC,CAAiD,MAAP,IAAiB,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACvD,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,2CAAnC,EAAgF,MAAhF;AACA;;;;;AAIA,YAAI,cAAc,GAAG,MAAM,KAAK,sBAAL,CAA4B,OAAO,CAAC,EAApC,CAA3B;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,oCAAtC,EAA4E,cAA5E;;AACA,YAAI,cAAJ,EAAoB;AAChB,UAAA,OAAO,CAAC,cAAD,CAAP;AACH,SAFD,MAEO;AACH,eAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iEAAlC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,mEAA3C,EAAgH,OAAhH;;AACA,UAAA,OAAO,CAAC,OAAD,CAAP;AACH;AACJ,OAf0D,CAA3D,EAeG,KAfH,CAeU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,wBAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0BAA3C,EAAuE,GAAvE;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAnBD;AAoBH,KA5BM,CAAP;AA6BH;AAED;;;;;;;;;;;;AAUA,EAAA,kBAAkB,CAAC,IAAD,EAAc;AAE5B,QAAI,CAAC,IAAL,EAAW;AACP,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,qDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,uDAA3C,EAAoG,IAApG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,KAAK,aAAL,CAAmB,IAAnB,EAAyB,IAAzB,CAAP;AACH;AAED;;;;;;;;;;;;AAUA,EAAA,mBAAmB,CAAC,KAAD,EAAe;AAE9B,QAAI,CAAC,KAAL,EAAY;AACR,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,uDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yDAA3C,EAAsG,KAAtG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,KAAK,aAAL,CAAmB,IAAnB,EAAyB,KAAzB,CAAP;AACH;AAED;;;;;;AAIQ,EAAA,aAAa,CAAC,IAAD,EAAgB,KAAhB,EAA8B;AAC/C;AACA,QAAI,UAAU,GAAI,EAAD,IAA0B;AACvC,aAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC3B,aAAK,YAAL,CAAkB,EAAlB,EAAsB,IAAtB,CAA4B,OAAD,IAAsB;AAC7C,UAAA,OAAO,CAAC,OAAD,CAAP;AACH,SAFD,EAEG,KAFH,CAEU,GAAD,IAAQ;AACb,eAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,mCAAnC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,qCAA3C,EAAkF,GAAlF;;AACA,UAAA,OAAO,CAAC,IAAD,CAAP;AACH,SAND;AAOH,OARM,CAAP;AASH,KAVD;;AAYA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,YAAX,CAAwB,IAAxB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,EAAiD,IAAjD,EAAuD,IAAvD,EAA6D,IAA7D,EAAmE,IAAnE,CAAyE,QAAD,IAAkB;AACtF,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8CAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,gDAAtC,EAAwF,QAAxF;;AAEA,YAAI,QAAQ,GAAG,EAAf;AAEA,QAAA,QAAQ,CAAC,OAAT,CAAkB,OAAD,IAAkB;AAC/B,UAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,SAFD;AAIA,QAAA,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA4B,cAAD,IAA+B;AACtD,UAAA,OAAO,CAAC,cAAD,CAAP;AACH,SAFD;AAIH,OAdD,EAcG,KAdH,CAcU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,wBAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0BAA3C,EAAuE,GAAvE;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAlBD;AAmBH,KArBM,CAAP;AAsBH;AAED;;;;;;;;;;;;;;;;AAcA,EAAA,cAAc,CAAC,EAAD,EAAK,KAAL,EAAW;AACrB,WAAO,KAAK,YAAL,CAAkB,EAAlB,EAAuB,KAAvB,CAAP;AACH;AAED;;;;;;;;;;;;;AAWM,EAAA,YAAY,CAAC,EAAD,EAAK,KAAL,EAAW;;AACzB,aAAO,IAAI,OAAJ,CAAY,CAAO,OAAP,EAAgB,MAAhB,KAA0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACzC,YAAI,CAAC,EAAL,EAAS;AACL,eAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,6CAAlC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gDAA3C,EAA6F,EAA7F;;AACA,iBAAO,MAAM,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAAhC,CAAb;AACH,SAJD,MAKK;AACD,cAAI,YAAY,GAAG,KAAK,mBAAL,CAAyB,EAAzB,CAAnB;;AAEA,cAAI,YAAY,IAAI,CAAC,KAArB,EAA4B;AACxB,iBAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sCAAlC;;AACA,iBAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,yCAAtC,EAAiF,YAAjF;;AACA,YAAA,OAAO,CAAC,YAAD,CAAP;AACH,WAJD,MAKK;AACD,iBAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,6DAAnC;;AACA,gBAAI,OAAO,GAAG,MAAM,KAAK,UAAL,CAAgB,EAAhB,CAApB;AACA,gBAAI,UAAU,GAAa,KAAK,yBAAL,CAA+B,OAA/B,CAA3B;AACA,YAAA,OAAO,CAAC,UAAD,CAAP;AACH;AACJ;AACJ,OArB4C,CAAtC,CAAP;AAsBH,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;;AAmBA,EAAA,qBAAqB,CAAE,MAAF,EAAQ;AACzB,QAAI,UAAU,GAAI,EAAD,IAA0B;AACvC,aAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC3B,aAAK,YAAL,CAAkB,EAAlB,EAAsB,IAAtB,CAA4B,OAAD,IAAsB;AAC7C,UAAA,OAAO,CAAC,OAAD,CAAP;AACH,SAFD,EAEG,KAFH,CAEU,GAAD,IAAQ;AACb,eAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,2CAAnC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,6CAA3C,EAA0F,GAA1F;;AACA,UAAA,OAAO,CAAC,IAAD,CAAP;AACH,SAND;AAOH,OARM,CAAP;AASH,KAVD;;AAYA,QAAI,CAAC,MAAL,EAAa;AACT,WAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,2DAAnC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,6DAAtC,EAAqG,MAArG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,YAAX,CAAwB,MAAM,CAAC,IAA/B,EAAqC,MAAM,CAAC,KAA5C,EAAmD,MAAM,CAAC,QAA1D,EAAoE,MAAM,CAAC,KAA3E,EAAkF,MAAM,CAAC,MAAzF,EAAiG,MAAM,CAAC,SAAxG,EAAoH,MAAM,CAAC,SAAP,IAAqB,MAAM,CAAC,SAAP,KAAqB,CAA1C,GAA+C,GAA/C,GAAqD,IAAzK,EAAgL,IAAhL,CAAsL,QAAD,IAAkB;AACnM,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wCAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,2CAAtC,EAAmF,QAAnF;;AAEA,YAAI,QAAQ,GAAG,EAAf;AAEA,QAAA,QAAQ,CAAC,OAAT,CAAkB,OAAD,IAAsB;AACnC,UAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,SAFD;AAIA,QAAA,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA4B,cAAD,IAA+B;AACtD,UAAA,OAAO,CAAC,cAAD,CAAP;AACH,SAFD;AAIH,OAdD,EAcG,KAdH,CAcU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,gCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kCAA3C,EAA+E,GAA/E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAlBD;AAmBH,KArBM,CAAP;AAsBH;;AAED;;;;;;;;;;;;;AAaA,EAAA,WAAW,GAAA;AACP,WAAO,KAAK,eAAL,EAAP;AACH;AAED;;;;;;;;;;;;AAUA,EAAA,eAAe,GAAA;AACX,QAAI,UAAU,GAAI,EAAD,IAA0B;AACvC,aAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC3B,aAAK,YAAL,CAAkB,EAAlB,EAAsB,IAAtB,CAA4B,OAAD,IAAY;AACnC,UAAA,OAAO,CAAC,OAAD,CAAP;AACH,SAFD,EAEG,KAFH,CAEU,GAAD,IAAQ;AACb,eAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,uCAAnC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yCAA3C,EAAsF,GAAtF;;AACA,UAAA,OAAO,CAAC,IAAD,CAAP;AACH,SAND;AAOH,OARM,CAAP;AASH,KAVD;;AAYA,WAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC3B,WAAK,KAAL,CAAW,WAAX,GAAyB,IAAzB,CAA+B,cAAD,IAAyB;AAEnD;AACA,YAAI,QAAQ,GAAG,EAAf;;AAEA,YAAI,KAAK,CAAC,OAAN,CAAc,cAAd,CAAJ,EAAmC;AAC/B,UAAA,cAAc,CAAC,OAAf,CAAwB,OAAD,IAAY;AAC/B,YAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,WAFD;AAGH,SAJD,MAIO;AACH,cAAK,WAAW,cAAhB,EAAgC;AAC5B,YAAA,cAAc,CAAC,KAAf,CAAqB,OAArB,CAA8B,OAAD,IAAY;AACrC,cAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,aAFD;AAGH;;AACD,cAAK,eAAe,cAApB,EAAoC;AAChC,YAAA,cAAc,CAAC,SAAf,CAAyB,OAAzB,CAAkC,OAAD,IAAY;AACzC,cAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,aAFD;AAGH;;AACD,cAAK,YAAY,cAAjB,EAAiC;AAC7B,YAAA,cAAc,CAAC,MAAf,CAAsB,OAAtB,CAA+B,OAAD,IAAY;AACtC,cAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,CAAC,OAAO,CAAC,EAAT,CAAxB;AACH,aAFD;AAGH;AACJ;;AAED,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,2EAAlC;;AACA,QAAA,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA4B,QAAD,IAAyB;AAChD,eAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,gCAAtC,EAAwE,QAAxE;;AACA,eAAK,SAAL,GAAiB,EAAjB;;AACA,cAAI,QAAJ,EAAc;AACV,YAAA,QAAQ,CAAC,OAAT,CAAkB,OAAD,IAAY;AACzB,mBAAK,yBAAL,CAA+B,OAA/B;AACH,aAFD;AAGH,WAP+C,CAQhD;;;AACA,UAAA,OAAO,CAAC,KAAK,SAAN,CAAP;AACH,SAVD;AAWH,OAvCD,EAuCG,KAvCH,CAuCU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,0BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,4BAA3C,EAAyE,GAAzE,EAFa,CAGb;;;AACA,aAAK,SAAL,GAAiB,EAAjB;AACA,QAAA,OAAO,CAAC,KAAK,SAAN,CAAP;AACH,OA7CD;AA8CH,KA/CM,CAAP;AAgDH;AAED;;;;;;;;;;AAQA,EAAA,cAAc,GAAA;AACV,WAAO,KAAK,SAAZ;AACH;AAED;;;;;;;;;;;;;AAWA,EAAA,kBAAkB,GAAA;AACd,WAAO,KAAK,mBAAL,EAAP;AACH;AAED;;;;;;;;;;AAQA,EAAA,mBAAmB,GAAA;AACf,WAAO,KAAK,SAAL,CAAe,MAAf,CAAuB,OAAD,IAAY;AACrC,aAAO,OAAO,CAAC,SAAR,KAAsB,KAAK,KAAL,CAAW,MAAxC;AACH,KAFM,CAAP;AAGH;AAED;;;;;;;;;;;;;AAWA,EAAA,uBAAuB,GAAA;AACnB,WAAO,KAAK,wBAAL,EAAP;AACH;AAED;;;;;;;;;;AAQA,EAAA,wBAAwB,GAAA;AACpB,WAAO,KAAK,SAAL,CAAe,MAAf,CAAuB,OAAD,IAAY;AACrC,aAAO,OAAO,CAAC,SAAR,KAAsB,KAAK,KAAL,CAAW,MAAxC;AACH,KAFM,CAAP;AAGH;AAGD;;;;;;;;;;AAQA,EAAA,qBAAqB,GAAA;AACjB,WAAO,KAAK,SAAL,CAAe,MAAf,CAAuB,OAAD,IAAY;AACrC,aAAO,OAAO,CAAC,OAAf;AACH,KAFM,CAAP;AAGH;AAED;;;;;;;;;;;;;;;;;AAeA,EAAA,uBAAuB,CAAC,OAAD,EAAU,OAAV,EAAmB,KAAnB,EAA0B,GAA1B,EAA+B,SAA/B,EAA0C,IAA1C,EAA8C;AACjE,WAAO,KAAK,UAAL,CAAgB,OAAhB,EAAyB,OAAzB,EAAkC,KAAlC,EAAyC,GAAzC,EAA8C,SAA9C,EAAyD,IAAzD,CAAP;AACH;AAED;;;;;;;;;;;;;;;;;AAeA,EAAA,UAAU,CAAC,OAAD,EAAU,OAAV,EAAmB,KAAnB,EAA0B,GAA1B,EAA+B,SAA/B,EAA0C,IAA1C,EAA8C;AACpD,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kDAA3C,EAA+F,OAA/F;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AACD,QAAI,CAAC,OAAL,EAAc;AACV,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8CAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gDAA3C,EAA6F,KAA7F;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,SAAS,IAAI,OAAO,SAAP,KAAqB,QAAlC,IAA8C,SAAS,CAAC,MAAV,GAAmB,CAArE,EAAwE;AACpE,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,oDAA3C,EAAiG,SAAjG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,IAAI,IAAI,CAAC,OAAD,EAAU,UAAV,EAAsB,MAAtB,EAA8B,MAA9B,EAAsC,OAAtC,CAA8C,IAA9C,MAAwD,CAAC,CAArE,EAAwE;AACpE,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,6CAAlC,EAAiF,IAAjF,EAAuF,sEAAvF;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAf,CAAP;AACH;;AAGD,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,MAAA,IAAI,GAAG,IAAI,GAAG,uBAAuB,IAA1B,GAAiC,yBAA5C;;AAEA,WAAK,KAAL,CAAW,cAAX,CAA0B,OAAO,CAAC,EAAlC,EAAsC,OAAtC,EAA+C,KAA/C,EAAsD,GAAtD,EAA2D,SAA3D,EAAsE,IAAtE,EAA4E,IAA5E,CAAkF,MAAD,IAAW;AACxF,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gCAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,mCAAtC,EAA2E,MAA3E;;AACA,QAAA,OAAO,CAAC,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,EAAhC,CAAP;AACH,OAJD,EAIG,KAJH,CAIU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,qBAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,uBAA3C,EAAoE,GAApE;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OARD;AASH,KAZM,CAAP;AAaH;AAED;;;;;;;;;;;;AAUA,EAAA,kBAAkB,CAAC,OAAD,EAAkB;AAChC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0DAA3C,EAAuG,OAAvG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,kBAAX,CAA8B,OAAO,CAAC,EAAtC,EAA0C,IAA1C,CAAgD,MAAD,IAAW;AACtD,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4CAAlC,EAAgF,MAAhF;;AAEA,aAAK,YAAL,CAAkB,OAAO,CAAC,EAA1B,EAA8B,IAA9B,EAAoC,IAApC,CAA0C,cAAD,IAAmB;AACxD,UAAA,OAAO,CAAC,cAAD,CAAP;AACH,SAFD;AAGH,OAND,EAMG,KANH,CAMU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,6BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,+BAA3C,EAA4E,GAA5E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAVD;AAWH,KAbM,CAAP;AAcH;AAED;;;;;;;;;;;;;AAWA,EAAA,sBAAsB,CAAE,EAAF,EAAI;AACtB,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,CAAC,EAAL,EAAS;AACL,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,mDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,qDAA3C,EAAkG,EAAlG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAa,CAAC,OAAD,EAAU,MAAV,KAAoB;AACpC,UAAI,OAAO,GAAG,IAAI,CAAC,mBAAL,CAAyB,EAAzB,CAAd;;AACA,UAAI,CAAC,OAAL,EAAc;AACV,QAAA,IAAI,CAAC,UAAL,CAAgB,EAAhB,EAAoB,IAApB,CAAyB,UAAU,YAAV,EAAsB;AAC3C,cAAI,YAAJ,EAAkB;AACd,YAAA,IAAI,CAAC,kBAAL,CAAwB,YAAxB,EACK,IADL,CACU,YAAA;AACF,cAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,oCAAnC,EAAyE,EAAzE;;AACA,cAAA,OAAO,CAAC;AACJ,gBAAA,IAAI,EAAE,IADF;AAEJ,gBAAA,KAAK,EAAE;AAFH,eAAD,CAAP;AAIH,aAPL,EAQK,KARL,CAQW,UAAU,GAAV,EAAa;AAChB,qBAAO,MAAM,CAAC,GAAD,CAAb;AACH,aAVL;AAWH,WAZD,MAYO;AACH,mBAAO,MAAM,CAAC;AACV,cAAA,IAAI,EAAE,iBADI;AAEV,cAAA,KAAK,EAAE,8BAA8B;AAF3B,aAAD,CAAb;AAIH;AACJ,SAnBD;AAoBH,OArBD,MAqBO;AACH,QAAA,IAAI,CAAC,kBAAL,CAAwB,OAAxB,EACK,IADL,CACU,YAAA;AACF,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,oCAAnC,EAAyE,EAAzE;;AACA,UAAA,OAAO,CAAC;AACJ,YAAA,IAAI,EAAE,IADF;AAEJ,YAAA,KAAK,EAAE;AAFH,WAAD,CAAP;AAIH,SAPL,EAQK,KARL,CAQW,UAAU,GAAV,EAAa;AAChB,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAVL;AAWH;AACJ,KApCM,CAAP;AAsCH;;AAED;;;;;;;;;;AAUA,EAAA,sBAAsB,CAAC,OAAD,EAAkB;AACpC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8DAA3C,EAA2G,OAA3G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,oBAAX,CAAgC,OAAO,CAAC,EAAxC,EAA4C,IAA5C,CAAkD,MAAD,IAAoB;AACjE,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kDAAlC,EAAsF,MAAtF;;AACA,QAAA,OAAO,CAAC,MAAD,CAAP;AACH,OAHD,EAGG,KAHH,CAGU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,iCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,mCAA3C,EAAgF,GAAhF;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAPD;AAQH,KAVM,CAAP;AAWH;AAED;;;;;;;;;;;;;AAWA,EAAA,kBAAkB,CAAE,OAAF,EAAW,WAAX,EAAsB;AACpC,WAAO,KAAK,wBAAL,CAA8B,OAA9B,EAAuC,WAAvC,CAAP;AACH;AAED;;;;;;;;;;;;;AAWA,EAAA,wBAAwB,CAAC,OAAD,EAAU,WAAV,EAAqB;AACzC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gEAA3C,EAA6G,OAA7G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,OAAO,CAAC,EAAb,EAAiB;AACb,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iEAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,mEAA3C,EAAgH,OAAO,CAAC,EAAxH;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,WAAL,EAAkB;AACd,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kEAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,oEAA3C,EAAiH,WAAjH;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,WAAK,KAAL,CAAW,aAAX,CAAyB,OAAO,CAAC,EAAjC,EAAqC,WAArC,EAAkD,IAAlD,EAAyD,IAAzD,EAAgE,IAAhE,EAAsE,IAAtE,EAA4E,IAA5E,EAAkF,IAAlF,CAAwF,cAAD,IAAyB;AAC5G,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4CAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,+CAAtC,EAAuF,cAAvF;;AAEA,YAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AACA;;;;AAIA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OAVD,EAUG,KAVH,CAUU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,mCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,qCAA3C,EAAkF,GAAlF;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAdD;AAeH,KAhBM,CAAP;AAiBH;AAED;;;;;;;;;;;;;;AAYA,EAAA,iBAAiB,CAAC,OAAD,EAAU,WAAV,EAAqB;AAClC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,uDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yDAA3C,EAAsG,OAAtG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,OAAO,CAAC,EAAb,EAAiB;AACb,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,4DAA3C,EAAyG,OAAO,CAAC,EAAjH;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,WAAL,EAAkB;AACd,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,2DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,6DAA3C,EAA0G,WAA1G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,aAAX,CAAyB,OAAO,CAAC,EAAjC,EAAqC,IAArC,EAA2C,IAA3C,EAAkD,IAAlD,EAAyD,IAAzD,EAA+D,WAA/D,EAA4E,IAA5E,EAAkF,IAAlF,CAAwF,cAAD,IAAyB;AAC5G,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sCAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wCAA3C,EAAqF,cAArF;;AAEA,YAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AAEA;;;;AAIA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OAXD,EAWG,KAXH,CAWU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8BAA3C,EAA2E,GAA3E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAfD;AAgBH,KAlBM,CAAP;AAmBH;;AAED;;;;;;;;;;;;;;;;;;;AAmBA,EAAA,aAAa,CAAE,EAAF,EAAM,YAAN,EAAoB,UAApB,EAAgC,SAAhC,EAA2C,gBAA3C,EAA6D,WAA7D,EAA0E,QAA1E,EAAkF;AAC3F,QAAI,IAAI,GAAG,IAAX;;AAEA,QAAI,CAAC,EAAL,EAAS;AACL,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8CAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gDAA3C,EAA6F,EAA7F;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH,KAJD,MAIO;AACH,UAAI,OAAO,GAAS,EAApB;;AACA,UAAI,YAAY,IAAI,IAApB,EAA0B;AACtB,QAAA,OAAO,CAAC,KAAR,GAAgB,YAAhB;AACH;;AACD,UAAI,UAAU,IAAI,IAAlB,EAAwB;AACpB,QAAA,OAAO,CAAC,IAAR,GAAe,UAAU,KAAK,SAAf,GAA2B,gBAA3B,GAA8C,gBAA7D;AACH;;AACD,UAAI,SAAS,IAAI,IAAjB,EAAuB;AACnB,QAAA,OAAO,CAAC,SAAR,GAAoB,SAApB;AACH;;AACD,UAAI,gBAAgB,IAAI,IAAxB,EAA8B;AAC1B,QAAA,OAAO,CAAC,gBAAR,GAA2B,gBAA3B;AACH;;AACD,UAAI,WAAW,IAAI,IAAnB,EAAyB;AACrB,QAAA,OAAO,CAAC,IAAR,GAAe,WAAf;AACH;;AACD,UAAI,QAAQ,IAAI,IAAhB,EAAsB;AAClB,QAAA,OAAO,CAAC,QAAR,GAAmB,QAAnB;AACH;;AAED,aAAQ,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEpC,QAAA,IAAI,CAAC,KAAL,CAAW,aAAX,CAAyB,EAAzB,EAA6B,OAAO,CAAC,KAArC,EAA4C,IAA5C,EAAkD,OAAO,CAAC,SAA1D,EAAqE,OAAO,CAAC,gBAA7E,EAA+F,OAAO,CAAC,IAAvG,EAA6G,OAAO,CAAC,IAArH,EACK,IADL,CACW,cAAD,IAAmB;AACrB,eAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,2CAAtC,EAAmF,cAAnF;;AACA,cAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;;AAEA,eAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,gDAAtC,EAAwF,UAAxF;;AACA,UAAA,OAAO,CAAC,UAAD,CAAP;AACH,SAPL,EAQK,KARL,CAQW,UAAU,GAAV,EAAa;AAChB,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAVL;AAWH,OAbO,CAAR;AAcH;AAEJ;;AAED;;;;;;;;;;;;AAYA,EAAA,uBAAuB,CAAC,OAAD,EAAU,UAAV,EAAoB;AACvC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,6DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,+DAA3C,EAA4G,OAA5G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,OAAO,CAAC,EAAb,EAAiB;AACb,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gEAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kEAA3C,EAA+G,OAAO,CAAC,EAAvH;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,UAAL,EAAiB;AACb,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gEAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kEAA3C,EAA+G,UAA/G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,IAAI,GAAG,UAAU,KAAK,SAAf,GAA2B,gBAA3B,GAA8C,gBAAzD;AACA,QAAI,IAAI,GAAG,OAAO,CAAC,IAAnB;AAEA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,aAAX,CAAyB,OAAO,CAAC,EAAjC,EAAqC,IAArC,EAA2C,IAA3C,EAAkD,IAAlD,EAAyD,IAAzD,EAA+D,IAA/D,EAAqE,IAArE,EAA2E,IAA3E,CAAiF,cAAD,IAAyB;AACrG,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,8CAAtC,EAAsF,cAAtF;;AAEA,YAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AAEA;;;;;AAIA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,8CAAtC,EAAsF,UAAtF;;AAEA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OAZD,EAYG,KAZH,CAYU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,kCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,oCAA3C,EAAiF,GAAjF;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAhBD;AAiBH,KAnBM,CAAP;AAoBH;;AAED;;;;;;;;;;;AAWO,EAAA,+BAA+B,CAAC,OAAD,EAAQ;AAC1C,WAAO,KAAK,uBAAL,CAA6B,OAA7B,EAAsC,SAAtC,CAAP;AACH;AAED;;;;;;;;;;;;;AAWO,EAAA,+BAA+B,CAAC,OAAD,EAAQ;AAC1C;AACA,WAAO,KAAK,uBAAL,CAA6B,OAA7B,EAAsC,QAAtC,CAAP;AACH;AAED;;;;;;;;;;;;;;AAYA,EAAA,mBAAmB,CAAE,OAAF,EAAW,SAAX,EAAoB;AACnC,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,yDAAlC;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,2DAA3C,EAAwG,OAAxG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH,KAJD,MAIO,IAAI,CAAC,SAAL,EAAgB;AACnB,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,2DAAlC;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,6DAA3C,EAA0G,SAA1G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH,KAJM,MAIA;AACH,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,YAAI;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,kCAAtC,EAA0E,OAA1E;;AACA,cAAI,EAAE,GAAG,OAAO,CAAC,EAAjB;AACA,cAAI,SAAS,GAAG,EAAE,CAAC,QAAH,CAAY,SAAZ,CAAhB;AACA,cAAI,EAAE,GAAG,EAAE,CAAC,QAAH,CAAY,SAAZ,EAAuB,IAAvB,CAAT;AACA,cAAI,GAAG,GAAG,IAAI,MAAJ,CAAW,SAAS,CAAC,IAArB,CAAV;AACA,UAAA,EAAE,CAAC,QAAH,CAAY,EAAZ,EAAgB,GAAhB,EAAqB,CAArB,EAAwB,SAAS,CAAC,IAAlC,EAAwC,IAAxC;AACA,cAAI,QAAQ,GAAG,SAAS,CAAC,MAAV,CAAiB,SAAjB,CAAf;;AAEA,UAAA,IAAI,CAAC,KAAL,CAAW,mBAAX,CAA+B,EAA/B,EAAmC,GAAnC,EAAwC,SAAS,CAAC;AAAI;AAAtD,YAA6F,QAA7F,EAAuG,IAAvG,CAA4G,YAAA;AACxG,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,kCAAtC,EAA0E,OAA1E;;AACA,YAAA,OAAO,CAAC;AACJ,cAAA,IAAI,EAAE,IADF;AAEJ,cAAA,KAAK,EAAE;AAFH,aAAD,CAAP;AAIH,WAND,EAMG,KANH,CAMS,UAAU,GAAV,EAAa;AAClB,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,wCAAnC;;AACA,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wCAA3C,EAAqF,GAArF,EAA2F,kBAA3F,EAA+G,OAA/G;;AACA,mBAAO,MAAM,CAAC,GAAD,CAAb;AACH,WAVD;AAWH,SApBD,CAoBE,OAAO,IAAP,EAAa;AACX,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,wCAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wCAA3C,EAAqF,IAArF,EAA4F,kBAA5F,EAAgH,OAAhH;;AACA,iBAAO,MAAM,CAAC,IAAD,CAAb;AACH;AACJ,OA1BM,CAAP;AA2BH;AACJ;;AAED;;;;;;;;;;;AAWA,EAAA,mBAAmB,CAAC,OAAD,EAAQ;AACvB,QAAI,IAAI,GAAG,IAAX;;AACA,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,yDAAlC;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,2DAA3C,EAAwG,OAAxG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH,KAJD,MAIO;AACH,aAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,YAAI,EAAE,GAAG,OAAO,CAAC,EAAjB;;AACA,QAAA,IAAI,CAAC,KAAL,CAAW,mBAAX,CAA+B,EAA/B,EACK,IADL,CACU,YAAA;AACF,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,kCAAtC,EAA0E,OAA1E;;AACA,UAAA,OAAO,CAAC;AACJ,YAAA,IAAI,EAAE,IADF;AAEJ,YAAA,KAAK,EAAE;AAFH,WAAD,CAAP;AAIH,SAPL,EAQK,KARL,CAQW,UAAU,GAAV,EAAa;AAChB,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAVL;AAWH,OAbM,CAAP;AAcH;AACJ;;AAED;;;;;;;;;;;;;;;;;;AAkBA,EAAA,mBAAmB,CAAC,OAAD,EAAU,OAAV,EAAiB;AAChC,WAAO,KAAK,iBAAL,CAAuB,OAAvB,EAAgC,OAAhC,CAAP;AACH;AAED;;;;;;;;;;;;;;;;;AAeO,EAAA,iBAAiB,CAAC,OAAD,EAAU,OAAV,EAAiB;AACrC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yDAA3C,EAAsG,OAAtG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,IAAI,GAAG;AACP,eAAS,GADF;AAEP,cAAQ,IAFD;AAGP,cAAQ;AAHD,KAAX;;AAMA,QAAI,OAAJ,EAAa;AACT,UAAI,UAAU,OAAd,EAAuB;AACnB,QAAA,IAAI,CAAC,IAAL,GAAY,MAAM,CAAC,OAAO,CAAC,IAAT,CAAlB;AACH;;AAED,UAAI,WAAW,OAAf,EAAwB;AACpB,QAAA,IAAI,CAAC,KAAL,GAAa,MAAM,CAAC,OAAO,CAAC,KAAT,CAAnB;AACH;;AAED,UAAI,oBAAoB,OAApB,IAA+B,OAAO,CAAC,cAA3C,EAA2D;AACvD,QAAA,IAAI,CAAC,IAAL,GAAY,WAAZ;AACH;;AAED,UAAI,gBAAgB,OAAhB,IAA2B,OAAO,CAAC,UAAvC,EAAmD;AAC/C,QAAA,IAAI,CAAC,IAAL,GAAY,OAAZ;AACH;AACJ;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,eAAX,CAA2B,OAAO,CAAC,EAAnC,EAAuC,IAAvC,EAA6C,IAA7C,CAAmD,KAAD,IAAe;AAC7D,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wCAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,0CAAtC,EAAkF,KAAK,CAAC,MAAxF;;AACA,QAAA,OAAO,CAAC,KAAD,CAAP;AACH,OAJD,EAIG,KAJH,CAIU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8BAA3C,EAA2E,GAA3E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OARD;AASH,KAXM,CAAP;AAYH;AAED;;;;;;;;;;;;;;;AAaA,EAAA,yBAAyB,CAAC,OAAD,EAAQ;AAC7B,WAAO,KAAK,yBAAL,CAA+B,OAA/B,CAAP;AACH;AACD;;;;;;;;;;;;AAUO,EAAA,yBAAyB,CAAC,OAAD,EAAQ;AACpC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iEAA3C,EAA8G,OAA9G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEnC,WAAK,KAAL,CAAW,yBAAX,CAAqC,OAAO,CAAC,EAA7C,EAAiD,IAAjD,CAAuD,MAAD,IAAW;AAC7D,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,oDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,uDAAtC,EAA+F,MAA/F;;AAEA,aAAK,KAAL,CAAW,UAAX,CAAsB,OAAO,CAAC,EAA9B,EAAkC,IAAlC,CAAwC,cAAD,IAAyB;AAC5D;AACA,cAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AACA;;;;;AAIA,UAAA,OAAO,CAAC,UAAD,CAAP;AACH,SARD;AAUH,OAdD,EAcG,KAdH,CAcU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,oCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,sCAA3C,EAAmF,GAAnF;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAlBD;AAmBH,KArBM,CAAP;AAsBH;AAED;;;;;;;;;;;;;AAWO,EAAA,kBAAkB,CAAC,OAAD,EAAU,KAAV,EAAe;AACpC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,uDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0DAA3C,EAAuG,OAAvG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,SAAS,GAAG,OAAO,CAAC,EAAxB;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC;AACA,WAAK,KAAL,CAAW,kBAAX,CAA8B,SAA9B,EAAyC,KAAzC,EAAgD,IAAhD,CAAsD,GAAD,IAAQ;AACzD,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4CAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,+CAAtC,EAAuF,GAAvF;;AAEA,aAAK,KAAL,CAAW,UAAX,CAAsB,SAAtB,EAAiC,IAAjC,CAAuC,cAAD,IAAyB;AAC3D;AACA,cAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AAEA;;;;;AAIA,eAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,yCAAtC,EAAiF,UAAjF;;AACA,UAAA,OAAO,CAAC,UAAD,CAAP;AACH,SAVD;AAWH,OAfD,EAeG,KAfH,CAeU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,6BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,+BAA3C,EAA4E,GAA5E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAnBD;AAoBH,KAtBM,CAAP;AAuBH;AAGD;;;;;;;;;;;;;AAWO,EAAA,kBAAkB,CAAC,OAAD,EAAoB,MAApB,EAA0B;AAC/C,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,uDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0DAA3C,EAAuG,OAAvG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,MAAL,EAAa;AACT,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yDAA3C,EAAsG,MAAtG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,OAAO,GAAG,EAAd;AAEA,IAAA,MAAM,CAAC,OAAP,CAAgB,IAAD,IAAS;AACpB,MAAA,OAAO,CAAC,IAAR,CAAa;AAAC,cAAM,IAAI,CAAC,EAAZ;AAAgB,gBAAQ;AAAxB,OAAb;AACH,KAFD;AAIA,QAAI,OAAO,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAd;AACA,WAAO,OAAP;AACH;AAED;;;;;;;;;;;;;AAWO,EAAA,sBAAsB,CAAC,OAAD,EAAoB,UAApB,EAA8B;AACvD,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA8B;AAC1B,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,2DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8DAA3C,EAA2G,OAA3G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,UAAD,IAAe,EAAE,UAAU,CAAC,MAAX,GAAoB,CAAtB,CAAnB,EAA6C;AACzC,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iEAA3C,EAA8G,UAA9G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,OAAO,GAAG,EAAd;AAEA,IAAA,UAAU,CAAC,OAAX,CAAoB,IAAD,IAAS;AACxB,MAAA,OAAO,CAAC,IAAR,CAAa;AAAC,cAAM,IAAI,CAAC,EAAZ;AAAgB,gBAAQ;AAAxB,OAAb;AACH,KAFD;AAIA,QAAI,OAAO,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAd;AACA,WAAO,OAAP;AACH;AAED;;;;;;;;;;;;;AAWa,EAAA,mBAAmB,CAAC,OAAD,EAAU,OAAV,EAAiB;;AAC7C;AACA,UAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,2DAA3C,EAAwG,OAAxG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,UAAI,CAAC,OAAL,EAAc;AACV,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,2DAA3C,EAAwG,OAAxG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,UAAI,OAAO,GAAe,EAA1B;AAEA,MAAA,OAAO,CAAC,OAAR,CAAiB,IAAD,IAAS;AACrB,YAAI,IAAJ,EAAU;AACN,UAAA,OAAO,CAAC,IAAR,CAAa;AAAC,kBAAM,IAAI,CAAC,EAAZ;AAAgB,oBAAQ;AAAxB,WAAb;AACH;AACJ,OAJD;;AAMA,UAAI,EAAE,OAAO,CAAC,MAAR,GAAiB,CAAnB,CAAJ,EAA2B;AACvB,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,2DAA3C,EAAwG,OAAxG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,UAAI,OAAO,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAd;AACA,aAAO,OAAP;AACH,K;AAAA;AAED;;;;;;;;;;;;;;;;AAcA,EAAA,uBAAuB,CAAC,OAAD,EAAU,KAAV,EAAe;AAClC,WAAO,KAAK,sBAAL,CAA4B,OAA5B,EAAqC,KAArC,CAAP;AACH;AACD;;;;;;;;;;;;;AAWO,EAAA,sBAAsB,CAAC,OAAD,EAAoB,KAApB,EAAyB;AAClD,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,2DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8DAA3C,EAA2G,OAA3G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,KAAL,EAAY;AACR,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iEAA3C,EAA8G,KAA9G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,OAAO,GAAG,EAAd;AAEA,IAAA,KAAK,CAAC,OAAN,CAAe,IAAD,IAAS;AACnB,MAAA,OAAO,CAAC,IAAR,CAAa;AAAC,cAAM,IAAI,CAAC,EAAZ;AAAgB,gBAAQ;AAAxB,OAAb;AACH,KAFD;AAIA,QAAI,OAAO,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAd;AACA,WAAO,OAAP;AACH;AAED;;;;;;;;;;;;;;;AAaA,EAAA,sBAAsB,CAAE,OAAF,EAAS;AAC3B,WAAO,KAAK,iBAAL,CAAuB,OAAvB,CAAP;AACH;AAED;;;;;;;;;;;;AAUO,EAAA,iBAAiB,CAAE,OAAF,EAAmB;AACvC,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,EAAzB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,yDAA3C,EAAsG,OAAtG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAa,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEpC,WAAK,KAAL,CAAW,kBAAX,CAA8B,OAAO,CAAC,EAAtC,EAA0C,IAA1C,CAAgD,GAAD,IAAc;AACzD,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wCAAlC,EAA4E,GAA5E;;AAEA,YAAI,QAAQ,GAAG,GAAG,CAAC,KAAnB;AAEA,YAAI,cAAc,GAAG,EAArB;AACA,QAAA,QAAQ,CAAC,OAAT,CAAkB,IAAD,IAAS;AACtB,cAAI,OAAO,GAAG;AACV,YAAA,EAAE,EAAE,IAAI,CAAC,IAAL,CAAU,CAAV,CAAY,EAAZ,GAAiB,IAAI,CAAC,IAAL,CAAU,CAAV,CAAY,EAA7B,GAAkC,EAD5B;AAEV,YAAA,KAAK,EAAE,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,KAAhB,GAAwB,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,KAAxC,GAAgD,EAF7C;AAGV,YAAA,OAAO,EAAE,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,OAAhB,GAA0B,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,OAA1C,GAAoD,EAHnD;AAIV,YAAA,GAAG,EAAE,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,GAAhB,GAAsB,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,GAAtC,GAA4C,EAJvC;AAKV,YAAA,MAAM,EAAE;AALE,WAAd;;AAQA,cAAI,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,MAA9B,CAAJ,EAA2C;AACvC,YAAA,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,MAAhB,CAAuB,OAAvB,CAAgC,KAAD,IAAU;AACrC,cAAA,OAAO,CAAC,MAAR,CAAe,IAAf,CAAoB,KAAK,CAAC,EAA1B;AACH,aAFD;AAGH,WAJD,MAIO;AACH;AACI,gBAAI,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,MAApB,EAA4B;AACxB,cAAA,OAAO,CAAC,MAAR,CAAe,IAAf,CAAoB,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,MAAhB,CAAuB,EAA3C;AACH;AACR;;AACD,UAAA,cAAc,CAAC,IAAf,CAAoB,OAApB;AACH,SApBD;AAqBA,QAAA,OAAO,CAAC,cAAD,CAAP;AACH,OA5BD,EA4BG,KA5BH,CA4BU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4BAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8BAA3C,EAA2E,GAA3E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OAhCD;AAiCH,KAnCM,CAAP;AAoCH;AAED;;;;;;;;;;;;;;;;AAcA,EAAA,wBAAwB,CAAC,SAAD,EAAY,SAAZ,EAAqB;AACzC,WAAO,KAAK,qBAAL,CAA2B,SAA3B,EAAsC,SAAtC,CAAP;AACH;AAED;;;;;;;;;;;;;AAWO,EAAA,qBAAqB,CAAE,SAAF,EAAa,MAAb,EAAmB;AAC3C,QAAI,CAAC,SAAL,EAAiB;AACb,WAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4DAAnC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,+DAA3C,EAA4G,SAA5G;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,QAAI,CAAC,MAAL,EAAa;AACT,WAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,yDAAnC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,4DAA3C,EAAyG,MAAzG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,CAAP;AACH;;AAED,WAAO,IAAI,OAAJ,CAAa,CAAC,OAAD,EAAU,MAAV,KAAoB;AAEpC,WAAK,KAAL,CAAW,oBAAX,CAAgC,SAAhC,EAA2C,MAA3C,EAAmD,IAAnD,CAAyD,MAAD,IAAW;AAC/D,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,qDAAtC,EAA6F,MAA7F;;AAEA,aAAK,KAAL,CAAW,UAAX,CAAsB,SAAtB,EAAiC,IAAjC,CAAuC,cAAD,IAAyB;AAC3D;AACA,cAAI,UAAU,GAAG,KAAK,yBAAL,CAA+B,cAA/B,CAAjB;AACA;;;;;AAIA,UAAA,OAAO,CAAC,UAAD,CAAP;AACH,SARD,EAQG,KARH,CAQU,GAAD,IAAQ;AACb,eAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,2CAAnC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,6CAA3C,EAA0F,GAA1F;;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SAZD;AAaH,OAjBD,EAiBG,KAjBH,CAiBU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,gCAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,kCAA3C,EAA+E,GAA/E;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OArBD;AAsBH,KAxBM,CAAP;AA0BH;;AAED,EAAA,yBAAyB,CAAC,OAAD,EAAQ;AAE7B,SAAK,YAAL,CAAkB,OAAO,CAAC,SAA1B,EAAqC,IAArC,CAA2C,OAAD,IAAY;AAClD,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAlB;AACA,aAAO,OAAO,CAAC,SAAf;;AACA,WAAK,aAAL,CAAmB,IAAnB,CAAwB,qCAAxB,EAA+D,OAA/D;AACH,KAJD;AAKH;AAED;;;;;;;;AAMO,EAAA,UAAU,CAAC,SAAD,EAAkB;AAC/B,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,WAAK,KAAL,CAAW,UAAX,CAAsB,SAAtB,EAAiC,IAAjC,CAAuC,OAAD,IAAY;AAC9C,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0CAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,6CAAtC,EAAqF,OAArF;;AACA,YAAI,UAAU,GAAa,SAAA,CAAA,OAAA,CAAQ,cAAR,GAAyB,OAAzB,EAAkC,KAAK,KAAL,CAAW,IAAX,CAAgB,SAAlD,CAA3B;AACA,QAAA,OAAO,CAAC,UAAD,CAAP;AACH,OALD,EAKG,KALH,CAKU,GAAD,IAAQ;AACb,aAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,qBAAnC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,uBAA3C,EAAoE,GAApE;;AACA,eAAO,MAAM,CAAC,GAAD,CAAb;AACH,OATD;AAUH,KAXM,CAAP;AAYH;;AAED;;;;;;AAMQ,EAAA,mBAAmB,CAAC,SAAD,EAAkB;AACzC,QAAI,YAAY,GAAG,IAAnB;;AACA,SAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,oCAAtC,EAA4E,SAA5E;;AAEA,QAAI,KAAK,SAAT,EAAoB;AAChB,UAAI,iBAAiB,GAAG,KAAK,SAAL,CAAe,SAAf,CAA0B,OAAD,IAAY;AACzD,eAAO,OAAO,CAAC,EAAR,KAAe,SAAtB;AACH,OAFuB,CAAxB;;AAGA,UAAI,iBAAiB,IAAI,CAAC,CAA1B,EAA6B;AACzB,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,wCAAtC,EAAgF,KAAK,SAAL,CAAe,iBAAf,CAAhF,EAAmH,aAAnH,EAAkI,SAAlI;;AACA,eAAO,KAAK,SAAL,CAAe,iBAAf,CAAP;AACH;AACJ;;AACD,SAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,wCAAtC,EAAgF,YAAhF,EAA8F,aAA9F,EAA6G,SAA7G;;AACA,WAAO,YAAP;AACH;;AAEO,EAAA,kBAAkB,GAAA;AACtB;AACA,SAAK,aAAL,GAAqB,KAAK,SAAL,CAAe,GAAf,CAAoB,IAAD,IAAS;AAAG,aAAO,IAAI,CAAC,EAAZ;AAAiB,KAAhD,CAArB;;AACA,SAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,4CAAtC,EAAoF,KAAK,aAAzF;AACH;;AAEO,EAAA,yBAAyB,CAAC,OAAD,EAAa;AAC1C,QAAI,UAAU,GAAa,SAAA,CAAA,OAAA,CAAQ,cAAR,GAAyB,OAAzB,EAAkC,KAAK,KAAL,CAAW,IAAX,CAAgB,SAAlD,CAA3B;;AACA,QAAI,iBAAiB,GAAG,KAAK,SAAL,CAAe,SAAf,CAA0B,WAAD,IAAgB;AAC7D,aAAO,WAAW,CAAC,EAAZ,KAAmB,OAAO,CAAC,EAAlC;AACH,KAFuB,CAAxB;;AAGA,QAAI,iBAAiB,IAAI,CAAC,CAA1B,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,6DAAtC,EAAqG,OAArG,EAA8G,2BAA9G,EAA2I,iBAA3I,EADyB,CAEzB;AACA;;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,yDAAtC,EAAiG,KAAK,SAAtG;;AACA,WAAK,SAAL,CAAe,iBAAf,EAAkC,aAAlC,CAAgD,OAAhD;;AACA,MAAA,UAAU,GAAG,KAAK,SAAL,CAAe,iBAAf,CAAb;AACH,KAPD,MAOO;AACH,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,wDAAtC,EAAgG,UAAhG;;AACA,WAAK,SAAL,CAAe,IAAf,CAAoB,UAApB;AACH;;AACD,SAAK,kBAAL;AACA,WAAO,UAAP;AACH;;AAEO,EAAA,sBAAsB,CAAC,SAAD,EAAkB;AAC5C,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC;AACA,UAAI,eAAe,GAAG,KAAK,mBAAL,CAAyB,SAAzB,CAAtB;;AACA,UAAI,eAAJ,EAAqB;AACjB;AACA;AAEA;AACA,YAAI,eAAe,CAAC,OAApB,EAA6B;AAAE,eAAK,0BAAL;AAAoC,SALlD,CAOjB;;;AACA,YAAI,SAAS,GAAG,eAAe,CAAC,EAAhC;;AAEA,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,yDAAtC,EAAiG,SAAjG;;AACA,aAAK,SAAL,GAAiB,KAAK,SAAL,CAAe,MAAf,CAAuB,UAAS,IAAT,EAAa;AACjD,iBAAO,EAAE,IAAI,CAAC,EAAL,KAAY,SAAd,CAAP;AACH,SAFgB,CAAjB;AAIA,aAAK,kBAAL,GAfiB,CAiBjB;AACA;;AACA,aAAK,eAAL,GACK,IADL,CACU,MAAK;AAAG,UAAA,OAAO,CAAC,eAAD,CAAP;AAA2B,SAD7C,EAEK,KAFL,CAEY,GAAD,IAAQ;AACX,eAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,iDAAnC;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,mDAA3C,EAAgG,GAAhG;;AACA,iBAAO,MAAM,CAAC,GAAD,CAAb;AACH,SANL;AAOH,OA1BD,MA0BO;AACH,QAAA,OAAO,CAAC,IAAD,CAAP;AACH;AACJ,KAhCM,CAAP;AAiCH;;AAEM,EAAA,eAAe,CAAC,UAAA,GAAmB,IAApB,EAAwB;AAC1C,WAAO,KAAK,KAAL,CAAW,iBAAX,CAA6B,EAA7B,EAAiC,UAAjC,EAA6C,IAA7C,EAAmD,IAAnD,CAAyD,QAAD,IAAkB;AAC7E;AACA,aAAO,QAAQ,CAAC,MAAhB;AACH,KAHM,CAAP;AAIH;;AAEM,EAAA,0BAA0B,GAAA;AAAK,SAAK,iBAAL,IAA0B,CAA1B;AAA8B;;AAC7D,EAAA,0BAA0B,GAAA;AAAK,SAAK,iBAAL,IAA0B,CAA1B;AAA8B;AAGpE;;AACA;;AACA;;;AACQ,EAAA,cAAc,CAAC,SAAD,EAAoB,MAApB,EAA+B;AACjD;;;;;;;;;;;;AAaH;;AAEO,EAAA,iBAAiB,CAAC,WAAD,EAAyB;AAC9C,QAAI,IAAI,GAAG,IAAX;AACA,QAAI,SAAS,GAAG,WAAW,CAAC,EAA5B;;AAEA,SAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,kCAAnC,EAAuE,SAAvE,EAJ8C,CAK9C;AACA;AAEA;;;AACA,SAAK,UAAL,CAAgB,SAAhB,EACK,IADL,CACW,UAAD,IAAe;AACb,UAAI,UAAU,GAAa,KAAK,yBAAL,CAA+B,UAA/B,CAA3B;AACJ;;;;;;AAKI,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,cAAM,UAAU,CAAC,EAAlB;AAAsB,gBAAS,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,IAAxD;AAA8D,iBAAU,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB;AAAjG,OAAvD,EAPa,CAQjB;;AACH,KAVL;AAWH;;AAEO,EAAA,cAAc,CAAC,WAAD,EAAyB;AAC3C,QAAI,IAAI,GAAG,IAAX;AACA,QAAI,SAAS,GAAG,WAAW,CAAC,EAA5B;;AACA,SAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,+BAAnC,EAAoE,SAApE,EAH2C,CAI3C;AAEA;;;AACA,QAAI,OAAO,GAAG,KAAK,mBAAL,CAAyB,SAAzB,CAAd,CAP2C,CAS3C;;AACA,SAAK,UAAL,CAAgB,SAAhB,EACK,IADL,CACW,UAAD,IAAe;AAEjB;AACA,UAAI,CAAC,OAAD,IAAY,CAAC,UAAU,CAAC,OAA5B,EAAqC;AACjC,YAAI,UAAU,GAAa,KAAK,yBAAL,CAA+B,UAA/B,CAA3B,CADiC,CAEjC;AACA;;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,gBAAM,UAAU,CAAC,EAAlB;AAAsB,kBAAS,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,IAAxD;AAA8D,mBAAU,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB;AAAjG,SAAvD;AACH,OALD,CAOA;AAPA,WAQK,IAAI,CAAC,OAAD,IAAY,UAAU,CAAC,OAA3B,EAAoC;AACrC,cAAI,UAAU,GAAa,KAAK,yBAAL,CAA+B,UAA/B,CAA3B;AACA,eAAK,0BAAL,GAFqC,CAGrC;;AACA,UAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,kBAAM,UAAU,CAAC,EAAlB;AAAsB,oBAAS,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B,IAA9D;AAAoE,qBAAU,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B;AAA7G,WAAvD,EAJqC,CAKrC;;AACH,SANI,CAQL;AARK,aASA,IAAI,OAAO,IAAI,UAAU,CAAC,QAAX,KAAwB,KAAK,SAAL,CAAe,IAAtD,EAA4D;AAC7D,YAAA,OAAO,CAAC,QAAR,GAAmB,UAAU,CAAC,QAA9B,CAD6D,CAE7D;;AACA,iBAAK,eAAL,GACK,IADL,CACU,MAAK;AACP;AACA,cAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,sBAAM,SAAP;AAAkB,wBAAS,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B,IAA1D;AAAgE,yBAAU,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B;AAAzG,eAAvD,EAFO,CAGP;;AACH,aALL;AAMH;AAEJ,KAhCL;AAiCH;;AAEa,EAAA,oBAAoB,CAAC,WAAD,EAA4B;;AAC1D,UAAI,IAAI,GAAG,IAAX;AACA,UAAI,SAAS,GAAG,WAAW,CAAC,EAA5B;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,qCAAnC,EAA0E,SAA1E;;AACA,UAAI,cAAc,GAAG,MAAM,IAAI,CAAC,sBAAL,CAA4B,SAA5B,CAA3B;AACA,UAAI,gBAAgB,GAAG,cAAc,GAAG,cAAc,CAAC,EAAlB,GAAuB,WAAW,CAAC,EAAxE;;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,cAAM,gBAAP;AAAyB,gBAAS,IAAI,CAAC,eAAL,CAAqB,MAArB,CAA4B,IAA9D;AAAoE,iBAAU,IAAI,CAAC,eAAL,CAAqB,MAArB,CAA4B;AAA1G,OAAvD,E,CACA;;AACH,K;AAAA;;AAEO,EAAA,oBAAoB,CAAC,WAAD,EAAoD;AAC5E,QAAI,IAAI,GAAG,IAAX;AACA,QAAI,SAAS,GAAW,WAAW,CAAC,EAApC;AACA,QAAI,eAAe,GAAW,WAAW,CAAC,WAA1C;;AACA,SAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,qCAAtC,EAA6E,SAA7E,EAAwF,sBAAxF,EAAgH,eAAhH,EAJ4E,CAK5E;;;AACA,QAAI,OAAO,GAAG,KAAK,mBAAL,CAAyB,SAAzB,CAAd;AACA,QAAI,WAAW,GAAG,MAAM,CAAC,QAAP,CAAgB,eAAhB,CAAlB;;AACA,QAAI,OAAJ,EAAa;AACT,MAAA,OAAO,CAAC,OAAR,GAAkB,KAAlB;AACA,MAAA,OAAO,CAAC,UAAR,GAAqB,IAArB;AACA,MAAA,OAAO,CAAC,iBAAR,GAA4B,WAA5B,CAHS,CAIT;;AACA,WAAK,eAAL,GACK,IADL,CACU,MAAK;AACP,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,gBAAM,SAAP;AAAkB,kBAAS,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B,IAA1D;AAAgE,mBAAU,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B;AAAzG,SAAvD,EADO,CAEP;;AACH,OAJL;AAKH,KAVD,CAYA;AAZA,SAaK;AACD,aAAK,UAAL,CAAgB,SAAhB,EACK,IADL,CACW,UAAD,IAAe;AACrB,cAAI,UAAU,GAAa,KAAK,yBAAL,CAA+B,UAA/B,CAA3B,CADqB,CAEjB;;AACA,iBAAO,KAAK,eAAL,EAAP;AACH,SALL,EAMK,IANL,CAMU,MAAK;AACP,UAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,kBAAM,SAAP;AAAkB,oBAAS,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B,IAA1D;AAAgE,qBAAU,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B;AAAzG,WAAvD,EADO,CAEP;;AACH,SATL;AAUH;AACJ;;AAEa,EAAA,sBAAsB,CAAC,WAAD,EAAoD;;AACpF,UAAI,IAAI,GAAG,IAAX;AACA,UAAI,SAAS,GAAW,WAAW,CAAC,EAApC;AACA,UAAI,eAAe,GAAW,WAAW,CAAC,WAA1C;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,uCAAtC,EAA+E,SAA/E,EAA0F,sBAA1F,EAAkH,eAAlH;;AACA,UAAI,WAAW,GAAG,MAAM,CAAC,QAAP,CAAgB,eAAhB,CAAlB;AACA,UAAI,OAAO,GAAc,MAAM,KAAK,YAAL,CAAkB,SAAlB,CAA/B;;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,OAAO,CAAC,iBAAR,GAA4B,WAA5B;AACA,QAAA,OAAO,CAAC,UAAR,GAAqB,KAArB;AACH,O,CAED;AACA;;;AACA,WAAK,eAAL,GAAuB,IAAvB,CAA4B,MAAK;AAC7B,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,gBAAM,SAAP;AAAkB,kBAAS,IAAI,CAAC,eAAL,CAAqB,WAArB,CAAiC,IAA5D;AAAkE,mBAAU,IAAI,CAAC,eAAL,CAAqB,WAArB,CAAiC;AAA7G,SAAvD,EAD6B,CAE7B;;AACH,OAHD;AAIH,K;AAAA;;AAEa,EAAA,eAAe,CAAC,WAAD,EAA4B;;AACrD,UAAI,IAAI,GAAG,IAAX;AACA,UAAI,SAAS,GAAW,WAAW,CAAC,EAApC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,gCAAnC,EAAqE,SAArE;;AACA,UAAI,cAAc,GAAG,MAAM,IAAI,CAAC,sBAAL,CAA4B,SAA5B,CAA3B;AACA,UAAI,gBAAgB,GAAG,cAAc,GAAG,cAAc,CAAC,EAAlB,GAAuB,WAAW,CAAC,EAAxE;;AAEA,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,6BAAxB,EAAuD;AAAC,cAAM,gBAAP;AAAyB,gBAAS,IAAI,CAAC,eAAL,CAAqB,MAArB,CAA4B,IAA9D;AAAoE,iBAAU,IAAI,CAAC,eAAL,CAAqB,MAArB,CAA4B;AAA1G,OAAvD,E,CACQ;;AACX,K;AAAA;;AAEa,EAAA,oBAAoB,CAAC,IAAD,EAA2D;;AACzF,UAAI,IAAI,GAAG,IAAX;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,qCAAtC,EAA6E,IAAI,CAAC,EAAlF,EAAsF,sBAAtF,EAA8G,IAAI,CAAC,WAAnH;;AACA,UAAI,OAAO,GAAa,MAAM,KAAK,YAAL,CAAkB,IAAI,CAAC,EAAvB,CAA9B;;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,OAAO,CAAC,iBAAR,GAA4B,IAAI,CAAC,WAAjC;AACH;;AAED,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,sCAAxB,EAAgE;AAAC,cAAM,IAAI,CAAC,EAAZ;AAAgB,kBAAU,IAAI,CAAC,MAA/B;AAAuC,gBAAS,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B,IAA/E;AAAqF,iBAAU,IAAI,CAAC,eAAL,CAAqB,SAArB,CAA+B;AAA9H,OAAhE,E,CACA;;AACH,K;AAAA;;AAEa,EAAA,sBAAsB,CAAC,IAAD,EAA2D;;AAC3F,UAAI,IAAI,GAAG,IAAX;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,uCAAtC,EAA+E,IAAI,CAAC,EAApF,EAAwF,sBAAxF,EAAgH,IAAI,CAAC,WAArH;;AACA,UAAI,OAAO,GAAa,MAAM,KAAK,YAAL,CAAkB,IAAI,CAAC,EAAvB,CAA9B;;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,OAAO,CAAC,iBAAR,GAA4B,IAAI,CAAC,WAAjC;AACH;;AAED,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,sCAAxB,EAAgE;AAAC,cAAM,IAAI,CAAC,EAAZ;AAAgB,kBAAU,IAAI,CAAC,MAA/B;AAAuC,gBAAS,IAAI,CAAC,eAAL,CAAqB,WAArB,CAAiC,IAAjF;AAAuF,iBAAU,IAAI,CAAC,eAAL,CAAqB,WAArB,CAAiC;AAAlI,OAAhE,E,CACA;;AACH,K;AAAA;;AAz9DS,CAAd;AAAM,QAAQ,GAAA,UAAA,CAAA,CAfb,OAAA,CAAA,YAAA,CAAa,MAAb,CAea,EAdb,OAAA,CAAA,SAAA,CAAU,EAAV;AACD;;;;;;;;;;;;;AAac,CAAA,EAAR,QAAQ,CAAR;AAk+Dc,OAAA,CAAA,eAAA,GAAA,QAAA;AADpB,MAAM,CAAC,OAAP,CAAe,eAAf,GAAiC,QAAjC","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\nconst Channel_1 = require(\"../common/models/Channel\");\nconst channelEventHandler_1 = require(\"../connection/XMPPServiceHandler/channelEventHandler\");\nconst PubSub = require(\"pubsub-js\");\nconst fs = require(\"fs\");\nconst mimetypes = require(\"mime-types\");\nconst Utils_1 = require(\"../common/Utils\");\nconst LOG_ID = \"CHANNELS/SVCE - \";\nlet Channels = \n/**\n * @module\n * @name Channels\n * @version 1.67.1 \n * @public\n * @description\n *      This service manages Channels. This service is in Beta.\n *      <br><br>\n *      The main methods proposed in that module allow to: <br>\n *      - Create a new channel <br>\n *      - Manage a channel: update, delete <br>\n *      - Manage users in a channel <br>\n */\nclass Channels {\n    constructor(_eventEmitter, _logger, _startConfig) {\n        this.invitationCounter = 0;\n        this.ready = false;\n        this.LIST_EVENT_TYPE = {\n            ADD: { code: 0, label: \"ADD\" },\n            UPDATE: { code: 1, label: \"UPDATE\" },\n            REMOVE: { code: 2, label: \"REMOVE\" },\n            DELETE: { code: 3, label: \"DELETE\" },\n            SUBSCRIBE: { code: 4, label: \"SUBSCRIBE\" },\n            UNSUBSCRIBE: { code: 5, label: \"UNSUBSCRIBE\" },\n            CREATE: { code: 6, label: \"CREATE\" }\n        };\n        this.USER_ROLE = {\n            NONE: \"none\",\n            OWNER: \"owner\",\n            PUBLISHER: \"publisher\",\n            MEMBER: \"member\"\n        };\n        this._startConfig = _startConfig;\n        this._xmpp = null;\n        this._rest = null;\n        this._s2s = null;\n        this._options = {};\n        this._useXMPP = false;\n        this._useS2S = false;\n        this._channels = null;\n        this._channelsList = null;\n        this._eventEmitter = _eventEmitter;\n        this._logger = _logger;\n        this.MAX_ITEMS = 100;\n        this.MAX_PAYLOAD_SIZE = 60000;\n        this.PUBLIC_VISIBILITY = \"company\";\n        this.PRIVATE_VISIBILITY = \"private\";\n        this.CLOSED_VISIBILITY = \"closed\";\n        this.ready = false;\n        this._eventEmitter.on(\"evt_internal_channelitemreceived\", this._onChannelMessageReceived.bind(this));\n        this._eventEmitter.on(\"evt_internal_addtochannel\", this.onAddToChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_updatetochannel\", this.onUpdateToChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_removefromchannel\", this.onRemovedFromChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_subscribetochannel\", this.onSubscribeToChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_unsubscribetochannel\", this.onUnsubscribeToChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_deletechannel\", this.onDeleteChannel.bind(this));\n        this._eventEmitter.on(\"evt_internal_usersubscribechannel\", this.onUserSubscribeEvent.bind(this));\n        this._eventEmitter.on(\"evt_internal_userunsubscribechannel\", this.onUserUnsubscribeEvent.bind(this));\n    }\n    get startConfig() {\n        return this._startConfig;\n    }\n    start(_options, _core) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            try {\n                that._xmpp = _core._xmpp;\n                that._rest = _core._rest;\n                that._options = _options;\n                that._s2s = _core._s2s;\n                that._useXMPP = that._options.useXMPP;\n                that._useS2S = that._options.useS2S;\n                that._channels = [];\n                that._channelsList = [];\n                that.attachHandlers();\n                this.ready = true;\n                resolve();\n            }\n            catch (err) {\n                this._logger.log(\"error\", LOG_ID + \"(start) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(start) error : \", err);\n                return reject(err);\n            }\n        });\n    }\n    stop() {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            try {\n                this._xmpp = null;\n                this._rest = null;\n                this._channels = null;\n                this._channelsList = null;\n                //                this._eventEmitter.removeListener(\"rainbow_onchannelmessagereceived\", this._onChannelMessageReceived);\n                if (that.channelHandlerToken) {\n                    that.channelHandlerToken.forEach((token) => PubSub.unsubscribe(token));\n                }\n                that.channelHandlerToken = [];\n                this.ready = false;\n                resolve();\n            }\n            catch (err) {\n                this._logger.log(\"error\", LOG_ID + \"(stop) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(stop) error : \", err);\n                return reject(err);\n            }\n        });\n    }\n    attachHandlers() {\n        let that = this;\n        that.channelEventHandler = new channelEventHandler_1.ChannelEventHandler(that._xmpp, that);\n        that.channelHandlerToken = [\n            //            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_CHAT, that.conversationEventHandler.onChatMessageReceived),\n            //            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_GROUPCHAT, that.conversationEventHandler.onChatMessageReceived),\n            //            PubSub.subscribe( that._xmpp.hash + \".\" + that.conversationEventHandler.MESSAGE_WEBRTC, that.conversationEventHandler.onWebRTCMessageReceived),\n            PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_MANAGEMENT, that.channelEventHandler.onManagementMessageReceived),\n            PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_ERROR, that.channelEventHandler.onErrorMessageReceived),\n            PubSub.subscribe(that._xmpp.hash + \".\" + that.channelEventHandler.MESSAGE_HEADLINE, that.channelEventHandler.onHeadlineMessageReceived),\n        ];\n    }\n    /**\n     * @public\n     * @method createChannel\n     * @instance\n     * @async\n     * @param {string} name  The name of the channel to create (max-length=255)\n     * @param {string} [channelTopic]  The description of the channel to create (max-length=255)\n     * @return {Promise<Channel>} New Channel\n     * @description\n     *  Create a new public channel with a visibility limited to my company\n     */\n    createChannel(name, channelTopic) {\n        return this.createPublicChannel(name, channelTopic, \"globalnews\");\n    }\n    /**\n     * @public\n     * @method createPublicChannel\n     * @instance\n     * @async\n     * @param {string} name  The name of the channel to create (max-length=255)\n     * @param {string} [channelTopic]  The description of the channel to create (max-length=255)\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Promise<Channel>} New Channel\n     * @description\n     *  Create a new public channel with a visibility limited to my company\n     */\n    createPublicChannel(name, channelTopic, category) {\n        return new Promise((resolve, reject) => {\n            if (!name) {\n                this._logger.log(\"warn\", LOG_ID + \"(createPublicChannel) bad or empty 'name' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(createPublicChannel) bad or empty 'name' parameter : \", name);\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                return;\n            }\n            this._rest.createPublicChannel(name, channelTopic, category, this.PUBLIC_VISIBILITY, this.MAX_ITEMS, this.MAX_PAYLOAD_SIZE).then((channel) => {\n                this._logger.log(\"debug\", LOG_ID + \"(createPublicChannel) creation successfull\");\n                //let channelObj : Channel = this.addOrUpdateChannelToCache(channel);\n                let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(createPublicChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(createPublicChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method createClosedChannel (ex: createPrivateChannel)\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the createClosedChannel method instead,\n     * @param {string} name  The name of the channel to create (max-length=255)\n     * @param {string} [description]  The description of the channel to create (max-length=255)\n     * @return {Promise<Channel>} New Channel\n     * @description\n     *  Create a new private channel\n     */\n    createPrivateChannel(name, description) {\n        return this.createClosedChannel(name, description, \"globalnews\");\n    }\n    /**\n     * @public\n     * @method createClosedChannel (ex: createPrivateChannel)\n     * @instance\n     * @async\n     * @param {string} name  The name of the channel to create (max-length=255)\n     * @param {string} [description]  The description of the channel to create (max-length=255)\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Promise<Channel>} New Channel\n     * @description\n     *  Create a new closed channel\n     */\n    createClosedChannel(name, description, category) {\n        return new Promise((resolve, reject) => {\n            if (!name) {\n                this._logger.log(\"warn\", LOG_ID + \"(createClosedChannel) bad or empty 'name' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(createClosedChannel) bad or empty 'name' parameter : \", name);\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                return;\n            }\n            this._rest.createPublicChannel(name, description, category, this.PRIVATE_VISIBILITY, this.MAX_ITEMS, this.MAX_PAYLOAD_SIZE).then((channel) => {\n                this._logger.log(\"debug\", LOG_ID + \"(createClosedChannel) creation successfull\");\n                //let channelObj : Channel = this.addOrUpdateChannelToCache(channel);\n                let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(createClosedChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(createClosedChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method deleteChannel\n     * @instance\n     * @async\n     * @param {Channel} channel  The channel to delete\n     * @return {Promise<CHannel>} Promise object represents The channel deleted\n     * @description\n     *  Delete a owned channel\n     */\n    deleteChannel(channel) {\n        return new Promise((resolve, reject) => {\n            if (!channel || !channel.id) {\n                this._logger.log(\"warn\", LOG_ID + \"(deleteChannel) bad or empty 'channel' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) bad or empty 'channel' parameter : \", channel);\n                reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                return;\n            }\n            this._rest.deleteChannel(channel.id).then((status) => __awaiter(this, void 0, void 0, function* () {\n                this._logger.log(\"debug\", LOG_ID + \"(deleteChannel) channel deleted status : \", status);\n                /*let channelRemoved = this._channels.splice(this._channels.findIndex((el) => {\n                    return el.id === channel.id;\n                }), 1); // */\n                let channelRemoved = yield this.removeChannelFromCache(channel.id);\n                this._logger.log(\"internal\", LOG_ID + \"(deleteChannel) channel deleted : \", channelRemoved);\n                if (channelRemoved) {\n                    resolve(channelRemoved);\n                }\n                else {\n                    this._logger.log(\"warn\", LOG_ID + \"(deleteChannel) the channel deleted was unknown from SDK cache \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) the channel deleted was unknown from SDK cache : \", channel);\n                    resolve(channel);\n                }\n            })).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(deleteChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(deleteChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method findChannelsByName\n     * @instance\n     * @async\n     * @param {String} name Search this provided substring in the channel name (case insensitive).\n     * @return {Promise<Channel[]>} Channels found\n     * @description\n     *  Find channels by name. Only channels with visibility equals to 'company' can be found. First 100 results are returned.\n     */\n    findChannelsByName(name) {\n        if (!name) {\n            this._logger.log(\"warn\", LOG_ID + \"(findChannelsByName) bad or empty 'name' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(findChannelsByName) bad or empty 'name' parameter : \", name);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return this._findChannels(name, null);\n    }\n    /**\n     * @public\n     * @method findChannelsByTopic\n     * @instance\n     * @async\n     * @param {String} topic Search this provided substring in the channel topic (case insensitive).\n     * @return {Promise<Channel[]>} Channels found\n     * @description\n     *  Find channels by topic. Only channels with visibility equals to 'company' can be found. First 100 results are returned.\n     */\n    findChannelsByTopic(topic) {\n        if (!topic) {\n            this._logger.log(\"warn\", LOG_ID + \"(findChannelsByTopic) bad or empty 'topic' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(findChannelsByTopic) bad or empty 'topic' parameter : \", topic);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return this._findChannels(null, topic);\n    }\n    /**\n     * @private\n     * @method findChannels\n     */\n    _findChannels(name, topic) {\n        //hack\n        let getChannel = (id) => {\n            return new Promise((resolve) => {\n                this.fetchChannel(id).then((channel) => {\n                    resolve(channel);\n                }).catch((err) => {\n                    this._logger.log(\"error\", LOG_ID + \"(_findChannels) error getChannel \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(_findChannels) error getChannel : \", err);\n                    resolve(null);\n                });\n            });\n        };\n        return new Promise((resolve, reject) => {\n            this._rest.findChannels(name, topic, null, null, null, null, null).then((channels) => {\n                this._logger.log(\"info\", LOG_ID + \"(_findChannels) findChannels channels found \");\n                this._logger.log(\"internal\", LOG_ID + \"(_findChannels) findChannels channels found : \", channels);\n                let promises = [];\n                channels.forEach((channel) => {\n                    promises.push(getChannel(channel.id));\n                });\n                Promise.all(promises).then((listOfChannels) => {\n                    resolve(listOfChannels);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(_findChannels) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(_findChannels) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method getChannelById\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the fetchChannel method instead,\n     * @param {String} id The id of the channel)\n     * @param {boolean} [force=false] True to force a request to the server\n     * @return {Promise<Channel>} The channel found\n     * @description\n     * Find a channel by its id (locally if exists or by sending a request to Rainbow)\n     */\n    getChannelById(id, force) {\n        return this.fetchChannel(id, force);\n    }\n    /**\n     * @public\n     * @method fetchChannel\n     * @instance\n     * @async\n     * @param {String} id The id of the channel)\n     * @param {boolean} [force=false] True to force a request to the server\n     * @return {Promise<Channel>} The channel found\n     * @description\n     * Find a channel by its id (locally if exists or by sending a request to Rainbow)\n     */\n    fetchChannel(id, force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                if (!id) {\n                    this._logger.log(\"warn\", LOG_ID + \"(fetchChannel) bad or empty 'jid' parameter\");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannel) bad or empty 'jid' parameter : \", id);\n                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n                }\n                else {\n                    let channelFound = this.getChannelFromCache(id);\n                    if (channelFound && !force) {\n                        this._logger.log(\"info\", LOG_ID + \"(fetchChannel) channel found locally\");\n                        this._logger.log(\"internal\", LOG_ID + \"(fetchChannel) channel found locally : \", channelFound);\n                        resolve(channelFound);\n                    }\n                    else {\n                        this._logger.log(\"debug\", LOG_ID + \"(fetchChannel) channel not found locally. Ask the server...\");\n                        let channel = yield this.getChannel(id);\n                        let channelObj = this.addOrUpdateChannelToCache(channel);\n                        resolve(channelObj);\n                    }\n                }\n            }));\n        });\n    }\n    /**\n     * @public\n     * @method fetchChannelsByFilter\n     * @since 1.55\n     * @instance\n     * @description\n     *    Find channels using a filter (on name, topic)<br/>\n     *    Result may be filtered with result limit, offet and sortField or SortOrder\n     *    Return a promise.\n     * @param {Object} filter The filter with at least [filter.name] or [filter.topic] defined\n     *      {String} [filter.name] search by channel names (case insensitive substring).\n     *      {String} [filter.topic] search by channel topics (case insensitive substring).\n     *      {Number} [filter.limit=100] allow to specify the number of channels to retrieve.\n     *      {Number} [filter.offset] allow to specify the position of first channel to retrieve (first channel if not specified). Warning: if offset > total, no results are returned.\n     *      {String} [filter.sortField=\"name\"] sort channel list based on the given field.\n     *      {Number} [filter.sortOrder=\"1\"] specify order ascending/descending. 1 for ascending, -1 for descending.\n     * @return {Promise<Channel[]>} Result of the find with\n     *      {Array}   found channels informations with an array of { id, name, topic, creatorId, visibility, users_count }\n     */\n    fetchChannelsByFilter(filter) {\n        let getChannel = (id) => {\n            return new Promise((resolve) => {\n                this.fetchChannel(id).then((channel) => {\n                    resolve(channel);\n                }).catch((err) => {\n                    this._logger.log(\"error\", LOG_ID + \"(fetchChannelsByFilter) error getChannel \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelsByFilter) error getChannel : \", err);\n                    resolve(null);\n                });\n            });\n        };\n        if (!filter) {\n            this._logger.log(\"debug\", LOG_ID + \"(fetchChannelsByFilter) bad or empty 'channel' parameter \");\n            this._logger.log(\"internal\", LOG_ID + \"(fetchChannelsByFilter) bad or empty 'channel' parameter : \", filter);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.findChannels(filter.name, filter.topic, filter.category, filter.limit, filter.offset, filter.sortField, (filter.sortOrder && (filter.sortOrder === 1) ? \"1\" : \"-1\")).then((channels) => {\n                this._logger.log(\"info\", LOG_ID + \"(fetchChannelsByFilter) channels found\");\n                this._logger.log(\"internal\", LOG_ID + \"(fetchChannelsByFilter) channels found : \", channels);\n                let promises = [];\n                channels.forEach((channel) => {\n                    promises.push(getChannel(channel.id));\n                });\n                Promise.all(promises).then((listOfChannels) => {\n                    resolve(listOfChannels);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(fetchChannelsByFilter) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelsByFilter) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    ;\n    /**\n     * @public\n     * @method getChannels\n     * @since 1.38\n     * @instance\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the fetchMyChannels method instead,\n     * @description\n     *    Get the channels you own, are subscribed to, are publisher<br/>\n     *    Return a promise.\n     * @return {{Promise<Channel[]>} } Return Promise with a list of channels or an empty array if no channel has been found\n     */\n    getChannels() {\n        return this.fetchMyChannels();\n    }\n    /**\n     * @public\n     * @method fetchMyChannels\n     * @since 1.38\n     * @instance\n     * @description\n     *    Get the channels you own, are subscribed to, are publisher<br/>\n     *    Return a promise.\n     * @return {Promise<Channel[]>} Return Promise with a list of channels or an empty array if no channel has been found\n     */\n    fetchMyChannels() {\n        let getChannel = (id) => {\n            return new Promise((resolve) => {\n                this.fetchChannel(id).then((channel) => {\n                    resolve(channel);\n                }).catch((err) => {\n                    this._logger.log(\"error\", LOG_ID + \"(fetchMyChannels) error fetchChannel \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(fetchMyChannels) error fetchChannel : \", err);\n                    resolve(null);\n                });\n            });\n        };\n        return new Promise((resolve) => {\n            this._rest.getChannels().then((listOfChannels) => {\n                // Hack waiting server change\n                let promises = [];\n                if (Array.isArray(listOfChannels)) {\n                    listOfChannels.forEach((channel) => {\n                        promises.push(getChannel(channel.id));\n                    });\n                }\n                else {\n                    if (\"owner\" in listOfChannels) {\n                        listOfChannels.owner.forEach((channel) => {\n                            promises.push(getChannel(channel.id));\n                        });\n                    }\n                    if (\"publisher\" in listOfChannels) {\n                        listOfChannels.publisher.forEach((channel) => {\n                            promises.push(getChannel(channel.id));\n                        });\n                    }\n                    if (\"member\" in listOfChannels) {\n                        listOfChannels.member.forEach((channel) => {\n                            promises.push(getChannel(channel.id));\n                        });\n                    }\n                }\n                this._logger.log(\"info\", LOG_ID + \"(fetchMyChannels) hack start get channel data individually from server...\");\n                Promise.all(promises).then((channels) => {\n                    this._logger.log(\"internal\", LOG_ID + \"(fetchMyChannels) hack done : \", channels);\n                    this._channels = [];\n                    if (channels) {\n                        channels.forEach((channel) => {\n                            this.addOrUpdateChannelToCache(channel);\n                        });\n                    }\n                    //this._logger.log(\"internal\", LOG_ID + \"(fetchMyChannels) get successfully and updated the channels cache : \", this._channels);\n                    resolve(this._channels);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(fetchMyChannels) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(fetchMyChannels) error : \", err);\n                // Do not block the startup on VM without channels API\n                this._channels = [];\n                resolve(this._channels);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method getAllChannels\n     * @instance\n     * @return {Channel[]} An array of channels (owned, invited, subscribed)\n     * @description\n     *  Return the list of channels (owned, invited, subscribed)\n     */\n    getAllChannels() {\n        return this._channels;\n    }\n    /**\n     * @public\n     * @method getAllOwnedChannel\n     * @instance\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the getAllOwnedChannels method instead,\n     * @return {Channel[]} An array of channels (owned only)\n     * @description\n     *  Return the list of owned channels only\n     */\n    getAllOwnedChannel() {\n        return this.getAllOwnedChannels();\n    }\n    /**\n     * @public\n     * @method getAllOwnedChannels\n     * @instance\n     * @return {Channel[]} An array of channels (owned only)\n     * @description\n     *  Return the list of owned channels only\n     */\n    getAllOwnedChannels() {\n        return this._channels.filter((channel) => {\n            return channel.creatorId === this._rest.userId;\n        });\n    }\n    /**\n     * @public\n     * @method getAllSubscribedChannel\n     * @instance\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the getAllSubscribedChannels method instead,\n     * @return {Channel[]} An array of channels (subscribed only)\n     * @description\n     *  Return the list of subscribed channels only\n     */\n    getAllSubscribedChannel() {\n        return this.getAllSubscribedChannels();\n    }\n    /**\n     * @public\n     * @method getAllSubscribedChannels\n     * @instance\n     * @return {Channel[]} An array of channels (subscribed only)\n     * @description\n     *  Return the list of subscribed channels only\n     */\n    getAllSubscribedChannels() {\n        return this._channels.filter((channel) => {\n            return channel.creatorId !== this._rest.userId;\n        });\n    }\n    /**\n     * @public\n     * @method getAllPendingChannels\n     * @instance\n     * @return {Channel[]} An array of channels (invited only)\n     * @description\n     *  Return the list of invited channels only\n     */\n    getAllPendingChannels() {\n        return this._channels.filter((channel) => {\n            return channel.invited;\n        });\n    }\n    /**\n     * @public\n     * @method publishMessageToChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel where to publish the message\n     * @param {String} message Message content\n     * @param {String} [title = \"\", limit=256] Message title\n     * @param {String} [url = \"\"] An URL\n     * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow\n     * @param {String} [type=\"basic\"] An optional message content type (could be basic, markdown, html or data)\n     * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull\n     * @description\n     *  Publish to a channel\n     */\n    publishMessageToChannel(channel, message, title, url, imagesIds, type) {\n        return this.createItem(channel, message, title, url, imagesIds, type);\n    }\n    /**\n     * @public\n     * @method createItem\n     * @instance\n     * @async\n     * @param {Channel} channel The channel where to publish the message\n     * @param {String} message Message content\n     * @param {String} [title = \"\", limit=256] Message title\n     * @param {String} [url = \"\"] An URL\n     * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow\n     * @param {String} [type=\"basic\"] An optional message content type (could be basic, markdown, html or data)\n     * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull\n     * @description\n     *  Publish to a channel\n     */\n    createItem(channel, message, title, url, imagesIds, type) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!message) {\n            this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'title' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'title' parameter : \", title);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (imagesIds && typeof imagesIds !== \"object\" && imagesIds.length < 1) {\n            this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'imagesIds' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(createItem) bad or empty 'imagesIds' parameter : \", imagesIds);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (type && [\"basic\", \"markdown\", \"html\", \"data\"].indexOf(type) === -1) {\n            this._logger.log(\"warn\", LOG_ID + \"(createItem) bad or empty 'type' parameter \", type, \" \\\"Parameter 'type' could be 'basic', 'markdown', 'html' or 'data'\\\"\");\n            return Promise.reject(ErrorManager_1.ErrorManager);\n        }\n        return new Promise((resolve, reject) => {\n            type = type ? \"urn:xmpp:channels:\" + type : \"urn:xmpp:channels:basic\";\n            this._rest.publishMessage(channel.id, message, title, url, imagesIds, type).then((status) => {\n                this._logger.log(\"info\", LOG_ID + \"(createItem) message published\");\n                this._logger.log(\"internal\", LOG_ID + \"(createItem) message published : \", status);\n                resolve(ErrorManager_1.ErrorManager.getErrorManager().OK);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(createItem) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(createItem) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method subscribeToChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel to subscribe\n     * @return {Promise<Channel>} The channel updated with the new subscription\n     * @description\n     *  Subscribe to a public channel\n     */\n    subscribeToChannel(channel) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(subscribeToChannel) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.subscribeToChannel(channel.id).then((status) => {\n                this._logger.log(\"info\", LOG_ID + \"(subscribeToChannel) channel subscribed : \", status);\n                this.fetchChannel(channel.id, true).then((channelUpdated) => {\n                    resolve(channelUpdated);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(subscribeToChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method\n     * @since 1.47\n     * @instance\n     * @description\n     *    Subscribe to a channel using its id<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Object} Nothing or an error object depending on the result\n     */\n    subscribeToChannelById(id) {\n        let that = this;\n        if (!id) {\n            this._logger.log(\"warn\", LOG_ID + \"(subscribeToChannel) bad or empty 'id' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(subscribeToChannel) bad or empty 'id' parameter : \", id);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            let channel = that.getChannelFromCache(id);\n            if (!channel) {\n                that.getChannel(id).then(function (channelFound) {\n                    if (channelFound) {\n                        that.subscribeToChannel(channelFound)\n                            .then(function () {\n                            that._logger.log(\"debug\", LOG_ID + \"(subscribeToChannel) subscribed : \", id);\n                            resolve({\n                                code: \"OK\",\n                                label: \"OK\"\n                            });\n                        })\n                            .catch(function (err) {\n                            return reject(err);\n                        });\n                    }\n                    else {\n                        return reject({\n                            code: \"ERRORBADREQUEST\",\n                            label: \"No channel found with id \" + id\n                        });\n                    }\n                });\n            }\n            else {\n                that.subscribeToChannel(channel)\n                    .then(function () {\n                    that._logger.log(\"debug\", LOG_ID + \"(subscribeToChannel) subscribed : \", id);\n                    resolve({\n                        code: \"OK\",\n                        label: \"OK\"\n                    });\n                })\n                    .catch(function (err) {\n                    return reject(err);\n                });\n            }\n        });\n    }\n    ;\n    /**\n     * @public\n     * @method unsubscribeFromChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel to unsubscribe\n     * @return {Promise<String>} The status of the unsubscribe.\n     * @description\n     *  Unsubscribe from a public channel\n     */\n    unsubscribeFromChannel(channel) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(unsubscribeFromChannel) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(unsubscribeFromChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.unsubscribeToChannel(channel.id).then((status) => {\n                this._logger.log(\"info\", LOG_ID + \"(unsubscribeFromChannel) channel unsubscribed : \", status);\n                resolve(status);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(unsubscribeFromChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(unsubscribeFromChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method updateChannelTopic\n     * @instance\n     * @async\n     * @param {Channel} channel The channel to update\n     * @param {string} description  The description of the channel to update (max-length=255)\n     * @return {Promise<Channel>} Updated channel\n     * @description\n     *  TODO\n     */\n    updateChannelTopic(channel, description) {\n        return this.updateChannelDescription(channel, description);\n    }\n    /**\n     * @public\n     * @method updateChannelDescription\n     * @instance\n     * @async\n     * @param {Channel} channel The channel to update\n     * @param {string} description  The description of the channel to update (max-length=255)\n     * @return {Promise<Channel>} Updated channel\n     * @description\n     *  TODO\n     */\n    updateChannelDescription(channel, description) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel.id' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'channel.id' parameter : \", channel.id);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!description) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelDescription) bad or empty 'description' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) bad or empty 'description' parameter : \", description);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.updateChannel(channel.id, description, null, null, null, null, null).then((channelUpdated) => {\n                this._logger.log(\"info\", LOG_ID + \"(updateChannelDescription) channel updated\");\n                this._logger.log(\"internal\", LOG_ID + \"(updateChannelDescription) channel updated : \", channelUpdated);\n                let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n                /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n                let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n                this._channels[foundIndex] = channelObj; // */\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(updateChannelDescription) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelDescription) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method\n     * @since 1.46\n     * @instance\n     * @description\n     *    Update a channel name<br/>\n     *    Return a promise.\n     * @param {Channel} channel The channel to update\n     * @param {String} channelName The name of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n    updateChannelName(channel, channelName) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channel.id' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channel.id' parameter : \", channel.id);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!channelName) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelName) bad or empty 'channelName' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) bad or empty 'channelName' parameter : \", channelName);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.updateChannel(channel.id, null, null, null, null, channelName, null).then((channelUpdated) => {\n                this._logger.log(\"info\", LOG_ID + \"(updateChannelName) channel updated \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) channel updated : \", channelUpdated);\n                let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n                /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n                let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n                this._channels[foundIndex] = channelObj; */\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(updateChannelName) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelName) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    ;\n    /**\n     * @public\n     * @method\n     * @since 1.38\n     * @instance\n     * @description\n     *    Update a channel<br/>\n     *      May be updated: name, topic, visibility, max_items and max_payload<br/>\n     *      Please put null to not update a property.<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} [channelTopic=\"\"] The topic of the channel\n     * @param {String} [visibility=public] public/company/closed group visibility for search\n     * @param {Number} [max_items=30] max # of items to persist in the channel\n     * @param {Number} [max_payload_size=60000] max # of items to persist in the channel\n     * @param {String} [channelName=\"\"] The name of the channel\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Promise<Channel>} Return the channel created or an error\n     */\n    updateChannel(id, channelTopic, visibility, max_items, max_payload_size, channelName, category) {\n        let that = this;\n        if (!id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannel) bad or empty 'id' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannel) bad or empty 'id' parameter : \", id);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        else {\n            let options = {};\n            if (channelTopic != null) {\n                options.topic = channelTopic;\n            }\n            if (visibility != null) {\n                options.mode = visibility === \"company\" ? \"company_public\" : \"company_closed\";\n            }\n            if (max_items != null) {\n                options.max_items = max_items;\n            }\n            if (max_payload_size != null) {\n                options.max_payload_size = max_payload_size;\n            }\n            if (channelName != null) {\n                options.name = channelName;\n            }\n            if (category != null) {\n                options.cateogry = category;\n            }\n            return new Promise((resolve, reject) => {\n                that._rest.updateChannel(id, options.topic, null, options.max_items, options.max_payload_size, options.name, options.mode)\n                    .then((channelUpdated) => {\n                    this._logger.log(\"internal\", LOG_ID + \"(updateChannel) channel channelUpdated : \", channelUpdated);\n                    let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n                    this._logger.log(\"internal\", LOG_ID + \"(updateChannel) channel updated, channelObj : \", channelObj);\n                    resolve(channelObj);\n                })\n                    .catch(function (err) {\n                    return reject(err);\n                });\n            });\n        }\n    }\n    ;\n    /**\n     * @public\n     * @method updateChannelVisibility\n     * @since 1.55\n     * @instance\n     * @description\n     *    Update a channel visibility<br/>\n     *    Return a promise.\n     * @param {String} channel The channel to update\n     * @param {String} visibility  The new channel visibility (closed or company)\n     * @return {Promise<Channel>} Return the channel updated or an error\n     */\n    updateChannelVisibility(channel, visibility) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel.id' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'channel.id' parameter : \", channel.id);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!visibility) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelVisibility) bad or empty 'visibility' parameter \");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) bad or empty 'visibility' parameter : \", visibility);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let mode = visibility === \"company\" ? \"company_public\" : \"company_closed\";\n        let name = channel.name;\n        return new Promise((resolve, reject) => {\n            this._rest.updateChannel(channel.id, null, null, null, null, name, mode).then((channelUpdated) => {\n                this._logger.log(\"internal\", LOG_ID + \"(updateChannelVisibility) channel updated : \", channelUpdated);\n                let channelObj = this.addOrUpdateChannelToCache(channelUpdated);\n                /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === channelUpdated.id);\n                let channelObj : Channel = Channel.ChannelFactory()(channelUpdated, this._rest.http.serverURL);\n                this._channels[foundIndex] = channelObj;\n                */\n                this._logger.log(\"internal\", LOG_ID + \"(updateChannelVisibility) channel updated : \", channelObj);\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(updateChannelVisibility) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelVisibility) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    ;\n    /**\n     * @public\n     * @method updateChannelVisibilityToPublic\n     * @since 1.55\n     * @instance\n     * @description\n     *    Set the channel visibility to company (visible for users in that company)<br/>\n     *    Return a promise.\n     * @param {String} channel The channel to update\n     * @return {Channel} Return the channel updated or an error\n     */\n    updateChannelVisibilityToPublic(channel) {\n        return this.updateChannelVisibility(channel, \"company\");\n    }\n    /**\n     * @public\n     * @method updateChannelVisibilityToClosed\n     * @since 1.55\n     * @instance\n     * @description\n     *    Set the channel visibility to closed (not visible by users)<br/>\n     *    Return a promise.\n     * @param {String} channel The channel to update\n     * @return {Channel} Return the channel updated or an error\n     */\n    updateChannelVisibilityToClosed(channel) {\n        //channel.name = channel.name + \"_updateToClosed\";\n        return this.updateChannelVisibility(channel, \"closed\");\n    }\n    /**\n     * @public\n     * @method\n     * @since 1.43\n     * @instance\n     * @description\n     *    Update a channel avatar<br/>\n     *    Return a promise.\n     * @param {Channel} channel The Channel to update\n     * @param {string} urlAvatar  The avatar Url.  It must be resized to 512 pixels before calling this API.\n     * @return {Channel} Return the channel updated or an error\n     */\n    updateChannelAvatar(channel, urlAvatar) {\n        let that = this;\n        if (!channel || !channel.id) {\n            that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter \");\n            that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        else if (!urlAvatar) {\n            that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'urlAvatar' parameter \");\n            that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'urlAvatar' parameter : \", urlAvatar);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                try {\n                    that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n                    let id = channel.id;\n                    let fileStats = fs.statSync(urlAvatar);\n                    let fd = fs.openSync(urlAvatar, \"r+\");\n                    let buf = new Buffer(fileStats.size);\n                    fs.readSync(fd, buf, 0, fileStats.size, null);\n                    let fileType = mimetypes.lookup(urlAvatar);\n                    that._rest.uploadChannelAvatar(id, buf, fileStats.size /* should resize the picture to 512*/, fileType).then(function () {\n                        that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n                        resolve({\n                            code: \"OK\",\n                            label: \"OK\"\n                        });\n                    }).catch(function (err) {\n                        that._logger.log(\"error\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \");\n                        that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \", err, \", for channel : \", channel);\n                        return reject(err);\n                    });\n                }\n                catch (err2) {\n                    that._logger.log(\"error\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \");\n                    that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) !!! CATCH Error \", err2, \", for channel : \", channel);\n                    return reject(err2);\n                }\n            });\n        }\n    }\n    ;\n    /**\n     * @public\n     * @method\n     * @since 1.43\n     * @instance\n     * @description\n     *    Delete a channel avatar<br/>\n     *    Return a promise.\n     * @param {Channel} channel The channel to update\n     * @return {Channel} Return the channel updated or an error\n     */\n    deleteChannelAvatar(channel) {\n        let that = this;\n        if (!channel || !channel.id) {\n            that._logger.log(\"warn\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter \");\n            that._logger.log(\"internalerror\", LOG_ID + \"(updateChannelAvatar) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                let id = channel.id;\n                that._rest.deleteChannelAvatar(id)\n                    .then(function () {\n                    that._logger.log(\"internal\", LOG_ID + \"(updateChannelAvatar) channel : \", channel);\n                    resolve({\n                        code: \"OK\",\n                        label: \"OK\"\n                    });\n                })\n                    .catch(function (err) {\n                    return reject(err);\n                });\n            });\n        }\n    }\n    ;\n    /**\n     * @public\n     * @method fetchChannelUsers\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the fetchChannelUsers method instead,\n     * @param {Channel} channel The channel\n     * @param {Object} [options] A filter parameter\n     * @param {Number} [options.page = 0] Display a specific page of results\n     * @param {Number} [options.limit=100] Number of results per page (max 1000)\n     * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only\n     * @param {Boolean} [options.onlyOwners=false] Filter to owners only\n     * @return {Promise<Users[]>} An array of users who belong to this channel\n     * @description\n     *  Get a pagined list of users who belongs to a channel\n     */\n    getUsersFromChannel(channel, options) {\n        return this.fetchChannelUsers(channel, options);\n    }\n    /**\n     * @public\n     * @method fetchChannelUsers\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @param {Object} [options] A filter parameter\n     * @param {Number} [options.page = 0] Display a specific page of results\n     * @param {Number} [options.limit=100] Number of results per page (max 1000)\n     * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only\n     * @param {Boolean} [options.onlyOwners=false] Filter to owners only\n     * @return {Promise<Users[]>} An array of users who belong to this channel\n     * @description\n     *  Get a pagined list of users who belongs to a channel\n     */\n    fetchChannelUsers(channel, options) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(fetchChannelUsers) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelUsers) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let json = {\n            \"limit\": 100,\n            \"page\": null,\n            \"type\": null\n        };\n        if (options) {\n            if (\"page\" in options) {\n                json.page = Number(options.page);\n            }\n            if (\"limit\" in options) {\n                json.limit = Number(options.limit);\n            }\n            if (\"onlyPublishers\" in options && options.onlyPublishers) {\n                json.type = \"publisher\";\n            }\n            if (\"onlyOwners\" in options && options.onlyOwners) {\n                json.type = \"owner\";\n            }\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.getChannelUsers(channel.id, json).then((users) => {\n                this._logger.log(\"info\", LOG_ID + \"(fetchChannelUsers) channel has users \");\n                this._logger.log(\"internal\", LOG_ID + \"(fetchChannelUsers) channel has users : \", users.length);\n                resolve(users);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(fetchChannelUsers) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelUsers) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method removeAllUsersFromChannel\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the deleteAllUsersFromChannel method instead,\n     * @param {String} channel The channel\n     * @return {Promise<Channel>} The channel updated\n     * @description\n     *  Remove all users from a channel\n     */\n    removeAllUsersFromChannel(channel) {\n        return this.deleteAllUsersFromChannel(channel);\n    }\n    /**\n     * @public\n     * @method deleteAllUsersFromChannel\n     * @instance\n     * @async\n     * @param {String} channel The channel\n     * @return {Promise<Channel>} The channel updated\n     * @description\n     *  Remove all users from a channel\n     */\n    deleteAllUsersFromChannel(channel) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(deleteAllUsersFromChannel) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllUsersFromChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.deleteAllUsersFromChannel(channel.id).then((result) => {\n                this._logger.log(\"info\", LOG_ID + \"(deleteAllUsersFromChannel) channel users deletion\");\n                this._logger.log(\"internal\", LOG_ID + \"(deleteAllUsersFromChannel) channel users deletion : \", result);\n                this._rest.getChannel(channel.id).then((updatedChannel) => {\n                    // Update local channel\n                    let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n                    /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n                    let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n                    this._channels[foundIndex] = channelObj;\n                     */\n                    resolve(channelObj);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(deleteAllUsersFromChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(deleteAllUsersFromChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method updateChannelUsers\n     * @instance\n     * @async\n     * @param {String} channelId The Id of the channel\n     * @param {ChannelUser[]} users The users of the channel\n     * @return {Promise<Channel>} Update Channel Users status\n     * @description\n     *  TODO\n     */\n    updateChannelUsers(channel, users) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(updateChannelUsers) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelUsers) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let channelId = channel.id;\n        return new Promise((resolve, reject) => {\n            //this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) this._channels : \", this._channels);\n            this._rest.updateChannelUsers(channelId, users).then((res) => {\n                this._logger.log(\"info\", LOG_ID + \"(updateChannelUsers) channel users updated\");\n                this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) channel users updated : \", res);\n                this._rest.getChannel(channelId).then((updatedChannel) => {\n                    // Update local channel\n                    let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n                    /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n                    let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n                    this._channels[foundIndex] = channelObj;\n                     */\n                    this._logger.log(\"internal\", LOG_ID + \"(updateChannelUsers) channel updated : \", channelObj);\n                    resolve(channelObj);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(updateChannelUsers) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(updateChannelUsers) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method addOwnersToChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @param owners\n     * @return {Promise<Channel>} The updated channel\n     * @description\n     *  Add a list of owners to the channel\n     */\n    addOwnersToChannel(channel, owners) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(addOwnersToChannel) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(addOwnersToChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!owners) {\n            this._logger.log(\"warn\", LOG_ID + \"(addOwnersToChannel) bad or empty 'owners' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(addOwnersToChannel) bad or empty 'owners' parameter : \", owners);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let usersId = [];\n        owners.forEach((user) => {\n            usersId.push({ \"id\": user.id, \"type\": \"owner\" });\n        });\n        let updated = this.updateChannelUsers(channel, usersId);\n        return updated;\n    }\n    /**\n     * @public\n     * @method addPublishersToChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @param {User[]} users An array of users to add\n     * @return {Promise<Channel>} The updated channel\n     * @description\n     *  Add a list of publishers to the channel\n     */\n    addPublishersToChannel(channel, publishers) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(addPublishersToChannel) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(addPublishersToChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!publishers || !(publishers.length > 0)) {\n            this._logger.log(\"warn\", LOG_ID + \"(addPublishersToChannel) bad or empty 'publishers' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(addPublishersToChannel) bad or empty 'publishers' parameter : \", publishers);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let usersId = [];\n        publishers.forEach((user) => {\n            usersId.push({ \"id\": user.id, \"type\": \"publisher\" });\n        });\n        let updated = this.updateChannelUsers(channel, usersId);\n        return updated;\n    }\n    /**\n     * @public\n     * @method addMembersToChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @param {User[]} users An array of users to add\n     * @return {Promise<Channel>} The updated channel\n     * @description\n     *  Add a list of members to the channel\n     */\n    addMembersToChannel(channel, members) {\n        return __awaiter(this, void 0, void 0, function* () {\n            //this._logger.log(\"internal\", LOG_ID + \"(addMembersToChannel) this._channels : \", this._channels);\n            if (!channel || !channel.id) {\n                this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'channel' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'channel' parameter : \", channel);\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            if (!members) {\n                this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter : \", members);\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            let usersId = [];\n            members.forEach((user) => {\n                if (user) {\n                    usersId.push({ \"id\": user.id, \"type\": \"member\" });\n                }\n            });\n            if (!(usersId.length > 0)) {\n                this._logger.log(\"warn\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter\");\n                this._logger.log(\"internalerror\", LOG_ID + \"(addMembersToChannel) bad or empty 'members' parameter : \", members);\n                return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n            }\n            let updated = this.updateChannelUsers(channel, usersId);\n            return updated;\n        });\n    }\n    /**\n     * @public\n     * @method removeUsersFromChannel1\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the deleteUsersFromChannel method instead,\n     * @param {Channel} channel The channel\n     * @param {User[]} users An array of users to remove\n     * @return {Promise<Channel>} The updated channel\n     * @description\n     *  Remove a list of users from a channel\n     */\n    removeUsersFromChannel1(channel, users) {\n        return this.deleteUsersFromChannel(channel, users);\n    }\n    /**\n     * @public\n     * @method deleteUsersFromChannel\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @param {User[]} users An array of users to remove\n     * @return {Promise<Channel>} The updated channel\n     * @description\n     *  Remove a list of users from a channel\n     */\n    deleteUsersFromChannel(channel, users) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!users) {\n            this._logger.log(\"warn\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'publishers' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteUsersFromChannel) bad or empty 'publishers' parameter : \", users);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        let usersId = [];\n        users.forEach((user) => {\n            usersId.push({ \"id\": user.id, \"type\": \"none\" });\n        });\n        let updated = this.updateChannelUsers(channel, usersId);\n        return updated;\n    }\n    /**\n     * @public\n     * @method getMessagesFromChannel\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the fetchChannelItems method instead,\n     * @param {Channel} channel The channel\n     * @return {Promise<Object[]>} The list of messages received\n     * @description\n     *  Retrieve the last messages from a channel\n     */\n    getMessagesFromChannel(channel) {\n        return this.fetchChannelItems(channel);\n    }\n    /**\n     * @public\n     * @method fetchChannelItems\n     * @instance\n     * @async\n     * @param {Channel} channel The channel\n     * @return {Promise<Object[]>} The list of messages received\n     * @description\n     *  Retrieve the last messages from a channel\n     */\n    fetchChannelItems(channel) {\n        if (!channel || !channel.id) {\n            this._logger.log(\"warn\", LOG_ID + \"(fetchChannelItems) bad or empty 'channel' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelItems) bad or empty 'channel' parameter : \", channel);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.getChannelMessages(channel.id).then((res) => {\n                this._logger.log(\"info\", LOG_ID + \"(fetchChannelItems) messages retrieved\", res);\n                let messages = res.items;\n                let listOfMessages = [];\n                messages.forEach((item) => {\n                    let message = {\n                        id: item.item.$.id ? item.item.$.id : \"\",\n                        title: item.item.entry.title ? item.item.entry.title : \"\",\n                        message: item.item.entry.message ? item.item.entry.message : \"\",\n                        url: item.item.entry.url ? item.item.entry.url : \"\",\n                        images: []\n                    };\n                    if (Array.isArray(item.item.entry.images)) {\n                        item.item.entry.images.forEach((image) => {\n                            message.images.push(image.id);\n                        });\n                    }\n                    else {\n                        // when there is only one image, the server give us a single object and not an Array.\n                        if (item.item.entry.images) {\n                            message.images.push(item.item.entry.images.id);\n                        }\n                    }\n                    listOfMessages.push(message);\n                });\n                resolve(listOfMessages);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(fetchChannelItems) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(fetchChannelItems) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    /**\n     * @public\n     * @method deleteMessageFromChannel\n     * @instance\n     * @async\n     * @deprecated [#1] since version 1.55 [#2].\n     * [#3] Will be deleted in future version\n     * [#4] In case you need similar behavior use the deleteItemFromChannel method instead,\n     * @param  {String} channelId The Id of the channel\n     * @param  {String} messageId The Id of the message\n     * @return {Promise<Channel>} The channel updated\n     * @description\n     *  Delete a message from a channel\n     */\n    deleteMessageFromChannel(channelId, messageId) {\n        return this.deleteItemFromChannel(channelId, messageId);\n    }\n    /**\n     * @public\n     * @method deleteItemFromChannel\n     * @instance\n     * @async\n     * @param  {String} channelId The Id of the channel\n     * @param  {String} itemId The Id of the item\n     * @return {Promise<Channel>} The channel updated\n     * @description\n     *  Delete a message from a channel\n     */\n    deleteItemFromChannel(channelId, itemId) {\n        if (!channelId) {\n            this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'channelId' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'channelId' parameter : \", channelId);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        if (!itemId) {\n            this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'itemId' parameter\");\n            this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) bad or empty 'itemId' parameter : \", itemId);\n            return Promise.reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);\n        }\n        return new Promise((resolve, reject) => {\n            this._rest.deleteChannelMessage(channelId, itemId).then((result) => {\n                this._logger.log(\"info\", LOG_ID + \"(deleteItemFromChannel) channel message deletion\");\n                this._logger.log(\"internal\", LOG_ID + \"(deleteItemFromChannel) channel message deletion : \", result);\n                this._rest.getChannel(channelId).then((updatedChannel) => {\n                    // Update local channel\n                    let channelObj = this.addOrUpdateChannelToCache(updatedChannel);\n                    /*let foundIndex = this._channels.findIndex(channelItem => channelItem.id === updatedChannel.id);\n                    let channelObj : Channel = Channel.ChannelFactory()(updatedChannel, this._rest.http.serverURL);\n                    this._channels[foundIndex] = channelObj;\n                     */\n                    resolve(channelObj);\n                }).catch((err) => {\n                    this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) error getChannel \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) error getChannel : \", err);\n                    return reject(err);\n                });\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(deleteItemFromChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(deleteItemFromChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    _onChannelMessageReceived(message) {\n        this.fetchChannel(message.channelId).then((channel) => {\n            message.channel = channel;\n            delete message.channelId;\n            this._eventEmitter.emit(\"evt_internal_channelmessagereceived\", message);\n        });\n    }\n    /**\n     * @private\n     * @param channelId\n     * @description\n     *      GET A CHANNEL\n     */\n    getChannel(channelId) {\n        return new Promise((resolve, reject) => {\n            this._rest.getChannel(channelId).then((channel) => {\n                this._logger.log(\"info\", LOG_ID + \"(getChannel) channel found on the server\");\n                this._logger.log(\"internal\", LOG_ID + \"(getChannel) channel found on the server : \", channel);\n                let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n                resolve(channelObj);\n            }).catch((err) => {\n                this._logger.log(\"error\", LOG_ID + \"(getChannel) error \");\n                this._logger.log(\"internalerror\", LOG_ID + \"(getChannel) error : \", err);\n                return reject(err);\n            });\n        });\n    }\n    ;\n    /**\n     * @private\n     * @param channelId\n     * @description\n     *      GET A CHANNEL FROM CACHE\n     */\n    getChannelFromCache(channelId) {\n        let channelFound = null;\n        this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) search id : \", channelId);\n        if (this._channels) {\n            let channelFoundindex = this._channels.findIndex((channel) => {\n                return channel.id === channelId;\n            });\n            if (channelFoundindex != -1) {\n                this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) channel found : \", this._channels[channelFoundindex], \" with id : \", channelId);\n                return this._channels[channelFoundindex];\n            }\n        }\n        this._logger.log(\"internal\", LOG_ID + \"(getChannelFromCache) channel found : \", channelFound, \" with id : \", channelId);\n        return channelFound;\n    }\n    updateChannelsList() {\n        //this._logger.log(\"debug\", LOG_ID + \"(updateChannelsList) keys : \", Object.keys(this._channels));\n        this._channelsList = this._channels.map((chnl) => { return chnl.id; });\n        this._logger.log(\"internal\", LOG_ID + \"(updateChannelsList) this._channelsList : \", this._channelsList);\n    }\n    addOrUpdateChannelToCache(channel) {\n        let channelObj = Channel_1.Channel.ChannelFactory()(channel, this._rest.http.serverURL);\n        let channelFoundindex = this._channels.findIndex((channelIter) => {\n            return channelIter.id === channel.id;\n        });\n        if (channelFoundindex != -1) {\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) update in cache with channel : \", channel, \", at channelFoundindex : \", channelFoundindex);\n            //this._channels.splice(channelFoundindex,1,channelObj);\n            //channelCached = channelObj;\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) in update this._channels : \", this._channels);\n            this._channels[channelFoundindex].updateChannel(channel);\n            channelObj = this._channels[channelFoundindex];\n        }\n        else {\n            this._logger.log(\"internal\", LOG_ID + \"(addOrUpdateChannelToCache) add in cache channelObj : \", channelObj);\n            this._channels.push(channelObj);\n        }\n        this.updateChannelsList();\n        return channelObj;\n    }\n    removeChannelFromCache(channelId) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            // Get the channel to remove\n            let channelToRemove = this.getChannelFromCache(channelId);\n            if (channelToRemove) {\n                // Store channel name\n                //let channelName = channelToRemove.name;\n                // Handle invitation channel\n                if (channelToRemove.invited) {\n                    this.decrementInvitationCounter();\n                }\n                // Remove from channels\n                let channelId = channelToRemove.id;\n                this._logger.log(\"internal\", LOG_ID + \"(removeChannelFromCache) remove from cache channelId : \", channelId);\n                this._channels = this._channels.filter(function (chnl) {\n                    return !(chnl.id === channelId);\n                });\n                this.updateChannelsList();\n                // Update messagesList\n                //this.feedChannel.messages = [];\n                this.retrieveLatests()\n                    .then(() => { resolve(channelToRemove); })\n                    .catch((err) => {\n                    this._logger.log(\"error\", LOG_ID + \"(removeChannelFromCache) error retrieveLatests \");\n                    this._logger.log(\"internalerror\", LOG_ID + \"(removeChannelFromCache) error retrieveLatests : \", err);\n                    return reject(err);\n                });\n            }\n            else {\n                resolve(null);\n            }\n        });\n    }\n    retrieveLatests(beforeDate = null) {\n        return this._rest.getLatestMessages(10, beforeDate, null).then((messages) => {\n            // TODO : this.feedChannel.messages.push.apply(this.feedChannel.messages, messages);\n            return messages.length;\n        });\n    }\n    incrementInvitationCounter() { this.invitationCounter += 1; }\n    decrementInvitationCounter() { this.invitationCounter -= 1; }\n    /****************************************************************/\n    /*** MANAGEMENT EVENT HANDLER                                 ***/\n    /****************************************************************/\n    onAvatarChange(channelId, avatar) {\n        /*\n        let action = avatar.attr(\"action\");\n        let updateDate: Date = avatar.attr(\"lastAvatarUpdateDate\") ? new Date(avatar.attr(\"lastAvatarUpdateDate\")) : null;\n        this.$log.info(\"[channelService] onChannelManagementReceived -- \" + action + \" avatar for \" + channelId);\n        if (action === \"delete\" || action === \"update\") {\n            let channel: Channel = this.getChannelFromCache(channelId);\n            channel.lastAvatarUpdateDate = updateDate;\n            if (updateDate !== null) {\n                channel.avatar = config.restServerUrl + \"/api/channel-avatar/\" + channelId + \"?size=256&ts=\" + new Date(updateDate).getTime();\n            }\n        }\n\n         */\n    }\n    onUpdateToChannel(channelInfo) {\n        let that = this;\n        let channelId = channelInfo.id;\n        this._logger.log(\"debug\", LOG_ID + \"(onUpdateToChannel) channelId : \", channelId);\n        // Get channel from cache\n        //let channel = this.getChannelFromCache(channelId);\n        // Get channel from server\n        this.getChannel(channelId)\n            .then((newChannel) => {\n            let channelObj = this.addOrUpdateChannelToCache(newChannel);\n            /*if (newChannel.invited) {\n                let channelObj : Channel = this.addOrUpdateChannelToCache(newChannel);\n                that._eventEmitter.emit(\"rainbow_channelcreated\", {'id': newChannel.id});\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n            } else { // */\n            that._eventEmitter.emit(\"evt_internal_channelupdated\", { \"id\": channelObj.id, \"kind\": that.LIST_EVENT_TYPE.ADD.code, \"label\": that.LIST_EVENT_TYPE.ADD.label });\n            //}\n        });\n    }\n    onAddToChannel(channelInfo) {\n        let that = this;\n        let channelId = channelInfo.id;\n        this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) channelId : \", channelId);\n        //this._logger.log(\"internal\", LOG_ID + \"(onAddToChannel) this._channels : \", this._channels);\n        // Get channel from cache\n        let channel = this.getChannelFromCache(channelId);\n        // Get channel from server\n        this.getChannel(channelId)\n            .then((newChannel) => {\n            // Handle channel creation\n            if (!channel && !newChannel.invited) {\n                let channelObj = this.addOrUpdateChannelToCache(newChannel);\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n                //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) rainbow_channelcreated : \", channelObj.id);\n                that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelObj.id, \"kind\": that.LIST_EVENT_TYPE.ADD.code, \"label\": that.LIST_EVENT_TYPE.ADD.label });\n            }\n            // Handle channel invitation\n            else if (!channel && newChannel.invited) {\n                let channelObj = this.addOrUpdateChannelToCache(newChannel);\n                this.incrementInvitationCounter();\n                //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) evt_internal_channelupdated : \", channelObj.id, \"kind : \", that.LIST_EVENT_TYPE.SUBSCRIBE);\n                that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelObj.id, \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label });\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, newChannel.id);\n            }\n            // Handle change role\n            else if (channel && newChannel.userRole !== this.USER_ROLE.NONE) {\n                channel.userRole = newChannel.userRole;\n                // TODO : this.feedChannel.messages = [];\n                this.retrieveLatests()\n                    .then(() => {\n                    //this._logger.log(\"debug\", LOG_ID + \"(onAddToChannel) retrieveLatests evt_internal_channelupdated : \", channelId, \"kind : \", that.LIST_EVENT_TYPE.SUBSCRIBE);\n                    that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelId, \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label });\n                    //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n                });\n            }\n        });\n    }\n    onRemovedFromChannel(channelInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            let channelId = channelInfo.id;\n            this._logger.log(\"debug\", LOG_ID + \"(onRemovedFromChannel) channelId : \", channelId);\n            let channelDeleted = yield that.removeChannelFromCache(channelId);\n            let channelIdDeleted = channelDeleted ? channelDeleted.id : channelInfo.id;\n            that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelIdDeleted, \"kind\": that.LIST_EVENT_TYPE.DELETE.code, \"label\": that.LIST_EVENT_TYPE.DELETE.label });\n            //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId);\n        });\n    }\n    onSubscribeToChannel(channelInfo) {\n        let that = this;\n        let channelId = channelInfo.id;\n        let subscribersInfo = channelInfo.subscribers;\n        this._logger.log(\"internal\", LOG_ID + \"(onSubscribeToChannel) channelId : \", channelId, \", subscribersInfo : \", subscribersInfo);\n        // Handle invitation case\n        let channel = this.getChannelFromCache(channelId);\n        let subscribers = Number.parseInt(subscribersInfo);\n        if (channel) {\n            channel.invited = false;\n            channel.subscribed = true;\n            channel.subscribers_count = subscribers;\n            //this.feedChannel.messages = [];\n            this.retrieveLatests()\n                .then(() => {\n                that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelId, \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label });\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n            });\n        }\n        // Handle self subscription case\n        else {\n            this.getChannel(channelId)\n                .then((newChannel) => {\n                let channelObj = this.addOrUpdateChannelToCache(newChannel);\n                //this.feedChannel.messages = [];\n                return this.retrieveLatests();\n            })\n                .then(() => {\n                that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelId, \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label });\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId);\n            });\n        }\n    }\n    onUnsubscribeToChannel(channelInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            let channelId = channelInfo.id;\n            let subscribersInfo = channelInfo.subscribers;\n            this._logger.log(\"internal\", LOG_ID + \"(onUnsubscribeToChannel) channelId : \", channelId, \", subscribersInfo : \", subscribersInfo);\n            let subscribers = Number.parseInt(subscribersInfo);\n            let channel = yield this.fetchChannel(channelId);\n            if (channel) {\n                channel.subscribers_count = subscribers;\n                channel.subscribed = false;\n            }\n            // Update messagesList\n            //this.feedChannel.messages = [];\n            this.retrieveLatests().then(() => {\n                that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelId, \"kind\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.label });\n                //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId);\n            });\n        });\n    }\n    onDeleteChannel(channelInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            let channelId = channelInfo.id;\n            this._logger.log(\"debug\", LOG_ID + \"(onDeleteChannel) channelId : \", channelId);\n            let channelDeleted = yield that.removeChannelFromCache(channelId);\n            let channelIdDeleted = channelDeleted ? channelDeleted.id : channelInfo.id;\n            that._eventEmitter.emit(\"evt_internal_channelupdated\", { 'id': channelIdDeleted, \"kind\": that.LIST_EVENT_TYPE.DELETE.code, \"label\": that.LIST_EVENT_TYPE.DELETE.label });\n            //this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId);\n        });\n    }\n    onUserSubscribeEvent(info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            this._logger.log(\"internal\", LOG_ID + \"(onUserSubscribeEvent) channelId : \", info.id, \", subscribersInfo : \", info.subscribers);\n            let channel = yield this.fetchChannel(info.id);\n            if (channel) {\n                channel.subscribers_count = info.subscribers;\n            }\n            that._eventEmitter.emit(\"evt_internal_channelusersubscription\", { 'id': info.id, 'userId': info.userId, \"kind\": that.LIST_EVENT_TYPE.SUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.SUBSCRIBE.label });\n            //this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId, userId);\n        });\n    }\n    onUserUnsubscribeEvent(info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let that = this;\n            this._logger.log(\"internal\", LOG_ID + \"(onUserUnsubscribeEvent) channelId : \", info.id, \", subscribersInfo : \", info.subscribers);\n            let channel = yield this.fetchChannel(info.id);\n            if (channel) {\n                channel.subscribers_count = info.subscribers;\n            }\n            that._eventEmitter.emit(\"evt_internal_channelusersubscription\", { 'id': info.id, 'userId': info.userId, \"kind\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.code, \"label\": that.LIST_EVENT_TYPE.UNSUBSCRIBE.label });\n            //this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId, userId);\n        });\n    }\n};\nChannels = __decorate([\n    Utils_1.logEntryExit(LOG_ID),\n    Utils_1.isStarted([])\n    /**\n     * @module\n     * @name Channels\n     * @version 1.67.1 \n     * @public\n     * @description\n     *      This service manages Channels. This service is in Beta.\n     *      <br><br>\n     *      The main methods proposed in that module allow to: <br>\n     *      - Create a new channel <br>\n     *      - Manage a channel: update, delete <br>\n     *      - Manage users in a channel <br>\n     */\n], Channels);\nexports.ChannelsService = Channels;\nmodule.exports.ChannelsService = Channels;\n//# sourceMappingURL=ChannelsService.js.map"]},"metadata":{},"sourceType":"script"}