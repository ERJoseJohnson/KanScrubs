{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Conversation_1 = require(\"../common/models/Conversation\");\n\nconst Emoji_1 = require(\"../common/Emoji\");\n\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"IM/SVCE - \";\nlet IMService =\n/**\r\n * @module\r\n * @name IMService\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This module manages Instant Messages. It allows to send messages to a user or a bubble.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Send a message to a user <br>\r\n *      - Send a message to a bubble <br>\r\n *      - Mark a message as read <br>\r\n */\nclass IMService {\n  constructor(_eventEmitter, _logger, _imOptions, _startConfig) {\n    this.ready = false;\n    this._startConfig = _startConfig;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._conversations = null;\n    this._logger = _logger;\n    this._eventEmitter = _eventEmitter;\n    this._pendingMessages = {};\n    this._imOptions = _imOptions;\n\n    this._eventEmitter.on(\"evt_internal_onreceipt\", this._onmessageReceipt.bind(this));\n\n    this.ready = false;\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._conversations = _core.conversations;\n        that._bulles = _core.bubbles;\n        that._fileStorage = _core.fileStorage;\n        that._presence = _core.presence;\n        that.ready = true;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = null;\n        that.ready = false;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @since 1.39\r\n   * @method getMessagesFromConversation\r\n   * @instance\r\n   * @description\r\n   *    <b>(beta)</b> Retrieve the list of messages from a conversation <br/>\r\n   *    Calling several times this method will load older message from the history (pagination) <br/>\r\n   * @param {Conversation} conversation The conversation\r\n   * @param {Number} intNbMessage The number of messages to retrieve. Optional. Default value is 30. Maximum value is 100\r\n   * @async\r\n   * @return {Promise<Conversation, ErrorManager>}\r\n   * @fulfil {Conversation, ErrorManager} Return the conversation updated with the list of messages requested or an error (reject) if there is no more messages to retrieve\r\n   * @category async\r\n   */\n\n\n  getMessagesFromConversation(conversation, intNbMessage) {\n    if (!conversation) {\n      return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n        msg: \"Parameter 'conversation' is missing or null\"\n      }));\n    }\n\n    intNbMessage = intNbMessage ? Math.min(intNbMessage, 100) : 30;\n    return this._conversations.getHistoryPage(conversation, intNbMessage);\n  }\n  /**\r\n   * @public\r\n   * @since 1.39\r\n   * @method getMessageFromConversationById\r\n   * @instance\r\n   * @description\r\n   *    <b>(beta)</b> Retrieve a specific message in a conversation using its id <br/>\r\n   * @param {Conversation} conversation The conversation where to search for the message\r\n   * @param {String} strMessageId The message id\r\n   * @return {Message} The message if found or null\r\n   */\n\n\n  getMessageFromConversationById(conversation, strMessageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!conversation) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'conversation' is missing or null\"\n        });\n      }\n\n      if (!strMessageId) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessageId' is missing or empty\"\n        });\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(getMessageFromConversationById) conversation : \", conversation, \", strMessageId : \", strMessageId);\n\n      let message = conversation.getMessageById(strMessageId); // Add FileDescriptor if needed\n\n      if (message && message.oob && message.oob.url) {\n        message.shortFileDescriptor = yield that._fileStorage.getFileDescriptorById(message.oob.url.substring(message.oob.url.lastIndexOf(\"/\") + 1));\n      }\n\n      return message;\n    });\n  }\n  /**\r\n   * @public\r\n   * @since 1.39\r\n   * @method getMessageFromBubbleById\r\n   * @instance\r\n   * @description\r\n   *    Retrieve a specific message in a bubble using its id <br/>\r\n   * @param {Bubble} bubble The bubble where to search for the message\r\n   * @param {String} strMessageId The message id\r\n   * @return {Message} The message if found or null\r\n   */\n\n\n  getMessageFromBubbleById(bubble, strMessageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!bubble) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'bubble' is missing or null\"\n        });\n      }\n\n      if (!strMessageId) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessageId' is missing or empty\"\n        });\n      }\n\n      let conversation = yield that._conversations.getConversationByBubbleId(bubble.id);\n\n      if (!conversation) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'bubble' don't have a conversation\"\n        });\n      }\n\n      if (conversation.type !== Conversation_1.Conversation.Type.ROOM) {\n        return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'conversation' is not a bubble conversation\"\n        });\n      }\n\n      that._logger.log(\"internal\", LOG_ID + \"(getMessageFromBubbleById) conversation : \", conversation, \", strMessageId : \", strMessageId);\n\n      let message = conversation.getMessageById(strMessageId);\n\n      if (message && message.oob && message.oob.url) {\n        let fileDescriptorId = message.oob.url.substring(message.oob.url.lastIndexOf(\"/\") + 1);\n\n        that._logger.log(\"internal\", LOG_ID + \"(getMessageFromBubbleById) oob url defined so build shortFileDescriptor :\", fileDescriptorId);\n\n        message.shortFileDescriptor = yield that._fileStorage.getFileDescriptorById(fileDescriptorId);\n      }\n\n      return message;\n    });\n  }\n  /**\r\n   * @public\r\n   * @since 1.39\r\n   * @method sendMessageToConversation\r\n   * @instance\r\n   * @description\r\n   *    <b>(beta)</b> Send a instant message to a conversation<br>\r\n   *    This method works for sending messages to a one-to-one conversation or to a bubble conversation\r\n   * @param {Conversation} conversation The conversation recipient\r\n   * @param {String} message The message to send\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToConversation(conversation, message, lang, content, subject) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!conversation) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'conversation' parameter.\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'conversation' parameter : \", conversation);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'conversation' is missing or null\"\n        }));\n      }\n\n      if (!message) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'message' parameter.\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'message' parameter : \", message);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'message' is missing or null\"\n        }));\n      }\n\n      if (message.length > that._imOptions.messageMaxLength) {\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\"\n        }));\n      }\n\n      let msgSent = undefined; //Promise.reject(Object.assign(ErrorManager.getErrorManager().BAD_REQUEST, {msg: \" sent message failed.\"}));\n\n      if (this._useXMPP) {\n        msgSent = conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE ? this.sendMessageToJid(message, conversation.id, lang, content, subject) : this.sendMessageToBubbleJid(message, conversation.id, lang, content, subject, undefined);\n      }\n\n      if (this._useS2S) {\n        /*\r\n        {\r\n        \"message\": {\r\n        \"subject\": \"Greeting\",\r\n        \"lang\": \"en\",\r\n        \"contents\": [\r\n        {\r\n        \"type\": \"text/markdown\",\r\n        \"data\": \"## Hello Bob\"\r\n        }\r\n        ],\r\n        \"body\": \"Hello world\"\r\n        }\r\n        }\r\n         */\n        let msg = {\n          \"message\": {\n            \"subject\": subject,\n            \"lang\": lang,\n            \"contents\": content,\n            // [\n            // {\n            //     \"type\": \"text/markdown\",\n            //     \"data\": \"## Hello Bob\"\n            // }\n            // ],\n            \"body\": message\n          }\n        };\n\n        if (!conversation.dbId) {\n          conversation = yield this._conversations.createServerConversation(conversation);\n\n          this._logger.log(\"internal\", LOG_ID + \"(sendMessageToConversation) conversation : \", conversation);\n        }\n\n        msgSent = this._s2s.sendMessageInConversation(conversation.dbId, msg);\n      }\n\n      return msgSent.then(messageSent => {\n        this._conversations.storePendingMessage(conversation, messageSent); //conversation.messages.push(messageSent);\n        //this.conversations.getServerConversations();\n\n\n        return messageSent;\n      });\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToContact\r\n   * @instance\r\n   * @description\r\n   *  Send a one-2-one message to a contact\r\n   * @param {String} message The message to send\r\n   * @param {Contact} contact The contact (should have at least a jid_im property)\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToContact(message, contact, lang, content, subject) {\n    if (!contact || !contact.jid_im) {\n      this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'contact' parameter.\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'contact' parameter : \", contact);\n\n      return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n        msg: \"Parameter 'contact' is missing or null\"\n      }));\n    }\n\n    return this.sendMessageToJid(message, contact.jid_im, lang, content, subject);\n  }\n  /**\r\n   * @private\r\n   * @description\r\n   *      Store the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n   *      It allow to give back the status of the sending process.\r\n   * @param conversation\r\n   * @param message\r\n   */\n\n  /*storePendingMessage(message) {\r\n      this._pendingMessages[message.id] = {\r\n  //            conversation: conversation,\r\n          message: message\r\n      };\r\n  } // */\n\n  /**\r\n   * @private\r\n   * @description\r\n   *      delete the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n   *      It allow to give back the status of the sending process.\r\n   * @param message\r\n   */\n\n  /* removePendingMessage(message) {\r\n      delete this._pendingMessages[message.id];\r\n  } // */\n\n\n  _onmessageReceipt(receipt) {\n    let that = this;\n    return;\n    /*if (this._pendingMessages[receipt.id]) {\r\n        let messagePending = this._pendingMessages[receipt.id].message;\r\n        that._logger.log(\"warn\", LOG_ID + \"(_onmessageReceipt) the pending message received from server, so remove from pending\", messagePending);\r\n        this.removePendingMessage(messagePending);\r\n    }\r\n    that._logger.log(\"warn\", LOG_ID + \"(_onmessageReceipt) the pending messages : \", that._pendingMessages);\r\n    // */\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToJid\r\n   * @instance\r\n   * @description\r\n   *  Send a one-2-one message to a contact identified by his Jid\r\n   * @param {String} message The message to send\r\n   * @param {String} jid The contact Jid\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} - the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToJid(message, jid, lang, content, subject) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!lang) {\n        lang = \"en\";\n      }\n\n      if (!message) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) bad or empty 'message' parameter.\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJid) bad or empty 'message' parameter : \", message);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'message' parameter\"\n        }));\n      } // Check size of the message\n\n\n      let messageSize = message.length;\n\n      if (content && content.message && typeof content.message === \"string\") {\n        messageSize += content.message.length;\n      }\n\n      if (messageSize > that._imOptions.messageMaxLength) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) message not sent. The content is too long (\" + messageSize + \")\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\"\n        }));\n      }\n\n      if (!jid) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) bad or empty 'jid' parameter\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'jid' parameter\"\n        }));\n      }\n\n      let messageUnicode = Emoji_1.shortnameToUnicode(message);\n      jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\n      let messageSent = Promise.reject();\n\n      if (this._useXMPP) {\n        messageSent = yield this._xmpp.sendChatMessage(messageUnicode, jid, lang, content, subject, undefined);\n      }\n      /*\r\n      this.storePendingMessage(messageSent);\r\n      await utils.until(() => {\r\n             return this._pendingMessages[messageSent.id] === undefined;\r\n          }\r\n          , \"Wait for the send chat message to be received by server\", 30000);\r\n      this.removePendingMessage(messageSent);\r\n      this._logger.log(\"debug\", LOG_ID + \"(sendMessageToJid) _exiting_\");\r\n      // */\n\n\n      return messageSent;\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToJidAnswer\r\n   * @instance\r\n   * @description\r\n   *  Send a reply to a one-2-one message to a contact identified by his Jid\r\n   * @param {String} message The message to send\r\n   * @param {String} jid The contact Jid\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @param {String} [answeredMsg] The message answered\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} - the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToJidAnswer(message, jid, lang, content, subject, answeredMsg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!lang) {\n        lang = \"en\";\n      }\n\n      if (!message) {\n        this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'message' parameter.\");\n\n        this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'message' parameter : \", message);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'message' parameter\"\n        }));\n      }\n\n      let typofansweredMsg = answeredMsg instanceof Object;\n\n      if (!typofansweredMsg && answeredMsg !== null) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad  'answeredMsg' parameter.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJidAnswer) bad  'answeredMsg' parameter : \", answeredMsg);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad 'answeredMsg' parameter\"\n        }));\n      } // Check size of the message\n\n\n      let messageSize = message.length;\n\n      if (content && content.message && typeof content.message === \"string\") {\n        messageSize += content.message.length;\n      }\n\n      if (messageSize > that._imOptions.messageMaxLength) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) message not sent. The content is too long (\" + messageSize + \")\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\"\n        }));\n      }\n\n      if (!jid) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'jid' parameter\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'jid' parameter\"\n        }));\n      }\n\n      let messageUnicode = Emoji_1.shortnameToUnicode(message);\n      jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\n      let messageSent = yield this._xmpp.sendChatMessage(messageUnicode, jid, lang, content, subject, answeredMsg);\n      /*\r\n      this.storePendingMessage(messageSent);\r\n      await utils.until(() => {\r\n             return this._pendingMessages[messageSent.id] === undefined;\r\n          }\r\n          , \"Wait for the send chat message to be received by server\", 30000);\r\n      this.removePendingMessage(messageSent);\r\n      this._logger.log(\"debug\", LOG_ID + \"(sendMessageToJid) _exiting_\");\r\n      // */\n\n      return messageSent;\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToBubble\r\n   * @instance\r\n   * @description\r\n   *  Send a message to a bubble\r\n   * @param {String} message The message to send\r\n   * @param {Bubble} bubble The bubble (should at least have a jid property)\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToBubble(message, bubble, lang, content, subject, mentions) {\n    if (!bubble || !bubble.jid) {\n      this._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubble) bad or empty 'bubble' parameter.\");\n\n      this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubble) bad or empty 'bubble' parameter : \", bubble);\n\n      return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n        msg: \"Bad or empty 'bubble' parameter\"\n      }));\n    }\n\n    return this.sendMessageToBubbleJid(message, bubble.jid, lang, content, subject, mentions);\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToBubbleJid\r\n   * @instance\r\n   * @description\r\n   *  Send a message to a bubble identified by its JID\r\n   * @param {String} message The message to send\r\n   * @param {String} jid The bubble JID\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToBubbleJid(message, jid, lang, content, subject, mentions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!lang) {\n        lang = \"en\";\n      }\n\n      if (!message) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'message' parameter.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'message' parameter : \", message);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'message' parameter\"\n        }));\n      } // Check size of the message\n\n\n      let messageSize = message.length;\n\n      if (content && content.message && typeof content.message === \"string\") {\n        messageSize += content.message.length;\n      }\n\n      if (messageSize > that._imOptions.messageMaxLength) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJid) message not sent. The content is too long (\" + messageSize + \")\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\"\n        }));\n      }\n\n      if (!jid) {\n        that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'jid' parameter\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'jid' parameter\"\n        }));\n      }\n\n      let messageUnicode = Emoji_1.shortnameToUnicode(message);\n      jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(jid);\n      let bubble = yield that._bulles.getBubbleByJid(jid);\n\n      that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJid) getBubbleByJid \", bubble);\n\n      if (bubble.isActive) {\n        let messageSent1 = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, undefined, mentions);\n\n        return messageSent1;\n      } else {\n        try {\n          that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) bubble is not active, so resume it before send the message.\");\n\n          that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJid) bubble is not active, so resume it before send the message. bubble : \", bubble);\n\n          yield that._presence.sendInitialBubblePresence(bubble.jid); //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) sendInitialBubblePresence succeed \");\n\n          yield Utils_1.until(() => {\n            return bubble.isActive === true;\n          }, \"Wait for the Bubble \" + bubble.jid + \" to be active\"); //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) until succeed, so the bubble is now active, send the message.\");\n\n          let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, undefined, mentions);\n\n          return messageSent;\n        } catch (err) {\n          return Promise.reject({\n            message: \"The sending message process failed!\",\n            error: err\n          });\n        }\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendMessageToBubbleJidAnswer\r\n   * @instance\r\n   * @description\r\n   *  Send a message to a bubble identified by its JID\r\n   * @param {String} message The message to send\r\n   * @param {String} jid The bubble JID\r\n   * @param {String} [lang=en] The content language used\r\n   * @param {Object} [content] Allow to send alternative text base content\r\n   * @param {String} [content.type=text/markdown] The content message type\r\n   * @param {String} [content.message] The content message body\r\n   * @param {String} [subject] The message subject\r\n   * @param {String} [answeredMsg] The message answered\r\n   * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n   * @async\r\n   * @return {Promise<Message, ErrorManager>}\r\n   * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n   * @category async\r\n   */\n\n\n  sendMessageToBubbleJidAnswer(message, jid, lang, content, subject, answeredMsg, mentions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (!lang) {\n        lang = \"en\";\n      }\n\n      if (!message) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'message' parameter.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'message' parameter : \", message);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'message' parameter\"\n        }));\n      }\n\n      let typofansweredMsg = answeredMsg instanceof Object;\n\n      if (!typofansweredMsg && answeredMsg !== null) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad  'answeredMsg' parameter.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad  'answeredMsg' parameter : \", answeredMsg);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad 'answeredMsg' parameter\"\n        }));\n      } // Check size of the message\n\n\n      let messageSize = message.length;\n\n      if (content && content.message && typeof content.message === \"string\") {\n        messageSize += content.message.length;\n      }\n\n      if (messageSize > that._imOptions.messageMaxLength) {\n        that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) message not sent. The content is too long (\" + messageSize + \")\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\"\n        }));\n      }\n\n      if (!jid) {\n        that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'jid' parameter\", jid);\n\n        return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Bad or empty 'jid' parameter\"\n        }));\n      }\n\n      let messageUnicode = Emoji_1.shortnameToUnicode(message);\n      jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(jid);\n      let bubble = yield that._bulles.getBubbleByJid(jid);\n\n      that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJidAnswer) getBubbleByJid \", bubble);\n\n      if (bubble.isActive) {\n        let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, answeredMsg, mentions);\n\n        return messageSent;\n      } else {\n        try {\n          that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bubble is not active, so resume it before send the message.\");\n\n          that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bubble is not active, so resume it before send the message. bubble : \", bubble);\n\n          yield that._xmpp.sendInitialBubblePresence(bubble.jid); //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) sendInitialBubblePresence succeed \");\n\n          yield Utils_1.until(() => {\n            return bubble.isActive === true;\n          }, \"Wait for the Bubble \" + bubble.jid + \" to be active\"); //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) until succeed, so the bubble is now active, send the message.\");\n\n          let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, answeredMsg, mentions);\n\n          return messageSent;\n        } catch (err) {\n          return Promise.reject({\n            message: \"The sending message process failed!\",\n            error: err\n          });\n        }\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @method sendIsTypingStateInBubble\r\n   * @instance IMService\r\n   * @description\r\n   *    Switch the \"is typing\" state in a bubble/room<br>\r\n   * @param {Bubble} bubble The destination bubble\r\n   * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n   * @return {Object} Return a promise with no parameter when succeed.\r\n   */\n\n\n  sendIsTypingStateInBubble(bubble, status) {\n    let that = this;\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      if (!bubble) {\n        return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'bubble' is missing or null\"\n        }));\n      }\n      /* else if (!status) {\r\n          reject(Object.assign( ErrorManager.getErrorManager().BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n      } // */\n      else {\n          if (!bubble.jid) {\n            return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n              msg: \"Parameter 'bubble': this bubble isn't a valid one\"\n            }));\n          } else {\n            that._logger.log(\"internal\", LOG_ID + \"sendIsTypingStateInBubble - bubble : \", bubble, \"status : \", status);\n\n            that._conversations.getBubbleConversation(bubble.jid, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined).then(function (conversation) {\n              return __awaiter(this, void 0, void 0, function* () {\n                if (!conversation) {\n                  return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), {\n                    msg: \"No 'conversation' found for this bubble\"\n                  }));\n                } else {\n                  yield that._xmpp.sendIsTypingState(conversation, status); //conversationService.sendIsTypingState(conversation, status);\n\n                  resolve();\n                }\n              });\n            }).catch(err => {\n              return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), {\n                msg: \"No 'conversation' found for this bubble : \" + err\n              }));\n            });\n          }\n        }\n    }));\n  } // */\n\n  /**\r\n   * @public\r\n   * @method sendIsTypingStateInConversation\r\n   * @instance IMService\r\n   * @description\r\n   *    Switch the \"is typing\" state in a conversation<br>\r\n   * @param {Conversation} conversation The conversation recipient\r\n   * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n   * @return Return a promise with no parameter when succeed\r\n   */\n\n\n  sendIsTypingStateInConversation(conversation, status) {\n    let that = this;\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      if (!conversation) {\n        return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n          msg: \"Parameter 'conversation' is missing or null\"\n        }));\n      }\n      /* else if (!status) {\r\n          reject(Object.assign( ErrorManager.getErrorManager().BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n      } // */\n      else {\n          conversation = conversation.id ? that._conversations.getConversationById(conversation.id) : null;\n\n          if (!conversation) {\n            return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), {\n              msg: \"Parameter 'conversation': this conversation doesn't exist\"\n            }));\n          } else {\n            yield that._xmpp.sendIsTypingState(conversation, status);\n            resolve();\n          }\n        }\n    }));\n  }\n  /**\r\n   * @public\r\n   * @method markMessageAsRead\r\n   * @instance\r\n   * @description\r\n   *  Send a 'read' receipt to the recipient\r\n   * @param {Message} messageReceived The message received to mark as read\r\n   * @async\r\n   * @return {Promise}\r\n   * @fulfil {} return nothing in case of success or an ErrorManager Object depending the result\r\n   * @category async\r\n   */\n\n\n  markMessageAsRead(messageReceived) {\n    if (!messageReceived) {\n      this._logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) bad or empty 'messageReceived' parameter\");\n\n      return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, {\n        msg: \"Bad or empty 'messageReceived' parameter\"\n      }));\n    }\n\n    if (messageReceived.isEvent) {\n      this._logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No receipt for 'event' message\");\n\n      return ErrorManager_1.ErrorManager.getErrorManager().OK;\n    }\n\n    this._logger.log(\"internal\", LOG_ID + \"(markMessageAsRead) 'messageReceived' parameter : \", messageReceived);\n\n    if (this._useXMPP) {\n      return this._xmpp.markMessageAsRead(messageReceived);\n    }\n\n    if (this._useS2S) {\n      if (messageReceived.conversation) {\n        let conversationId = messageReceived.conversation.dbId ? messageReceived.conversation.dbId : messageReceived.conversation.id;\n        let messageId = messageReceived.id;\n        return this._rest.markMessageAsRead(conversationId, messageId);\n      } else {\n        return Promise.reject('No conversation found in message.');\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   * @method enableCarbon\r\n   * @instance\r\n   * @description\r\n   *      Enable message carbon XEP-0280\r\n   * @async\r\n   * @return {Promise}\r\n   * @fulfil {} return nothing in case of success or an ErrorManager Object depending the result\r\n   * @category async\r\n   */\n\n\n  enableCarbon() {\n    let that = this;\n    return new Promise(resolve => {\n      if (this._useXMPP) {\n        that._eventEmitter.once(\"rainbow_oncarbonactivated\", function fn_oncarbonactivated() {\n          that._logger.log(\"info\", LOG_ID + \"(enableCarbon) XEP-280 Message Carbon activated\");\n\n          that._eventEmitter.removeListener(\"rainbow_oncarbonactivated\", fn_oncarbonactivated);\n\n          resolve();\n        });\n\n        that._xmpp.enableCarbon();\n      } else if (this._useS2S) {\n        resolve();\n      } else {\n        resolve();\n      }\n    });\n  }\n\n};\nIMService = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n * @module\r\n * @name IMService\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This module manages Instant Messages. It allows to send messages to a user or a bubble.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Send a message to a user <br>\r\n *      - Send a message to a bubble <br>\r\n *      - Mark a message as read <br>\r\n */\n], IMService);\nexports.IMService = IMService;\nmodule.exports.IMService = IMService;","map":{"version":3,"sources":["../../src/lib/services/ImsService.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,MAAA,cAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,+BAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAUA,MAAM,MAAM,GAAG,YAAf;AAiBA,IAAM,SAAS;AAbf;;;;;;;;;;;;;AAaA,MAAM,SAAN,CAAe;AAwBX,EAAA,WAAA,CAAY,aAAZ,EAA0C,OAA1C,EAA4D,UAA5D,EAAwE,YAAxE,EAAoF;AAf7E,SAAA,KAAA,GAAiB,KAAjB;AAgBH,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,QAAL,GAAgB,EAAhB;AACA,SAAK,QAAL,GAAgB,KAAhB;AACA,SAAK,OAAL,GAAe,KAAf;AACA,SAAK,cAAL,GAAsB,IAAtB;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,gBAAL,GAAwB,EAAxB;AACA,SAAK,UAAL,GAAkB,UAAlB;;AAEA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,wBAAtB,EAAgD,KAAK,iBAAL,CAAuB,IAAvB,CAA4B,IAA5B,CAAhD;;AACA,SAAK,KAAL,GAAa,KAAb;AAGH;;AAtBD,MAAI,WAAJ,GAAe;AACX,WAAO,KAAK,YAAZ;AACH;;AAsBD,EAAA,KAAK,CAAC,QAAD,EAAW,KAAX,EAAuB;AACxB,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AACvC,UAAI;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,KAAK,CAAC,KAAnB;AACA,QAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB;AACA,QAAA,IAAI,CAAC,IAAL,GAAY,KAAK,CAAC,IAAlB;AACA,QAAA,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,QAAL,CAAc,OAA9B;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,IAAI,CAAC,QAAL,CAAc,MAA7B;AACA,QAAA,IAAI,CAAC,cAAL,GAAsB,KAAK,CAAC,aAA5B;AACA,QAAA,IAAI,CAAC,OAAL,GAAe,KAAK,CAAC,OAArB;AACA,QAAA,IAAI,CAAC,YAAL,GAAoB,KAAK,CAAC,WAA1B;AACA,QAAA,IAAI,CAAC,SAAL,GAAiB,KAAK,CAAC,QAAvB;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AACA,QAAA,OAAO;AAEV,OAdD,CAcE,OAAO,GAAP,EAAY;AACV,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KAlBM,CAAP;AAmBH;;AAED,EAAA,IAAI,GAAA;AACA,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AACvC,UAAI;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,KAAb;AACA,QAAA,OAAO;AAEV,OALD,CAKE,OAAO,GAAP,EAAY;AACV,eAAO,MAAM,CAAC,GAAD,CAAb;AACH;AACJ,KATM,CAAP;AAUH;AAED;;;;;;;;;;;;;;;;;AAeA,EAAA,2BAA2B,CAAC,YAAD,EAAe,YAAf,EAA2B;AAClD,QAAI,CAAC,YAAL,EAAmB;AACf,aAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,QAAA,GAAG,EAAE;AAAN,OAA3D,CAAf,CAAP;AACH;;AAED,IAAA,YAAY,GAAG,YAAY,GACrB,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,GAAvB,CADqB,GAErB,EAFN;AAGA,WAAO,KACF,cADE,CAEF,cAFE,CAEa,YAFb,EAE2B,YAF3B,CAAP;AAIH;AAED;;;;;;;;;;;;;AAWM,EAAA,8BAA8B,CAAC,YAAD,EAAe,YAAf,EAA2B;;AAC3D,UAAI,IAAI,GAAG,IAAX;;AAEA,UAAI,CAAC,YAAL,EAAmB;AACf,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,UAAI,CAAC,YAAL,EAAmB;AACf,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,kDAAtC,EAA0F,YAA1F,EAAwG,mBAAxG,EAA6H,YAA7H;;AAEA,UAAI,OAAO,GAAG,YAAY,CAAC,cAAb,CAA4B,YAA5B,CAAd,C,CAEA;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,GAAnB,IAA0B,OAAO,CAAC,GAAR,CAAY,GAA1C,EAA+C;AAC3C,QAAA,OAAO,CAAC,mBAAR,GAA8B,MAAM,IAAI,CAAC,YAAL,CAAkB,qBAAlB,CAAwC,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAgB,SAAhB,CAA0B,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAgB,WAAhB,CAA4B,GAA5B,IAAmC,CAA7D,CAAxC,CAApC;AACH;;AACD,aAAO,OAAP;AACH,K;AAAA;AAED;;;;;;;;;;;;;AAWM,EAAA,wBAAwB,CAAC,MAAD,EAAS,YAAT,EAAqB;;AAC/C,UAAI,IAAI,GAAG,IAAX;;AAEA,UAAI,CAAC,MAAL,EAAa;AACT,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,UAAI,CAAC,YAAL,EAAmB;AACf,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,UAAI,YAAY,GAAG,MAAM,IAAI,CAAC,cAAL,CAAoB,yBAApB,CAA8C,MAAM,CAAC,EAArD,CAAzB;;AAEA,UAAI,CAAC,YAAL,EAAmB;AACf,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,UAAI,YAAY,CAAC,IAAb,KAAsB,cAAA,CAAA,YAAA,CAAa,IAAb,CAAkB,IAA5C,EAAkD;AAC9C,eAAO,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAP;AACH;;AAED,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,4CAAtC,EAAoF,YAApF,EAAkG,mBAAlG,EAAuH,YAAvH;;AAEA,UAAI,OAAO,GAAI,YAAY,CAAC,cAAb,CAA4B,YAA5B,CAAf;;AAEA,UAAI,OAAO,IAAI,OAAO,CAAC,GAAnB,IAA0B,OAAO,CAAC,GAAR,CAAY,GAA1C,EAA+C;AAC3C,YAAI,gBAAgB,GAAG,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAgB,SAAhB,CAA0B,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAgB,WAAhB,CAA4B,GAA5B,IAAmC,CAA7D,CAAvB;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,2EAAtC,EAAmH,gBAAnH;;AACA,QAAA,OAAO,CAAC,mBAAR,GAA8B,MAAM,IAAI,CAAC,YAAL,CAAkB,qBAAlB,CAAwC,gBAAxC,CAApC;AACH;;AAED,aAAO,OAAP;AACH,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBM,EAAA,yBAAyB,CAAC,YAAD,EAAe,OAAf,EAAwB,IAAxB,EAA8B,OAA9B,EAAuC,OAAvC,EAA8C;;AACzE,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI,CAAC,YAAL,EAAmB;AACf,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,+DAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,iEAA3C,EAA8G,YAA9G;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,CAAC,OAAL,EAAc;AACV,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0DAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,4DAA3C,EAAyG,OAAzG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,OAAO,CAAC,MAAR,GAAiB,IAAI,CAAC,UAAL,CAAgB,gBAArC,EAAuD;AACnD,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE,iDAAiD,IAAI,CAAC,UAAL,CAAgB,gBAAjE,GAAoF;AAA1F,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,OAAO,GAAS,SAApB,C,CAA+B;;AAC/B,UAAI,KAAK,QAAT,EAAmB;AACf,QAAA,OAAO,GAAG,YAAY,CAAC,IAAb,KAAsB,cAAA,CAAA,YAAA,CAAa,IAAb,CAAkB,UAAxC,GAAqD,KAAK,gBAAL,CAAsB,OAAtB,EAA+B,YAAY,CAAC,EAA5C,EAAgD,IAAhD,EAAsD,OAAtD,EAA+D,OAA/D,CAArD,GAA+H,KAAK,sBAAL,CAA4B,OAA5B,EAAqC,YAAY,CAAC,EAAlD,EAAsD,IAAtD,EAA4D,OAA5D,EAAqE,OAArE,EAA8E,SAA9E,CAAzI;AACH;;AACD,UAAK,KAAK,OAAV,EAAoB;AAChB;;;;;;;;;;;;;;;AAeA,YAAI,GAAG,GAAG;AACN,qBAAW;AACP,uBAAW,OADJ;AAEP,oBAAQ,IAFD;AAGP,wBACA,OAJO;AAKP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAQ;AAXD;AADL,SAAV;;AAgBA,YAAI,CAAC,YAAY,CAAC,IAAlB,EAAwB;AACpB,UAAA,YAAY,GAAG,MAAM,KAAK,cAAL,CAAoB,wBAApB,CAA6C,YAA7C,CAArB;;AACA,eAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,6CAAtC,EAAqF,YAArF;AACH;;AAED,QAAA,OAAO,GAAG,KAAK,IAAL,CAAU,yBAAV,CAAoC,YAAY,CAAC,IAAjD,EAAuD,GAAvD,CAAV;AACH;;AAED,aAAO,OAAO,CAAC,IAAR,CAAc,WAAD,IAAgB;AAChC,aAAK,cAAL,CAAoB,mBAApB,CAAwC,YAAxC,EAAsD,WAAtD,EADgC,CAEhC;AACA;;;AACA,eAAO,WAAP;AACH,OALM,CAAP;AAOH,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;AAkBA,EAAA,oBAAoB,CAAC,OAAD,EAAU,OAAV,EAAmB,IAAnB,EAAyB,OAAzB,EAAkC,OAAlC,EAAyC;AACzD,QAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,MAAzB,EAAiC;AAC7B,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,0DAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,4DAA3C,EAAyG,OAAzG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,QAAA,GAAG,EAAE;AAAN,OAA3D,CAAf,CAAP;AACH;;AAED,WAAO,KAAK,gBAAL,CAAsB,OAAtB,EAA+B,OAAO,CAAC,MAAvC,EAA+C,IAA/C,EAAqD,OAArD,EAA8D,OAA9D,CAAP;AACH;AAED;;;;;;;;;AAQA;;;;;;;AAOA;;;;;;;;AAOA;;;;;AAIA,EAAA,iBAAiB,CAAC,OAAD,EAAQ;AACrB,QAAI,IAAI,GAAG,IAAX;AACA;AACA;;;;;;;AAOH;AAED;;;;;;;;;;;;;;;;;;;;AAkBM,EAAA,gBAAgB,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAqC;;AACvD,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI,CAAC,IAAL,EAAW;AACP,QAAA,IAAI,GAAG,IAAP;AACH;;AACD,UAAI,CAAC,OAAL,EAAc;AACV,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sDAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,wDAA3C,EAAqG,OAArG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH,O,CAED;;;AACA,UAAI,WAAW,GAAG,OAAO,CAAC,MAA1B;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,OAAnB,IAA8B,OAAO,OAAO,CAAC,OAAf,KAA2B,QAA7D,EAAuE;AACnE,QAAA,WAAW,IAAI,OAAO,CAAC,OAAR,CAAgB,MAA/B;AACH;;AACD,UAAI,WAAW,GAAG,IAAI,CAAC,UAAL,CAAgB,gBAAlC,EAAoD;AAChD,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,gEAAT,GAA4E,WAA5E,GAA0F,GAAnH,EAAwH,GAAxH;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE,iDAAiD,IAAI,CAAC,UAAL,CAAgB,gBAAjE,GAAoF;AAA1F,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,CAAC,GAAL,EAAU;AACN,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iDAAlC,EAAqF,GAArF;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,cAAc,GAAG,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAArB;AAEA,MAAA,GAAG,GAAG,WAAA,CAAA,SAAA,CAAU,YAAV,GAAyB,qBAAzB,CAA+C,GAA/C,CAAN;AAEA,UAAI,WAAW,GAAS,OAAO,CAAC,MAAR,EAAxB;;AAEA,UAAI,KAAK,QAAT,EAAmB;AACd,QAAA,WAAW,GAAG,MAAM,KAAK,KAAL,CAAW,eAAX,CAA2B,cAA3B,EAA2C,GAA3C,EAAgD,IAAhD,EAAsD,OAAtD,EAA+D,OAA/D,EAAwE,SAAxE,CAApB;AACJ;AAED;;;;;;;;;;;AASA,aAAO,WAAP;AACH,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;;AAmBM,EAAA,sBAAsB,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,WAAvC,EAAkD;;AAC1E,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI,CAAC,IAAL,EAAW;AACP,QAAA,IAAI,GAAG,IAAP;AACH;;AAED,UAAI,CAAC,OAAL,EAAc;AACV,aAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4DAAlC;;AACA,aAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8DAA3C,EAA2G,OAA3G;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,gBAAgB,GAAG,WAAW,YAAY,MAA9C;;AACA,UAAI,CAAC,gBAAD,IAAqB,WAAW,KAAK,IAAzC,EAAgD;AAC5C,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0DAA3C,EAAuG,WAAvG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH,O,CAED;;;AACA,UAAI,WAAW,GAAG,OAAO,CAAC,MAA1B;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,OAAnB,IAA8B,OAAO,OAAO,CAAC,OAAf,KAA2B,QAA7D,EAAuE;AACnE,QAAA,WAAW,IAAI,OAAO,CAAC,OAAR,CAAgB,MAA/B;AACH;;AACD,UAAI,WAAW,GAAG,IAAI,CAAC,UAAL,CAAgB,gBAAlC,EAAoD;AAChD,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sEAAT,GAAkF,WAAlF,GAAgG,GAAzH,EAA8H,GAA9H;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE,iDAAiD,IAAI,CAAC,UAAL,CAAgB,gBAAjE,GAAoF;AAA1F,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,CAAC,GAAL,EAAU;AACN,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,uDAAlC,EAA2F,GAA3F;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,cAAc,GAAG,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAArB;AAEA,MAAA,GAAG,GAAG,WAAA,CAAA,SAAA,CAAU,YAAV,GAAyB,qBAAzB,CAA+C,GAA/C,CAAN;AAEA,UAAI,WAAW,GAAG,MAAM,KAAK,KAAL,CAAW,eAAX,CAA2B,cAA3B,EAA2C,GAA3C,EAAgD,IAAhD,EAAsD,OAAtD,EAA+D,OAA/D,EAAwE,WAAxE,CAAxB;AAEA;;;;;;;;;;AASA,aAAO,WAAP;AACH,K;AAAA;AAGD;;;;;;;;;;;;;;;;;;;;;AAmBA,EAAA,mBAAmB,CAAC,OAAD,EAAU,MAAV,EAAkB,IAAlB,EAAwB,OAAxB,EAAiC,OAAjC,EAA0C,QAA1C,EAAkD;AACjE,QAAI,CAAC,MAAD,IAAW,CAAC,MAAM,CAAC,GAAvB,EAA4B;AACxB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,wDAAlC;;AACA,WAAK,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,0DAA3C,EAAuG,MAAvG;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,QAAA,GAAG,EAAE;AAAN,OAA3D,CAAf,CAAP;AACH;;AAED,WAAO,KAAK,sBAAL,CAA4B,OAA5B,EAAqC,MAAM,CAAC,GAA5C,EAAiD,IAAjD,EAAuD,OAAvD,EAAgE,OAAhE,EAAyE,QAAzE,CAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;AAmBM,EAAA,sBAAsB,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,QAAvC,EAA+C;;AACvE,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI,CAAC,IAAL,EAAW;AACP,QAAA,IAAI,GAAG,IAAP;AACH;;AACD,UAAI,CAAC,OAAL,EAAc;AACV,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4DAAlC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,8DAA3C,EAA2G,OAA3G;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH,O,CAED;;;AACA,UAAI,WAAW,GAAG,OAAO,CAAC,MAA1B;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,OAAnB,IAA8B,OAAO,OAAO,CAAC,OAAf,KAA2B,QAA7D,EAAuE;AACnE,QAAA,WAAW,IAAI,OAAO,CAAC,OAAR,CAAgB,MAA/B;AACH;;AACD,UAAI,WAAW,GAAG,IAAI,CAAC,UAAL,CAAgB,gBAAlC,EAAoD;AAChD,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,sEAAT,GAAkF,WAAlF,GAAgG,GAAzH,EAA8H,GAA9H;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE,iDAAiD,IAAI,CAAC,UAAL,CAAgB,gBAAjE,GAAoF;AAA1F,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,CAAC,GAAL,EAAU;AACN,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,uDAAnC,EAA4F,GAA5F;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,cAAc,GAAG,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAArB;AAEA,MAAA,GAAG,GAAG,WAAA,CAAA,SAAA,CAAU,YAAV,GAAyB,qBAAzB,CAA+C,GAA/C,CAAN;AAEA,UAAI,MAAM,GAAG,MAAM,IAAI,CAAC,OAAL,CAAa,cAAb,CAA4B,GAA5B,CAAnB;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,0CAAtC,EAAkF,MAAlF;;AACA,UAAI,MAAM,CAAC,QAAX,EAAqB;AACjB,YAAI,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,uBAAX,CAAmC,cAAnC,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,OAA9D,EAAuE,OAAvE,EAAgF,SAAhF,EAA2F,QAA3F,CAAnB;;AACA,eAAO,YAAP;AACH,OAHD,MAGO;AACH,YAAI;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,sFAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,gGAAtC,EAAwI,MAAxI;;AACA,gBAAM,IAAI,CAAC,SAAL,CAAe,yBAAf,CAAyC,MAAM,CAAC,GAAhD,CAAN,CAHA,CAIA;;AACA,gBAAM,OAAA,CAAA,KAAA,CAAM,MAAK;AACb,mBAAO,MAAM,CAAC,QAAP,KAAoB,IAA3B;AACH,WAFK,EAEH,yBAAyB,MAAM,CAAC,GAAhC,GAAsC,eAFnC,CAAN,CALA,CAQA;;AACA,cAAI,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,uBAAX,CAAmC,cAAnC,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,OAA9D,EAAuE,OAAvE,EAAgF,SAAhF,EAA2F,QAA3F,CAAlB;;AACA,iBAAO,WAAP;AACH,SAXD,CAWE,OAAO,GAAP,EAAY;AACV,iBAAO,OAAO,CAAC,MAAR,CAAe;AAAC,YAAA,OAAO,EAAE,qCAAV;AAAiD,YAAA,KAAK,EAAE;AAAxD,WAAf,CAAP;AACH;AACJ;AACJ,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBM,EAAA,4BAA4B,CAAC,OAAD,EAAU,GAAV,EAAe,IAAf,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,WAAvC,EAAoD,QAApD,EAA4D;;AAC1F,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI,CAAC,IAAL,EAAW;AACP,QAAA,IAAI,GAAG,IAAP;AACH;;AACD,UAAI,CAAC,OAAL,EAAc;AACV,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,kEAAlC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,oEAA3C,EAAiH,OAAjH;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AACD,UAAI,gBAAgB,GAAG,WAAW,YAAY,MAA9C;;AACA,UAAI,CAAC,gBAAD,IAAqB,WAAW,KAAK,IAAzC,EAAgD;AAC5C,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,eAAjB,EAAkC,MAAM,GAAG,gEAA3C,EAA6G,WAA7G;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH,O,CAED;;;AACA,UAAI,WAAW,GAAG,OAAO,CAAC,MAA1B;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,OAAnB,IAA8B,OAAO,OAAO,CAAC,OAAf,KAA2B,QAA7D,EAAuE;AACnE,QAAA,WAAW,IAAI,OAAO,CAAC,OAAR,CAAgB,MAA/B;AACH;;AACD,UAAI,WAAW,GAAG,IAAI,CAAC,UAAL,CAAgB,gBAAlC,EAAoD;AAChD,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,4EAAT,GAAwF,WAAxF,GAAsG,GAA/H,EAAoI,GAApI;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE,iDAAiD,IAAI,CAAC,UAAL,CAAgB,gBAAjE,GAAoF;AAA1F,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,CAAC,GAAL,EAAU;AACN,QAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,6DAAnC,EAAkG,GAAlG;;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAf,CAAP;AACH;;AAED,UAAI,cAAc,GAAG,OAAA,CAAA,kBAAA,CAAmB,OAAnB,CAArB;AAEA,MAAA,GAAG,GAAG,WAAA,CAAA,SAAA,CAAU,YAAV,GAAyB,qBAAzB,CAA+C,GAA/C,CAAN;AAEA,UAAI,MAAM,GAAG,MAAM,IAAI,CAAC,OAAL,CAAa,cAAb,CAA4B,GAA5B,CAAnB;;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,gDAAtC,EAAwF,MAAxF;;AACA,UAAI,MAAM,CAAC,QAAX,EAAqB;AACjB,YAAI,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,uBAAX,CAAmC,cAAnC,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,OAA9D,EAAuE,OAAvE,EAAgF,WAAhF,EAA6F,QAA7F,CAAlB;;AACA,eAAO,WAAP;AACH,OAHD,MAGO;AACH,YAAI;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,OAAjB,EAA0B,MAAM,GAAG,4FAAnC;;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,sGAAtC,EAA8I,MAA9I;;AACA,gBAAM,IAAI,CAAC,KAAL,CAAW,yBAAX,CAAqC,MAAM,CAAC,GAA5C,CAAN,CAHA,CAIA;;AACA,gBAAM,OAAA,CAAA,KAAA,CAAM,MAAK;AACb,mBAAO,MAAM,CAAC,QAAP,KAAoB,IAA3B;AACH,WAFK,EAEH,yBAAyB,MAAM,CAAC,GAAhC,GAAsC,eAFnC,CAAN,CALA,CAQA;;AACA,cAAI,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,uBAAX,CAAmC,cAAnC,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,OAA9D,EAAuE,OAAvE,EAAgF,WAAhF,EAA6F,QAA7F,CAAlB;;AACA,iBAAO,WAAP;AACH,SAXD,CAWE,OAAO,GAAP,EAAY;AACV,iBAAO,OAAO,CAAC,MAAR,CAAe;AAAC,YAAA,OAAO,EAAE,qCAAV;AAAiD,YAAA,KAAK,EAAE;AAAxD,WAAf,CAAP;AACH;AACJ;AACJ,K;AAAA;AAED;;;;;;;;;;;;AAUA,EAAA,yBAAyB,CAAC,MAAD,EAAS,MAAT,EAAe;AACpC,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAO,OAAP,EAAe,MAAf,KAAyB,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACxC,UAAI,CAAC,MAAL,EAAa;AACT,eAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA3D,CAAD,CAAb;AACH;AACD;;;AAHA,WAMK;AACD,cAAI,CAAC,MAAM,CAAC,GAAZ,EAAiB;AACb,mBAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,cAAA,GAAG,EAAE;AAAN,aAA3D,CAAD,CAAb;AACH,WAFD,MAEO;AACH,YAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA8B,MAAM,GAAG,uCAAvC,EAAgF,MAAhF,EAAwF,WAAxF,EAAqG,MAArG;;AAEA,YAAA,IAAI,CAAC,cAAL,CAAoB,qBAApB,CAA0C,MAAM,CAAC,GAAjD,EAAsD,SAAtD,EAAiE,SAAjE,EAA4E,SAA5E,EAAuF,SAAvF,EAAkG,SAAlG,EAA6G,SAA7G,EAAwH,SAAxH,EAAmI,SAAnI,EAA8I,IAA9I,CAAmJ,UAAgB,YAAhB,EAA4B;;AAC3K,oBAAI,CAAC,YAAL,EAAmB;AACf,yBAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,UAA/B,CAA0C,eAA1C,EAA2D,eAA3D,CAAf,EAA4F;AAAC,oBAAA,GAAG,EAAE;AAAN,mBAA5F,CAAD,CAAb;AACH,iBAFD,MAGK;AACD,wBAAM,IAAI,CAAC,KAAL,CAAW,iBAAX,CAA6B,YAA7B,EAA2C,MAA3C,CAAN,CADC,CAED;;AACA,kBAAA,OAAO;AACV;AACJ,e;AAAA,aATD,EASG,KATH,CASU,GAAD,IAAO;AACZ,qBAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,UAA/B,CAA0C,eAA1C,EAA2D,eAA3D,CAAf,EAA4F;AAAC,gBAAA,GAAG,EAAE,+CAA+C;AAArD,eAA5F,CAAD,CAAb;AACH,aAXD;AAYH;AACJ;AAEJ,KA5B2C,CAArC,CAAP;AA6BH,GAhsBU,CAgsBT;;AAEF;;;;;;;;;;;;AAUA,EAAA,+BAA+B,CAAC,YAAD,EAAe,MAAf,EAAqB;AAChD,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAY,CAAO,OAAP,EAAgB,MAAhB,KAA0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACzC,UAAI,CAAC,YAAL,EAAmB;AACf,eAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAc,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA7C,EAA0D;AAAC,UAAA,GAAG,EAAE;AAAN,SAA1D,CAAD,CAAb;AACH;AACD;;;AAHA,WAMK;AACD,UAAA,YAAY,GAAG,YAAY,CAAC,EAAb,GAAkB,IAAI,CAAC,cAAL,CAAoB,mBAApB,CAAwC,YAAY,CAAC,EAArD,CAAlB,GAA6E,IAA5F;;AACA,cAAI,CAAC,YAAL,EAAmB;AACf,mBAAO,MAAM,CAAC,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,UAA/B,CAA0C,eAA1C,EAA2D,eAA3D,CAAf,EAA4F;AAAC,cAAA,GAAG,EAAE;AAAN,aAA5F,CAAD,CAAb;AACH,WAFD,MAEO;AACH,kBAAM,IAAI,CAAC,KAAL,CAAW,iBAAX,CAA6B,YAA7B,EAA2C,MAA3C,CAAN;AACA,YAAA,OAAO;AACV;AACJ;AACJ,KAhB4C,CAAtC,CAAP;AAiBH;AAGD;;;;;;;;;;;;;;AAYA,EAAA,iBAAiB,CAAC,eAAD,EAAgB;AAC7B,QAAI,CAAC,eAAL,EAAsB;AAClB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,8DAAlC;;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,MAAP,CAAe,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,WAA9C,EAA2D;AAAC,QAAA,GAAG,EAAE;AAAN,OAA3D,CAAf,CAAP;AACH;;AAED,QAAI,eAAe,CAAC,OAApB,EAA6B;AACzB,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,oDAAlC;;AACA,aAAO,cAAA,CAAA,YAAA,CAAa,eAAb,GAA+B,EAAtC;AACH;;AAED,SAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,MAAM,GAAG,oDAAtC,EAA4F,eAA5F;;AAEA,QAAI,KAAK,QAAT,EAAmB;AACf,aAAO,KAAK,KAAL,CAAW,iBAAX,CAA6B,eAA7B,CAAP;AACH;;AACD,QAAK,KAAK,OAAV,EAAoB;AAChB,UAAI,eAAe,CAAC,YAApB,EAAkC;AAC9B,YAAI,cAAc,GAAG,eAAe,CAAC,YAAhB,CAA6B,IAA7B,GAAoC,eAAe,CAAC,YAAhB,CAA6B,IAAjE,GAAwE,eAAe,CAAC,YAAhB,CAA6B,EAA1H;AACA,YAAI,SAAS,GAAG,eAAe,CAAC,EAAhC;AACA,eAAO,KAAK,KAAL,CAAW,iBAAX,CAA6B,cAA7B,EAA6C,SAA7C,CAAP;AACH,OAJD,MAIO;AACH,eAAO,OAAO,CAAC,MAAR,CAAe,mCAAf,CAAP;AACH;AACJ;AACJ;AAED;;;;;;;;;;;;;AAWA,EAAA,YAAY,GAAA;AACR,QAAI,IAAI,GAAG,IAAX;AACA,WAAO,IAAI,OAAJ,CAAa,OAAD,IAAY;AAC3B,UAAI,KAAK,QAAT,EAAmB;AACf,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,2BAAxB,EAAqD,SAAS,oBAAT,GAA6B;AAC9E,UAAA,IAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAAjB,EAAyB,MAAM,GAAG,iDAAlC;;AACA,UAAA,IAAI,CAAC,aAAL,CAAmB,cAAnB,CAAkC,2BAAlC,EAA+D,oBAA/D;;AACA,UAAA,OAAO;AACV,SAJD;;AAKA,QAAA,IAAI,CAAC,KAAL,CAAW,YAAX;AACH,OAPD,MAQA,IAAI,KAAK,OAAT,EAAiB;AACb,QAAA,OAAO;AACV,OAFD,MAEO;AACH,QAAA,OAAO;AACV;AACJ,KAdM,CAAP;AAeH;;AAryBU,CAAf;AAAM,SAAS,GAAA,UAAA,CAAA,CAfd,OAAA,CAAA,YAAA,CAAa,MAAb,CAec,EAdd,OAAA,CAAA,SAAA,CAAU,EAAV;AACD;;;;;;;;;;;;;AAae,CAAA,EAAT,SAAS,CAAT;AA4yBE,OAAA,CAAA,SAAA,GAAA,SAAA;AADR,MAAM,CAAC,OAAP,CAAe,SAAf,GAA2B,SAA3B","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Conversation_1 = require(\"../common/models/Conversation\");\r\nconst Emoji_1 = require(\"../common/Emoji\");\r\nconst XMPPUtils_1 = require(\"../common/XMPPUtils\");\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst LOG_ID = \"IM/SVCE - \";\r\nlet IMService = \r\n/**\r\n * @module\r\n * @name IMService\r\n * @version 1.67.1 \r\n * @public\r\n * @description\r\n *      This module manages Instant Messages. It allows to send messages to a user or a bubble.\r\n *      <br><br>\r\n *      The main methods proposed in that module allow to: <br>\r\n *      - Send a message to a user <br>\r\n *      - Send a message to a bubble <br>\r\n *      - Mark a message as read <br>\r\n */\r\nclass IMService {\r\n    constructor(_eventEmitter, _logger, _imOptions, _startConfig) {\r\n        this.ready = false;\r\n        this._startConfig = _startConfig;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._conversations = null;\r\n        this._logger = _logger;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._pendingMessages = {};\r\n        this._imOptions = _imOptions;\r\n        this._eventEmitter.on(\"evt_internal_onreceipt\", this._onmessageReceipt.bind(this));\r\n        this.ready = false;\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = _core._xmpp;\r\n                that._rest = _core._rest;\r\n                that._options = _options;\r\n                that._s2s = _core._s2s;\r\n                that._useXMPP = that._options.useXMPP;\r\n                that._useS2S = that._options.useS2S;\r\n                that._conversations = _core.conversations;\r\n                that._bulles = _core.bubbles;\r\n                that._fileStorage = _core.fileStorage;\r\n                that._presence = _core.presence;\r\n                that.ready = true;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    stop() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = null;\r\n                that.ready = false;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @since 1.39\r\n     * @method getMessagesFromConversation\r\n     * @instance\r\n     * @description\r\n     *    <b>(beta)</b> Retrieve the list of messages from a conversation <br/>\r\n     *    Calling several times this method will load older message from the history (pagination) <br/>\r\n     * @param {Conversation} conversation The conversation\r\n     * @param {Number} intNbMessage The number of messages to retrieve. Optional. Default value is 30. Maximum value is 100\r\n     * @async\r\n     * @return {Promise<Conversation, ErrorManager>}\r\n     * @fulfil {Conversation, ErrorManager} Return the conversation updated with the list of messages requested or an error (reject) if there is no more messages to retrieve\r\n     * @category async\r\n     */\r\n    getMessagesFromConversation(conversation, intNbMessage) {\r\n        if (!conversation) {\r\n            return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is missing or null\" }));\r\n        }\r\n        intNbMessage = intNbMessage\r\n            ? Math.min(intNbMessage, 100)\r\n            : 30;\r\n        return this\r\n            ._conversations\r\n            .getHistoryPage(conversation, intNbMessage);\r\n    }\r\n    /**\r\n     * @public\r\n     * @since 1.39\r\n     * @method getMessageFromConversationById\r\n     * @instance\r\n     * @description\r\n     *    <b>(beta)</b> Retrieve a specific message in a conversation using its id <br/>\r\n     * @param {Conversation} conversation The conversation where to search for the message\r\n     * @param {String} strMessageId The message id\r\n     * @return {Message} The message if found or null\r\n     */\r\n    getMessageFromConversationById(conversation, strMessageId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!conversation) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is missing or null\" });\r\n            }\r\n            if (!strMessageId) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessageId' is missing or empty\" });\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(getMessageFromConversationById) conversation : \", conversation, \", strMessageId : \", strMessageId);\r\n            let message = conversation.getMessageById(strMessageId);\r\n            // Add FileDescriptor if needed\r\n            if (message && message.oob && message.oob.url) {\r\n                message.shortFileDescriptor = yield that._fileStorage.getFileDescriptorById(message.oob.url.substring(message.oob.url.lastIndexOf(\"/\") + 1));\r\n            }\r\n            return message;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @since 1.39\r\n     * @method getMessageFromBubbleById\r\n     * @instance\r\n     * @description\r\n     *    Retrieve a specific message in a bubble using its id <br/>\r\n     * @param {Bubble} bubble The bubble where to search for the message\r\n     * @param {String} strMessageId The message id\r\n     * @return {Message} The message if found or null\r\n     */\r\n    getMessageFromBubbleById(bubble, strMessageId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!bubble) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'bubble' is missing or null\" });\r\n            }\r\n            if (!strMessageId) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessageId' is missing or empty\" });\r\n            }\r\n            let conversation = yield that._conversations.getConversationByBubbleId(bubble.id);\r\n            if (!conversation) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'bubble' don't have a conversation\" });\r\n            }\r\n            if (conversation.type !== Conversation_1.Conversation.Type.ROOM) {\r\n                return Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is not a bubble conversation\" });\r\n            }\r\n            that._logger.log(\"internal\", LOG_ID + \"(getMessageFromBubbleById) conversation : \", conversation, \", strMessageId : \", strMessageId);\r\n            let message = conversation.getMessageById(strMessageId);\r\n            if (message && message.oob && message.oob.url) {\r\n                let fileDescriptorId = message.oob.url.substring(message.oob.url.lastIndexOf(\"/\") + 1);\r\n                that._logger.log(\"internal\", LOG_ID + \"(getMessageFromBubbleById) oob url defined so build shortFileDescriptor :\", fileDescriptorId);\r\n                message.shortFileDescriptor = yield that._fileStorage.getFileDescriptorById(fileDescriptorId);\r\n            }\r\n            return message;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @since 1.39\r\n     * @method sendMessageToConversation\r\n     * @instance\r\n     * @description\r\n     *    <b>(beta)</b> Send a instant message to a conversation<br>\r\n     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation\r\n     * @param {Conversation} conversation The conversation recipient\r\n     * @param {String} message The message to send\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToConversation(conversation, message, lang, content, subject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!conversation) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'conversation' parameter.\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'conversation' parameter : \", conversation);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is missing or null\" }));\r\n            }\r\n            if (!message) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'message' parameter.\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'message' parameter : \", message);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'message' is missing or null\" }));\r\n            }\r\n            if (message.length > that._imOptions.messageMaxLength) {\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\" }));\r\n            }\r\n            let msgSent = undefined; //Promise.reject(Object.assign(ErrorManager.getErrorManager().BAD_REQUEST, {msg: \" sent message failed.\"}));\r\n            if (this._useXMPP) {\r\n                msgSent = conversation.type === Conversation_1.Conversation.Type.ONE_TO_ONE ? this.sendMessageToJid(message, conversation.id, lang, content, subject) : this.sendMessageToBubbleJid(message, conversation.id, lang, content, subject, undefined);\r\n            }\r\n            if ((this._useS2S)) {\r\n                /*\r\n    {\r\n      \"message\": {\r\n        \"subject\": \"Greeting\",\r\n        \"lang\": \"en\",\r\n        \"contents\": [\r\n          {\r\n            \"type\": \"text/markdown\",\r\n            \"data\": \"## Hello Bob\"\r\n          }\r\n        ],\r\n        \"body\": \"Hello world\"\r\n      }\r\n    }\r\n                 */\r\n                let msg = {\r\n                    \"message\": {\r\n                        \"subject\": subject,\r\n                        \"lang\": lang,\r\n                        \"contents\": content,\r\n                        // [\r\n                        // {\r\n                        //     \"type\": \"text/markdown\",\r\n                        //     \"data\": \"## Hello Bob\"\r\n                        // }\r\n                        // ],\r\n                        \"body\": message\r\n                    }\r\n                };\r\n                if (!conversation.dbId) {\r\n                    conversation = yield this._conversations.createServerConversation(conversation);\r\n                    this._logger.log(\"internal\", LOG_ID + \"(sendMessageToConversation) conversation : \", conversation);\r\n                }\r\n                msgSent = this._s2s.sendMessageInConversation(conversation.dbId, msg);\r\n            }\r\n            return msgSent.then((messageSent) => {\r\n                this._conversations.storePendingMessage(conversation, messageSent);\r\n                //conversation.messages.push(messageSent);\r\n                //this.conversations.getServerConversations();\r\n                return messageSent;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToContact\r\n     * @instance\r\n     * @description\r\n     *  Send a one-2-one message to a contact\r\n     * @param {String} message The message to send\r\n     * @param {Contact} contact The contact (should have at least a jid_im property)\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToContact(message, contact, lang, content, subject) {\r\n        if (!contact || !contact.jid_im) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(sendMessageToContact) bad or empty 'contact' parameter.\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToContact) bad or empty 'contact' parameter : \", contact);\r\n            return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'contact' is missing or null\" }));\r\n        }\r\n        return this.sendMessageToJid(message, contact.jid_im, lang, content, subject);\r\n    }\r\n    /**\r\n     * @private\r\n     * @description\r\n     *      Store the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n     *      It allow to give back the status of the sending process.\r\n     * @param conversation\r\n     * @param message\r\n     */\r\n    /*storePendingMessage(message) {\r\n        this._pendingMessages[message.id] = {\r\n//            conversation: conversation,\r\n            message: message\r\n        };\r\n    } // */\r\n    /**\r\n     * @private\r\n     * @description\r\n     *      delete the message in a pending list. This pending list is used to wait the \"_onReceipt\" event from server when a message is sent.\r\n     *      It allow to give back the status of the sending process.\r\n     * @param message\r\n     */\r\n    /* removePendingMessage(message) {\r\n        delete this._pendingMessages[message.id];\r\n    } // */\r\n    _onmessageReceipt(receipt) {\r\n        let that = this;\r\n        return;\r\n        /*if (this._pendingMessages[receipt.id]) {\r\n            let messagePending = this._pendingMessages[receipt.id].message;\r\n            that._logger.log(\"warn\", LOG_ID + \"(_onmessageReceipt) the pending message received from server, so remove from pending\", messagePending);\r\n            this.removePendingMessage(messagePending);\r\n        }\r\n        that._logger.log(\"warn\", LOG_ID + \"(_onmessageReceipt) the pending messages : \", that._pendingMessages);\r\n        // */\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToJid\r\n     * @instance\r\n     * @description\r\n     *  Send a one-2-one message to a contact identified by his Jid\r\n     * @param {String} message The message to send\r\n     * @param {String} jid The contact Jid\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} - the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToJid(message, jid, lang, content, subject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!lang) {\r\n                lang = \"en\";\r\n            }\r\n            if (!message) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) bad or empty 'message' parameter.\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJid) bad or empty 'message' parameter : \", message);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'message' parameter\" }));\r\n            }\r\n            // Check size of the message\r\n            let messageSize = message.length;\r\n            if (content && content.message && typeof content.message === \"string\") {\r\n                messageSize += content.message.length;\r\n            }\r\n            if (messageSize > that._imOptions.messageMaxLength) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) message not sent. The content is too long (\" + messageSize + \")\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\" }));\r\n            }\r\n            if (!jid) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJid) bad or empty 'jid' parameter\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'jid' parameter\" }));\r\n            }\r\n            let messageUnicode = Emoji_1.shortnameToUnicode(message);\r\n            jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\r\n            let messageSent = Promise.reject();\r\n            if (this._useXMPP) {\r\n                messageSent = yield this._xmpp.sendChatMessage(messageUnicode, jid, lang, content, subject, undefined);\r\n            }\r\n            /*\r\n            this.storePendingMessage(messageSent);\r\n            await utils.until(() => {\r\n                   return this._pendingMessages[messageSent.id] === undefined;\r\n                }\r\n                , \"Wait for the send chat message to be received by server\", 30000);\r\n            this.removePendingMessage(messageSent);\r\n            this._logger.log(\"debug\", LOG_ID + \"(sendMessageToJid) _exiting_\");\r\n            // */\r\n            return messageSent;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToJidAnswer\r\n     * @instance\r\n     * @description\r\n     *  Send a reply to a one-2-one message to a contact identified by his Jid\r\n     * @param {String} message The message to send\r\n     * @param {String} jid The contact Jid\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @param {String} [answeredMsg] The message answered\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} - the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToJidAnswer(message, jid, lang, content, subject, answeredMsg) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!lang) {\r\n                lang = \"en\";\r\n            }\r\n            if (!message) {\r\n                this._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'message' parameter.\");\r\n                this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'message' parameter : \", message);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'message' parameter\" }));\r\n            }\r\n            let typofansweredMsg = answeredMsg instanceof Object;\r\n            if (!typofansweredMsg && answeredMsg !== null) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad  'answeredMsg' parameter.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToJidAnswer) bad  'answeredMsg' parameter : \", answeredMsg);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad 'answeredMsg' parameter\" }));\r\n            }\r\n            // Check size of the message\r\n            let messageSize = message.length;\r\n            if (content && content.message && typeof content.message === \"string\") {\r\n                messageSize += content.message.length;\r\n            }\r\n            if (messageSize > that._imOptions.messageMaxLength) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) message not sent. The content is too long (\" + messageSize + \")\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\" }));\r\n            }\r\n            if (!jid) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToJidAnswer) bad or empty 'jid' parameter\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'jid' parameter\" }));\r\n            }\r\n            let messageUnicode = Emoji_1.shortnameToUnicode(message);\r\n            jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(jid);\r\n            let messageSent = yield this._xmpp.sendChatMessage(messageUnicode, jid, lang, content, subject, answeredMsg);\r\n            /*\r\n            this.storePendingMessage(messageSent);\r\n            await utils.until(() => {\r\n                   return this._pendingMessages[messageSent.id] === undefined;\r\n                }\r\n                , \"Wait for the send chat message to be received by server\", 30000);\r\n            this.removePendingMessage(messageSent);\r\n            this._logger.log(\"debug\", LOG_ID + \"(sendMessageToJid) _exiting_\");\r\n            // */\r\n            return messageSent;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToBubble\r\n     * @instance\r\n     * @description\r\n     *  Send a message to a bubble\r\n     * @param {String} message The message to send\r\n     * @param {Bubble} bubble The bubble (should at least have a jid property)\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToBubble(message, bubble, lang, content, subject, mentions) {\r\n        if (!bubble || !bubble.jid) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubble) bad or empty 'bubble' parameter.\");\r\n            this._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubble) bad or empty 'bubble' parameter : \", bubble);\r\n            return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'bubble' parameter\" }));\r\n        }\r\n        return this.sendMessageToBubbleJid(message, bubble.jid, lang, content, subject, mentions);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToBubbleJid\r\n     * @instance\r\n     * @description\r\n     *  Send a message to a bubble identified by its JID\r\n     * @param {String} message The message to send\r\n     * @param {String} jid The bubble JID\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToBubbleJid(message, jid, lang, content, subject, mentions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!lang) {\r\n                lang = \"en\";\r\n            }\r\n            if (!message) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'message' parameter.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'message' parameter : \", message);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'message' parameter\" }));\r\n            }\r\n            // Check size of the message\r\n            let messageSize = message.length;\r\n            if (content && content.message && typeof content.message === \"string\") {\r\n                messageSize += content.message.length;\r\n            }\r\n            if (messageSize > that._imOptions.messageMaxLength) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJid) message not sent. The content is too long (\" + messageSize + \")\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\" }));\r\n            }\r\n            if (!jid) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) bad or empty 'jid' parameter\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'jid' parameter\" }));\r\n            }\r\n            let messageUnicode = Emoji_1.shortnameToUnicode(message);\r\n            jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(jid);\r\n            let bubble = yield that._bulles.getBubbleByJid(jid);\r\n            that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJid) getBubbleByJid \", bubble);\r\n            if (bubble.isActive) {\r\n                let messageSent1 = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, undefined, mentions);\r\n                return messageSent1;\r\n            }\r\n            else {\r\n                try {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) bubble is not active, so resume it before send the message.\");\r\n                    that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJid) bubble is not active, so resume it before send the message. bubble : \", bubble);\r\n                    yield that._presence.sendInitialBubblePresence(bubble.jid);\r\n                    //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) sendInitialBubblePresence succeed \");\r\n                    yield Utils_1.until(() => {\r\n                        return bubble.isActive === true;\r\n                    }, \"Wait for the Bubble \" + bubble.jid + \" to be active\");\r\n                    //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJid) until succeed, so the bubble is now active, send the message.\");\r\n                    let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, undefined, mentions);\r\n                    return messageSent;\r\n                }\r\n                catch (err) {\r\n                    return Promise.reject({ message: \"The sending message process failed!\", error: err });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendMessageToBubbleJidAnswer\r\n     * @instance\r\n     * @description\r\n     *  Send a message to a bubble identified by its JID\r\n     * @param {String} message The message to send\r\n     * @param {String} jid The bubble JID\r\n     * @param {String} [lang=en] The content language used\r\n     * @param {Object} [content] Allow to send alternative text base content\r\n     * @param {String} [content.type=text/markdown] The content message type\r\n     * @param {String} [content.message] The content message body\r\n     * @param {String} [subject] The message subject\r\n     * @param {String} [answeredMsg] The message answered\r\n     * @param {array} mentions array containing a list of JID of contact to mention or a string containing a sigle JID of the contact.\r\n     * @async\r\n     * @return {Promise<Message, ErrorManager>}\r\n     * @fulfil {Message} the message sent, or null in case of error, as parameter of the resolve\r\n     * @category async\r\n     */\r\n    sendMessageToBubbleJidAnswer(message, jid, lang, content, subject, answeredMsg, mentions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (!lang) {\r\n                lang = \"en\";\r\n            }\r\n            if (!message) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'message' parameter.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'message' parameter : \", message);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'message' parameter\" }));\r\n            }\r\n            let typofansweredMsg = answeredMsg instanceof Object;\r\n            if (!typofansweredMsg && answeredMsg !== null) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad  'answeredMsg' parameter.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad  'answeredMsg' parameter : \", answeredMsg);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad 'answeredMsg' parameter\" }));\r\n            }\r\n            // Check size of the message\r\n            let messageSize = message.length;\r\n            if (content && content.message && typeof content.message === \"string\") {\r\n                messageSize += content.message.length;\r\n            }\r\n            if (messageSize > that._imOptions.messageMaxLength) {\r\n                that._logger.log(\"warn\", LOG_ID + \"(sendMessageToBubbleJidAnswer) message not sent. The content is too long (\" + messageSize + \")\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'strMessage' should be lower than \" + that._imOptions.messageMaxLength + \" characters\" }));\r\n            }\r\n            if (!jid) {\r\n                that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bad or empty 'jid' parameter\", jid);\r\n                return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'jid' parameter\" }));\r\n            }\r\n            let messageUnicode = Emoji_1.shortnameToUnicode(message);\r\n            jid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(jid);\r\n            let bubble = yield that._bulles.getBubbleByJid(jid);\r\n            that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJidAnswer) getBubbleByJid \", bubble);\r\n            if (bubble.isActive) {\r\n                let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, answeredMsg, mentions);\r\n                return messageSent;\r\n            }\r\n            else {\r\n                try {\r\n                    that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bubble is not active, so resume it before send the message.\");\r\n                    that._logger.log(\"internal\", LOG_ID + \"(sendMessageToBubbleJidAnswer) bubble is not active, so resume it before send the message. bubble : \", bubble);\r\n                    yield that._xmpp.sendInitialBubblePresence(bubble.jid);\r\n                    //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) sendInitialBubblePresence succeed \");\r\n                    yield Utils_1.until(() => {\r\n                        return bubble.isActive === true;\r\n                    }, \"Wait for the Bubble \" + bubble.jid + \" to be active\");\r\n                    //that._logger.log(\"debug\", LOG_ID + \"(sendMessageToBubbleJidAnswer) until succeed, so the bubble is now active, send the message.\");\r\n                    let messageSent = that._xmpp.sendChatMessageToBubble(messageUnicode, jid, lang, content, subject, answeredMsg, mentions);\r\n                    return messageSent;\r\n                }\r\n                catch (err) {\r\n                    return Promise.reject({ message: \"The sending message process failed!\", error: err });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method sendIsTypingStateInBubble\r\n     * @instance IMService\r\n     * @description\r\n     *    Switch the \"is typing\" state in a bubble/room<br>\r\n     * @param {Bubble} bubble The destination bubble\r\n     * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n     * @return {Object} Return a promise with no parameter when succeed.\r\n     */\r\n    sendIsTypingStateInBubble(bubble, status) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            if (!bubble) {\r\n                return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'bubble' is missing or null\" }));\r\n            }\r\n            /* else if (!status) {\r\n                reject(Object.assign( ErrorManager.getErrorManager().BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n            } // */\r\n            else {\r\n                if (!bubble.jid) {\r\n                    return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'bubble': this bubble isn't a valid one\" }));\r\n                }\r\n                else {\r\n                    that._logger.log(\"internal\", LOG_ID + \"sendIsTypingStateInBubble - bubble : \", bubble, \"status : \", status);\r\n                    that._conversations.getBubbleConversation(bubble.jid, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined).then(function (conversation) {\r\n                        return __awaiter(this, void 0, void 0, function* () {\r\n                            if (!conversation) {\r\n                                return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), { msg: \"No 'conversation' found for this bubble\" }));\r\n                            }\r\n                            else {\r\n                                yield that._xmpp.sendIsTypingState(conversation, status);\r\n                                //conversationService.sendIsTypingState(conversation, status);\r\n                                resolve();\r\n                            }\r\n                        });\r\n                    }).catch((err) => {\r\n                        return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), { msg: \"No 'conversation' found for this bubble : \" + err }));\r\n                    });\r\n                }\r\n            }\r\n        }));\r\n    } // */\r\n    /**\r\n     * @public\r\n     * @method sendIsTypingStateInConversation\r\n     * @instance IMService\r\n     * @description\r\n     *    Switch the \"is typing\" state in a conversation<br>\r\n     * @param {Conversation} conversation The conversation recipient\r\n     * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\r\n     * @return Return a promise with no parameter when succeed\r\n     */\r\n    sendIsTypingStateInConversation(conversation, status) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            if (!conversation) {\r\n                return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Parameter 'conversation' is missing or null\" }));\r\n            }\r\n            /* else if (!status) {\r\n                reject(Object.assign( ErrorManager.getErrorManager().BAD_REQUEST, {msg: \"Parameter 'status' is missing or null\"}));\r\n            } // */\r\n            else {\r\n                conversation = conversation.id ? that._conversations.getConversationById(conversation.id) : null;\r\n                if (!conversation) {\r\n                    return reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(\"ERRORNOTFOUND\", \"ERRORNOTFOUND\"), { msg: \"Parameter 'conversation': this conversation doesn't exist\" }));\r\n                }\r\n                else {\r\n                    yield that._xmpp.sendIsTypingState(conversation, status);\r\n                    resolve();\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @public\r\n     * @method markMessageAsRead\r\n     * @instance\r\n     * @description\r\n     *  Send a 'read' receipt to the recipient\r\n     * @param {Message} messageReceived The message received to mark as read\r\n     * @async\r\n     * @return {Promise}\r\n     * @fulfil {} return nothing in case of success or an ErrorManager Object depending the result\r\n     * @category async\r\n     */\r\n    markMessageAsRead(messageReceived) {\r\n        if (!messageReceived) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) bad or empty 'messageReceived' parameter\");\r\n            return Promise.reject(Object.assign(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST, { msg: \"Bad or empty 'messageReceived' parameter\" }));\r\n        }\r\n        if (messageReceived.isEvent) {\r\n            this._logger.log(\"warn\", LOG_ID + \"(markMessageAsRead) No receipt for 'event' message\");\r\n            return ErrorManager_1.ErrorManager.getErrorManager().OK;\r\n        }\r\n        this._logger.log(\"internal\", LOG_ID + \"(markMessageAsRead) 'messageReceived' parameter : \", messageReceived);\r\n        if (this._useXMPP) {\r\n            return this._xmpp.markMessageAsRead(messageReceived);\r\n        }\r\n        if ((this._useS2S)) {\r\n            if (messageReceived.conversation) {\r\n                let conversationId = messageReceived.conversation.dbId ? messageReceived.conversation.dbId : messageReceived.conversation.id;\r\n                let messageId = messageReceived.id;\r\n                return this._rest.markMessageAsRead(conversationId, messageId);\r\n            }\r\n            else {\r\n                return Promise.reject('No conversation found in message.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @method enableCarbon\r\n     * @instance\r\n     * @description\r\n     *      Enable message carbon XEP-0280\r\n     * @async\r\n     * @return {Promise}\r\n     * @fulfil {} return nothing in case of success or an ErrorManager Object depending the result\r\n     * @category async\r\n     */\r\n    enableCarbon() {\r\n        let that = this;\r\n        return new Promise((resolve) => {\r\n            if (this._useXMPP) {\r\n                that._eventEmitter.once(\"rainbow_oncarbonactivated\", function fn_oncarbonactivated() {\r\n                    that._logger.log(\"info\", LOG_ID + \"(enableCarbon) XEP-280 Message Carbon activated\");\r\n                    that._eventEmitter.removeListener(\"rainbow_oncarbonactivated\", fn_oncarbonactivated);\r\n                    resolve();\r\n                });\r\n                that._xmpp.enableCarbon();\r\n            }\r\n            else if (this._useS2S) {\r\n                resolve();\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n};\r\nIMService = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n     * @module\r\n     * @name IMService\r\n     * @version 1.67.1 \r\n     * @public\r\n     * @description\r\n     *      This module manages Instant Messages. It allows to send messages to a user or a bubble.\r\n     *      <br><br>\r\n     *      The main methods proposed in that module allow to: <br>\r\n     *      - Send a message to a user <br>\r\n     *      - Send a message to a bubble <br>\r\n     *      - Mark a message as read <br>\r\n     */\r\n], IMService);\r\nexports.IMService = IMService;\r\nmodule.exports.IMService = IMService;\r\n//# sourceMappingURL=ImsService.js.map"]},"metadata":{},"sourceType":"script"}