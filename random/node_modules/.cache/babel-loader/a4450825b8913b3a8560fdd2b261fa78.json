{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"../../common/Utils\");\n\nconst Utils = require(\"../../common/Utils\");\n\nconst GenericHandler = require(\"./genericHandler\"); //const Conversation = require(\"../../common/models/Conversation\");\n//const NameUpdatePrio = require(\"../../common/models/Contact\").NameUpdatePrio;\n\n\nconst moment = require(\"moment\");\n\nconst Deferred = require(\"../../common/Utils\").Deferred;\n\nconst CallLog = require(\"../../common/models/CallLog\");\n\nconst xml = require(\"@xmpp/xml\");\n\nconst PromiseQueue = require(\"../../common/promiseQueue\");\n\nconst orderByFilter = require(\"../../common/Utils\").orderByFilter; //const config = require(\"../../config/config\");\n\n\nconst config_1 = require(\"../../config/config\");\n\nconst LOG_ID = \"XMPP/HNDL/TEL/CLOG - \";\n/*********************************************************************/\n\n/** PRIVATE CONSTRUCTOR                                             **/\n\n/*********************************************************************/\n\nlet CallLogEventHandler = class CallLogEventHandler extends GenericHandler {\n  constructor(xmppService, calllogService, contactService, profileService, telephonyService) {\n    super(xmppService); //let self = this;\n\n    this.MESSAGE = \"jabber:client.message\";\n    this.IQ_RESULT = \"jabber:client.iq.result\";\n    this.IQ_ERROR = \"jabber:client.iq.error\"; //this.callLogRequestNS = \"jabber:iq:webrtc:call:log\";\n\n    this.IQ_CALLLOG = \"jabber:iq:telephony:call_log\";\n    this.CALLLOG_ACK = \"urn:xmpp:telephony:call_log:receipts\";\n    this.IQ_CALLOG_NOTIFICATION = \"jabber:iq:notification:telephony:call_log\";\n    this.calllogService = calllogService;\n    this.contactService = contactService;\n    this.profileService = profileService;\n    this.telephonyService = telephonyService;\n    this.callLogsPromises = [];\n    this.calllogs = {\n      \"callLogs\": [],\n      \"orderByNameCallLogs\": [],\n      \"orderByDateCallLogs\": [],\n      \"orderByNameCallLogsBruts\": [],\n      \"orderByDateCallLogsBruts\": [],\n      \"simplifiedCallLogs\": [],\n      \"numberMissedCalls\": 0,\n      \"lastTimestamp\": null\n    }; //this.promiseQueue = PromiseQueue.createPromiseQueue(that.logger);\n    // C:\\Projets\\RandD\\Rainbow\\Sources\\CPaas\\Rainbow-Node-SDK - sample2\\node_modules\\ltx\\lib\\Element.js\n\n    this.onIqCallLogReceived = (msg, stanza) => {\n      let that = this;\n      that.logger.log(\"internal\", LOG_ID + \"(onIqCallLogReceived) received - 'stanza'\", msg, stanza);\n\n      try {\n        //that.logger.log(\"info\", LOG_ID + \"[callLogService] onCallLogMessageReceived\");\n        //handle message\n        if (stanza.find(\"call_log\").length > 0) {\n          that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\n        } //handle end of logs\n        else if (stanza.find(\"count\").length > 0 && stanza.find(\"query\").length > 0) {\n            //save last message timestamp\n            that.calllogs.lastTimestamp = stanza.find(\"last\").text();\n            that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : all call logs received\");\n\n            if (that.callLogsPromises.length > 0) {\n              Promise.all(that.callLogsPromises).then(() => {\n                that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : all call logs are ready\");\n                that.callLogsPromises = [];\n                that.orderCallLogsFunction();\n                let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\n                let num = that.getMissedCallLogCounter(); // $rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\n\n                that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs);\n\n                if (num !== oldMissedCallLogCounter) {\n                  that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs); // $rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\n                }\n              });\n            }\n          } //handle other messages\n          else {\n              that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : ignored stanza for calllog !\");\n            }\n      } catch (error) {\n        that.logger.log(\"error\", LOG_ID + \"(onIqCallLogReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onIqCallLogReceived) CATCH Error !!! : \", error);\n        return true;\n      }\n\n      return true;\n    };\n\n    this.onCallLogAckReceived = (msg, stanza) => {\n      let that = this;\n      that.logger.log(\"internal\", LOG_ID + \"(onCallLogAckReceived) received - 'stanza'\", msg, stanza);\n\n      try {\n        that.logger.log(\"info\", LOG_ID + \"(onCallLogAckReceived) received\"); //console.log(stanza);\n\n        let read = stanza.find(\"read\");\n\n        if (read.length > 0) {\n          let msgId = stanza.find(\"read\").attr(\"call_id\");\n          that.callLogAckUpdate(msgId);\n          let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\n          let num = that.getMissedCallLogCounter();\n\n          if (num !== oldMissedCallLogCounter) {\n            that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs); //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\n          }\n        }\n      } catch (error) {\n        that.logger.log(\"error\", LOG_ID + \"(onCallLogAckReceived) \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onCallLogAckReceived) : \" + error);\n        return true;\n      }\n\n      return true;\n    };\n\n    this.onIqCallLogNotificationReceived = (msg, stanza) => __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"internal\", LOG_ID + \"(onIqCallLogNotificationReceived) received - 'stanza'\", msg, stanza);\n      that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) received\"); //console.log(stanza);\n\n      try {\n        let deleted_call_log = stanza.find(\"deleted_call_log\");\n        let updated_call_log = stanza.find(\"updated_call_log\");\n\n        if (deleted_call_log.length > 0) {\n          that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) deleted IQ\");\n          let peer = stanza.find(\"deleted_call_log\").attr(\"peer\"); //no given user JID, reset all call-logs\n\n          if (!peer) {\n            that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) no given user JID, reset all call-logs\");\n            yield that.resetCallLogs();\n            yield that.calllogService.getCallLogHistoryPage();\n          } else {\n            that.removeCallLogsForUser(peer);\n          }\n        } else if (updated_call_log.length > 0) {\n          that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived)  : Update call-logs\");\n          that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\n          Promise.all(that.callLogsPromises).then(function () {\n            that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) : update is done\");\n            that.callLogsPromises = [];\n            that.orderCallLogsFunction();\n            let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\n            let num = that.getMissedCallLogCounter();\n            that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs); //$rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\n\n            if (num !== oldMissedCallLogCounter) {\n              that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs); //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\n            }\n          });\n        }\n      } catch (error) {\n        that.logger.log(\"error\", LOG_ID + \"(onIqCallLogNotificationReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onIqCallLogNotificationReceived) CATCH Error !!! : \", error);\n        return true;\n      }\n    });\n  }\n  /**\r\n   * Method isMediaPillarJid\r\n   * @public\r\n   * @param {string} fromJid the from jid\r\n   * @returns {boolean} true if it is the media pillar Jid\r\n   * @memberof WebrtcGatewayService\r\n   */\n\n\n  isMediaPillarJid(fromJid) {\n    let indexMPinJid = -1; // presence&pos of \"mp_\" in jid\n    //no jid provided!\n\n    if (!fromJid) {\n      return false;\n    }\n\n    indexMPinJid = fromJid.search(\"mp_\"); //\"mp_\" must be at position 0\n\n    return indexMPinJid === 0;\n  }\n\n  removeCallLogsForUser(jid) {\n    let that = this;\n\n    if (jid.endsWith(\"@_\")) {\n      // Ticket 2629 : remove @_ from jid added by server for JIDisation...\n      jid = jid.substring(0, jid.length - 2);\n    }\n\n    that.logger.log(\"info\", LOG_ID + \"removeCallLogsForUser with jid: \" + jid);\n    let newLogs = [];\n\n    for (let i = 0; i < that.calllogs.callLogs.length; i++) {\n      if (!that.calllogs.callLogs[i].contact || that.calllogs.callLogs[i].contact.jid !== jid && that.calllogs.callLogs[i].contact.id !== jid) {\n        newLogs.push(that.calllogs.callLogs[i]);\n      }\n    }\n\n    that.calllogs.callLogs = newLogs;\n    that.orderCallLogsFunction();\n    let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\n    let num = that.getMissedCallLogCounter(); //$rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\n\n    that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs);\n\n    if (num !== oldMissedCallLogCounter) {\n      //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\n      that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs);\n    }\n  }\n\n  createCallLogFromMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; // that.logger.log(\"info\", LOG_ID + \"[callLogService] createCallLogFromMessage\"); MCO really verbose....\n\n      let defered = new Deferred();\n      let messageElem = message;\n      let otherParticipantJid = null;\n      let otherParticipantNumber = null;\n      let direction = \"\";\n      let callid = messageElem.find(\"call_id\");\n      let id = callid.text();\n      let callerJid = messageElem.find(\"caller\").text();\n      let calleeJid = messageElem.find(\"callee\").text();\n      let state = messageElem.find(\"state\").text();\n      let duration = parseInt(messageElem.find(\"duration\").text(), 10);\n      let callSubject = messageElem.find(\"subject\").text();\n      let foundidentity = null;\n      let identityFirstName = \"\";\n      let identityLastName = \"\";\n      let type = \"webrtc\";\n\n      if (callerJid && callerJid.indexOf(\"janusgateway\") !== -1 || calleeJid && calleeJid.indexOf(\"janusgateway\") !== -1) {\n        that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore janusgateway call-logs\");\n        return;\n      }\n\n      if (callerJid && this.isMediaPillarJid(callerJid) || calleeJid && this.isMediaPillarJid(calleeJid)) {\n        that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore janusgateway call-logs\");\n        return;\n      }\n\n      let typeCall = messageElem.find(\"call_log\").attr(\"type\"); //compatibility with the old method\n\n      if (!typeCall) {\n        typeCall = messageElem.find(\"type\").text();\n      }\n\n      let read = messageElem.find(\"ack\").attr(\"read\") === \"true\";\n      let date = messageElem.find(\"delay\").attr(\"stamp\");\n      let conference = messageElem.find(\"call_log\").attr(\"service\") === \"conference\"; //check if phonebook search is allowed by profile else no result\n\n      if (that.profileService.isFeatureEnabled(that.profileService.getFeaturesEnum().TELEPHONY_PHONE_BOOK) || config_1.config.permitSearchFromPhoneBook) {\n        foundidentity = messageElem.find(\"identity\");\n      }\n\n      if (duration > 0) {\n        duration = moment.duration(duration, \"ms\").format(\"h[H] mm[m] ss[s]\");\n      } else {\n        duration = 0;\n      }\n\n      if (date) {\n        date = new Date(date);\n      }\n\n      if (conference) {\n        otherParticipantJid = callerJid;\n        type = \"conference\";\n        direction = this.contactService.isUserContactJid(callerJid) ? \"outgoing\" : \"incoming\";\n\n        if (otherParticipantJid.indexOf(\"@\") === -1) {\n          //telephone number\n          otherParticipantNumber = otherParticipantJid;\n          otherParticipantJid = null;\n        }\n      } else {\n        if (typeCall === \"phone\") {\n          type = \"telephone\";\n        }\n\n        if (this.contactService.isUserContactJid(callerJid)) {\n          otherParticipantJid = calleeJid;\n          direction = \"outgoing\";\n        } else {\n          otherParticipantJid = callerJid;\n          direction = \"incoming\";\n        }\n\n        if (otherParticipantJid.indexOf(\"@\") === -1) {\n          //telephone number\n          otherParticipantNumber = otherParticipantJid;\n          otherParticipantJid = null;\n          type = \"telephone\";\n        }\n      }\n\n      if (otherParticipantJid || otherParticipantNumber) {\n        this.contactService.getOrCreateContact(otherParticipantJid, otherParticipantNumber).then(contact => {\n          that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage otherParticipant jid:\" + otherParticipantJid + \" => contact retrieved (temp:\" + contact.temp + \")\");\n          that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage otherParticipant jid:\" + otherParticipantJid + \"  Number:\" + otherParticipantNumber + \" => contact retrieved (temp:\" + contact.temp + \")\");\n\n          if (!conference && !otherParticipantJid && contact.temp) {\n            //only in case of temp contact\n            //find Xnames from directories\n            if (foundidentity && foundidentity.length) {\n              let foundFirstName = foundidentity.attr(\"firstName\");\n              let foundLastName = foundidentity.attr(\"lastName\");\n              let foundDisplayName = foundidentity.attr(\"displayName\");\n              identityFirstName = foundFirstName ? foundFirstName : \"\";\n              identityLastName = foundLastName ? foundLastName : \"\";\n\n              if (identityLastName === \"\" && identityFirstName === \"\" && foundDisplayName && foundDisplayName.length !== 0 && foundDisplayName !== otherParticipantNumber) {\n                identityLastName = foundDisplayName; //hack to use displayName instead of lastName (when lastName not available)\n              }\n\n              if (identityFirstName.length || identityLastName.length) {\n                //update contact\n                that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  xNames updated from directories for contact \" + contact.id);\n                contact.updateName(identityFirstName, identityLastName);\n              }\n            } else {} //try to find in outlook\n            // Do not do it in node.\n\n            /*\r\n            try {\r\n                let centralizedService = $injector.get(\"centralizedService\");\r\n                let reload = true;\r\n                centralizedService.outlook.updateContactFromOutlookInfos(contact, otherParticipantNumber, reload)\r\n                    .then(\r\n                        function successCallback(updateStatus) {\r\n                            if (updateStatus) {\r\n                                that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  xNames updated from outlook for contact \" + contact.id);\r\n                            } else {\r\n                                that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage no update from outlook for contact :\" + contact.id);\r\n                            }\r\n                        },\r\n                        function errorCallback() {\r\n                            that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  no Outlook search available\");\r\n                        }\r\n                    );\r\n            } catch (error) {\r\n            }\r\n            // */\n            //#29830++\n            //if displayNmane is a phone number (and only for contact.temp)\n            //then use phoneProcan as displayName and display only that in calllog (done in callLogsCell.html)\n\n\n            let displayNameisAPhoneNumber = false;\n            let phone_number_regex = /^[0-9A-D #\\-\\+\\*\\(\\)\\./]{1,32}$/;\n\n            if (that.telephonyService.started) {\n              let matchAsNumber = contact.displayName.match(phone_number_regex);\n              displayNameisAPhoneNumber = matchAsNumber && that.telephonyService.startAsPhoneNumber(contact.displayName);\n            }\n\n            if (displayNameisAPhoneNumber) {\n              if (contact.phoneProCan && contact.phoneProCan !== \"\") {\n                contact.displayName = contact.phoneProCan; //use phoneProCan as displayName\n              }\n            } //#29830--\n\n          }\n\n          let callLog = CallLog.create(id, contact, state, duration, type, read, date, direction, callSubject); //do not push up duplicates\n\n          if (!that.logAlreadyExists(callLog) && state !== \"failed\" && state !== \"ongoing\") {\n            that.calllogs.callLogs.push(callLog);\n          } else {\n            that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore call log, state: \" + state);\n            that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore call log with id: \" + id + \", state: \" + state);\n          }\n\n          that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage success\");\n          defered.resolve(callLog);\n        }).catch(function (error) {\n          that.logger.log(\"error\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage error \");\n          that.logger.log(\"internalerror\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage error : \" + error);\n          defered.resolve();\n        });\n      } else {\n        that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  No jid or no phoneNumber \");\n        defered.resolve();\n      }\n\n      return defered.promise;\n    });\n  }\n\n  logAlreadyExists(log) {\n    let that = this;\n    let i;\n\n    for (i = 0; i < that.calllogs.callLogs.length; i++) {\n      if (that.calllogs.callLogs[i].id === log.id) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  orderCallLogsFunction() {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"[orderCallLogsFunction] orderByFunction\");\n    that.calllogs.orderByNameCallLogsBruts = orderByFilter(that.calllogs.callLogs, CallLog.getNames, false, CallLog.sortByContact);\n    that.calllogs.orderByDateCallLogsBruts = orderByFilter(that.calllogs.callLogs, CallLog.getDate, false, CallLog.sortByDate);\n    that.calllogs.simplifiedCallLogs = that.simplifyCallLogs(that.calllogs.orderByDateCallLogsBruts);\n    that.calllogs.orderByNameCallLogs = that.fusionInformation(that.calllogs.orderByNameCallLogsBruts);\n    that.calllogs.orderByDateCallLogs = that.fusionInformation(that.calllogs.orderByDateCallLogsBruts);\n    return this.calllogs;\n  } //get number of non-ack missed calls\n\n\n  getMissedCallLogCounter() {\n    let that = this;\n    let num = 0;\n    that.calllogs.callLogs.forEach(callLog => {\n      if (!callLog.read && callLog.state === \"missed\" && callLog.direction === \"incoming\") {\n        num++;\n      }\n    });\n    that.calllogs.numberMissedCalls = num;\n    return num;\n  } //update ACK for call log with ID\n\n\n  callLogAckUpdate(id) {\n    let that = this;\n\n    try {\n      that.calllogs.callLogs.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n      that.calllogs.simplifiedCallLogs.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n      that.calllogs.orderByDateCallLogs.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n      that.calllogs.orderByNameCallLogsBruts.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n      that.calllogs.orderByDateCallLogsBruts.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n      that.calllogs.orderByNameCallLogs.forEach(function (callLog) {\n        if (callLog.id === id) {\n          callLog.read = true;\n          return;\n        }\n      });\n    } catch (err) {\n      that.logger.log(\"error\", LOG_ID + \"[callLogAckUpdate] !!! CATCH Error \");\n      that.logger.log(\"internalerror\", LOG_ID + \"[callLogAckUpdate] !!! CATCH Error : \", err);\n    }\n  }\n\n  simplifyCallLogs(callLogs) {\n    let result = [];\n\n    for (let i = 0; i < callLogs.length; i++) {\n      result[i] = {};\n      result[i].contact = callLogs[i].contact.id;\n      result[i].contactDisplayName = callLogs[i].contact.displayName;\n      result[i].contactInitials = callLogs[i].contact.initials;\n      result[i].id = callLogs[i].id;\n      result[i].state = callLogs[i].state;\n      result[i].duration = callLogs[i].duration;\n      result[i].direction = callLogs[i].direction;\n      result[i].type = callLogs[i].type;\n      result[i].read = callLogs[i].read;\n      result[i].date = callLogs[i].date;\n    }\n\n    return result;\n  }\n\n  resetCallLogs() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[resetCallLogs] resetCallLogs\");\n      that.calllogs = {\n        \"callLogs\": [],\n        \"orderByNameCallLogs\": [],\n        \"orderByDateCallLogs\": [],\n        \"orderByNameCallLogsBruts\": [],\n        \"orderByDateCallLogsBruts\": [],\n        \"simplifiedCallLogs\": [],\n        \"numberMissedCalls\": 0,\n        \"lastTimestamp\": null\n      };\n    });\n  }\n\n  fusionInformation(callLogs) {\n    let passed = {};\n    let current = 0;\n    let fusion = [];\n\n    for (let i = 0; i < callLogs.length; i++) {\n      let log = callLogs[i];\n      let jid = log.contact.jid;\n\n      if (!log.contact.jid) {\n        jid = log.contact.id;\n      } //if conference log\n\n\n      if (log.type === \"conference\") {\n        if (i !== 0) {\n          current++;\n        }\n\n        fusion[current] = log;\n        fusion[current].count = 1;\n        fusion[current].editable = false;\n        continue;\n      } //first element\n\n\n      if (i === 0) {\n        passed[jid] = 1;\n        fusion[current] = log;\n        fusion[current].count = 1;\n        fusion[current].editable = true;\n\n        if (log.state === \"missed\" && log.direction === \"incoming\") {\n          fusion[current].isMissed = true;\n        } else if (log.state === \"missed\" && log.direction === \"outgoing\") {\n          fusion[current].isNotAnswered = true;\n        }\n\n        continue;\n      } //if we already have this element\n\n\n      if (passed[jid]) {\n        let index = passed[jid];\n        let element = fusion[index - 1];\n\n        if (element.editable) {\n          if (element.isMissed && log.state === \"missed\" && log.direction === \"incoming\") {\n            element.count++;\n          } else if (element.isNotAnswered && log.state === \"missed\" && log.direction === \"outgoing\") {\n            element.count++;\n          } else {\n            element.editable = false;\n          }\n        }\n      } //new element\n      else {\n          current++;\n          passed[jid] = current + 1;\n          fusion[current] = log;\n          fusion[current].count = 1;\n          fusion[current].editable = true;\n\n          if (log.state === \"missed\" && log.direction === \"incoming\") {\n            fusion[current].isMissed = true;\n          } else if (log.state === \"missed\" && log.direction === \"outgoing\") {\n            fusion[current].isNotAnswered = true;\n          }\n\n          continue;\n        }\n    }\n\n    return fusion;\n  }\n\n};\nCallLogEventHandler = __decorate([Utils_1.logEntryExit(LOG_ID)], CallLogEventHandler);\nexports.CallLogEventHandler = CallLogEventHandler;\nmodule.exports.CallLogEventHandler = CallLogEventHandler;","map":{"version":3,"sources":["../../../src/lib/connection/XMPPServiceHandler/calllogEventHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Utils_1 = require(\"../../common/Utils\");\r\nconst Utils = require(\"../../common/Utils\");\r\nconst GenericHandler = require(\"./genericHandler\");\r\n//const Conversation = require(\"../../common/models/Conversation\");\r\n//const NameUpdatePrio = require(\"../../common/models/Contact\").NameUpdatePrio;\r\nconst moment = require(\"moment\");\r\nconst Deferred = require(\"../../common/Utils\").Deferred;\r\nconst CallLog = require(\"../../common/models/CallLog\");\r\nconst xml = require(\"@xmpp/xml\");\r\nconst PromiseQueue = require(\"../../common/promiseQueue\");\r\nconst orderByFilter = require(\"../../common/Utils\").orderByFilter;\r\n//const config = require(\"../../config/config\");\r\nconst config_1 = require(\"../../config/config\");\r\nconst LOG_ID = \"XMPP/HNDL/TEL/CLOG - \";\r\n/*********************************************************************/\r\n/** PRIVATE CONSTRUCTOR                                             **/\r\n/*********************************************************************/\r\nlet CallLogEventHandler = class CallLogEventHandler extends GenericHandler {\r\n    constructor(xmppService, calllogService, contactService, profileService, telephonyService) {\r\n        super(xmppService);\r\n        //let self = this;\r\n        this.MESSAGE = \"jabber:client.message\";\r\n        this.IQ_RESULT = \"jabber:client.iq.result\";\r\n        this.IQ_ERROR = \"jabber:client.iq.error\";\r\n        //this.callLogRequestNS = \"jabber:iq:webrtc:call:log\";\r\n        this.IQ_CALLLOG = \"jabber:iq:telephony:call_log\";\r\n        this.CALLLOG_ACK = \"urn:xmpp:telephony:call_log:receipts\";\r\n        this.IQ_CALLOG_NOTIFICATION = \"jabber:iq:notification:telephony:call_log\";\r\n        this.calllogService = calllogService;\r\n        this.contactService = contactService;\r\n        this.profileService = profileService;\r\n        this.telephonyService = telephonyService;\r\n        this.callLogsPromises = [];\r\n        this.calllogs = {\r\n            \"callLogs\": [],\r\n            \"orderByNameCallLogs\": [],\r\n            \"orderByDateCallLogs\": [],\r\n            \"orderByNameCallLogsBruts\": [],\r\n            \"orderByDateCallLogsBruts\": [],\r\n            \"simplifiedCallLogs\": [],\r\n            \"numberMissedCalls\": 0,\r\n            \"lastTimestamp\": null\r\n        };\r\n        //this.promiseQueue = PromiseQueue.createPromiseQueue(that.logger);\r\n        // C:\\Projets\\RandD\\Rainbow\\Sources\\CPaas\\Rainbow-Node-SDK - sample2\\node_modules\\ltx\\lib\\Element.js\r\n        this.onIqCallLogReceived = (msg, stanza) => {\r\n            let that = this;\r\n            that.logger.log(\"internal\", LOG_ID + \"(onIqCallLogReceived) received - 'stanza'\", msg, stanza);\r\n            try {\r\n                //that.logger.log(\"info\", LOG_ID + \"[callLogService] onCallLogMessageReceived\");\r\n                //handle message\r\n                if (stanza.find(\"call_log\").length > 0) {\r\n                    that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\r\n                }\r\n                //handle end of logs\r\n                else if (stanza.find(\"count\").length > 0 && stanza.find(\"query\").length > 0) {\r\n                    //save last message timestamp\r\n                    that.calllogs.lastTimestamp = stanza.find(\"last\").text();\r\n                    that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : all call logs received\");\r\n                    if (that.callLogsPromises.length > 0) {\r\n                        Promise.all(that.callLogsPromises).then(() => {\r\n                            that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : all call logs are ready\");\r\n                            that.callLogsPromises = [];\r\n                            that.orderCallLogsFunction();\r\n                            let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\r\n                            let num = that.getMissedCallLogCounter();\r\n                            // $rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\r\n                            that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs);\r\n                            if (num !== oldMissedCallLogCounter) {\r\n                                that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs);\r\n                                // $rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                //handle other messages\r\n                else {\r\n                    that.logger.log(\"info\", LOG_ID + \"(onIqCallLogReceived) : ignored stanza for calllog !\");\r\n                }\r\n            }\r\n            catch (error) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onIqCallLogReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onIqCallLogReceived) CATCH Error !!! : \", error);\r\n                return true;\r\n            }\r\n            return true;\r\n        };\r\n        this.onCallLogAckReceived = (msg, stanza) => {\r\n            let that = this;\r\n            that.logger.log(\"internal\", LOG_ID + \"(onCallLogAckReceived) received - 'stanza'\", msg, stanza);\r\n            try {\r\n                that.logger.log(\"info\", LOG_ID + \"(onCallLogAckReceived) received\");\r\n                //console.log(stanza);\r\n                let read = stanza.find(\"read\");\r\n                if (read.length > 0) {\r\n                    let msgId = stanza.find(\"read\").attr(\"call_id\");\r\n                    that.callLogAckUpdate(msgId);\r\n                    let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\r\n                    let num = that.getMissedCallLogCounter();\r\n                    if (num !== oldMissedCallLogCounter) {\r\n                        that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs);\r\n                        //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onCallLogAckReceived) \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onCallLogAckReceived) : \" + error);\r\n                return true;\r\n            }\r\n            return true;\r\n        };\r\n        this.onIqCallLogNotificationReceived = (msg, stanza) => __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"internal\", LOG_ID + \"(onIqCallLogNotificationReceived) received - 'stanza'\", msg, stanza);\r\n            that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) received\");\r\n            //console.log(stanza);\r\n            try {\r\n                let deleted_call_log = stanza.find(\"deleted_call_log\");\r\n                let updated_call_log = stanza.find(\"updated_call_log\");\r\n                if (deleted_call_log.length > 0) {\r\n                    that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) deleted IQ\");\r\n                    let peer = stanza.find(\"deleted_call_log\").attr(\"peer\");\r\n                    //no given user JID, reset all call-logs\r\n                    if (!peer) {\r\n                        that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) no given user JID, reset all call-logs\");\r\n                        yield that.resetCallLogs();\r\n                        yield that.calllogService.getCallLogHistoryPage();\r\n                    }\r\n                    else {\r\n                        that.removeCallLogsForUser(peer);\r\n                    }\r\n                }\r\n                else if (updated_call_log.length > 0) {\r\n                    that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived)  : Update call-logs\");\r\n                    that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\r\n                    Promise.all(that.callLogsPromises)\r\n                        .then(function () {\r\n                        that.logger.log(\"info\", LOG_ID + \"(onIqCallLogNotificationReceived) : update is done\");\r\n                        that.callLogsPromises = [];\r\n                        that.orderCallLogsFunction();\r\n                        let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\r\n                        let num = that.getMissedCallLogCounter();\r\n                        that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs);\r\n                        //$rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\r\n                        if (num !== oldMissedCallLogCounter) {\r\n                            that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs);\r\n                            //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            catch (error) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onIqCallLogNotificationReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onIqCallLogNotificationReceived) CATCH Error !!! : \", error);\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Method isMediaPillarJid\r\n     * @public\r\n     * @param {string} fromJid the from jid\r\n     * @returns {boolean} true if it is the media pillar Jid\r\n     * @memberof WebrtcGatewayService\r\n     */\r\n    isMediaPillarJid(fromJid) {\r\n        let indexMPinJid = -1; // presence&pos of \"mp_\" in jid\r\n        //no jid provided!\r\n        if (!fromJid) {\r\n            return false;\r\n        }\r\n        indexMPinJid = fromJid.search(\"mp_\"); //\"mp_\" must be at position 0\r\n        return (indexMPinJid === 0);\r\n    }\r\n    removeCallLogsForUser(jid) {\r\n        let that = this;\r\n        if (jid.endsWith(\"@_\")) {\r\n            // Ticket 2629 : remove @_ from jid added by server for JIDisation...\r\n            jid = jid.substring(0, jid.length - 2);\r\n        }\r\n        that.logger.log(\"info\", LOG_ID + \"removeCallLogsForUser with jid: \" + jid);\r\n        let newLogs = [];\r\n        for (let i = 0; i < that.calllogs.callLogs.length; i++) {\r\n            if (!that.calllogs.callLogs[i].contact || (that.calllogs.callLogs[i].contact.jid !== jid && that.calllogs.callLogs[i].contact.id !== jid)) {\r\n                newLogs.push(that.calllogs.callLogs[i]);\r\n            }\r\n        }\r\n        that.calllogs.callLogs = newLogs;\r\n        that.orderCallLogsFunction();\r\n        let oldMissedCallLogCounter = that.calllogs.numberMissedCalls;\r\n        let num = that.getMissedCallLogCounter();\r\n        //$rootScope.$broadcast(\"ON_CALL_LOG_UPDATED\");\r\n        that.eventEmitter.emit(\"evt_internal_calllogupdated\", that.calllogs);\r\n        if (num !== oldMissedCallLogCounter) {\r\n            //$rootScope.$broadcast(\"ON_CALL_LOG_ACK_UPDATED\");\r\n            that.eventEmitter.emit(\"evt_internal_calllogackupdated\", that.calllogs);\r\n        }\r\n    }\r\n    ;\r\n    createCallLogFromMessage(message) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            // that.logger.log(\"info\", LOG_ID + \"[callLogService] createCallLogFromMessage\"); MCO really verbose....\r\n            let defered = new Deferred();\r\n            let messageElem = message;\r\n            let otherParticipantJid = null;\r\n            let otherParticipantNumber = null;\r\n            let direction = \"\";\r\n            let callid = messageElem.find(\"call_id\");\r\n            let id = callid.text();\r\n            let callerJid = messageElem.find(\"caller\").text();\r\n            let calleeJid = messageElem.find(\"callee\").text();\r\n            let state = messageElem.find(\"state\").text();\r\n            let duration = parseInt(messageElem.find(\"duration\").text(), 10);\r\n            let callSubject = messageElem.find(\"subject\").text();\r\n            let foundidentity = null;\r\n            let identityFirstName = \"\";\r\n            let identityLastName = \"\";\r\n            let type = \"webrtc\";\r\n            if ((callerJid && callerJid.indexOf(\"janusgateway\") !== -1) || (calleeJid && calleeJid.indexOf(\"janusgateway\") !== -1)) {\r\n                that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore janusgateway call-logs\");\r\n                return;\r\n            }\r\n            if ((callerJid && this.isMediaPillarJid(callerJid)) || (calleeJid && this.isMediaPillarJid(calleeJid))) {\r\n                that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore janusgateway call-logs\");\r\n                return;\r\n            }\r\n            let typeCall = messageElem.find(\"call_log\").attr(\"type\");\r\n            //compatibility with the old method\r\n            if (!typeCall) {\r\n                typeCall = messageElem.find(\"type\").text();\r\n            }\r\n            let read = (messageElem.find(\"ack\").attr(\"read\") === \"true\");\r\n            let date = messageElem.find(\"delay\").attr(\"stamp\");\r\n            let conference = (messageElem.find(\"call_log\").attr(\"service\") === \"conference\");\r\n            //check if phonebook search is allowed by profile else no result\r\n            if (that.profileService.isFeatureEnabled(that.profileService.getFeaturesEnum().TELEPHONY_PHONE_BOOK) || config_1.config.permitSearchFromPhoneBook) {\r\n                foundidentity = messageElem.find(\"identity\");\r\n            }\r\n            if (duration > 0) {\r\n                duration = moment.duration(duration, \"ms\").format(\"h[H] mm[m] ss[s]\");\r\n            }\r\n            else {\r\n                duration = 0;\r\n            }\r\n            if (date) {\r\n                date = new Date(date);\r\n            }\r\n            if (conference) {\r\n                otherParticipantJid = callerJid;\r\n                type = \"conference\";\r\n                direction = this.contactService.isUserContactJid(callerJid) ? \"outgoing\" : \"incoming\";\r\n                if (otherParticipantJid.indexOf(\"@\") === -1) {\r\n                    //telephone number\r\n                    otherParticipantNumber = otherParticipantJid;\r\n                    otherParticipantJid = null;\r\n                }\r\n            }\r\n            else {\r\n                if (typeCall === \"phone\") {\r\n                    type = \"telephone\";\r\n                }\r\n                if (this.contactService.isUserContactJid(callerJid)) {\r\n                    otherParticipantJid = calleeJid;\r\n                    direction = \"outgoing\";\r\n                }\r\n                else {\r\n                    otherParticipantJid = callerJid;\r\n                    direction = \"incoming\";\r\n                }\r\n                if (otherParticipantJid.indexOf(\"@\") === -1) {\r\n                    //telephone number\r\n                    otherParticipantNumber = otherParticipantJid;\r\n                    otherParticipantJid = null;\r\n                    type = \"telephone\";\r\n                }\r\n            }\r\n            if (otherParticipantJid || otherParticipantNumber) {\r\n                this.contactService.getOrCreateContact(otherParticipantJid, otherParticipantNumber).then((contact) => {\r\n                    that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage otherParticipant jid:\" + otherParticipantJid + \" => contact retrieved (temp:\" + contact.temp + \")\");\r\n                    that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage otherParticipant jid:\" + otherParticipantJid + \"  Number:\" + otherParticipantNumber + \" => contact retrieved (temp:\" + contact.temp + \")\");\r\n                    if (!conference && !otherParticipantJid && contact.temp) { //only in case of temp contact\r\n                        //find Xnames from directories\r\n                        if (foundidentity && foundidentity.length) {\r\n                            let foundFirstName = foundidentity.attr(\"firstName\");\r\n                            let foundLastName = foundidentity.attr(\"lastName\");\r\n                            let foundDisplayName = foundidentity.attr(\"displayName\");\r\n                            identityFirstName = foundFirstName ? foundFirstName : \"\";\r\n                            identityLastName = foundLastName ? foundLastName : \"\";\r\n                            if (identityLastName === \"\" && identityFirstName === \"\" &&\r\n                                foundDisplayName && foundDisplayName.length !== 0 && foundDisplayName !== otherParticipantNumber) {\r\n                                identityLastName = foundDisplayName; //hack to use displayName instead of lastName (when lastName not available)\r\n                            }\r\n                            if (identityFirstName.length || identityLastName.length) {\r\n                                //update contact\r\n                                that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  xNames updated from directories for contact \" + contact.id);\r\n                                contact.updateName(identityFirstName, identityLastName);\r\n                            }\r\n                        }\r\n                        else { //try to find in outlook\r\n                            // Do not do it in node.\r\n                            /*\r\n                            try {\r\n                                let centralizedService = $injector.get(\"centralizedService\");\r\n                                let reload = true;\r\n                                centralizedService.outlook.updateContactFromOutlookInfos(contact, otherParticipantNumber, reload)\r\n                                    .then(\r\n                                        function successCallback(updateStatus) {\r\n                                            if (updateStatus) {\r\n                                                that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  xNames updated from outlook for contact \" + contact.id);\r\n                                            } else {\r\n                                                that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage no update from outlook for contact :\" + contact.id);\r\n                                            }\r\n                                        },\r\n                                        function errorCallback() {\r\n                                            that.logger.log(\"debug\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  no Outlook search available\");\r\n                                        }\r\n                                    );\r\n                            } catch (error) {\r\n                            }\r\n                            // */\r\n                        }\r\n                        //#29830++\r\n                        //if displayNmane is a phone number (and only for contact.temp)\r\n                        //then use phoneProcan as displayName and display only that in calllog (done in callLogsCell.html)\r\n                        let displayNameisAPhoneNumber = false;\r\n                        let phone_number_regex = /^[0-9A-D #\\-\\+\\*\\(\\)\\./]{1,32}$/;\r\n                        if (that.telephonyService.started) {\r\n                            let matchAsNumber = contact.displayName.match(phone_number_regex);\r\n                            displayNameisAPhoneNumber = matchAsNumber && that.telephonyService.startAsPhoneNumber(contact.displayName);\r\n                        }\r\n                        if (displayNameisAPhoneNumber) {\r\n                            if (contact.phoneProCan && contact.phoneProCan !== \"\") {\r\n                                contact.displayName = contact.phoneProCan; //use phoneProCan as displayName\r\n                            }\r\n                        }\r\n                        //#29830--\r\n                    }\r\n                    let callLog = CallLog.create(id, contact, state, duration, type, read, date, direction, callSubject);\r\n                    //do not push up duplicates\r\n                    if (!that.logAlreadyExists(callLog) && state !== \"failed\" && state !== \"ongoing\") {\r\n                        that.calllogs.callLogs.push(callLog);\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore call log, state: \" + state);\r\n                        that.logger.log(\"internal\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage ignore call log with id: \" + id + \", state: \" + state);\r\n                    }\r\n                    that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage success\");\r\n                    defered.resolve(callLog);\r\n                })\r\n                    .catch(function (error) {\r\n                    that.logger.log(\"error\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage error \");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage error : \" + error);\r\n                    defered.resolve();\r\n                });\r\n            }\r\n            else {\r\n                that.logger.log(\"info\", LOG_ID + \"[createCallLogFromMessage] createCallLogFromMessage  No jid or no phoneNumber \");\r\n                defered.resolve();\r\n            }\r\n            return defered.promise;\r\n        });\r\n    }\r\n    logAlreadyExists(log) {\r\n        let that = this;\r\n        let i;\r\n        for (i = 0; i < that.calllogs.callLogs.length; i++) {\r\n            if (that.calllogs.callLogs[i].id === log.id) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    orderCallLogsFunction() {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"[orderCallLogsFunction] orderByFunction\");\r\n        that.calllogs.orderByNameCallLogsBruts = orderByFilter(that.calllogs.callLogs, CallLog.getNames, false, CallLog.sortByContact);\r\n        that.calllogs.orderByDateCallLogsBruts = orderByFilter(that.calllogs.callLogs, CallLog.getDate, false, CallLog.sortByDate);\r\n        that.calllogs.simplifiedCallLogs = that.simplifyCallLogs(that.calllogs.orderByDateCallLogsBruts);\r\n        that.calllogs.orderByNameCallLogs = that.fusionInformation(that.calllogs.orderByNameCallLogsBruts);\r\n        that.calllogs.orderByDateCallLogs = that.fusionInformation(that.calllogs.orderByDateCallLogsBruts);\r\n        return this.calllogs;\r\n    }\r\n    //get number of non-ack missed calls\r\n    getMissedCallLogCounter() {\r\n        let that = this;\r\n        let num = 0;\r\n        that.calllogs.callLogs.forEach((callLog) => {\r\n            if (!callLog.read && callLog.state === \"missed\" && callLog.direction === \"incoming\") {\r\n                num++;\r\n            }\r\n        });\r\n        that.calllogs.numberMissedCalls = num;\r\n        return num;\r\n    }\r\n    //update ACK for call log with ID\r\n    callLogAckUpdate(id) {\r\n        let that = this;\r\n        try {\r\n            that.calllogs.callLogs.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n            that.calllogs.simplifiedCallLogs.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n            that.calllogs.orderByDateCallLogs.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n            that.calllogs.orderByNameCallLogsBruts.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n            that.calllogs.orderByDateCallLogsBruts.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n            that.calllogs.orderByNameCallLogs.forEach(function (callLog) {\r\n                if (callLog.id === id) {\r\n                    callLog.read = true;\r\n                    return;\r\n                }\r\n            });\r\n        }\r\n        catch (err) {\r\n            that.logger.log(\"error\", LOG_ID + \"[callLogAckUpdate] !!! CATCH Error \");\r\n            that.logger.log(\"internalerror\", LOG_ID + \"[callLogAckUpdate] !!! CATCH Error : \", err);\r\n        }\r\n    }\r\n    simplifyCallLogs(callLogs) {\r\n        let result = [];\r\n        for (let i = 0; i < callLogs.length; i++) {\r\n            result[i] = {};\r\n            result[i].contact = callLogs[i].contact.id;\r\n            result[i].contactDisplayName = callLogs[i].contact.displayName;\r\n            result[i].contactInitials = callLogs[i].contact.initials;\r\n            result[i].id = callLogs[i].id;\r\n            result[i].state = callLogs[i].state;\r\n            result[i].duration = callLogs[i].duration;\r\n            result[i].direction = callLogs[i].direction;\r\n            result[i].type = callLogs[i].type;\r\n            result[i].read = callLogs[i].read;\r\n            result[i].date = callLogs[i].date;\r\n        }\r\n        return result;\r\n    }\r\n    resetCallLogs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[resetCallLogs] resetCallLogs\");\r\n            that.calllogs = {\r\n                \"callLogs\": [],\r\n                \"orderByNameCallLogs\": [],\r\n                \"orderByDateCallLogs\": [],\r\n                \"orderByNameCallLogsBruts\": [],\r\n                \"orderByDateCallLogsBruts\": [],\r\n                \"simplifiedCallLogs\": [],\r\n                \"numberMissedCalls\": 0,\r\n                \"lastTimestamp\": null\r\n            };\r\n        });\r\n    }\r\n    fusionInformation(callLogs) {\r\n        let passed = {};\r\n        let current = 0;\r\n        let fusion = [];\r\n        for (let i = 0; i < callLogs.length; i++) {\r\n            let log = callLogs[i];\r\n            let jid = log.contact.jid;\r\n            if (!log.contact.jid) {\r\n                jid = log.contact.id;\r\n            }\r\n            //if conference log\r\n            if (log.type === \"conference\") {\r\n                if (i !== 0) {\r\n                    current++;\r\n                }\r\n                fusion[current] = log;\r\n                fusion[current].count = 1;\r\n                fusion[current].editable = false;\r\n                continue;\r\n            }\r\n            //first element\r\n            if (i === 0) {\r\n                passed[jid] = 1;\r\n                fusion[current] = log;\r\n                fusion[current].count = 1;\r\n                fusion[current].editable = true;\r\n                if (log.state === \"missed\" && log.direction === \"incoming\") {\r\n                    fusion[current].isMissed = true;\r\n                }\r\n                else if (log.state === \"missed\" && log.direction === \"outgoing\") {\r\n                    fusion[current].isNotAnswered = true;\r\n                }\r\n                continue;\r\n            }\r\n            //if we already have this element\r\n            if (passed[jid]) {\r\n                let index = passed[jid];\r\n                let element = fusion[index - 1];\r\n                if (element.editable) {\r\n                    if (element.isMissed && log.state === \"missed\" && log.direction === \"incoming\") {\r\n                        element.count++;\r\n                    }\r\n                    else if (element.isNotAnswered && log.state === \"missed\" && log.direction === \"outgoing\") {\r\n                        element.count++;\r\n                    }\r\n                    else {\r\n                        element.editable = false;\r\n                    }\r\n                }\r\n            }\r\n            //new element\r\n            else {\r\n                current++;\r\n                passed[jid] = current + 1;\r\n                fusion[current] = log;\r\n                fusion[current].count = 1;\r\n                fusion[current].editable = true;\r\n                if (log.state === \"missed\" && log.direction === \"incoming\") {\r\n                    fusion[current].isMissed = true;\r\n                }\r\n                else if (log.state === \"missed\" && log.direction === \"outgoing\") {\r\n                    fusion[current].isNotAnswered = true;\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n        return fusion;\r\n    }\r\n};\r\nCallLogEventHandler = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID)\r\n], CallLogEventHandler);\r\nexports.CallLogEventHandler = CallLogEventHandler;\r\nmodule.exports.CallLogEventHandler = CallLogEventHandler;\r\n//# sourceMappingURL=calllogEventHandler.js.map"]},"metadata":{},"sourceType":"script"}