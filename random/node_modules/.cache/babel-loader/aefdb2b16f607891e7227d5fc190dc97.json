{"ast":null,"code":"//\n// FileReader\n//\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\n// https://developer.mozilla.org/en/DOM/FileReader\n(function () {\n  \"use strict\";\n\n  var fs = require(\"fs\"),\n      EventEmitter = require(\"events\").EventEmitter;\n\n  function doop(fn, args, context) {\n    if ('function' === typeof fn) {\n      fn.apply(context, args);\n    }\n  }\n\n  function toDataUrl(data, type) {\n    // var data = self.result;\n    var dataUrl = 'data:';\n\n    if (type) {\n      dataUrl += type + ';';\n    }\n\n    if (/text/i.test(type)) {\n      dataUrl += 'charset=utf-8,';\n      dataUrl += data.toString('utf8');\n    } else {\n      dataUrl += 'base64,';\n      dataUrl += data.toString('base64');\n    }\n\n    return dataUrl;\n  }\n\n  function mapDataToFormat(file, data, format, encoding) {\n    // var data = self.result;\n    switch (format) {\n      case 'buffer':\n        return data;\n        break;\n\n      case 'binary':\n        return data.toString('binary');\n        break;\n\n      case 'dataUrl':\n        return toDataUrl(data, file.type);\n        break;\n\n      case 'text':\n        return data.toString(encoding || 'utf8');\n        break;\n    }\n  }\n\n  function FileReader() {\n    var self = this,\n        emitter = new EventEmitter(),\n        file;\n\n    self.addEventListener = function (on, callback) {\n      emitter.on(on, callback);\n    };\n\n    self.removeEventListener = function (callback) {\n      emitter.removeListener(callback);\n    };\n\n    self.dispatchEvent = function (on) {\n      emitter.emit(on);\n    };\n\n    self.EMPTY = 0;\n    self.LOADING = 1;\n    self.DONE = 2;\n    self.error = undefined; // Read only\n\n    self.readyState = self.EMPTY; // Read only\n\n    self.result = undefined; // Road only\n    // non-standard\n\n    self.on = function () {\n      emitter.on.apply(emitter, arguments);\n    };\n\n    self.nodeChunkedEncoding = false;\n\n    self.setNodeChunkedEncoding = function (val) {\n      self.nodeChunkedEncoding = val;\n    }; // end non-standard\n    // Whatever the file object is, turn it into a Node.JS File.Stream\n\n\n    function createFileStream() {\n      var stream = new EventEmitter(),\n          chunked = self.nodeChunkedEncoding; // attempt to make the length computable\n\n      if (!file.size && chunked && file.path) {\n        fs.stat(file.path, function (err, stat) {\n          file.size = stat.size;\n          file.lastModifiedDate = stat.mtime;\n        });\n      } // The stream exists, do nothing more\n\n\n      if (file.stream) {\n        return;\n      } // Create a read stream from a buffer\n\n\n      if (file.buffer) {\n        process.nextTick(function () {\n          stream.emit('data', file.buffer);\n          stream.emit('end');\n        });\n        file.stream = stream;\n        return;\n      } // Create a read stream from a file\n\n\n      if (file.path) {\n        // TODO url\n        if (!chunked) {\n          fs.readFile(file.path, function (err, data) {\n            if (err) {\n              stream.emit('error', err);\n            }\n\n            if (data) {\n              stream.emit('data', data);\n              stream.emit('end');\n            }\n          });\n          file.stream = stream;\n          return;\n        } // TODO don't duplicate this code here,\n        // expose a method in File instead\n\n\n        file.stream = fs.createReadStream(file.path);\n      }\n    } // before any other listeners are added\n\n\n    emitter.on('abort', function () {\n      self.readyState = self.DONE;\n    }); // Map `error`, `progress`, `load`, and `loadend`\n\n    function mapStreamToEmitter(format, encoding) {\n      var stream = file.stream,\n          buffers = [],\n          chunked = self.nodeChunkedEncoding;\n      buffers.dataLength = 0;\n      stream.on('error', function (err) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        self.readyState = self.DONE;\n        self.error = err;\n        emitter.emit('error', err);\n      });\n      stream.on('data', function (data) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        buffers.dataLength += data.length;\n        buffers.push(data);\n        emitter.emit('progress', {\n          // fs.stat will probably complete before this\n          // but possibly it will not, hence the check\n          lengthComputable: !isNaN(file.size) ? true : false,\n          loaded: buffers.dataLength,\n          total: file.size\n        });\n        emitter.emit('data', data);\n      });\n      stream.on('end', function () {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        var data;\n\n        if (buffers.length > 1) {\n          data = Buffer.concat(buffers);\n        } else {\n          data = buffers[0];\n        }\n\n        self.readyState = self.DONE;\n        self.result = mapDataToFormat(file, data, format, encoding);\n        emitter.emit('load', {\n          target: {\n            // non-standard\n            nodeBufferResult: data,\n            result: self.result\n          }\n        });\n        emitter.emit('loadend');\n      });\n    } // Abort is overwritten by readAsXyz\n\n\n    self.abort = function () {\n      if (self.readState == self.DONE) {\n        return;\n      }\n\n      self.readyState = self.DONE;\n      emitter.emit('abort');\n    }; // \n\n\n    function mapUserEvents() {\n      emitter.on('start', function () {\n        doop(self.onloadstart, arguments);\n      });\n      emitter.on('progress', function () {\n        doop(self.onprogress, arguments);\n      });\n      emitter.on('error', function (err) {\n        // TODO translate to FileError\n        if (self.onerror) {\n          self.onerror(err);\n        } else {\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\n            throw err;\n          }\n        }\n      });\n      emitter.on('load', function () {\n        doop(self.onload, arguments);\n      });\n      emitter.on('end', function () {\n        doop(self.onloadend, arguments);\n      });\n      emitter.on('abort', function () {\n        doop(self.onabort, arguments);\n      });\n    }\n\n    function readFile(_file, format, encoding) {\n      file = _file;\n\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\n      }\n\n      if (0 !== self.readyState) {\n        console.log(\"already loading, request to change format ignored\");\n        return;\n      } // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\n      // Hence we waste a single tick waiting\n\n\n      process.nextTick(function () {\n        self.readyState = self.LOADING;\n        emitter.emit('loadstart');\n        createFileStream();\n        mapStreamToEmitter(format, encoding);\n        mapUserEvents();\n      });\n    }\n\n    self.readAsArrayBuffer = function (file) {\n      readFile(file, 'buffer');\n    };\n\n    self.readAsBinaryString = function (file) {\n      readFile(file, 'binary');\n    };\n\n    self.readAsDataURL = function (file) {\n      readFile(file, 'dataUrl');\n    };\n\n    self.readAsText = function (file, encoding) {\n      readFile(file, 'text', encoding);\n    };\n  }\n\n  module.exports = FileReader;\n})();","map":{"version":3,"sources":["C:/Users/Jose Johnson/Desktop/KanScrubs/random/node_modules/filereader/FileReader.js"],"names":["fs","require","EventEmitter","doop","fn","args","context","apply","toDataUrl","data","type","dataUrl","test","toString","mapDataToFormat","file","format","encoding","FileReader","self","emitter","addEventListener","on","callback","removeEventListener","removeListener","dispatchEvent","emit","EMPTY","LOADING","DONE","error","undefined","readyState","result","arguments","nodeChunkedEncoding","setNodeChunkedEncoding","val","createFileStream","stream","chunked","size","path","stat","err","lastModifiedDate","mtime","buffer","process","nextTick","readFile","createReadStream","mapStreamToEmitter","buffers","dataLength","length","push","lengthComputable","isNaN","loaded","total","Buffer","concat","target","nodeBufferResult","abort","readState","mapUserEvents","onloadstart","onprogress","onerror","listeners","onload","onloadend","onabort","_file","name","Error","JSON","stringify","console","log","readAsArrayBuffer","readAsBinaryString","readAsDataURL","readAsText","module","exports"],"mappings":"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","sourcesContent":["//\r\n// FileReader\r\n//\r\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\r\n// https://developer.mozilla.org/en/DOM/FileReader\r\n(function () {\r\n  \"use strict\";\r\n\r\n  var fs = require(\"fs\")\r\n    , EventEmitter = require(\"events\").EventEmitter\r\n    ;\r\n\r\n  function doop(fn, args, context) {\r\n    if ('function' === typeof fn) {\r\n      fn.apply(context, args);\r\n    }\r\n  }\r\n\r\n  function toDataUrl(data, type) {\r\n    // var data = self.result;\r\n    var dataUrl = 'data:';\r\n\r\n    if (type) {\r\n      dataUrl += type + ';';\r\n    }\r\n\r\n    if (/text/i.test(type)) {\r\n      dataUrl += 'charset=utf-8,';\r\n      dataUrl += data.toString('utf8');\r\n    } else {\r\n      dataUrl += 'base64,';\r\n      dataUrl += data.toString('base64');\r\n    }\r\n\r\n    return dataUrl;\r\n  }\r\n\r\n  function mapDataToFormat(file, data, format, encoding) {\r\n    // var data = self.result;\r\n\r\n    switch(format) {\r\n      case 'buffer':\r\n        return data;\r\n        break;\r\n      case 'binary':\r\n        return data.toString('binary');\r\n        break;\r\n      case 'dataUrl':\r\n        return toDataUrl(data, file.type);\r\n        break;\r\n      case 'text':\r\n        return data.toString(encoding || 'utf8');\r\n        break;\r\n    }\r\n  }\r\n\r\n  function FileReader() {\r\n    var self = this,\r\n      emitter = new EventEmitter,\r\n      file;\r\n\r\n    self.addEventListener = function (on, callback) {\r\n      emitter.on(on, callback);\r\n    };\r\n    self.removeEventListener = function (callback) {\r\n      emitter.removeListener(callback);\r\n    }\r\n    self.dispatchEvent = function (on) {\r\n      emitter.emit(on);\r\n    }\r\n\r\n    self.EMPTY = 0;\r\n    self.LOADING = 1;\r\n    self.DONE = 2;\r\n\r\n    self.error = undefined;         // Read only\r\n    self.readyState = self.EMPTY;   // Read only\r\n    self.result = undefined;        // Road only\r\n\r\n    // non-standard\r\n    self.on = function () {\r\n      emitter.on.apply(emitter, arguments);\r\n    }\r\n    self.nodeChunkedEncoding = false;\r\n    self.setNodeChunkedEncoding = function (val) {\r\n      self.nodeChunkedEncoding = val;\r\n    };\r\n    // end non-standard\r\n\r\n\r\n\r\n    // Whatever the file object is, turn it into a Node.JS File.Stream\r\n    function createFileStream() {\r\n      var stream = new EventEmitter(),\r\n        chunked = self.nodeChunkedEncoding;\r\n\r\n      // attempt to make the length computable\r\n      if (!file.size && chunked && file.path) {\r\n        fs.stat(file.path, function (err, stat) {\r\n          file.size = stat.size;\r\n          file.lastModifiedDate = stat.mtime;\r\n        });\r\n      }\r\n\r\n\r\n      // The stream exists, do nothing more\r\n      if (file.stream) {\r\n        return;\r\n      }\r\n\r\n\r\n      // Create a read stream from a buffer\r\n      if (file.buffer) {\r\n        process.nextTick(function () {\r\n          stream.emit('data', file.buffer);\r\n          stream.emit('end');\r\n        });\r\n        file.stream = stream;\r\n        return;\r\n      }\r\n\r\n\r\n      // Create a read stream from a file\r\n      if (file.path) {\r\n        // TODO url\r\n        if (!chunked) {\r\n          fs.readFile(file.path, function (err, data) {\r\n            if (err) {\r\n              stream.emit('error', err);\r\n            }\r\n            if (data) {\r\n              stream.emit('data', data);\r\n              stream.emit('end');\r\n            }\r\n          });\r\n\r\n          file.stream = stream;\r\n          return;\r\n        }\r\n\r\n        // TODO don't duplicate this code here,\r\n        // expose a method in File instead\r\n        file.stream = fs.createReadStream(file.path);\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // before any other listeners are added\r\n    emitter.on('abort', function () {\r\n      self.readyState = self.DONE;\r\n    });\r\n\r\n\r\n\r\n    // Map `error`, `progress`, `load`, and `loadend`\r\n    function mapStreamToEmitter(format, encoding) {\r\n      var stream = file.stream,\r\n        buffers = [],\r\n        chunked = self.nodeChunkedEncoding;\r\n\r\n      buffers.dataLength = 0;\r\n\r\n      stream.on('error', function (err) {\r\n        if (self.DONE === self.readyState) {\r\n          return;\r\n        }\r\n\r\n        self.readyState = self.DONE;\r\n        self.error = err;\r\n        emitter.emit('error', err);\r\n      });\r\n\r\n      stream.on('data', function (data) {\r\n        if (self.DONE === self.readyState) {\r\n          return;\r\n        }\r\n\r\n        buffers.dataLength += data.length;\r\n        buffers.push(data);\r\n\r\n        emitter.emit('progress', {\r\n          // fs.stat will probably complete before this\r\n          // but possibly it will not, hence the check\r\n          lengthComputable: (!isNaN(file.size)) ? true : false,\r\n          loaded: buffers.dataLength,\r\n          total: file.size\r\n        });\r\n\r\n        emitter.emit('data', data);\r\n      });\r\n\r\n      stream.on('end', function () {\r\n        if (self.DONE === self.readyState) {\r\n          return;\r\n        }\r\n\r\n        var data;\r\n\r\n        if (buffers.length > 1 ) {\r\n          data = Buffer.concat(buffers);\r\n        } else {\r\n          data = buffers[0];\r\n        }\r\n\r\n        self.readyState = self.DONE;\r\n        self.result = mapDataToFormat(file, data, format, encoding);\r\n        emitter.emit('load', {\r\n          target: {\r\n            // non-standard\r\n            nodeBufferResult: data,\r\n            result: self.result\r\n          }\r\n        });\r\n\r\n        emitter.emit('loadend');\r\n      });\r\n    }\r\n\r\n\r\n    // Abort is overwritten by readAsXyz\r\n    self.abort = function () {\r\n      if (self.readState == self.DONE) {\r\n        return;\r\n      }\r\n      self.readyState = self.DONE;\r\n      emitter.emit('abort');\r\n    };\r\n\r\n\r\n\r\n    // \r\n    function mapUserEvents() {\r\n      emitter.on('start', function () {\r\n        doop(self.onloadstart, arguments);\r\n      });\r\n      emitter.on('progress', function () {\r\n        doop(self.onprogress, arguments);\r\n      });\r\n      emitter.on('error', function (err) {\r\n        // TODO translate to FileError\r\n        if (self.onerror) {\r\n          self.onerror(err);\r\n        } else {\r\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\r\n            throw err;\r\n          }\r\n        }\r\n      });\r\n      emitter.on('load', function () {\r\n        doop(self.onload, arguments);\r\n      });\r\n      emitter.on('end', function () {\r\n        doop(self.onloadend, arguments);\r\n      });\r\n      emitter.on('abort', function () {\r\n        doop(self.onabort, arguments);\r\n      });\r\n    }\r\n\r\n\r\n\r\n    function readFile(_file, format, encoding) {\r\n      file = _file;\r\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\r\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\r\n      }\r\n      if (0 !== self.readyState) {\r\n        console.log(\"already loading, request to change format ignored\");\r\n        return;\r\n      }\r\n\r\n      // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\r\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\r\n      // Hence we waste a single tick waiting\r\n      process.nextTick(function () {\r\n        self.readyState = self.LOADING;\r\n        emitter.emit('loadstart');\r\n        createFileStream();\r\n        mapStreamToEmitter(format, encoding);\r\n        mapUserEvents();\r\n      });\r\n    }\r\n\r\n    self.readAsArrayBuffer = function (file) {\r\n      readFile(file, 'buffer');\r\n    };\r\n    self.readAsBinaryString = function (file) {\r\n      readFile(file, 'binary');\r\n    };\r\n    self.readAsDataURL = function (file) {\r\n      readFile(file, 'dataUrl');\r\n    };\r\n    self.readAsText = function (file, encoding) {\r\n      readFile(file, 'text', encoding);\r\n    };\r\n  }\r\n\r\n  module.exports = FileReader;\r\n}());\r\n"]},"metadata":{},"sourceType":"script"}