{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst URL = require(\"url\");\n\nconst fs = require(\"fs\"); //const TransferPromiseQueue = require(\"./TransferPromiseQueue\");\n\n\nconst promiseQueue_1 = require(\"../common/promiseQueue\");\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"FileServer/SVCE - \";\nconst ONE_KILOBYTE = 1024;\nconst ONE_MEGABYTE = 1024 * 1024;\nconst ONE_GIGABYTE = 1024 * 1024 * 1024;\nlet FileServer =\n/**\r\n* @module\r\n* @name FileStorage\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service manage files on server side\r\n*/\nclass FileServer {\n  constructor(_eventEmitter, _logger, _startConfig) {\n    this.ready = false;\n    this._startConfig = _startConfig;\n    this._eventEmitter = _eventEmitter;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this._logger = _logger;\n    this._capabilities = null;\n    this.transferPromiseQueue = null;\n    this._fileStorageService = null;\n    this.ready = false;\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  get capabilities() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      if (!that._capabilities) {\n        if (that._rest) {\n          that._rest.getServerCapabilities().then(capabilities => {\n            that._capabilities = capabilities; //that.transferPromiseQueue = new TransferPromiseQueue(that._logger);\n\n            resolve(this._capabilities);\n          }).catch(() => {\n            return reject();\n          });\n        } else {\n          return reject();\n        }\n\n        return;\n      }\n\n      resolve(that._capabilities);\n    });\n  }\n\n  start(_options, _core) {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = _core._xmpp;\n        that._rest = _core._rest;\n        that._options = _options;\n        that._s2s = _core._s2s;\n        that._useXMPP = that._options.useXMPP;\n        that._useS2S = that._options.useS2S;\n        that._fileStorageService = _core.fileStorage;\n        that.ready = true;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  stop() {\n    let that = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        that._xmpp = null;\n        that._rest = null;\n        that.ready = false;\n        resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  init() {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      let capa = that.capabilities;\n      resolve(capa);\n    });\n  }\n  /**\r\n   * Method retrieve data from server using range request mecanism (RFC7233)\r\n   *\r\n   * @private\r\n   * @param {string} url [required] server url for request\r\n   * @param {number} minRange [requied] minimum value of range\r\n   * @param {number} maxRange [required] maximum value of range\r\n   * @param {number} index [required] index of the part. Used to re-assemble the data\r\n   * @returns {Object} structure containing the response data from server and the index\r\n   *\r\n   */\n\n\n  getPartialDataFromServer(url, minRange, maxRange, index) {\n    return this._rest.getPartialDataFromServer(url, minRange, maxRange, index);\n  }\n  /**\r\n   * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary\r\n   *\r\n   * @param {string} url [required] server url for request\r\n   * @param {string} mime [required] Mime type of the blob to be created\r\n   * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n   * @param {string} fileName [optional] name of file to be downloaded\r\n   * @returns {Buffer} Buffer created from data received from server\r\n   *\r\n   */\n\n\n  getBufferFromUrlWithOptimization(url, mime, fileSize, fileName, uploadedDate) {\n    let that = this;\n\n    if (fileSize === void 0) {\n      fileSize = 0;\n    }\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    if (uploadedDate === void 0) {\n      uploadedDate = \"\";\n    }\n\n    if (uploadedDate.length !== 0) {\n      url += \"?update=\" + crypto.createHash(\"md5\").update(uploadedDate).digest(\"hex\");\n    }\n\n    let _url = url.startsWith(\"http\") ? URL.parse(url).path : url;\n\n    return new Promise((resolve, reject) => {\n      this.capabilities.then(capabilities => {\n        if (Boolean(capabilities.maxChunkSizeDownload) && fileSize !== 0 && fileSize > capabilities.maxChunkSizeDownload) {\n          let range = capabilities.maxChunkSizeDownload;\n          let minRange = 0;\n          let maxRange = range - 1;\n          let repetition = Math.ceil(fileSize / range);\n          let bufferArray = new Array(repetition);\n          let promiseArray = [];\n\n          for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n            promiseArray.push(this.getPartialDataFromServer(_url, minRange, maxRange, i).then(response => {\n              bufferArray[response.index] = response.data;\n              return response.data;\n            }));\n          }\n\n          Promise.all(promiseArray).then(() => {\n            let buffer = Buffer.concat(bufferArray);\n\n            that._logger.log(\"info\", LOG_ID + \"[FileServer] getBufferFromUrlWithOptimization success\");\n\n            resolve(buffer);\n          }, error => {\n            that._logger.log(\"error\", LOG_ID + \"[FileServer] Error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"[FileServer] Error : \", error);\n\n            return reject(error);\n          });\n        } else {\n          resolve(that._rest.getFileFromUrl(_url));\n        }\n      });\n    });\n  }\n  /**\r\n   * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary\r\n   *\r\n   * @param destFile\r\n   * @param {string} url [required] server url for request\r\n   * @param {string} mime [required] Mime type of the blob to be created\r\n   * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n   * @param {string} fileName [optional] name of file to be downloaded\r\n   * @param {string} uploadedDate [optional] date of the upload\r\n   * @returns {Buffer} Buffer created from data received from server\r\n   *\r\n   */\n\n\n  getFileFromUrlWithOptimization(destFile, url, mime, fileSize, fileName, uploadedDate) {\n    let that = this;\n\n    if (fileSize === void 0) {\n      fileSize = 0;\n    }\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    if (uploadedDate === void 0) {\n      uploadedDate = \"\";\n    }\n\n    if (uploadedDate.length !== 0) {\n      url += \"?update=\" + crypto.createHash(\"md5\").update(uploadedDate).digest(\"hex\");\n    }\n\n    let _url = url.startsWith(\"http\") ? URL.parse(url).path : url;\n\n    let stream = fs.createWriteStream(destFile, {\n      flags: \"a\"\n    });\n    return new Promise((resolve, reject) => {\n      this.capabilities.then(capabilities => {\n        if (Boolean(capabilities.maxChunkSizeDownload) && fileSize !== 0 && fileSize > capabilities.maxChunkSizeDownload) {\n          let range = capabilities.maxChunkSizeDownload;\n          let minRange = 0;\n          let maxRange = range - 1;\n          let repetition = Math.ceil(fileSize / range);\n          let blobArray = new Array(repetition);\n          let promiseArray = [];\n\n          for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n            promiseArray.push(this.getPartialDataFromServer(_url, minRange, maxRange, i).then(response => {\n              blobArray[response.index] = response.data;\n              return response.data;\n            }));\n          }\n\n          Promise.all(promiseArray).then(() => {\n            let buffer = Buffer.concat(blobArray);\n\n            that._logger.log(\"info\", LOG_ID + \"[FileServer] getBufferFromUrlWithOptimization success\");\n\n            resolve(buffer);\n          }, error => {\n            that._logger.log(\"error\", LOG_ID + \"[FileServer] Error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"[FileServer] Error : \", error);\n\n            return reject(error);\n          });\n        } else {\n          resolve(that._rest.getFileFromUrl(_url));\n        }\n      });\n    });\n  }\n  /***\r\n   * @private\r\n   * @param fileDescriptor\r\n   * @param large\r\n   */\n\n\n  getBlobThumbnailFromFileDescriptor(fileDescriptor, large = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      /*\r\n              if (fileDescriptor.thumbnail.isThumbnailAvailable() ||\r\n                  (fileDescriptor.isImage() && fileDescriptor.size < (20 * this.ONE_KILOBYTE)) ) {\r\n      \r\n                  // Check if a request for this thumbnail is already lauched\r\n                  let existingPromise = this.thumbnailPromises[fileDescriptor.id];\r\n                  if (existingPromise) {\r\n                      this.$log.info(\"[FileServerService] getBlobThumbnailFromFileDescriptor \" + fileDescriptor.id + \" already lauched\");\r\n                      return existingPromise.promise;\r\n                  }\r\n      \r\n                  // Create the defered object\r\n                  let defered = this.$q.defer();\r\n                  this.thumbnailPromises[fileDescriptor.id] = defered;\r\n      \r\n                  // Forge the thumbnail url\r\n                  let url = fileDescriptor.url;\r\n                  if (fileDescriptor.thumbnail.isThumbnailAvailable() && fileDescriptor.size >= (20 * this.ONE_KILOBYTE)) {\r\n                      if (large) { url += \"?thumbnail500=true\"; }\r\n                      else { url += \"?thumbnail=true\"; }\r\n                  }\r\n                  else if (fileDescriptor.uploadedDate) { url += \"?update=\" + MD5.hexdigest(fileDescriptor.uploadedDate); }\r\n      \r\n                  // Get the thumbnail blob\r\n                  this.getBlobFromUrl(url, fileDescriptor.typeMIME, fileDescriptor.size, fileDescriptor.fileName)\r\n                      .then((blob) => {\r\n                          fileDescriptor.previewBlob = blob;\r\n      \r\n                          this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                              result: \"success\", type: \"download\",\r\n                              fileDesc: fileDescriptor});\r\n                          delete this.thumbnailPromises[fileDescriptor.id];\r\n                          defered.resolve(blob);\r\n                      })\r\n                      .catch((error) => {\r\n                          this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                              result: \"failure\", type: \"download\", message: error.message,\r\n                              fileDesc: fileDescriptor});\r\n                          delete this.thumbnailPromises[fileDescriptor.id];\r\n                          defered.reject(error);\r\n                      });\r\n      \r\n                  return defered.promise;\r\n              }\r\n              else { return this.$q.reject(); }\r\n      \r\n       */\n    });\n  }\n\n  /**\r\n   * Method sends data file to server\r\n   *\r\n   * @private\r\n   * @param {string} fileId [required] file descriptor ID of file to be sent\r\n   * @param {File} file [required] file to be sent\r\n   * @param {string} mime [required] mime type of file\r\n   * @returns {Promise<FileDescriptor>} file descriptor data received as response from server or http error response\r\n   *\r\n   */\n  _uploadAFile(fileId, filePath, mime) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      let fileDescriptor = that._fileStorageService.getFileDescriptorById(fileId);\n\n      if (fileDescriptor) {\n        fileDescriptor.state = \"uploading\";\n      }\n\n      let stream = fs.createReadStream(filePath); //let buffer = new Buffer(ONE_MEGABYTE);\n\n      /*\r\n                  let myWritableStreamBuffer = new streamBuffers.WritableStreamBuffer({\r\n                      initialSize: (1000 * 1024),   // start at 100 kilobytes.\r\n                      incrementAmount: (100 * 1024) // grow by 10 kilobytes each time buffer overflows.\r\n                  });\r\n      */\n      //stream.pipe(myWritableStreamBuffer);\n      //            stream.pipe(buffer)\n\n      that._rest.uploadAStream(fileId, stream).then(response => {\n        //let fileDescResponse = response.data.data;\n        let newFileDescriptor = that._fileStorageService.getFileDescriptorById(fileId);\n\n        if (newFileDescriptor) {\n          newFileDescriptor.state = \"uploaded\";\n        }\n\n        that._logger.log(\"info\", LOG_ID + \"(UploadAFile) success\"); // this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\n        //     result: \"success\",\n        //     type: \"upload\",\n        //     url: this.portalURL + \"/\" + fileId,\n        //     fileId: fileId,\n        //     mime: mime,\n        //     filename: file.name,\n        //     filesize: file.size\n        // });\n        // this._fileStorageService.orderDocuments();\n\n\n        resolve(newFileDescriptor);\n      }).catch(errorResponse => {\n        // let error = this.errorHelperService.handleError(errorResponse);\n        // this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\n        //     result: \"failure\",\n        //     type: \"upload\",\n        //     url: this.portalURL + \"/\" + fileId,\n        //     fileId: fileId,\n        //     mime: mime,\n        //     filename: file.name,\n        //     filesize: file.size\n        // });\n        that._logger.log(\"error\", LOG_ID + \"(UploadAFile) error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(UploadAFile) error : \", errorResponse);\n\n        return reject(errorResponse);\n      });\n    });\n  }\n  /**\r\n   * Method sends data to server using range request mecanism (RFC7233)\r\n   *\r\n   * @private\r\n   * @param {string} fileId [required] file descriptor ID of file to be sent\r\n   * @param {Blob} file [required] file to be sent\r\n   * @param {number} initialSize [required] initial size of whole file to be sent before partition\r\n   * @param {number} minRange [requied] minimum value of range\r\n   * @param {number} maxRange [required] maximum value of range\r\n   * @param {number} index [required] index of the part. Used to indicate the part number to the server\r\n   * @returns {Promise<{}>} file descriptor data received as response from server or http error response\r\n   *\r\n   */\n\n\n  _sendPartialDataToServer(fileId, file, index) {\n    let that = this;\n    return new Promise((resolve, reject) => {\n      that._rest.sendPartialDataToServer(fileId, file, index).then(response => {\n        let filedescriptor = response.data;\n\n        that._logger.log(\"info\", LOG_ID + \"(_sendPartialDataToServer) sendPartialDataToServer success\");\n\n        resolve(filedescriptor);\n      }, errorResponse => {\n        //let error = this.errorHelperService.handleError(errorResponse);\n        that._logger.log(\"error\", LOG_ID + \"(_sendPartialDataToServer) Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"(_sendPartialDataToServer) Error : \", errorResponse);\n\n        return reject(errorResponse);\n      });\n    });\n  }\n  /**\r\n   * Upload File ByChunk progressCallback callback is displayed as part of the Requester class.\r\n   * @callback uploadAFileByChunk~progressCallback\r\n   * @param {FileDescriptor} fileDescriptor\r\n   */\n\n  /**\r\n   * Method sends data to server using range request mecanism (RFC7233)\r\n   *\r\n   * @private\r\n   * @param {FileDescriptor} fileDescriptor [required] file descriptor Object of file to be sent\r\n   * @param {File} file [required] filePath of the file to be sent\r\n  //     * @param {uploadAFileByChunk~progressCallback} progressCallback [required] initial size of whole file to be sent before partition\r\n   * @returns {Promise<{FileDescriptor}>} file descriptor data received as response from server or http error response\r\n   *\r\n   */\n\n\n  uploadAFileByChunk(fileDescriptor, filePath\n  /*, progressCallback */\n  ) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      let promiseQueue = promiseQueue_1.createPromiseQueue(that._logger);\n      let fileStats = fs.statSync(filePath); //let range = ONE_MEGABYTE;\n\n      let range = (yield that.capabilities).maxChunkSizeUpload;\n\n      if (range < fileStats.size) {\n        if (fileStats.size >= 100 * range) {\n          range = fileStats.size / 100 + this.ONE_KILOBYTE;\n\n          that._logger.log(\"debug\", LOG_ID + \"(uploadAFileByChunk) changing chunk size: \" + range);\n        }\n\n        let deferred = new Utils_1.Deferred();\n        fileDescriptor.chunkTotalNumber = Math.ceil(fileStats.size / range);\n        fileDescriptor.chunkPerformed = 0;\n        fileDescriptor.chunkPerformedPercent = 0;\n        fileDescriptor.state = \"uploading\"; //let promiseArray = [];\n\n        let fd = fs.openSync(filePath, \"r+\");\n\n        let partialSent = (promiseDeferred, blob, i) => {\n          //let promiseArrayDeferred = new Deferred();\n          that._sendPartialDataToServer(fileDescriptor.id, blob, i).then(response => {\n            fileDescriptor.chunkPerformed++;\n            fileDescriptor.chunkPerformedPercent = 100 * fileDescriptor.chunkPerformed / fileDescriptor.chunkTotalNumber; // progressCallback(fileDescriptor);\n\n            return promiseDeferred.resolve(response);\n          }).catch(error => {\n            that._logger.log(\"error\", LOG_ID + \"(uploadAFileByChunk) error on chunk upload.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"(uploadAFileByChunk) error on chunk upload : \", error);\n\n            return promiseDeferred.reject(error);\n          });\n\n          return promiseDeferred.promise;\n        };\n\n        for (let i = 0, minRange = 0, maxRange = range - 1, repetition = Math.ceil(fileStats.size / range); repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n          let max = maxRange < fileStats.size ? maxRange + 1 : fileStats.size;\n          let sizeToRead = max - minRange;\n          let buf = new Buffer(sizeToRead);\n\n          that._logger.log(\"debug\", LOG_ID + \"(uploadAFileByChunk) sizeToRead=\", sizeToRead, \", minRange : \", minRange, \", max : \", max, \", buff.byteLength : \", buf.byteLength);\n\n          let promiseDeferred = new Utils_1.Deferred(); //promiseArray.push(promiseDeferred.promise);\n\n          promiseQueue.add(() => {\n            fs.readSync(fd, buf, 0, sizeToRead, null);\n            partialSent(promiseDeferred, buf, i);\n            return promiseDeferred.promise;\n          });\n        }\n        /* let promisesCompletion = () => {\r\n             this._rest.sendPartialFileCompletion(fileDescriptor.id)\r\n                 .then(\r\n                     (response) => {\r\n                         that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) success\");\r\n                         fileDescriptor.state = \"uploaded\";\r\n                         fileDescriptor.chunkPerformed = 0;\r\n                         fileDescriptor.chunkTotalNumber = 0;\r\n                         fileDescriptor.chunkPerformedPercent = 0;\r\n                         // progressCallback(fileDescriptor);\r\n                         deferred.resolve(fileDescriptor);\r\n                     })\r\n                 .catch((errorResponse) => {\r\n                     deferred.reject(errorResponse);\r\n                 });\r\n         };\r\n         let promisesReject = (errorResponse) => {\r\n             deferred.reject(errorResponse);\r\n         };\r\n         that.transferPromiseQueue.addPromiseArray(promiseArray, promisesCompletion, promisesReject);\r\n         // */\n\n\n        promiseQueue.add(() => {\n          return this._rest.sendPartialFileCompletion(fileDescriptor.id).then(response => {\n            that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) success\");\n\n            fileDescriptor.state = \"uploaded\";\n            fileDescriptor.chunkPerformed = 0;\n            fileDescriptor.chunkTotalNumber = 0;\n            fileDescriptor.chunkPerformedPercent = 0; // progressCallback(fileDescriptor);\n\n            deferred.resolve(fileDescriptor);\n          }).catch(errorResponse => {\n            return deferred.reject(errorResponse);\n          });\n        }); // */\n\n        return deferred.promise;\n      } // Fallback if capabilities retrieval fails or file is small enough to upload the whole file in one go\n      // progressCallback(fileDescriptor);\n\n\n      return that._uploadAFile(fileDescriptor.id, filePath, fileDescriptor.typeMIME).then(response => {\n        that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) uploadAFile success\"); // progressCallback(fileDescriptor);\n\n\n        return Promise.resolve(fileDescriptor);\n      });\n    });\n  }\n\n  isTransferInProgress() {\n    return this.transferPromiseQueue.isTransferInProgress();\n  }\n\n  cancelAllTransfers() {\n    this.transferPromiseQueue.cancelAllTransfers();\n  }\n  /**\r\n   * Method creates blob from a file retrieved from server using optimization (range request) whenever necessary\r\n   *\r\n   * @param {string} url [required] server url for request\r\n   * @param {string} mime [required] Mime type of the blob to be created\r\n   * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n   * @param {string} fileName [optional] name of file to be downloaded\r\n   * @returns {Promise<Blob>} Blob created from data received from server\r\n   *\r\n   * !!!!!! OBSOLETE\r\n   */\n\n\n  getBlobFromUrlWithOptimization(url, mime, fileSize, fileName, uploadedDate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n\n      if (fileSize == null || fileSize == undefined) {\n        fileSize = 0;\n      }\n\n      if (fileName == null || fileName == undefined) {\n        fileName = \"\";\n      }\n\n      if (uploadedDate == null || uploadedDate == undefined) {\n        uploadedDate = \"\";\n      }\n\n      if (uploadedDate.length !== 0) {// NEED TO BE CORREDTED TO BE USED IN NODE RAINBOW SDK  url += \"?update=\" + MD5.hexdigest(uploadedDate);\n      }\n\n      if (!!(yield that.capabilities).maxChunkSizeDownload && fileSize !== 0 && fileSize > (yield that.capabilities).maxChunkSizeDownload) {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n          let range = (yield that.capabilities).maxChunkSizeDownload;\n\n          if (range > that.ONE_MEGABYTE) {\n            range = that.ONE_MEGABYTE;\n          }\n\n          let minRange = 0;\n          let maxRange = range - 1;\n          let repetition = Math.ceil(fileSize / range);\n          let blobArray = new Array(repetition);\n\n          that._logger.log(\"info\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \" + repetition + \" chunks to be downloaded\");\n\n          let promiseArray = [];\n\n          for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n            promiseArray.push(that.getPartialDataFromServer(url, minRange, maxRange, i).then(response => {\n              blobArray[response['index']] = response['data'];\n              return response['data'];\n            }));\n          }\n\n          Promise.all(promiseArray).then(() => {\n            /* NEED TO BE CORREDTED TO BE USED IN NODE RAINBOW SDK\r\n             let blob = new Blob(blobArray,\r\n                { type: mime });\r\n            that._logger.log(\"info\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization success\");\r\n              resolve(blob);\r\n            */\n          }, errorResponse => {\n            let errorMessage = \"[FileServerService] getBlobFromUrlWithOptimization failure : \" + errorResponse.message;\n\n            that._logger.log(\"error\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization Error.\");\n\n            that._logger.log(\"internalerror\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \", errorResponse);\n\n            return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\n            /*\r\n            let error = this.errorHelperService.handleError(errorResponse);\r\n              let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\r\n            let translatedErrorMessage = that.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\r\n            that._logger.log(\"info\", LOG_ID + \"[FileServerService] \" + translatedErrorMessage ? translatedErrorMessage : error.message);\r\n            */\n            //reject(errorMessage);\n          });\n        }));\n      } else {\n        return this.getBlobFromUrl(url, mime, fileSize, fileName);\n      }\n    });\n  }\n\n  /**\r\n   * Method creates blob from a file retrieved from server\r\n   *\r\n   * @private\r\n   * @param {string} url [required] server url for request\r\n   * @param {string} mime [required] Mime type of the blob to be created\r\n   * @param {number} fileSize [required] size of file to be retrieved\r\n   * @param {string} fileName [required] name of file to be downloaded\r\n   * @returns {ng.IPromise<Blob>} Blob created from data received from server\r\n   *\r\n   */\n  getBlobFromUrl(url, mime, fileSize, fileName) {\n    let that = this;\n\n    that._logger.log(\"info\", LOG_ID + \"[FileServerService] >getBlobFromUrl\");\n\n    that._logger.log(\"internal\", LOG_ID + \"[FileServerService] >getBlobFromUrl : \" + url);\n\n    return new Promise((resolve, reject) => {\n      /*this.$http({\r\n          method: \"GET\",\r\n          url: url,\r\n          headers: this.authService.getRequestHeader(),\r\n          responseType: 'arraybuffer'\r\n      }) // */\n      that._rest.getBlobFromUrl(url).then(response => {\n        /* let blob = blobUtil.createBlob([response.data],\r\n            { type: mime }); // */\n        let blob = {\n          buffer: response,\n          type: mime,\n          fileSize: fileSize,\n          fileName: fileName\n        }; // */\n\n        /*let blob = new Blob([response.data],\r\n            { type: mime }); // */\n\n        that._logger.log(\"debug\", LOG_ID + \"[FileServerService] getBlobFromUrl success\");\n\n        resolve(blob);\n      }, errorResponse => {\n        let errorMessage = \"[FileServerService] getBlobFromUrlWithOptimization failure : \" + errorResponse;\n\n        that._logger.log(\"error\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization Error.\");\n\n        that._logger.log(\"internalerror\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \", errorResponse);\n\n        let err = ErrorManager_1.ErrorManager.getErrorManager().ERROR;\n        err.msg = errorMessage;\n        return reject(err);\n        /*\r\n        let error = this.errorHelperService.handleError(errorResponse);\r\n        let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\r\n        let translatedErrorMessage = this.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\r\n        this.$log.error(\"[FileServerService] \" + (translatedErrorMessage) ? translatedErrorMessage : error.message);\r\n        // */\n      });\n    });\n  }\n  /**\r\n  * Method retrieves user quota (capabilities) for user\r\n  *\r\n  * @returns {Capabilities} user quota for user\r\n  *\r\n  */\n\n\n  getServerCapabilities() {\n    return this._rest.getServerCapabilities();\n  }\n\n};\nFileServer = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n* @module\r\n* @name FileStorage\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service manage files on server side\r\n*/\n], FileServer);\nexports.FileServerService = FileServer;\nmodule.exports.FileServerService = FileServer;","map":{"version":3,"sources":["../../src/lib/services/FileServerService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst crypto = require(\"crypto\");\r\nconst URL = require(\"url\");\r\nconst fs = require(\"fs\");\r\n//const TransferPromiseQueue = require(\"./TransferPromiseQueue\");\r\nconst promiseQueue_1 = require(\"../common/promiseQueue\");\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst ErrorManager_1 = require(\"../common/ErrorManager\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst LOG_ID = \"FileServer/SVCE - \";\r\nconst ONE_KILOBYTE = 1024;\r\nconst ONE_MEGABYTE = 1024 * 1024;\r\nconst ONE_GIGABYTE = 1024 * 1024 * 1024;\r\nlet FileServer = \r\n/**\r\n* @module\r\n* @name FileStorage\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service manage files on server side\r\n*/\r\nclass FileServer {\r\n    constructor(_eventEmitter, _logger, _startConfig) {\r\n        this.ready = false;\r\n        this._startConfig = _startConfig;\r\n        this._eventEmitter = _eventEmitter;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this._logger = _logger;\r\n        this._capabilities = null;\r\n        this.transferPromiseQueue = null;\r\n        this._fileStorageService = null;\r\n        this.ready = false;\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    get capabilities() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            if (!that._capabilities) {\r\n                if (that._rest) {\r\n                    that._rest.getServerCapabilities().then((capabilities) => {\r\n                        that._capabilities = capabilities;\r\n                        //that.transferPromiseQueue = new TransferPromiseQueue(that._logger);\r\n                        resolve(this._capabilities);\r\n                    }).catch(() => {\r\n                        return reject();\r\n                    });\r\n                }\r\n                else {\r\n                    return reject();\r\n                }\r\n                return;\r\n            }\r\n            resolve(that._capabilities);\r\n        });\r\n    }\r\n    start(_options, _core) {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = _core._xmpp;\r\n                that._rest = _core._rest;\r\n                that._options = _options;\r\n                that._s2s = _core._s2s;\r\n                that._useXMPP = that._options.useXMPP;\r\n                that._useS2S = that._options.useS2S;\r\n                that._fileStorageService = _core.fileStorage;\r\n                that.ready = true;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    stop() {\r\n        let that = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                that._xmpp = null;\r\n                that._rest = null;\r\n                that.ready = false;\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                return reject(err);\r\n            }\r\n        });\r\n    }\r\n    init() {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            let capa = that.capabilities;\r\n            resolve(capa);\r\n        });\r\n    }\r\n    /**\r\n     * Method retrieve data from server using range request mecanism (RFC7233)\r\n     *\r\n     * @private\r\n     * @param {string} url [required] server url for request\r\n     * @param {number} minRange [requied] minimum value of range\r\n     * @param {number} maxRange [required] maximum value of range\r\n     * @param {number} index [required] index of the part. Used to re-assemble the data\r\n     * @returns {Object} structure containing the response data from server and the index\r\n     *\r\n     */\r\n    getPartialDataFromServer(url, minRange, maxRange, index) {\r\n        return this._rest.getPartialDataFromServer(url, minRange, maxRange, index);\r\n    }\r\n    /**\r\n     * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary\r\n     *\r\n     * @param {string} url [required] server url for request\r\n     * @param {string} mime [required] Mime type of the blob to be created\r\n     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n     * @param {string} fileName [optional] name of file to be downloaded\r\n     * @returns {Buffer} Buffer created from data received from server\r\n     *\r\n     */\r\n    getBufferFromUrlWithOptimization(url, mime, fileSize, fileName, uploadedDate) {\r\n        let that = this;\r\n        if (fileSize === void 0) {\r\n            fileSize = 0;\r\n        }\r\n        if (fileName === void 0) {\r\n            fileName = \"\";\r\n        }\r\n        if (uploadedDate === void 0) {\r\n            uploadedDate = \"\";\r\n        }\r\n        if (uploadedDate.length !== 0) {\r\n            url += \"?update=\" + crypto.createHash(\"md5\").update(uploadedDate).digest(\"hex\");\r\n        }\r\n        let _url = url.startsWith(\"http\") ? URL.parse(url).path : url;\r\n        return new Promise((resolve, reject) => {\r\n            this.capabilities.then((capabilities) => {\r\n                if (Boolean(capabilities.maxChunkSizeDownload) && fileSize !== 0 && fileSize > capabilities.maxChunkSizeDownload) {\r\n                    let range = capabilities.maxChunkSizeDownload;\r\n                    let minRange = 0;\r\n                    let maxRange = range - 1;\r\n                    let repetition = Math.ceil(fileSize / range);\r\n                    let bufferArray = new Array(repetition);\r\n                    let promiseArray = [];\r\n                    for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\r\n                        promiseArray.push(this.getPartialDataFromServer(_url, minRange, maxRange, i).then((response) => {\r\n                            bufferArray[response.index] = response.data;\r\n                            return (response.data);\r\n                        }));\r\n                    }\r\n                    Promise.all(promiseArray)\r\n                        .then(() => {\r\n                        let buffer = Buffer.concat(bufferArray);\r\n                        that._logger.log(\"info\", LOG_ID + \"[FileServer] getBufferFromUrlWithOptimization success\");\r\n                        resolve(buffer);\r\n                    }, (error) => {\r\n                        that._logger.log(\"error\", LOG_ID + \"[FileServer] Error.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"[FileServer] Error : \", error);\r\n                        return reject(error);\r\n                    });\r\n                }\r\n                else {\r\n                    resolve(that._rest.getFileFromUrl(_url));\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary\r\n     *\r\n     * @param destFile\r\n     * @param {string} url [required] server url for request\r\n     * @param {string} mime [required] Mime type of the blob to be created\r\n     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n     * @param {string} fileName [optional] name of file to be downloaded\r\n     * @param {string} uploadedDate [optional] date of the upload\r\n     * @returns {Buffer} Buffer created from data received from server\r\n     *\r\n     */\r\n    getFileFromUrlWithOptimization(destFile, url, mime, fileSize, fileName, uploadedDate) {\r\n        let that = this;\r\n        if (fileSize === void 0) {\r\n            fileSize = 0;\r\n        }\r\n        if (fileName === void 0) {\r\n            fileName = \"\";\r\n        }\r\n        if (uploadedDate === void 0) {\r\n            uploadedDate = \"\";\r\n        }\r\n        if (uploadedDate.length !== 0) {\r\n            url += \"?update=\" + crypto.createHash(\"md5\").update(uploadedDate).digest(\"hex\");\r\n        }\r\n        let _url = url.startsWith(\"http\") ? URL.parse(url).path : url;\r\n        let stream = fs.createWriteStream(destFile, {\r\n            flags: \"a\"\r\n        });\r\n        return new Promise((resolve, reject) => {\r\n            this.capabilities.then((capabilities) => {\r\n                if (Boolean(capabilities.maxChunkSizeDownload) && fileSize !== 0 && fileSize > capabilities.maxChunkSizeDownload) {\r\n                    let range = capabilities.maxChunkSizeDownload;\r\n                    let minRange = 0;\r\n                    let maxRange = range - 1;\r\n                    let repetition = Math.ceil(fileSize / range);\r\n                    let blobArray = new Array(repetition);\r\n                    let promiseArray = [];\r\n                    for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\r\n                        promiseArray.push(this.getPartialDataFromServer(_url, minRange, maxRange, i)\r\n                            .then((response) => {\r\n                            blobArray[response.index] = response.data;\r\n                            return (response.data);\r\n                        }));\r\n                    }\r\n                    Promise.all(promiseArray)\r\n                        .then(() => {\r\n                        let buffer = Buffer.concat(blobArray);\r\n                        that._logger.log(\"info\", LOG_ID + \"[FileServer] getBufferFromUrlWithOptimization success\");\r\n                        resolve(buffer);\r\n                    }, (error) => {\r\n                        that._logger.log(\"error\", LOG_ID + \"[FileServer] Error.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"[FileServer] Error : \", error);\r\n                        return reject(error);\r\n                    });\r\n                }\r\n                else {\r\n                    resolve(that._rest.getFileFromUrl(_url));\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /***\r\n     * @private\r\n     * @param fileDescriptor\r\n     * @param large\r\n     */\r\n    getBlobThumbnailFromFileDescriptor(fileDescriptor, large = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            /*\r\n                    if (fileDescriptor.thumbnail.isThumbnailAvailable() ||\r\n                        (fileDescriptor.isImage() && fileDescriptor.size < (20 * this.ONE_KILOBYTE)) ) {\r\n            \r\n                        // Check if a request for this thumbnail is already lauched\r\n                        let existingPromise = this.thumbnailPromises[fileDescriptor.id];\r\n                        if (existingPromise) {\r\n                            this.$log.info(\"[FileServerService] getBlobThumbnailFromFileDescriptor \" + fileDescriptor.id + \" already lauched\");\r\n                            return existingPromise.promise;\r\n                        }\r\n            \r\n                        // Create the defered object\r\n                        let defered = this.$q.defer();\r\n                        this.thumbnailPromises[fileDescriptor.id] = defered;\r\n            \r\n                        // Forge the thumbnail url\r\n                        let url = fileDescriptor.url;\r\n                        if (fileDescriptor.thumbnail.isThumbnailAvailable() && fileDescriptor.size >= (20 * this.ONE_KILOBYTE)) {\r\n                            if (large) { url += \"?thumbnail500=true\"; }\r\n                            else { url += \"?thumbnail=true\"; }\r\n                        }\r\n                        else if (fileDescriptor.uploadedDate) { url += \"?update=\" + MD5.hexdigest(fileDescriptor.uploadedDate); }\r\n            \r\n                        // Get the thumbnail blob\r\n                        this.getBlobFromUrl(url, fileDescriptor.typeMIME, fileDescriptor.size, fileDescriptor.fileName)\r\n                            .then((blob) => {\r\n                                fileDescriptor.previewBlob = blob;\r\n            \r\n                                this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                                    result: \"success\", type: \"download\",\r\n                                    fileDesc: fileDescriptor});\r\n                                delete this.thumbnailPromises[fileDescriptor.id];\r\n                                defered.resolve(blob);\r\n                            })\r\n                            .catch((error) => {\r\n                                this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                                    result: \"failure\", type: \"download\", message: error.message,\r\n                                    fileDesc: fileDescriptor});\r\n                                delete this.thumbnailPromises[fileDescriptor.id];\r\n                                defered.reject(error);\r\n                            });\r\n            \r\n                        return defered.promise;\r\n                    }\r\n                    else { return this.$q.reject(); }\r\n            \r\n             */\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Method sends data file to server\r\n     *\r\n     * @private\r\n     * @param {string} fileId [required] file descriptor ID of file to be sent\r\n     * @param {File} file [required] file to be sent\r\n     * @param {string} mime [required] mime type of file\r\n     * @returns {Promise<FileDescriptor>} file descriptor data received as response from server or http error response\r\n     *\r\n     */\r\n    _uploadAFile(fileId, filePath, mime) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            let fileDescriptor = that._fileStorageService.getFileDescriptorById(fileId);\r\n            if (fileDescriptor) {\r\n                fileDescriptor.state = \"uploading\";\r\n            }\r\n            let stream = fs.createReadStream(filePath);\r\n            //let buffer = new Buffer(ONE_MEGABYTE);\r\n            /*\r\n                        let myWritableStreamBuffer = new streamBuffers.WritableStreamBuffer({\r\n                            initialSize: (1000 * 1024),   // start at 100 kilobytes.\r\n                            incrementAmount: (100 * 1024) // grow by 10 kilobytes each time buffer overflows.\r\n                        });\r\n            */\r\n            //stream.pipe(myWritableStreamBuffer);\r\n            //            stream.pipe(buffer)\r\n            that._rest.uploadAStream(fileId, stream).then((response) => {\r\n                //let fileDescResponse = response.data.data;\r\n                let newFileDescriptor = that._fileStorageService.getFileDescriptorById(fileId);\r\n                if (newFileDescriptor) {\r\n                    newFileDescriptor.state = \"uploaded\";\r\n                }\r\n                that._logger.log(\"info\", LOG_ID + \"(UploadAFile) success\");\r\n                // this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                //     result: \"success\",\r\n                //     type: \"upload\",\r\n                //     url: this.portalURL + \"/\" + fileId,\r\n                //     fileId: fileId,\r\n                //     mime: mime,\r\n                //     filename: file.name,\r\n                //     filesize: file.size\r\n                // });\r\n                // this._fileStorageService.orderDocuments();\r\n                resolve(newFileDescriptor);\r\n            }).catch((errorResponse) => {\r\n                // let error = this.errorHelperService.handleError(errorResponse);\r\n                // this.$rootScope.$broadcast(\"ON_FILE_TRANSFER_EVENT\", {\r\n                //     result: \"failure\",\r\n                //     type: \"upload\",\r\n                //     url: this.portalURL + \"/\" + fileId,\r\n                //     fileId: fileId,\r\n                //     mime: mime,\r\n                //     filename: file.name,\r\n                //     filesize: file.size\r\n                // });\r\n                that._logger.log(\"error\", LOG_ID + \"(UploadAFile) error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(UploadAFile) error : \", errorResponse);\r\n                return reject(errorResponse);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Method sends data to server using range request mecanism (RFC7233)\r\n     *\r\n     * @private\r\n     * @param {string} fileId [required] file descriptor ID of file to be sent\r\n     * @param {Blob} file [required] file to be sent\r\n     * @param {number} initialSize [required] initial size of whole file to be sent before partition\r\n     * @param {number} minRange [requied] minimum value of range\r\n     * @param {number} maxRange [required] maximum value of range\r\n     * @param {number} index [required] index of the part. Used to indicate the part number to the server\r\n     * @returns {Promise<{}>} file descriptor data received as response from server or http error response\r\n     *\r\n     */\r\n    _sendPartialDataToServer(fileId, file, index) {\r\n        let that = this;\r\n        return new Promise((resolve, reject) => {\r\n            that._rest.sendPartialDataToServer(fileId, file, index).then((response) => {\r\n                let filedescriptor = response.data;\r\n                that._logger.log(\"info\", LOG_ID + \"(_sendPartialDataToServer) sendPartialDataToServer success\");\r\n                resolve(filedescriptor);\r\n            }, (errorResponse) => {\r\n                //let error = this.errorHelperService.handleError(errorResponse);\r\n                that._logger.log(\"error\", LOG_ID + \"(_sendPartialDataToServer) Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"(_sendPartialDataToServer) Error : \", errorResponse);\r\n                return reject(errorResponse);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Upload File ByChunk progressCallback callback is displayed as part of the Requester class.\r\n     * @callback uploadAFileByChunk~progressCallback\r\n     * @param {FileDescriptor} fileDescriptor\r\n     */\r\n    /**\r\n     * Method sends data to server using range request mecanism (RFC7233)\r\n     *\r\n     * @private\r\n     * @param {FileDescriptor} fileDescriptor [required] file descriptor Object of file to be sent\r\n     * @param {File} file [required] filePath of the file to be sent\r\n//     * @param {uploadAFileByChunk~progressCallback} progressCallback [required] initial size of whole file to be sent before partition\r\n     * @returns {Promise<{FileDescriptor}>} file descriptor data received as response from server or http error response\r\n     *\r\n     */\r\n    uploadAFileByChunk(fileDescriptor, filePath /*, progressCallback */) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            let promiseQueue = promiseQueue_1.createPromiseQueue(that._logger);\r\n            let fileStats = fs.statSync(filePath);\r\n            //let range = ONE_MEGABYTE;\r\n            let range = (yield that.capabilities).maxChunkSizeUpload;\r\n            if (range < fileStats.size) {\r\n                if (fileStats.size >= 100 * range) {\r\n                    range = (fileStats.size / 100) + this.ONE_KILOBYTE;\r\n                    that._logger.log(\"debug\", LOG_ID + \"(uploadAFileByChunk) changing chunk size: \" + range);\r\n                }\r\n                let deferred = new Utils_1.Deferred();\r\n                fileDescriptor.chunkTotalNumber = Math.ceil(fileStats.size / range);\r\n                fileDescriptor.chunkPerformed = 0;\r\n                fileDescriptor.chunkPerformedPercent = 0;\r\n                fileDescriptor.state = \"uploading\";\r\n                //let promiseArray = [];\r\n                let fd = fs.openSync(filePath, \"r+\");\r\n                let partialSent = (promiseDeferred, blob, i) => {\r\n                    //let promiseArrayDeferred = new Deferred();\r\n                    that._sendPartialDataToServer(fileDescriptor.id, blob, i)\r\n                        .then((response) => {\r\n                        fileDescriptor.chunkPerformed++;\r\n                        fileDescriptor.chunkPerformedPercent = 100 * fileDescriptor.chunkPerformed / fileDescriptor.chunkTotalNumber;\r\n                        // progressCallback(fileDescriptor);\r\n                        return promiseDeferred.resolve(response);\r\n                    })\r\n                        .catch((error) => {\r\n                        that._logger.log(\"error\", LOG_ID + \"(uploadAFileByChunk) error on chunk upload.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"(uploadAFileByChunk) error on chunk upload : \", error);\r\n                        return promiseDeferred.reject(error);\r\n                    });\r\n                    return promiseDeferred.promise;\r\n                };\r\n                for (let i = 0, minRange = 0, maxRange = range - 1, repetition = Math.ceil(fileStats.size / range); repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\r\n                    let max = maxRange < fileStats.size ? maxRange + 1 : fileStats.size;\r\n                    let sizeToRead = max - minRange;\r\n                    let buf = new Buffer(sizeToRead);\r\n                    that._logger.log(\"debug\", LOG_ID + \"(uploadAFileByChunk) sizeToRead=\", sizeToRead, \", minRange : \", minRange, \", max : \", max, \", buff.byteLength : \", buf.byteLength);\r\n                    let promiseDeferred = new Utils_1.Deferred();\r\n                    //promiseArray.push(promiseDeferred.promise);\r\n                    promiseQueue.add(() => {\r\n                        fs.readSync(fd, buf, 0, sizeToRead, null);\r\n                        partialSent(promiseDeferred, buf, i);\r\n                        return promiseDeferred.promise;\r\n                    });\r\n                }\r\n                /* let promisesCompletion = () => {\r\n                     this._rest.sendPartialFileCompletion(fileDescriptor.id)\r\n                         .then(\r\n                             (response) => {\r\n                                 that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) success\");\r\n                                 fileDescriptor.state = \"uploaded\";\r\n                                 fileDescriptor.chunkPerformed = 0;\r\n                                 fileDescriptor.chunkTotalNumber = 0;\r\n                                 fileDescriptor.chunkPerformedPercent = 0;\r\n                                 // progressCallback(fileDescriptor);\r\n                                 deferred.resolve(fileDescriptor);\r\n                             })\r\n                         .catch((errorResponse) => {\r\n                             deferred.reject(errorResponse);\r\n                         });\r\n                 };\r\n                 let promisesReject = (errorResponse) => {\r\n                     deferred.reject(errorResponse);\r\n                 };\r\n                 that.transferPromiseQueue.addPromiseArray(promiseArray, promisesCompletion, promisesReject);\r\n                 // */\r\n                promiseQueue.add(() => {\r\n                    return this._rest.sendPartialFileCompletion(fileDescriptor.id)\r\n                        .then((response) => {\r\n                        that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) success\");\r\n                        fileDescriptor.state = \"uploaded\";\r\n                        fileDescriptor.chunkPerformed = 0;\r\n                        fileDescriptor.chunkTotalNumber = 0;\r\n                        fileDescriptor.chunkPerformedPercent = 0;\r\n                        // progressCallback(fileDescriptor);\r\n                        deferred.resolve(fileDescriptor);\r\n                    })\r\n                        .catch((errorResponse) => {\r\n                        return deferred.reject(errorResponse);\r\n                    });\r\n                });\r\n                // */\r\n                return deferred.promise;\r\n            }\r\n            // Fallback if capabilities retrieval fails or file is small enough to upload the whole file in one go\r\n            // progressCallback(fileDescriptor);\r\n            return that._uploadAFile(fileDescriptor.id, filePath, fileDescriptor.typeMIME)\r\n                .then((response) => {\r\n                that._logger.log(\"info\", LOG_ID + \"(uploadAFileByChunk) uploadAFile success\");\r\n                // progressCallback(fileDescriptor);\r\n                return Promise.resolve(fileDescriptor);\r\n            });\r\n        });\r\n    }\r\n    isTransferInProgress() {\r\n        return this.transferPromiseQueue.isTransferInProgress();\r\n    }\r\n    cancelAllTransfers() {\r\n        this.transferPromiseQueue.cancelAllTransfers();\r\n    }\r\n    /**\r\n     * Method creates blob from a file retrieved from server using optimization (range request) whenever necessary\r\n     *\r\n     * @param {string} url [required] server url for request\r\n     * @param {string} mime [required] Mime type of the blob to be created\r\n     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\r\n     * @param {string} fileName [optional] name of file to be downloaded\r\n     * @returns {Promise<Blob>} Blob created from data received from server\r\n     *\r\n     * !!!!!! OBSOLETE\r\n     */\r\n    getBlobFromUrlWithOptimization(url, mime, fileSize, fileName, uploadedDate) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            if (fileSize == null || fileSize == undefined) {\r\n                fileSize = 0;\r\n            }\r\n            if (fileName == null || fileName == undefined) {\r\n                fileName = \"\";\r\n            }\r\n            if (uploadedDate == null || uploadedDate == undefined) {\r\n                uploadedDate = \"\";\r\n            }\r\n            if (uploadedDate.length !== 0) {\r\n                // NEED TO BE CORREDTED TO BE USED IN NODE RAINBOW SDK  url += \"?update=\" + MD5.hexdigest(uploadedDate);\r\n            }\r\n            if (!!(yield that.capabilities).maxChunkSizeDownload && fileSize !== 0 && fileSize > (yield that.capabilities).maxChunkSizeDownload) {\r\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                    let range = (yield that.capabilities).maxChunkSizeDownload;\r\n                    if (range > that.ONE_MEGABYTE) {\r\n                        range = that.ONE_MEGABYTE;\r\n                    }\r\n                    let minRange = 0;\r\n                    let maxRange = range - 1;\r\n                    let repetition = Math.ceil(fileSize / range);\r\n                    let blobArray = new Array(repetition);\r\n                    that._logger.log(\"info\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \" + repetition + \" chunks to be downloaded\");\r\n                    let promiseArray = [];\r\n                    for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\r\n                        promiseArray.push(that.getPartialDataFromServer(url, minRange, maxRange, i)\r\n                            .then((response) => {\r\n                            blobArray[response['index']] = response['data'];\r\n                            return (response['data']);\r\n                        }));\r\n                    }\r\n                    Promise.all(promiseArray)\r\n                        .then(() => {\r\n                        /* NEED TO BE CORREDTED TO BE USED IN NODE RAINBOW SDK\r\n                         let blob = new Blob(blobArray,\r\n                            { type: mime });\r\n                        that._logger.log(\"info\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization success\");\r\n\r\n                        resolve(blob);\r\n                        */\r\n                    }, (errorResponse) => {\r\n                        let errorMessage = \"[FileServerService] getBlobFromUrlWithOptimization failure : \" + errorResponse.message;\r\n                        that._logger.log(\"error\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization Error.\");\r\n                        that._logger.log(\"internalerror\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \", errorResponse);\r\n                        return reject(ErrorManager_1.ErrorManager.getErrorManager().OTHERERROR(errorMessage, errorMessage));\r\n                        /*\r\n                        let error = this.errorHelperService.handleError(errorResponse);\r\n\r\n                        let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\r\n                        let translatedErrorMessage = that.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\r\n                        that._logger.log(\"info\", LOG_ID + \"[FileServerService] \" + translatedErrorMessage ? translatedErrorMessage : error.message);\r\n                        */\r\n                        //reject(errorMessage);\r\n                    });\r\n                }));\r\n            }\r\n            else {\r\n                return this.getBlobFromUrl(url, mime, fileSize, fileName);\r\n            }\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Method creates blob from a file retrieved from server\r\n     *\r\n     * @private\r\n     * @param {string} url [required] server url for request\r\n     * @param {string} mime [required] Mime type of the blob to be created\r\n     * @param {number} fileSize [required] size of file to be retrieved\r\n     * @param {string} fileName [required] name of file to be downloaded\r\n     * @returns {ng.IPromise<Blob>} Blob created from data received from server\r\n     *\r\n     */\r\n    getBlobFromUrl(url, mime, fileSize, fileName) {\r\n        let that = this;\r\n        that._logger.log(\"info\", LOG_ID + \"[FileServerService] >getBlobFromUrl\");\r\n        that._logger.log(\"internal\", LOG_ID + \"[FileServerService] >getBlobFromUrl : \" + url);\r\n        return new Promise((resolve, reject) => {\r\n            /*this.$http({\r\n                method: \"GET\",\r\n                url: url,\r\n                headers: this.authService.getRequestHeader(),\r\n                responseType: 'arraybuffer'\r\n            }) // */\r\n            that._rest.getBlobFromUrl(url).then((response) => {\r\n                /* let blob = blobUtil.createBlob([response.data],\r\n                    { type: mime }); // */\r\n                let blob = { buffer: response,\r\n                    type: mime,\r\n                    fileSize: fileSize,\r\n                    fileName: fileName\r\n                }; // */\r\n                /*let blob = new Blob([response.data],\r\n                    { type: mime }); // */\r\n                that._logger.log(\"debug\", LOG_ID + \"[FileServerService] getBlobFromUrl success\");\r\n                resolve(blob);\r\n            }, (errorResponse) => {\r\n                let errorMessage = \"[FileServerService] getBlobFromUrlWithOptimization failure : \" + errorResponse;\r\n                that._logger.log(\"error\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization Error.\");\r\n                that._logger.log(\"internalerror\", LOG_ID + \"[FileServerService] getBlobFromUrlWithOptimization : \", errorResponse);\r\n                let err = ErrorManager_1.ErrorManager.getErrorManager().ERROR;\r\n                err.msg = errorMessage;\r\n                return reject(err);\r\n                /*\r\n        let error = this.errorHelperService.handleError(errorResponse);\r\n\r\n        let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\r\n        let translatedErrorMessage = this.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\r\n        this.$log.error(\"[FileServerService] \" + (translatedErrorMessage) ? translatedErrorMessage : error.message);\r\n            // */\r\n            });\r\n        });\r\n    }\r\n    /**\r\n    * Method retrieves user quota (capabilities) for user\r\n    *\r\n    * @returns {Capabilities} user quota for user\r\n    *\r\n    */\r\n    getServerCapabilities() {\r\n        return this._rest.getServerCapabilities();\r\n    }\r\n};\r\nFileServer = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n    * @module\r\n    * @name FileStorage\r\n     * @version 1.67.1 \r\n    * @public\r\n    * @description\r\n    *      This service manage files on server side\r\n    */\r\n], FileServer);\r\nexports.FileServerService = FileServer;\r\nmodule.exports.FileServerService = FileServer;\r\n//# sourceMappingURL=FileServerService.js.map"]},"metadata":{},"sourceType":"script"}