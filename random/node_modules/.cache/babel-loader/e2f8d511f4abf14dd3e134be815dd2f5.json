{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"../common/Utils\");\n\nconst PubSub = require(\"pubsub-js\");\n\nconst calllogEventHandler_1 = require(\"../connection/XMPPServiceHandler/calllogEventHandler\");\n\nconst Utils_2 = require(\"../common/Utils\");\n\nconst LOG_ID = \"CALLLOG/SVCE - \";\n\nfunction CallLogsBean() {\n  return {\n    \"callLogs\": [],\n    \"orderByNameCallLogs\": [],\n    \"orderByDateCallLogs\": [],\n    \"orderByNameCallLogsBruts\": [],\n    \"orderByDateCallLogsBruts\": [],\n    \"simplifiedCallLogs\": [],\n    \"numberMissedCalls\": 0,\n    \"lastTimestamp\": 0\n  };\n}\n\nlet CallLogService =\n/**\r\n* @module\r\n* @name CallsLog\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service allow to get the call log and manage it. <br><br>\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Get all calls log <br/>\r\n*      - Delete one or all calls log <br/>\r\n*      - Mark calls as read / unread <br/>\r\n*/\nclass CallLogService {\n  // $q, $log, $rootScope, $interval, contactService, xmppService, CallLog, orderByFilter, profileService, $injector, telephonyService, webrtcGatewayService\n  constructor(_eventEmitter, logger, _startConfig) {\n    this.ready = false;\n    /*********************************************************/\n\n    /**                 LIFECYCLE STUFF                     **/\n\n    /*********************************************************/\n\n    this._startConfig = _startConfig; //let that = this;\n\n    this._eventEmitter = _eventEmitter;\n    this.logger = logger;\n    this._xmpp = null;\n    this._rest = null;\n    this._s2s = null;\n    this._options = {};\n    this._useXMPP = false;\n    this._useS2S = false;\n    this.started = false;\n    this._initialized = false;\n    this.ready = false;\n    /*this.callLogs = [];\r\n    this.orderByNameCallLogs = [];\r\n    this.orderByDateCallLogs = [];\r\n    this.orderByDateCallLogsBruts = [];\r\n    this.simplifiedCallLogs = []; // */\n\n    this.calllogs = CallLogsBean();\n    this.callLogHandlerRef = null;\n    this.callLogMessageAckRef = null;\n    this.callLogNotificationRef = null; //        this.numberMissedCalls = 0;\n    //        this.lastTimestamp = null;\n\n    this.callLogsHistory = [];\n    this.telephonyCallLog = {};\n    this.telephonyCallLogHistory = {};\n    this.deferedObject = null;\n    this.callLogComplete = false;\n    this.callLogIndex = -1;\n\n    this._eventEmitter.on(\"evt_internal_calllogupdated\", this.onCallLogUpdated.bind(this));\n\n    this._eventEmitter.on(\"evt_internal_calllogackupdated\", this.onCallLogAckReceived.bind(this));\n  }\n\n  get startConfig() {\n    return this._startConfig;\n  }\n\n  start(_options, _core) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that._xmpp = _core._xmpp;\n      that._rest = _core._rest;\n      that._contacts = _core.contacts;\n      that._profiles = _core.profiles;\n      that._telephony = _core.telephony;\n      that._options = _options;\n      that._s2s = _core._s2s;\n      that._useXMPP = that._options.useXMPP;\n      that._useS2S = that._options.useS2S;\n      this.calllogHandlerToken = [];\n      that.logger.log(\"info\", LOG_ID + \" \");\n      that.logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\n      this.attachHandlers();\n      this.ready = true;\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[stop] Stopping\"); //remove all saved call logs\n\n      this.started = false;\n      this._initialized = false; //this.callLogs = [];\n      //this.callLogsPromises = [];\n\n      this.callLogHandlerRef = null;\n      this.callLogMessageAckRef = null;\n      this.calllogs = CallLogsBean();\n      this.telephonyCallLog = {};\n      this.telephonyCallLogHistory = {};\n      this.callLogComplete = false;\n      this.callLogIndex = -1;\n      this.callLogsHistory = [];\n      that._xmpp = null;\n      that._rest = null;\n      that._contacts = null;\n      that._profiles = null;\n      delete that._calllogEventHandler;\n      that._calllogEventHandler = null;\n\n      if (that.calllogHandlerToken) {\n        that.calllogHandlerToken.forEach(token => PubSub.unsubscribe(token));\n      }\n\n      that.calllogHandlerToken = [];\n      this.ready = false;\n      that.logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\n    });\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this; //that._eventEmitter.on(\"rainbow_oncalllogupdated\", that.onIqCallLogNotificationReceived.bind(that));\n\n      yield Utils_1.setTimeoutPromised(3000).then(() => {\n        let startDate = new Date();\n        that.getCallLogHistoryPage().then(() => {\n          // @ts-ignore\n          let duration = new Date() - startDate;\n          let startDuration = Math.round(duration);\n          that.logger.log(\"info\", LOG_ID + \" callLogService start duration : \", startDuration);\n          that.logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\n          that.started = true;\n        }).catch(error => {\n          that.logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\n          that.logger.log(\"internalerror\", LOG_ID + \"[start] === STARTING FAILURE === : \", error);\n        });\n      });\n    });\n  }\n\n  attachHandlers() {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"(attachHandlers)\");\n    that._calllogEventHandler = new calllogEventHandler_1.CallLogEventHandler(that._xmpp, that, that._contacts, that._profiles, that._telephony);\n    that.calllogHandlerToken = [PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.IQ_CALLLOG, that._calllogEventHandler.onIqCallLogReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.CALLLOG_ACK, that._calllogEventHandler.onCallLogAckReceived), PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.IQ_CALLOG_NOTIFICATION, that._calllogEventHandler.onIqCallLogNotificationReceived)];\n    /*\r\n    //if reconnection, update the call-logs\r\n    if (that.started && that.lastTimestamp) {\r\n        $interval(function () {\r\n            that.getCallLogHistoryPage(that.lastTimestamp);\r\n        }, 1000, 1, true);\r\n    }\r\n    // */\n  }\n  /*********************************************************/\n\n  /**       MAM REQUESTS                                  **/\n\n  /*********************************************************/\n\n\n  getCallLogHistoryPage(useAfter) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"(getCallLogHistoryPage)\");\n\n      if (that._useXMPP) {\n        return yield that._xmpp.sendGetCallLogHistoryPage(useAfter);\n      }\n\n      if (that._useS2S) {\n        return Promise.resolve();\n      }\n    });\n  }\n  /*********************************************************/\n\n  /**                     API                             **/\n\n  /*********************************************************/\n\n  /**\r\n   * @public\r\n   * @method getAll\r\n   * @instance\r\n   * @description\r\n   *    Get all calls log history for the connected user\r\n   * @return {CallLog[]} An array of call log entry\r\n   */\n\n\n  getAll() {\n    let that = this;\n    that.calllogs = this._calllogEventHandler.orderCallLogsFunction();\n    let callLogs = that.getSimplifiedCallLogs(); // as duration is \"h[H] mm[m] ss[s]\" in rb, switch it back to ms ...\n\n    for (let i = 0; i < callLogs.length; i++) {\n      let durationMs = 0;\n      let hmmss = callLogs[i].duration;\n\n      if (hmmss && typeof hmmss === \"string\" && hmmss.match(/^(?:(?:([01]?\\d|2[0-3])h )?([0-5]?\\d)m )?([0-5]?\\ds)$/)) {\n        // Remove h, m and s\n        hmmss = hmmss.replace(/[hms]/g, \"\"); // split it at the \"space\", also reverse it to get seconds then minutes then hours\n\n        let parts = hmmss.split(' ').reverse();\n\n        for (let j = 0; j < parts.length; j++) {\n          durationMs += parts[j] * Math.pow(60, j);\n        }\n\n        callLogs[i].duration = durationMs * 1000;\n      }\n    }\n\n    return callLogs;\n  }\n  /**\r\n   * @public\r\n   * @method getMissedCallLogCounter\r\n   * @instance\r\n   * @description\r\n   *    Get the number of call missed (state === \"missed\" && direction === \"incoming\")\r\n   * @return {Number} The number of call missed\r\n   */\n\n\n  getMissedCallLogCounter() {\n    let that = this;\n    let num = 0;\n    that.calllogs.callLogs.forEach(function (callLog) {\n      if (!callLog.read && callLog.state === \"missed\" && callLog.direction === \"incoming\") {\n        that.logger.log(\"info\", LOG_ID + \"(getMissedCallLogCounter) iter : \", num, \", callLog : \", callLog);\n        num++;\n      }\n    });\n    return num;\n  }\n\n  /**\r\n   * @public\r\n   * @method deleteOneCallLog\r\n   * @instance\r\n   * @description\r\n   *    Delete a call log from it's id<br/>\r\n   *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n   * @param {String} id The call log id to remove\r\n   * @return Nothing\r\n   */\n  deleteOneCallLog(id) {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"(deleteOneCallLog) id : \", id);\n    return that._xmpp.deleteOneCallLog(id);\n  }\n  /**\r\n   * @public\r\n   * @method deleteCallLogsForContact\r\n   * @instance\r\n   * @description\r\n   *    Delete all calls log items associated to a contact's given jid<br/>\r\n   *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n   * @param {String} jid The call log id to remove\r\n   * @return Nothing\r\n   */\n\n\n  deleteCallLogsForContact(jid) {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"(deleteCallLogsForContact) jid : \", jid);\n    return that._xmpp.deleteCallLogsForContact(jid);\n  }\n  /**\r\n   * @public\r\n   * @method deleteAllCallLogs\r\n   * @instance\r\n   * @description\r\n   *    Delete all call logs history<br/>\r\n   *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n   * @return Nothing\r\n   */\n\n\n  deleteAllCallLogs() {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"(deleteAllCallLogs)\");\n    return that._xmpp.deleteAllCallLogs();\n  }\n  /**\r\n   * @public\r\n   * @method markCallLogAsRead\r\n   * @instance\r\n   * @description\r\n   *    Mark a call log item as read<br/>\r\n   *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished\r\n   * @param {String} id The call log id\r\n   * @return Nothing\r\n   */\n\n\n  markCallLogAsRead(id) {\n    let that = this;\n    that.logger.log(\"info\", LOG_ID + \"(markCallLogAsRead) id : \", id);\n    return that._xmpp.markCallLogAsRead(id);\n  }\n  /**\r\n   * @public\r\n   * @method markAllCallsLogsAsRead\r\n   * @instance\r\n   * @description\r\n   *    Mark all call log items as read<br/>\r\n   *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished\r\n   * @return Nothing\r\n   */\n\n\n  markAllCallsLogsAsRead() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"(markAllCallsLogsAsRead) \");\n      that.logger.log(\"internal\", LOG_ID + \"(markAllCallsLogsAsRead) that.calllogs.callLogs : \", that.calllogs.callLogs);\n      yield that._xmpp.markAllCallsLogsAsRead(that.calllogs.callLogs);\n    });\n  }\n  /**\r\n   * @public\r\n   * @method isInitialized\r\n   * @instance\r\n   * @description\r\n   *    Check if the call log history has been received from Rainbow\r\n   *    A false answer means that the call logs have not yet been retrieved from the server.\r\n   * @return {Boolean} True if the call logs have been retrieved. False elsewhere.\r\n   */\n\n\n  isInitialized() {\n    return this._initialized;\n  }\n  /*********************************************************/\n\n  /**                  EVENT HANDLERS                     **/\n\n  /*********************************************************/\n\n\n  onCallLogUpdated(calllogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.calllogs = calllogs;\n      this._initialized = true;\n    });\n  }\n\n  onCallLogAckReceived(calllogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.calllogs = calllogs;\n      this._initialized = true;\n    });\n  }\n  /*async onIqCallLogNotificationReceived(calllogs) {\r\n      this.calllogs = calllogs ;\r\n  } // */\n\n  /*********************************************************/\n\n  /**                  HELPER FUNCTIONS                   **/\n\n  /*********************************************************/\n\n\n  getOrderByNameCallLogs() {\n    let that = this;\n    return that.calllogs.orderByNameCallLogs;\n  }\n\n  getOrderByDateCallLogs() {\n    let that = this;\n\n    if (that.calllogs.orderByDateCallLogs.length !== 0) {\n      that.calllogs.orderByDateCallLogs[0].isLatestCall = true; //update the latest callLog to show its subject next to the contact name.\n\n      if (that.calllogs.orderByDateCallLogs[1]) {\n        that.calllogs.orderByDateCallLogs[1].isLatestCall = false;\n      }\n    }\n\n    return that.calllogs.orderByDateCallLogs;\n  }\n\n  getOrderByNameCallLogsBruts() {\n    let that = this;\n    return that.calllogs.orderByNameCallLogsBruts;\n  }\n\n  getOrderByDateCallLogsBruts() {\n    let that = this;\n    return that.calllogs.orderByDateCallLogsBruts;\n  } //call logs where the contact is replaced by his JID or telephone number\n\n\n  getSimplifiedCallLogs() {\n    let that = this;\n    return that.calllogs.simplifiedCallLogs;\n  }\n\n  getNumberMissedCalls() {\n    let that = this;\n    return that.calllogs.numberMissedCalls;\n  }\n\n  resetCallLogs() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"info\", LOG_ID + \"[resetCallLogs] resetCallLogs\");\n      that.calllogs = CallLogsBean();\n      yield this._calllogEventHandler.resetCallLogs();\n      yield that.getCallLogHistoryPage();\n    });\n  }\n\n};\nCallLogService = __decorate([Utils_1.logEntryExit(LOG_ID), Utils_2.isStarted([])\n/**\r\n* @module\r\n* @name CallsLog\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service allow to get the call log and manage it. <br><br>\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Get all calls log <br/>\r\n*      - Delete one or all calls log <br/>\r\n*      - Mark calls as read / unread <br/>\r\n*/\n], CallLogService);\nexports.CallLogService = CallLogService;\nmodule.exports.CallLogService = CallLogService;","map":{"version":3,"sources":["../../src/lib/services/CallLogService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Utils_1 = require(\"../common/Utils\");\r\nconst PubSub = require(\"pubsub-js\");\r\nconst calllogEventHandler_1 = require(\"../connection/XMPPServiceHandler/calllogEventHandler\");\r\nconst Utils_2 = require(\"../common/Utils\");\r\nconst LOG_ID = \"CALLLOG/SVCE - \";\r\nfunction CallLogsBean() {\r\n    return {\r\n        \"callLogs\": [],\r\n        \"orderByNameCallLogs\": [],\r\n        \"orderByDateCallLogs\": [],\r\n        \"orderByNameCallLogsBruts\": [],\r\n        \"orderByDateCallLogsBruts\": [],\r\n        \"simplifiedCallLogs\": [],\r\n        \"numberMissedCalls\": 0,\r\n        \"lastTimestamp\": 0\r\n    };\r\n}\r\nlet CallLogService = \r\n/**\r\n* @module\r\n* @name CallsLog\r\n * @version 1.67.1 \r\n* @public\r\n* @description\r\n*      This service allow to get the call log and manage it. <br><br>\r\n*      The main methods and events proposed in that service allow to: <br>\r\n*      - Get all calls log <br/>\r\n*      - Delete one or all calls log <br/>\r\n*      - Mark calls as read / unread <br/>\r\n*/\r\nclass CallLogService {\r\n    // $q, $log, $rootScope, $interval, contactService, xmppService, CallLog, orderByFilter, profileService, $injector, telephonyService, webrtcGatewayService\r\n    constructor(_eventEmitter, logger, _startConfig) {\r\n        this.ready = false;\r\n        /*********************************************************/\r\n        /**                 LIFECYCLE STUFF                     **/\r\n        /*********************************************************/\r\n        this._startConfig = _startConfig;\r\n        //let that = this;\r\n        this._eventEmitter = _eventEmitter;\r\n        this.logger = logger;\r\n        this._xmpp = null;\r\n        this._rest = null;\r\n        this._s2s = null;\r\n        this._options = {};\r\n        this._useXMPP = false;\r\n        this._useS2S = false;\r\n        this.started = false;\r\n        this._initialized = false;\r\n        this.ready = false;\r\n        /*this.callLogs = [];\r\n        this.orderByNameCallLogs = [];\r\n        this.orderByDateCallLogs = [];\r\n        this.orderByDateCallLogsBruts = [];\r\n        this.simplifiedCallLogs = []; // */\r\n        this.calllogs = CallLogsBean();\r\n        this.callLogHandlerRef = null;\r\n        this.callLogMessageAckRef = null;\r\n        this.callLogNotificationRef = null;\r\n        //        this.numberMissedCalls = 0;\r\n        //        this.lastTimestamp = null;\r\n        this.callLogsHistory = [];\r\n        this.telephonyCallLog = {};\r\n        this.telephonyCallLogHistory = {};\r\n        this.deferedObject = null;\r\n        this.callLogComplete = false;\r\n        this.callLogIndex = -1;\r\n        this._eventEmitter.on(\"evt_internal_calllogupdated\", this.onCallLogUpdated.bind(this));\r\n        this._eventEmitter.on(\"evt_internal_calllogackupdated\", this.onCallLogAckReceived.bind(this));\r\n    }\r\n    get startConfig() {\r\n        return this._startConfig;\r\n    }\r\n    start(_options, _core) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that._xmpp = _core._xmpp;\r\n            that._rest = _core._rest;\r\n            that._contacts = _core.contacts;\r\n            that._profiles = _core.profiles;\r\n            that._telephony = _core.telephony;\r\n            that._options = _options;\r\n            that._s2s = _core._s2s;\r\n            that._useXMPP = that._options.useXMPP;\r\n            that._useS2S = that._options.useS2S;\r\n            this.calllogHandlerToken = [];\r\n            that.logger.log(\"info\", LOG_ID + \" \");\r\n            that.logger.log(\"info\", LOG_ID + \"[start] === STARTING ===\");\r\n            this.attachHandlers();\r\n            this.ready = true;\r\n        });\r\n    }\r\n    stop() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[stop] Stopping\");\r\n            //remove all saved call logs\r\n            this.started = false;\r\n            this._initialized = false;\r\n            //this.callLogs = [];\r\n            //this.callLogsPromises = [];\r\n            this.callLogHandlerRef = null;\r\n            this.callLogMessageAckRef = null;\r\n            this.calllogs = CallLogsBean();\r\n            this.telephonyCallLog = {};\r\n            this.telephonyCallLogHistory = {};\r\n            this.callLogComplete = false;\r\n            this.callLogIndex = -1;\r\n            this.callLogsHistory = [];\r\n            that._xmpp = null;\r\n            that._rest = null;\r\n            that._contacts = null;\r\n            that._profiles = null;\r\n            delete that._calllogEventHandler;\r\n            that._calllogEventHandler = null;\r\n            if (that.calllogHandlerToken) {\r\n                that.calllogHandlerToken.forEach((token) => PubSub.unsubscribe(token));\r\n            }\r\n            that.calllogHandlerToken = [];\r\n            this.ready = false;\r\n            that.logger.log(\"info\", LOG_ID + \"[stop] Stopped\");\r\n        });\r\n    }\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            //that._eventEmitter.on(\"rainbow_oncalllogupdated\", that.onIqCallLogNotificationReceived.bind(that));\r\n            yield Utils_1.setTimeoutPromised(3000).then(() => {\r\n                let startDate = new Date();\r\n                that.getCallLogHistoryPage()\r\n                    .then(() => {\r\n                    // @ts-ignore\r\n                    let duration = new Date() - startDate;\r\n                    let startDuration = Math.round(duration);\r\n                    that.logger.log(\"info\", LOG_ID + \" callLogService start duration : \", startDuration);\r\n                    that.logger.log(\"info\", LOG_ID + \"[start] === STARTED (\" + startDuration + \" ms) ===\");\r\n                    that.started = true;\r\n                })\r\n                    .catch((error) => {\r\n                    that.logger.log(\"error\", LOG_ID + \"[start] === STARTING FAILURE ===\");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"[start] === STARTING FAILURE === : \", error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    attachHandlers() {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"(attachHandlers)\");\r\n        that._calllogEventHandler = new calllogEventHandler_1.CallLogEventHandler(that._xmpp, that, that._contacts, that._profiles, that._telephony);\r\n        that.calllogHandlerToken = [\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.IQ_CALLLOG, that._calllogEventHandler.onIqCallLogReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.CALLLOG_ACK, that._calllogEventHandler.onCallLogAckReceived),\r\n            PubSub.subscribe(that._xmpp.hash + \".\" + that._calllogEventHandler.IQ_CALLOG_NOTIFICATION, that._calllogEventHandler.onIqCallLogNotificationReceived)\r\n        ];\r\n        /*\r\n        //if reconnection, update the call-logs\r\n        if (that.started && that.lastTimestamp) {\r\n            $interval(function () {\r\n                that.getCallLogHistoryPage(that.lastTimestamp);\r\n            }, 1000, 1, true);\r\n        }\r\n        // */\r\n    }\r\n    /*********************************************************/\r\n    /**       MAM REQUESTS                                  **/\r\n    /*********************************************************/\r\n    getCallLogHistoryPage(useAfter) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"(getCallLogHistoryPage)\");\r\n            if (that._useXMPP) {\r\n                return yield that._xmpp.sendGetCallLogHistoryPage(useAfter);\r\n            }\r\n            if (that._useS2S) {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    /*********************************************************/\r\n    /**                     API                             **/\r\n    /*********************************************************/\r\n    /**\r\n     * @public\r\n     * @method getAll\r\n     * @instance\r\n     * @description\r\n     *    Get all calls log history for the connected user\r\n     * @return {CallLog[]} An array of call log entry\r\n     */\r\n    getAll() {\r\n        let that = this;\r\n        that.calllogs = this._calllogEventHandler.orderCallLogsFunction();\r\n        let callLogs = that.getSimplifiedCallLogs();\r\n        // as duration is \"h[H] mm[m] ss[s]\" in rb, switch it back to ms ...\r\n        for (let i = 0; i < callLogs.length; i++) {\r\n            let durationMs = 0;\r\n            let hmmss = callLogs[i].duration;\r\n            if (hmmss && (typeof hmmss === \"string\") && hmmss.match(/^(?:(?:([01]?\\d|2[0-3])h )?([0-5]?\\d)m )?([0-5]?\\ds)$/)) {\r\n                // Remove h, m and s\r\n                hmmss = hmmss.replace(/[hms]/g, \"\");\r\n                // split it at the \"space\", also reverse it to get seconds then minutes then hours\r\n                let parts = hmmss.split(' ').reverse();\r\n                for (let j = 0; j < parts.length; j++) {\r\n                    durationMs += parts[j] * Math.pow(60, j);\r\n                }\r\n                callLogs[i].duration = durationMs * 1000;\r\n            }\r\n        }\r\n        return callLogs;\r\n    }\r\n    /**\r\n     * @public\r\n     * @method getMissedCallLogCounter\r\n     * @instance\r\n     * @description\r\n     *    Get the number of call missed (state === \"missed\" && direction === \"incoming\")\r\n     * @return {Number} The number of call missed\r\n     */\r\n    getMissedCallLogCounter() {\r\n        let that = this;\r\n        let num = 0;\r\n        that.calllogs.callLogs.forEach(function (callLog) {\r\n            if (!callLog.read && callLog.state === \"missed\" && callLog.direction === \"incoming\") {\r\n                that.logger.log(\"info\", LOG_ID + \"(getMissedCallLogCounter) iter : \", num, \", callLog : \", callLog);\r\n                num++;\r\n            }\r\n        });\r\n        return num;\r\n    }\r\n    ;\r\n    /**\r\n     * @public\r\n     * @method deleteOneCallLog\r\n     * @instance\r\n     * @description\r\n     *    Delete a call log from it's id<br/>\r\n     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n     * @param {String} id The call log id to remove\r\n     * @return Nothing\r\n     */\r\n    deleteOneCallLog(id) {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"(deleteOneCallLog) id : \", id);\r\n        return that._xmpp.deleteOneCallLog(id);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method deleteCallLogsForContact\r\n     * @instance\r\n     * @description\r\n     *    Delete all calls log items associated to a contact's given jid<br/>\r\n     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n     * @param {String} jid The call log id to remove\r\n     * @return Nothing\r\n     */\r\n    deleteCallLogsForContact(jid) {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"(deleteCallLogsForContact) jid : \", jid);\r\n        return that._xmpp.deleteCallLogsForContact(jid);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method deleteAllCallLogs\r\n     * @instance\r\n     * @description\r\n     *    Delete all call logs history<br/>\r\n     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished\r\n     * @return Nothing\r\n     */\r\n    deleteAllCallLogs() {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"(deleteAllCallLogs)\");\r\n        return that._xmpp.deleteAllCallLogs();\r\n    }\r\n    /**\r\n     * @public\r\n     * @method markCallLogAsRead\r\n     * @instance\r\n     * @description\r\n     *    Mark a call log item as read<br/>\r\n     *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished\r\n     * @param {String} id The call log id\r\n     * @return Nothing\r\n     */\r\n    markCallLogAsRead(id) {\r\n        let that = this;\r\n        that.logger.log(\"info\", LOG_ID + \"(markCallLogAsRead) id : \", id);\r\n        return that._xmpp.markCallLogAsRead(id);\r\n    }\r\n    /**\r\n     * @public\r\n     * @method markAllCallsLogsAsRead\r\n     * @instance\r\n     * @description\r\n     *    Mark all call log items as read<br/>\r\n     *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished\r\n     * @return Nothing\r\n     */\r\n    markAllCallsLogsAsRead() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"(markAllCallsLogsAsRead) \");\r\n            that.logger.log(\"internal\", LOG_ID + \"(markAllCallsLogsAsRead) that.calllogs.callLogs : \", that.calllogs.callLogs);\r\n            yield that._xmpp.markAllCallsLogsAsRead(that.calllogs.callLogs);\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @method isInitialized\r\n     * @instance\r\n     * @description\r\n     *    Check if the call log history has been received from Rainbow\r\n     *    A false answer means that the call logs have not yet been retrieved from the server.\r\n     * @return {Boolean} True if the call logs have been retrieved. False elsewhere.\r\n     */\r\n    isInitialized() {\r\n        return this._initialized;\r\n    }\r\n    /*********************************************************/\r\n    /**                  EVENT HANDLERS                     **/\r\n    /*********************************************************/\r\n    onCallLogUpdated(calllogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.calllogs = calllogs;\r\n            this._initialized = true;\r\n        });\r\n    }\r\n    onCallLogAckReceived(calllogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.calllogs = calllogs;\r\n            this._initialized = true;\r\n        });\r\n    }\r\n    /*async onIqCallLogNotificationReceived(calllogs) {\r\n        this.calllogs = calllogs ;\r\n    } // */\r\n    /*********************************************************/\r\n    /**                  HELPER FUNCTIONS                   **/\r\n    /*********************************************************/\r\n    getOrderByNameCallLogs() {\r\n        let that = this;\r\n        return that.calllogs.orderByNameCallLogs;\r\n    }\r\n    getOrderByDateCallLogs() {\r\n        let that = this;\r\n        if (that.calllogs.orderByDateCallLogs.length !== 0) {\r\n            that.calllogs.orderByDateCallLogs[0].isLatestCall = true; //update the latest callLog to show its subject next to the contact name.\r\n            if (that.calllogs.orderByDateCallLogs[1]) {\r\n                that.calllogs.orderByDateCallLogs[1].isLatestCall = false;\r\n            }\r\n        }\r\n        return that.calllogs.orderByDateCallLogs;\r\n    }\r\n    getOrderByNameCallLogsBruts() {\r\n        let that = this;\r\n        return that.calllogs.orderByNameCallLogsBruts;\r\n    }\r\n    getOrderByDateCallLogsBruts() {\r\n        let that = this;\r\n        return that.calllogs.orderByDateCallLogsBruts;\r\n    }\r\n    //call logs where the contact is replaced by his JID or telephone number\r\n    getSimplifiedCallLogs() {\r\n        let that = this;\r\n        return that.calllogs.simplifiedCallLogs;\r\n    }\r\n    getNumberMissedCalls() {\r\n        let that = this;\r\n        return that.calllogs.numberMissedCalls;\r\n    }\r\n    resetCallLogs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"info\", LOG_ID + \"[resetCallLogs] resetCallLogs\");\r\n            that.calllogs = CallLogsBean();\r\n            yield this._calllogEventHandler.resetCallLogs();\r\n            yield that.getCallLogHistoryPage();\r\n        });\r\n    }\r\n};\r\nCallLogService = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID),\r\n    Utils_2.isStarted([])\r\n    /**\r\n    * @module\r\n    * @name CallsLog\r\n     * @version 1.67.1 \r\n    * @public\r\n    * @description\r\n    *      This service allow to get the call log and manage it. <br><br>\r\n    *      The main methods and events proposed in that service allow to: <br>\r\n    *      - Get all calls log <br/>\r\n    *      - Delete one or all calls log <br/>\r\n    *      - Mark calls as read / unread <br/>\r\n    */\r\n], CallLogService);\r\nexports.CallLogService = CallLogService;\r\nmodule.exports.CallLogService = CallLogService;\r\n//# sourceMappingURL=CallLogService.js.map"]},"metadata":{},"sourceType":"script"}