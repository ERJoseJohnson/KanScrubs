{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\n\nconst GenericHandler = require(\"./genericHandler\");\n\nconst Conversation_1 = require(\"../../common/models/Conversation\");\n\nconst util = require('util');\n\nconst xml = require(\"@xmpp/xml\");\n\nconst LOG_ID = \"XMPP/HNDL/CONV - \";\nconst TYPE_CHAT = \"chat\";\nconst TYPE_GROUPCHAT = \"groupchat\";\n\nconst Utils_1 = require(\"../../common/Utils\");\n\nlet ConversationEventHandler = class ConversationEventHandler extends GenericHandler {\n  constructor(xmppService, conversationService, fileStorageService, fileServerService) {\n    super(xmppService);\n    this.MESSAGE_CHAT = \"jabber:client.message.chat\";\n    this.MESSAGE_GROUPCHAT = \"jabber:client.message.groupchat\";\n    this.MESSAGE_WEBRTC = \"jabber:client.message.webrtc\";\n    this.MESSAGE_MANAGEMENT = \"jabber:client.message.management\";\n    this.MESSAGE_ERROR = \"jabber:client.message.error\";\n    this.MESSAGE_HEADLINE = \"jabber:client.message.headline\";\n    this.MESSAGE_CLOSE = \"jabber:client.message.headline\";\n    this.conversationService = conversationService;\n    this.fileStorageService = fileStorageService;\n    this.fileServerService = fileServerService;\n    let that = this;\n\n    this.onChatMessageReceived = (msg, stanza) => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) _entering_ : \", msg, stanza);\n        let content = \"\";\n        let lang = \"\";\n        let alternativeContent = [];\n        let subject = \"\";\n        let event = \"\";\n        let eventJid = \"\";\n        let hasATextMessage = false;\n        let oob = null;\n        let messageType = stanza.attrs.type;\n        let timestamp = new Date();\n        let replaceMessageId = null;\n        let attention = false;\n        let fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(stanza.attrs.from);\n        let resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from);\n        let toJid = stanza.attrs.to;\n        let id = stanza.attrs.id;\n        let children = stanza.children;\n        children.forEach(node => {\n          switch (node.getName()) {\n            case \"sent\":\n              if (node.attrs.xmlns === \"urn:xmpp:carbons:2\") {\n                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' received\");\n                let forwarded = node.children[0];\n\n                if (forwarded && forwarded.getName() === \"forwarded\") {\n                  let message = forwarded.children[0];\n\n                  if (message && message.getName() === \"message\") {\n                    fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(message.attrs.from);\n                    resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(message.attrs.from);\n                    toJid = message.attrs.to;\n                    id = message.attrs.id;\n                    let childs = message.children;\n\n                    if (childs) {\n                      let timestamp = message.getChildren(\"archived\").length && message.getChildren(\"archived\")[0] && message.getChildren(\"archived\")[0].attrs.stamp ? new Date(message.getChildren(\"archived\")[0].attrs.stamp) : new Date();\n                      childs.forEach(nodeChild => {\n                        if (nodeChild.getName() === \"body\") {\n                          that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' of type chat received \");\n                          let data = {\n                            \"fromJid\": fromJid,\n                            \"resource\": resource,\n                            \"toJid\": toJid,\n                            \"type\": messageType,\n                            \"content\": nodeChild.getText(),\n                            \"id\": id,\n                            \"lang\": nodeChild.attrs[\"xml:lang\"],\n                            \"cc\": true,\n                            \"cctype\": \"sent\",\n                            \"isEvent\": false,\n                            \"date\": timestamp\n                          };\n                          let conversationId = data.toJid;\n\n                          that._onMessageReceived(conversationId, data);\n                        }\n                      });\n                    }\n                  }\n                }\n              }\n\n              break;\n\n            case \"received\":\n              if (node.attrs.xmlns === \"urn:xmpp:carbons:2\") {\n                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' received\");\n                let forwarded = node.children[0];\n\n                if (forwarded && forwarded.getName() === \"forwarded\") {\n                  let message = forwarded.children[0];\n\n                  if (message && message.getName() === \"message\") {\n                    fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(message.attrs.from);\n                    resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(message.attrs.from);\n                    toJid = message.attrs.to;\n                    id = message.attrs.id;\n                    let childs = message.children;\n\n                    if (childs) {\n                      let timestamp = message.getChildren(\"archived\").length && message.getChildren(\"archived\")[0] && message.getChildren(\"archived\")[0].attrs.stamp ? new Date(message.getChildren(\"archived\")[0].attrs.stamp) : new Date();\n                      childs.forEach(function (nodeChild) {\n                        if (nodeChild.getName() === \"body\") {\n                          that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' of type chat received \");\n                          let data = {\n                            \"fromJid\": fromJid,\n                            \"resource\": resource,\n                            \"toJid\": toJid,\n                            \"type\": messageType,\n                            \"content\": nodeChild.getText(),\n                            \"id\": id,\n                            \"lang\": nodeChild.attrs[\"xml:lang\"],\n                            \"cc\": true,\n                            \"cctype\": \"sent\",\n                            \"isEvent\": false,\n                            \"date\": timestamp\n                          };\n                          let conversationId = data.fromJid;\n\n                          that._onMessageReceived(conversationId, data);\n                        }\n                      });\n                    }\n                  }\n                }\n              } else {\n                let receipt = {\n                  event: node.attrs.event,\n                  entity: node.attrs.entity,\n                  type: messageType,\n                  id: node.attrs.id,\n                  fromJid: fromJid,\n                  resource: resource\n                };\n                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - receipt received\");\n                that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\n              }\n\n              break;\n\n            case \"active\":\n            case \"inactive\":\n            case \"composing\":\n            case \"paused\":\n              let chatstate = {\n                type: messageType,\n                fromJid: fromJid,\n                resource: resource,\n                chatstate: node.getName()\n              };\n              that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) message - someone is \" + node.getName());\n              that.eventEmitter.emit(\"evt_internal_chatstate\", chatstate);\n              break;\n\n            case \"archived\":\n              break;\n\n            case \"stanza-id\":\n              break;\n\n            case \"subject\":\n              subject = node.getText();\n              hasATextMessage = !(!subject || subject === '');\n              break;\n\n            case \"event\":\n              event = node.attrs.name;\n              eventJid = node.attrs.jid;\n              break;\n\n            case \"body\":\n              content = node.getText();\n              that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - content\", \"***\");\n\n              if (node.attrs[\"xml:lang\"]) {\n                // in <body>\n                lang = node.attrs[\"xml:lang\"];\n              } else if (node.parent.attrs[\"xml:lang\"]) {\n                // in <message>\n                lang = node.parent.attrs[\"xml:lang\"];\n              } else {\n                lang = \"en\";\n              }\n\n              that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - lang\", lang);\n              hasATextMessage = !(!content || content === '');\n              break;\n\n            case \"content\":\n              alternativeContent.push({\n                \"message\": node.getText(),\n                \"type\": node.getAttr(\"type\")\n              });\n              hasATextMessage = true;\n              break;\n\n            case \"request\":\n              that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - asked for receipt\"); // Acknowledge 'received'\n\n              let stanzaReceived = xml(\"message\", {\n                \"to\": fromJid,\n                \"from\": toJid,\n                \"type\": messageType\n              }, xml(\"received\", {\n                \"xmlns\": \"urn:xmpp:receipts\",\n                \"event\": \"received\",\n                \"entity\": \"client\",\n                \"id\": stanza.attrs.id\n              }));\n              that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) answered - send receipt 'received' : \", stanzaReceived.root().toString());\n              that.xmppClient.send(stanzaReceived); //Acknowledge 'read'\n\n              if (that.xmppService.shouldSendReadReceipt || messageType === TYPE_GROUPCHAT && XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from) === that.fullJid) {\n                let stanzaRead = xml(\"message\", {\n                  \"to\": fromJid,\n                  \"from\": toJid,\n                  \"type\": messageType\n                }, xml(\"received\", {\n                  \"xmlns\": \"urn:xmpp:receipts\",\n                  \"event\": \"read\",\n                  \"entity\": \"client\",\n                  \"id\": stanza.attrs.id\n                }));\n                that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) answered - send markAsRead : receipt 'read' : \", stanzaRead.root().toString());\n                that.xmppClient.send(stanzaRead);\n              }\n\n              break;\n\n            case \"recording\":\n              that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - recording message\"); // TODO\n\n              break;\n\n            case \"timestamp\":\n              timestamp = node.attrs.value ? new Date(node.attrs.value) : new Date();\n              break;\n\n            case \"x\":\n              {\n                let xmlns = node.attrs.xmlns;\n\n                switch (xmlns) {\n                  case \"jabber:x:bubble:conference\":\n                  case \"jabber:x:conference\":\n                    {\n                      let invitation = {\n                        event: \"invitation\",\n                        bubbleId: node.attrs.thread,\n                        bubbleJid: node.attrs.jid,\n                        fromJid: fromJid,\n                        resource: resource\n                      };\n                      that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) invitation received\");\n                      that.eventEmitter.emit(\"evt_internal_invitationreceived\", invitation);\n                    }\n                    break;\n\n                  case \"jabber:x:oob\":\n                    {\n                      oob = {\n                        url: node.getChild(\"url\").getText(),\n                        mime: node.getChild(\"mime\").getText(),\n                        filename: node.getChild(\"filename\").getText(),\n                        filesize: node.getChild(\"size\").getText()\n                      };\n                      that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) oob received\");\n                      break;\n                    }\n\n                  default:\n                    break;\n                }\n\n                break;\n              }\n\n            case \"no-store\":\n              break;\n\n            case \"no-permanent-store\":\n              break;\n\n            case \"store\":\n              break;\n\n            case \"replace\":\n              {\n                let replacedId = node.attrs.id;\n                replaceMessageId = replacedId;\n              }\n              break;\n\n            case \"deleted\":\n              {\n                let idDeleted = node.attrs.id;\n                let conversationJid = node.attrs.with;\n\n                if (idDeleted === \"all\") {\n                  let conversation = that.conversationService.getConversationById(conversationJid);\n\n                  if (conversation) {\n                    that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) conversation with all messages deleted received \", conversation.id);\n                    conversation.reset();\n                    that.eventEmitter.emit(\"evt_internal_allmessagedremovedfromconversationreceived\", conversation);\n                  }\n                }\n              }\n              break;\n\n            case \"mark_as_read\":\n              {\n                let conversationId = node.find(\"mark_as_read\").attr(\"with\");\n                let conversation = this.conversationService.getConversationById(conversationId);\n\n                if (conversation) {\n                  let typeread = node.find(\"mark_as_read\").attr(\"id\");\n\n                  switch (typeread) {\n                    case \"all-received\":\n                      // messages for this conversation have been acknowledged\n                      conversation.missedCounter = 0;\n                      break;\n\n                    case \"all-sent\":\n                      // messages for this conversation have been read\n                      // Not take into account : conversation.ackReadAllMessages();\n                      break;\n\n                    default:\n                      that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) error - unknown read type : \", typeread);\n                      break;\n                  }\n                }\n              }\n              break;\n\n            case \"deleted_call_log\":\n              break;\n\n            case \"updated_call_log\":\n              break;\n\n            case \"attention\":\n              attention = true;\n              break;\n\n            default:\n              that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) unmanaged chat message node : \", node.getName());\n              that.logger.log(\"internalerror\", LOG_ID + \"(onChatMessageReceived) unmanaged chat message node : \", node.getName(), stanza);\n              break;\n          }\n        });\n        let fromBubbleJid = \"\";\n        let fromBubbleUserJid = \"\";\n\n        if (stanza.attrs.type === TYPE_GROUPCHAT) {\n          fromBubbleJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(stanza.attrs.from);\n          fromBubbleUserJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from);\n          resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(fromBubbleUserJid);\n        }\n\n        if (messageType === TYPE_GROUPCHAT && fromBubbleUserJid !== that.fullJid || messageType === TYPE_CHAT && fromJid !== that.fullJid) {\n          that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - chat message received\");\n          timestamp = stanza.getChildren(\"archived\").length && stanza.getChildren(\"archived\")[0] && stanza.getChildren(\"archived\")[0].attrs.stamp ? new Date(stanza.getChildren(\"archived\")[0].attrs.stamp) : new Date();\n          let data = {\n            \"fromJid\": fromJid,\n            \"resource\": resource,\n            \"toJid\": toJid,\n            \"type\": messageType,\n            \"content\": content,\n            \"alternativeContent\": alternativeContent,\n            \"id\": stanza.attrs.id,\n            \"lang\": lang,\n            \"cc\": false,\n            \"cctype\": \"\",\n            \"isEvent\": false,\n            \"oob\": oob,\n            \"date\": timestamp,\n            \"fromBubbleJid\": null,\n            \"fromBubbleUserJid\": null,\n            \"event\": null,\n            \"eventJid\": null,\n            \"originalMessageReplaced\": null,\n            \"attention\": undefined,\n            subject\n          };\n\n          if (stanza.attrs.type === TYPE_GROUPCHAT) {\n            data.fromBubbleJid = fromBubbleJid;\n            data.fromBubbleUserJid = fromBubbleUserJid;\n            data.fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(stanza.attrs.from);\n\n            if (event) {\n              data.event = event;\n              data.eventJid = eventJid;\n              data.isEvent = true;\n            }\n\n            if (attention) {\n              data.attention = attention;\n            }\n          }\n\n          let outgoingMessage = that.conversationService._contacts.isUserContactJid(fromJid);\n\n          let conversationId = outgoingMessage ? data.toJid : stanza.attrs.type === TYPE_GROUPCHAT ? fromBubbleJid : data.fromJid;\n\n          if (replaceMessageId) {\n            //data.replaceMessageId = replaceMessageId;\n            let conversation = that.conversationService.getConversationById(conversationId);\n\n            if (conversation) {\n              data.originalMessageReplaced = conversation.getMessageById(replaceMessageId);\n            } else {\n              that.logger.log(\"warn\", LOG_ID + \"(onChatMessageReceived) This is a replace msg but no conversation found for the original msg id. So store an empty msg to avoid the lost of information.\", replaceMessageId);\n              data.originalMessageReplaced = {};\n              data.originalMessageReplaced.id = replaceMessageId;\n            }\n\n            data.originalMessageReplaced.replacedByMessage = data;\n          } else {\n            if (!hasATextMessage) {\n              that.logger.log(\"debug\", LOG_ID + \"(_onMessageReceived) with no message text, so ignore it! hasATextMessage : \", hasATextMessage);\n              return;\n            } else {\n              that.logger.log(\"internal\", LOG_ID + \"(_onMessageReceived) with message : \", data, \", hasATextMessage : \", hasATextMessage);\n            }\n          }\n\n          this._onMessageReceived(conversationId, data);\n        } else {\n          that.logger.log(\"debug\", LOG_ID + \"(onChatMessageReceived) We are the sender, so ignore it.\");\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onChatMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this._onMessageReceived = (conversationId, data) => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(_onMessageReceived) _entering_ : \", conversationId, data);\n        let conversation = that.conversationService.getConversationById(conversationId);\n\n        if (!conversation) {\n          let cs = this.conversationService;\n          let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId) : cs.getOrCreateOneToOneConversation(conversationId);\n          createPromise.then(conv => {\n            data.conversation = conv;\n            data.conversation.addMessage(data);\n            /*if (data.conversation.messages.length === 0 || !data.conversation.messages.find((elmt) => { if (elmt.id === data.id) { return elmt; } })) {\r\n                data.conversation.messages.push(data);\r\n            } // */\n\n            this.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\n            that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\n          });\n        } else {\n          data.conversation = conversation;\n          data.conversation.addMessage(data);\n          /*if (data.conversation.messages.length === 0 || !data.conversation.messages.find((elmt) => { if (elmt.id === data.id) { return elmt; } })) {\r\n              data.conversation.messages.push(data);\r\n          } // */\n\n          this.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\n          that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(_onMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(_onMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onRoomAdminMessageReceived = (msg, stanza) => {};\n\n    this.onFileMessageReceived = (msg, stanza) => {};\n\n    this.onWebRTCMessageReceived = (msg, stanza) => {// No treatment, dedicated to Call Log later\n    };\n\n    this.onManagementMessageReceived = (msg, stanza) => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onManagementMessageReceived) _entering_ : \", msg, stanza);\n        let children = stanza.children;\n        children.forEach(function (node) {\n          switch (node.getName()) {\n            case \"room\":\n              that.onRoomManagementMessageReceived(node);\n              break;\n\n            case \"usersettings\":\n              that.onUserSettingsManagementMessageReceived(node);\n              break;\n\n            case \"userinvite\":\n              that.onUserInviteManagementMessageReceived(node);\n              break;\n\n            case \"group\":\n              that.onGroupManagementMessageReceived(node);\n              break;\n\n            case \"conversation\":\n              that.onConversationManagementMessageReceived(node);\n              break;\n\n            case \"mute\":\n              that.onMuteManagementMessageReceived(node);\n              break;\n\n            case \"unmute\":\n              that.onUnmuteManagementMessageReceived(node);\n              break;\n\n            case \"file\":\n              that.onFileManagementMessageReceived(node);\n              break;\n\n            case \"thumbnail\":\n              that.onThumbnailManagementMessageReceived(node);\n              break;\n\n            case \"channel-subscription\":\n            case \"channel\":\n              //treated in channelEventHandler::onFavoriteManagementMessageReceived(node);\n              break;\n\n            case \"favorite\":\n              // treated in favoriteEventHandler\n              break;\n\n            default:\n              that.logger.log(\"error\", LOG_ID + \"(onManagementMessageReceived) unmanaged management message node \" + node.getName());\n              break;\n          }\n        });\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onRoomManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onRoomManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          // Affiliation changed (my own or for a member)\n          if (node.attrs.status) {\n            if (node.attrs.userjid === XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(that.fullJid)) {\n              that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble management received for own.\");\n              that.eventEmitter.emit(\"evt_internal_ownaffiliationchanged\", {\n                \"bubbleId\": node.attrs.roomid,\n                \"bubbleJid\": node.attrs.roomjid,\n                \"userJid\": node.attrs.userjid,\n                \"status\": node.attrs.status\n              });\n            } else {\n              that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble affiliation received\");\n              that.eventEmitter.emit(\"evt_internal_affiliationchanged\", {\n                \"bubbleId\": node.attrs.roomid,\n                \"bubbleJid\": node.attrs.roomjid,\n                \"userJid\": node.attrs.userjid,\n                \"status\": node.attrs.status\n              });\n            }\n          } // Custom data changed\n          else if (node.attrs.customData) {\n              that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble custom-data changed\");\n              that.eventEmitter.emit(\"evt_internal_customdatachanged\", {\n                \"bubbleId\": node.attrs.roomid,\n                \"bubbleJid\": node.attrs.roomjid,\n                \"customData\": node.attrs.customData\n              });\n            } // Topic changed\n\n\n          if (node.attrs.topic) {\n            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble topic changed\");\n            that.eventEmitter.emit(\"evt_internal_topicchanged\", {\n              \"bubbleId\": node.attrs.roomid,\n              \"bubbleJid\": node.attrs.roomjid,\n              \"topic\": node.attrs.topic\n            });\n          } // Topic changed\n\n\n          if (node.attrs.privilege) {\n            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble privilege changed\");\n            that.eventEmitter.emit(\"evt_internal_privilegechanged\", {\n              \"bubbleId\": node.attrs.roomid,\n              \"bubbleJid\": node.attrs.roomjid,\n              \"userjid\": node.attrs.userjid,\n              \"privilege\": node.attrs.privilege\n            });\n          } // Name changed\n\n\n          if (node.attrs.name) {\n            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble name changed\");\n            that.eventEmitter.emit(\"evt_internal_namechanged\", {\n              \"bubbleId\": node.attrs.roomid,\n              \"bubbleJid\": node.attrs.roomjid,\n              \"name\": node.attrs.name\n            });\n          }\n\n          let lastAvatarUpdateDate = node.attrs.lastAvatarUpdateDate;\n          let avatarElem = node.find(\"avatar\");\n          let avatarType = null;\n\n          if (avatarElem.length > 0) {\n            if (avatarElem.attr(\"action\") === \"delete\") {\n              avatarType = \"delete\";\n            } else {\n              avatarType = \"update\";\n            }\n          }\n\n          if (lastAvatarUpdateDate || avatarType) {\n            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble avatar changed\");\n            that.eventEmitter.emit(\"evt_internal_bubbleavatarchanged\", {\n              \"bubbleId\": node.attrs.roomid\n            });\n            /*service.getServerRoom(room.dbId)\r\n                .then(function(roomToUpdate) {\r\n                    roomToUpdate.updateAvatarInfo();\r\n                    $rootScope.$broadcast(service.ROOM_AVATAR_UPDATE_EVENT, room);\r\n                }); // */\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onRoomManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onRoomManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onUserSettingsManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"debug\", LOG_ID + \"(onUserSettingsManagementMessageReceived) _entering_\");\n        that.logger.log(\"internal\", LOG_ID + \"(onUserSettingsManagementMessageReceived) _entering_\", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          switch (node.attrs.action) {\n            case \"update\":\n              that.logger.log(\"debug\", LOG_ID + \"(onUserSettingsManagementMessageReceived) usersettings updated\");\n              that.eventEmitter.emit(\"evt_internal_usersettingschanged\");\n              break;\n\n            default:\n              break;\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onUserSettingsManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onUserSettingsManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onUserInviteManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) _entering_\");\n        that.logger.log(\"internal\", LOG_ID + \"(onUserInviteManagementMessageReceived) _entering_\", node);\n        /*\r\n        // Know the treatment is done in invitationEventHandler\r\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n            that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) xmlns configuration, treat action : \");\r\n            switch (node.attrs.action) {\r\n                case \"create\":\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite received\");\r\n                        that.eventEmitter.emit(\"evt_internal_userinvitemngtreceived\", {invitationId: node.attrs.id});\r\n                    break;\r\n                case \"update\":\r\n                    if (node.attrs.type === \"sent\" && node.attrs.status === \"canceled\") {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite canceled\");\r\n                        that.eventEmitter.emit(\"evt_internal_userinvitecanceled\", {invitationId: node.attrs.id});\r\n                    } else if (node.attrs.type === \"sent\" && node.attrs.status === \"accepted\") {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite accepted\");\r\n                        that.eventEmitter.emit(\"evt_internal_userinviteaccepted\", {invitationId: node.attrs.id});\r\n                    }\r\n                    break;\r\n                default:\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) action not reconized, so default switch used to do nothing.\");\r\n                    break;\r\n            }\r\n        } else {\r\n            that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) not xmlns configuration, ignore it : \", node.attrs.xmlns);\r\n        }\r\n        // */\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onUserInviteManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onUserInviteManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onGroupManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onGroupManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          let action = node.attrs.action;\n          let scope = node.attrs.scope;\n\n          if (action === \"create\" && scope === \"group\") {\n            that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group created\");\n            that.eventEmitter.emit(\"evt_internal_hdle_groupcreated\", {\n              \"groupId\": node.attrs.id\n            });\n          } else if (action === \"create\" && scope === \"user\" && node.attrs.userId) {\n            that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) user added in group\");\n            that.eventEmitter.emit(\"evt_internal_hdle_useraddedingroup\", {\n              \"groupId\": node.attrs.id,\n              \"userId\": node.attrs.userId\n            });\n          } else if (action === \"delete\" && scope === \"group\") {\n            that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group deleted\");\n            that.eventEmitter.emit(\"evt_internal_hdle_groupdeleted\", {\n              \"groupId\": node.attrs.id\n            });\n          } else if (action === \"delete\" && scope === \"user\" && node.attrs.userId) {\n            that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) user removed from group\");\n            that.eventEmitter.emit(\"evt_internal_hdle_userremovedfromgroup\", {\n              \"groupId\": node.attrs.id,\n              \"userId\": node.attrs.userId\n            });\n          } else if (action === \"update\" && scope === \"group\") {\n            if (node.attrs.name || node.attrs.comment || node.attrs.isFavorite) {\n              that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group updated\");\n              that.eventEmitter.emit(\"evt_internal_hdle_groupupdated\", {\n                \"groupId\": node.attrs.id\n              });\n            }\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onGroupManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onGroupManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onConversationManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onConversationManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          let conversationId = node.attrs.id;\n          let conversation = this.conversationService.getConversationById(conversationId);\n          let action = node.attrs.action;\n          that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) action : \" + action + \"\");\n          that.logger.log(\"internal\", LOG_ID + \"(onConversationManagementMessageReceived) action : \" + action + \", for conversation : \", conversation);\n\n          if (conversation) {\n            switch (action) {\n              case \"create\":\n                //                                conversation.dbId = node.getAttribute(\"id\");\n                conversation.dbId = conversationId;\n                conversation.lastModification = new Date(node.find(\"lastMessageDate\").text());\n                conversation.missedCounter = parseInt(node.find(\"unreadMessageNumber\").text(), 10) || 0;\n                conversation.isFavorite = node.find(\"isFavorite\").text() === \"true\"; //this.conversationService.orderConversations();\n                //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\");\n                // Send conversations update event\n\n                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n                break;\n\n              case \"delete\":\n                this.conversationService.removeConversation(conversation);\n                break;\n\n              case \"update\":\n                conversation.isFavorite = node.find(\"isFavorite\").text() === \"true\"; //this.conversationService.orderConversations();\n                // Send conversations update event\n\n                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation); //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\");\n\n                break;\n\n              default:\n                break;\n            }\n          } else {\n            that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) conversation not know in cache action : \", action);\n\n            if (action === \"create\") {\n              let convId = node.find(\"peer\").text();\n              let peerId = node.find(\"peerId\").text();\n              let convDbId = node.attrs.id;\n              let lastModification = new Date(node.find(\"lastMessageDate\").text());\n              let lastMessageText = node.find(\"lastMessageText\").text();\n              let lastMessageSender = node.find(\"lastMessageSender\").text();\n              let missedIMCounter = parseInt(node.find(\"unreadMessageNumber\").text(), 10) || 0;\n              let muted = node.find(\"mute\").text() === \"true\";\n              let isFavorite = node.find(\"isFavorite\").text() === \"true\";\n              let type = node.find(\"type\").text();\n              let conversationGetter = null;\n\n              if (type === \"user\") {\n                conversationGetter = this.conversationService.getOrCreateOneToOneConversation(convId);\n              } else {\n                let bubbleId = convId;\n                that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) create, find conversation, bubbleId : \" + bubbleId + \", convDbId : \", convDbId, \", peerId : \", peerId); // conversationGetter = this.conversationService.getConversationByBubbleId(convId);\n\n                conversationGetter = this.conversationService.getBubbleConversation(bubbleId, peerId, lastModification, lastMessageText, missedIMCounter, null, muted, new Date(), lastMessageSender);\n              }\n\n              if (!conversationGetter) {\n                return;\n              }\n\n              conversationGetter.then(function (conv) {\n                that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) update conversation (\" + conv.id + \")\");\n                conv.dbId = convDbId;\n                conv.lastModification = lastModification ? new Date(lastModification) : undefined;\n                conv.lastMessageText = lastMessageText;\n                conv.lastMessageSender = lastMessageSender;\n                conv.muted = muted;\n                conv.isFavorite = isFavorite;\n                conv.preload = true;\n                conv.missedCounter = missedIMCounter; // Send conversations update event\n\n                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv); //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\", conv);\n              });\n            }\n\n            if (action === \"delete\") {\n              that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) conversation not know in cache deleted : \", conversationId);\n              let conversationUnknown = new Conversation_1.Conversation(conversationId);\n\n              if (conversationUnknown) {\n                that.conversationService.removeConversation(conversationUnknown);\n              }\n            }\n          } // Handle mute/unmute room\n\n\n          if (node.find(\"mute\") || node.find(\"unmute\")) {\n            let muteElem = node.find(\"mute\");\n            let mute = false;\n\n            if (muteElem.length) {\n              if (muteElem.text().length) {\n                mute = muteElem.text() === \"true\";\n              } else {\n                mute = true;\n              }\n            }\n\n            let conversationDbId = node.find(\"mute\").attrs.conversation || node.find(\"unmute\").attrs.conversation;\n            let conversation = this.conversationService.getConversationByDbId(conversationDbId);\n\n            if (conversation) {\n              that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) : mute is changed to \" + mute);\n              conversation.muted = mute;\n            }\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onConversationManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onConversationManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onMuteManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onMuteManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          that.logger.log(\"debug\", LOG_ID + \"(onMuteManagementMessageReceived) conversation muted\");\n          let conversationId = node.attrs.conversation;\n          let conversation = that.conversationService.getConversationById(conversationId);\n\n          if (!conversation) {\n            let cs = this.conversationService;\n            let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined) : cs.getOrCreateOneToOneConversation(conversationId);\n            createPromise.then(conv => {\n              that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\n            });\n          } else {\n            that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onMuteManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onMuteManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onUnmuteManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onUnmuteManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          that.logger.log(\"debug\", LOG_ID + \"(onUnmuteManagementMessageReceived) conversation unmuted\");\n          let conversationId = node.attrs.conversation;\n          let conversation = that.conversationService.getConversationById(conversationId);\n\n          if (!conversation) {\n            let cs = this.conversationService;\n            let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined) : cs.getOrCreateOneToOneConversation(conversationId);\n            createPromise.then(conv => {\n              that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\n            });\n          } else {\n            that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onUnmuteManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onUnmuteManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onFileManagementMessageReceived = node => __awaiter(this, void 0, void 0, function* () {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onFileManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          let updateConsumption = false;\n\n          switch (node.attrs.action) {\n            case \"create\":\n              {\n                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file created\");\n                let fileNode = node.children[0];\n                let fileid = fileNode.children[0]; //.getText() ||  \"\";\n\n                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\n\n                if (!fileDescriptor) {\n                  updateConsumption = true;\n                }\n\n                yield that.fileStorageService.retrieveAndStoreOneFileDescriptor(fileid, true).then(function (fileDesc) {\n                  that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) fileDescriptor retrieved\");\n\n                  if (!fileDesc.previewBlob) {\n                    that.fileServerService.getBlobThumbnailFromFileDescriptor(fileDesc).then(function (blob) {\n                      fileDesc.previewBlob = blob;\n                    });\n                  }\n                });\n                that.eventEmitter.emit(\"evt_internal_filecreated\", {\n                  'fileid': fileid\n                });\n              }\n              break;\n\n            case \"update\":\n              {\n                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file updated\");\n                let fileNode = node.children[0];\n                let fileid = fileNode.children[0]; //.getText() ||  \"\";\n\n                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\n\n                if (!fileDescriptor) {\n                  updateConsumption = true;\n                }\n\n                yield that.fileStorageService.retrieveAndStoreOneFileDescriptor(fileid, true).then(function (fileDesc) {\n                  that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) fileDescriptor retrieved\");\n\n                  if (!fileDesc.previewBlob) {\n                    that.fileServerService.getBlobThumbnailFromFileDescriptor(fileDesc).then(function (blob) {\n                      fileDesc.previewBlob = blob;\n                    });\n                  }\n                });\n                that.eventEmitter.emit(\"evt_internal_fileupdated\", {\n                  'fileid': fileid\n                });\n              }\n              break;\n\n            case \"delete\":\n              {\n                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file deleted\");\n                let fileNode = node.children[0];\n                let fileid = fileNode.children[0]; //.getText() ||  \"\";\n\n                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\n\n                if (fileDescriptor) {\n                  //check if we've deleted one of our own files\n                  if (fileDescriptor.ownerId === that.userId && fileDescriptor.state !== \"deleted\") {\n                    updateConsumption = true;\n                  }\n\n                  this.fileStorageService.deleteFileDescriptorFromCache(fileid, true);\n                }\n\n                that.eventEmitter.emit(\"evt_internal_filedeleted\", {\n                  'fileid': fileid\n                });\n              }\n              break;\n\n            default:\n              break;\n          }\n\n          if (updateConsumption) {\n            this.fileStorageService.retrieveUserConsumption();\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onFileManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onFileManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    });\n\n    this.onThumbnailManagementMessageReceived = node => {\n      try {\n        that.logger.log(\"internal\", LOG_ID + \"(onThumbnailManagementMessageReceived) _entering_ : \", node);\n\n        if (node.attrs.xmlns === \"jabber:iq:configuration\") {\n          switch (node.attrs.action) {\n            case \"create\":\n              {\n                that.logger.log(\"debug\", LOG_ID + \"(onThumbnailManagementMessageReceived) file created\");\n                let url = node.getChild('url') ? node.getChild('url').children[0] : ''; //let fileId = fileNode.children[0];\n                //.getText() ||  \"\";\n\n                let mime = node.getChild('mime') ? node.getChild('mime').children[0] : '';\n                let filename = node.getChild('filename') ? node.getChild('filename').children[0] : '';\n                let size = node.getChild('size') ? node.getChild('size').children[0] : '';\n                let md5sum = node.getChild('md5sum') ? node.getChild('md5sum').children[0] : '';\n                let fileid = node.getChild('fileid') ? node.getChild('fileid').children[0] : '';\n                that.eventEmitter.emit(\"evt_internal_thumbnailcreated\", {\n                  'url': url,\n                  'mime': mime,\n                  'filename': filename,\n                  'size': size,\n                  'md5sum': md5sum,\n                  'fileid': fileid\n                });\n              }\n              break;\n\n            default:\n              break;\n          }\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onThumbnailManagementMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onThumbnailManagementMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.onReceiptMessageReceived = (msg, stanza) => {};\n\n    this.onErrorMessageReceived = (msg, stanza) => {\n      try {\n        if (stanza.getChild('no-store') != undefined) {\n          that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) The 'to' of the message can not received the message\");\n          let err = {\n            \"id\": stanza.attrs.id,\n            \"body\": stanza.getChild('body').text(),\n            \"subject\": stanza.getChild('subject').text()\n          };\n          that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) no-store message setted...\");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) failed to send : \", err);\n          that.eventEmitter.emit(\"evt_internal_onsendmessagefailed\", err);\n        } else {\n          that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) something goes wrong...\");\n          that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) something goes wrong... : \", msg, util.inspect(stanza));\n          that.eventEmitter.emit(\"evt_internal_xmpperror\", msg);\n        }\n      } catch (err) {\n        that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) CATCH Error !!! \");\n        that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) CATCH Error !!! : \", err);\n      }\n    };\n\n    this.findAttrs = () => {};\n    /*\r\n    this.findChildren = (element) => {\r\n        try {\r\n            that.logger.log(\"debug\", LOG_ID + \"(findChildren) _entering_\");\r\n            that.logger.log(\"internal\", LOG_ID + \"(findChildren) _entering_\", element);\r\n            that.logger.log(\"error\", LOG_ID + \"(findChildren) findChildren element : \", element, \" name : \", element.getName());\r\n            let json = {};\r\n            //let result = null;\r\n            let children = element.children;\r\n            if (children.length > 0) {\r\n                json[element.getName()] = {};\r\n                let childrenJson = json[element.getName()];\r\n                children.forEach((elemt) => {\r\n                    // @ts-ignore\r\n                    if (typeof elemt.children === Array) {\r\n                        that.logger.log(\"error\", LOG_ID + \"(findChildren)  children.forEach Array : \", element, \", elemt : \", elemt);\r\n                        childrenJson[elemt.getName()] = elemt.children[0];\r\n                    }\r\n                    that.logger.log(\"error\", LOG_ID + \"(findChildren)  children.forEach element : \", element, \", elemt : \", elemt);\r\n                    childrenJson[elemt.getName()] = this.findChildren(elemt);\r\n                });\r\n                return json;\r\n            } else {\r\n                that.logger.log(\"error\", LOG_ID + \"(findChildren)  No children element : \", element);\r\n                return element.getText();\r\n            }\r\n            //return result;\r\n        } catch (err) {\r\n            that.logger.log(\"error\", LOG_ID + \"(findChildren) CATCH Error !!! : \", err);\r\n        }\r\n    };\r\n       */\n\n\n    this.onCloseMessageReceived = (msg, stanza) => {};\n  }\n\n};\nConversationEventHandler = __decorate([Utils_1.logEntryExit(LOG_ID)], ConversationEventHandler);\nexports.ConversationEventHandler = ConversationEventHandler;\nmodule.exports.ConversationEventHandler = ConversationEventHandler;","map":{"version":3,"sources":["../../../src/lib/connection/XMPPServiceHandler/conversationEventHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst XMPPUtils_1 = require(\"../../common/XMPPUtils\");\r\nconst GenericHandler = require(\"./genericHandler\");\r\nconst Conversation_1 = require(\"../../common/models/Conversation\");\r\nconst util = require('util');\r\nconst xml = require(\"@xmpp/xml\");\r\nconst LOG_ID = \"XMPP/HNDL/CONV - \";\r\nconst TYPE_CHAT = \"chat\";\r\nconst TYPE_GROUPCHAT = \"groupchat\";\r\nconst Utils_1 = require(\"../../common/Utils\");\r\nlet ConversationEventHandler = class ConversationEventHandler extends GenericHandler {\r\n    constructor(xmppService, conversationService, fileStorageService, fileServerService) {\r\n        super(xmppService);\r\n        this.MESSAGE_CHAT = \"jabber:client.message.chat\";\r\n        this.MESSAGE_GROUPCHAT = \"jabber:client.message.groupchat\";\r\n        this.MESSAGE_WEBRTC = \"jabber:client.message.webrtc\";\r\n        this.MESSAGE_MANAGEMENT = \"jabber:client.message.management\";\r\n        this.MESSAGE_ERROR = \"jabber:client.message.error\";\r\n        this.MESSAGE_HEADLINE = \"jabber:client.message.headline\";\r\n        this.MESSAGE_CLOSE = \"jabber:client.message.headline\";\r\n        this.conversationService = conversationService;\r\n        this.fileStorageService = fileStorageService;\r\n        this.fileServerService = fileServerService;\r\n        let that = this;\r\n        this.onChatMessageReceived = (msg, stanza) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) _entering_ : \", msg, stanza);\r\n                let content = \"\";\r\n                let lang = \"\";\r\n                let alternativeContent = [];\r\n                let subject = \"\";\r\n                let event = \"\";\r\n                let eventJid = \"\";\r\n                let hasATextMessage = false;\r\n                let oob = null;\r\n                let messageType = stanza.attrs.type;\r\n                let timestamp = new Date();\r\n                let replaceMessageId = null;\r\n                let attention = false;\r\n                let fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(stanza.attrs.from);\r\n                let resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from);\r\n                let toJid = stanza.attrs.to;\r\n                let id = stanza.attrs.id;\r\n                let children = stanza.children;\r\n                children.forEach((node) => {\r\n                    switch (node.getName()) {\r\n                        case \"sent\":\r\n                            if (node.attrs.xmlns === \"urn:xmpp:carbons:2\") {\r\n                                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' received\");\r\n                                let forwarded = node.children[0];\r\n                                if (forwarded && forwarded.getName() === \"forwarded\") {\r\n                                    let message = forwarded.children[0];\r\n                                    if (message && message.getName() === \"message\") {\r\n                                        fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(message.attrs.from);\r\n                                        resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(message.attrs.from);\r\n                                        toJid = message.attrs.to;\r\n                                        id = message.attrs.id;\r\n                                        let childs = message.children;\r\n                                        if (childs) {\r\n                                            let timestamp = message.getChildren(\"archived\").length &&\r\n                                                message.getChildren(\"archived\")[0] &&\r\n                                                message.getChildren(\"archived\")[0].attrs.stamp ?\r\n                                                new Date(message.getChildren(\"archived\")[0].attrs.stamp) : new Date();\r\n                                            childs.forEach((nodeChild) => {\r\n                                                if (nodeChild.getName() === \"body\") {\r\n                                                    that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' of type chat received \");\r\n                                                    let data = {\r\n                                                        \"fromJid\": fromJid,\r\n                                                        \"resource\": resource,\r\n                                                        \"toJid\": toJid,\r\n                                                        \"type\": messageType,\r\n                                                        \"content\": nodeChild.getText(),\r\n                                                        \"id\": id,\r\n                                                        \"lang\": nodeChild.attrs[\"xml:lang\"],\r\n                                                        \"cc\": true,\r\n                                                        \"cctype\": \"sent\",\r\n                                                        \"isEvent\": false,\r\n                                                        \"date\": timestamp\r\n                                                    };\r\n                                                    let conversationId = data.toJid;\r\n                                                    that._onMessageReceived(conversationId, data);\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"received\":\r\n                            if (node.attrs.xmlns === \"urn:xmpp:carbons:2\") {\r\n                                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' received\");\r\n                                let forwarded = node.children[0];\r\n                                if (forwarded && forwarded.getName() === \"forwarded\") {\r\n                                    let message = forwarded.children[0];\r\n                                    if (message && message.getName() === \"message\") {\r\n                                        fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(message.attrs.from);\r\n                                        resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(message.attrs.from);\r\n                                        toJid = message.attrs.to;\r\n                                        id = message.attrs.id;\r\n                                        let childs = message.children;\r\n                                        if (childs) {\r\n                                            let timestamp = message.getChildren(\"archived\").length &&\r\n                                                message.getChildren(\"archived\")[0] &&\r\n                                                message.getChildren(\"archived\")[0].attrs.stamp ?\r\n                                                new Date(message.getChildren(\"archived\")[0].attrs.stamp) : new Date();\r\n                                            childs.forEach(function (nodeChild) {\r\n                                                if (nodeChild.getName() === \"body\") {\r\n                                                    that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - CC message 'sent' of type chat received \");\r\n                                                    let data = {\r\n                                                        \"fromJid\": fromJid,\r\n                                                        \"resource\": resource,\r\n                                                        \"toJid\": toJid,\r\n                                                        \"type\": messageType,\r\n                                                        \"content\": nodeChild.getText(),\r\n                                                        \"id\": id,\r\n                                                        \"lang\": nodeChild.attrs[\"xml:lang\"],\r\n                                                        \"cc\": true,\r\n                                                        \"cctype\": \"sent\",\r\n                                                        \"isEvent\": false,\r\n                                                        \"date\": timestamp\r\n                                                    };\r\n                                                    let conversationId = data.fromJid;\r\n                                                    that._onMessageReceived(conversationId, data);\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                let receipt = {\r\n                                    event: node.attrs.event,\r\n                                    entity: node.attrs.entity,\r\n                                    type: messageType,\r\n                                    id: node.attrs.id,\r\n                                    fromJid: fromJid,\r\n                                    resource: resource\r\n                                };\r\n                                that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - receipt received\");\r\n                                that.eventEmitter.emit(\"evt_internal_onreceipt\", receipt);\r\n                            }\r\n                            break;\r\n                        case \"active\":\r\n                        case \"inactive\":\r\n                        case \"composing\":\r\n                        case \"paused\":\r\n                            let chatstate = {\r\n                                type: messageType,\r\n                                fromJid: fromJid,\r\n                                resource: resource,\r\n                                chatstate: node.getName()\r\n                            };\r\n                            that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) message - someone is \" + node.getName());\r\n                            that.eventEmitter.emit(\"evt_internal_chatstate\", chatstate);\r\n                            break;\r\n                        case \"archived\":\r\n                            break;\r\n                        case \"stanza-id\":\r\n                            break;\r\n                        case \"subject\":\r\n                            subject = node.getText();\r\n                            hasATextMessage = (!(!subject || subject === ''));\r\n                            break;\r\n                        case \"event\":\r\n                            event = node.attrs.name;\r\n                            eventJid = node.attrs.jid;\r\n                            break;\r\n                        case \"body\":\r\n                            content = node.getText();\r\n                            that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - content\", \"***\");\r\n                            if (node.attrs[\"xml:lang\"]) { // in <body>\r\n                                lang = node.attrs[\"xml:lang\"];\r\n                            }\r\n                            else if (node.parent.attrs[\"xml:lang\"]) { // in <message>\r\n                                lang = node.parent.attrs[\"xml:lang\"];\r\n                            }\r\n                            else {\r\n                                lang = \"en\";\r\n                            }\r\n                            that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - lang\", lang);\r\n                            hasATextMessage = (!(!content || content === ''));\r\n                            break;\r\n                        case \"content\":\r\n                            alternativeContent.push({\r\n                                \"message\": node.getText(),\r\n                                \"type\": node.getAttr(\"type\")\r\n                            });\r\n                            hasATextMessage = true;\r\n                            break;\r\n                        case \"request\":\r\n                            that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - asked for receipt\");\r\n                            // Acknowledge 'received'\r\n                            let stanzaReceived = xml(\"message\", {\r\n                                \"to\": fromJid,\r\n                                \"from\": toJid,\r\n                                \"type\": messageType\r\n                            }, xml(\"received\", {\r\n                                \"xmlns\": \"urn:xmpp:receipts\",\r\n                                \"event\": \"received\",\r\n                                \"entity\": \"client\",\r\n                                \"id\": stanza.attrs.id\r\n                            }));\r\n                            that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) answered - send receipt 'received' : \", stanzaReceived.root().toString());\r\n                            that.xmppClient.send(stanzaReceived);\r\n                            //Acknowledge 'read'\r\n                            if (that.xmppService.shouldSendReadReceipt || (messageType === TYPE_GROUPCHAT && XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from) === that.fullJid)) {\r\n                                let stanzaRead = xml(\"message\", {\r\n                                    \"to\": fromJid,\r\n                                    \"from\": toJid,\r\n                                    \"type\": messageType\r\n                                }, xml(\"received\", {\r\n                                    \"xmlns\": \"urn:xmpp:receipts\",\r\n                                    \"event\": \"read\",\r\n                                    \"entity\": \"client\",\r\n                                    \"id\": stanza.attrs.id\r\n                                }));\r\n                                that.logger.log(\"internal\", LOG_ID + \"(onChatMessageReceived) answered - send markAsRead : receipt 'read' : \", stanzaRead.root().toString());\r\n                                that.xmppClient.send(stanzaRead);\r\n                            }\r\n                            break;\r\n                        case \"recording\":\r\n                            that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - recording message\");\r\n                            // TODO\r\n                            break;\r\n                        case \"timestamp\":\r\n                            timestamp = node.attrs.value ?\r\n                                new Date(node.attrs.value) : new Date();\r\n                            break;\r\n                        case \"x\": {\r\n                            let xmlns = node.attrs.xmlns;\r\n                            switch (xmlns) {\r\n                                case \"jabber:x:bubble:conference\":\r\n                                case \"jabber:x:conference\":\r\n                                    {\r\n                                        let invitation = {\r\n                                            event: \"invitation\",\r\n                                            bubbleId: node.attrs.thread,\r\n                                            bubbleJid: node.attrs.jid,\r\n                                            fromJid: fromJid,\r\n                                            resource: resource\r\n                                        };\r\n                                        that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) invitation received\");\r\n                                        that.eventEmitter.emit(\"evt_internal_invitationreceived\", invitation);\r\n                                    }\r\n                                    break;\r\n                                case \"jabber:x:oob\": {\r\n                                    oob = {\r\n                                        url: node.getChild(\"url\").getText(),\r\n                                        mime: node.getChild(\"mime\").getText(),\r\n                                        filename: node.getChild(\"filename\").getText(),\r\n                                        filesize: node.getChild(\"size\").getText()\r\n                                    };\r\n                                    that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) oob received\");\r\n                                    break;\r\n                                }\r\n                                default:\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"no-store\":\r\n                            break;\r\n                        case \"no-permanent-store\":\r\n                            break;\r\n                        case \"store\":\r\n                            break;\r\n                        case \"replace\":\r\n                            {\r\n                                let replacedId = node.attrs.id;\r\n                                replaceMessageId = replacedId;\r\n                            }\r\n                            break;\r\n                        case \"deleted\":\r\n                            {\r\n                                let idDeleted = node.attrs.id;\r\n                                let conversationJid = node.attrs.with;\r\n                                if (idDeleted === \"all\") {\r\n                                    let conversation = that.conversationService.getConversationById(conversationJid);\r\n                                    if (conversation) {\r\n                                        that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) conversation with all messages deleted received \", conversation.id);\r\n                                        conversation.reset();\r\n                                        that.eventEmitter.emit(\"evt_internal_allmessagedremovedfromconversationreceived\", conversation);\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"mark_as_read\":\r\n                            {\r\n                                let conversationId = node.find(\"mark_as_read\").attr(\"with\");\r\n                                let conversation = this.conversationService.getConversationById(conversationId);\r\n                                if (conversation) {\r\n                                    let typeread = node.find(\"mark_as_read\").attr(\"id\");\r\n                                    switch (typeread) {\r\n                                        case \"all-received\": // messages for this conversation have been acknowledged\r\n                                            conversation.missedCounter = 0;\r\n                                            break;\r\n                                        case \"all-sent\": // messages for this conversation have been read\r\n                                            // Not take into account : conversation.ackReadAllMessages();\r\n                                            break;\r\n                                        default:\r\n                                            that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) error - unknown read type : \", typeread);\r\n                                            break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"deleted_call_log\":\r\n                            break;\r\n                        case \"updated_call_log\":\r\n                            break;\r\n                        case \"attention\":\r\n                            attention = true;\r\n                            break;\r\n                        default:\r\n                            that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) unmanaged chat message node : \", node.getName());\r\n                            that.logger.log(\"internalerror\", LOG_ID + \"(onChatMessageReceived) unmanaged chat message node : \", node.getName(), stanza);\r\n                            break;\r\n                    }\r\n                });\r\n                let fromBubbleJid = \"\";\r\n                let fromBubbleUserJid = \"\";\r\n                if (stanza.attrs.type === TYPE_GROUPCHAT) {\r\n                    fromBubbleJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(stanza.attrs.from);\r\n                    fromBubbleUserJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(stanza.attrs.from);\r\n                    resource = XMPPUtils_1.XMPPUTils.getXMPPUtils().getResourceFromFullJID(fromBubbleUserJid);\r\n                }\r\n                if ((messageType === TYPE_GROUPCHAT && fromBubbleUserJid !== that.fullJid) || (messageType === TYPE_CHAT && fromJid !== that.fullJid)) {\r\n                    that.logger.log(\"info\", LOG_ID + \"(onChatMessageReceived) message - chat message received\");\r\n                    timestamp = stanza.getChildren(\"archived\").length &&\r\n                        stanza.getChildren(\"archived\")[0] &&\r\n                        stanza.getChildren(\"archived\")[0].attrs.stamp ?\r\n                        new Date(stanza.getChildren(\"archived\")[0].attrs.stamp) : new Date();\r\n                    let data = {\r\n                        \"fromJid\": fromJid,\r\n                        \"resource\": resource,\r\n                        \"toJid\": toJid,\r\n                        \"type\": messageType,\r\n                        \"content\": content,\r\n                        \"alternativeContent\": alternativeContent,\r\n                        \"id\": stanza.attrs.id,\r\n                        \"lang\": lang,\r\n                        \"cc\": false,\r\n                        \"cctype\": \"\",\r\n                        \"isEvent\": false,\r\n                        \"oob\": oob,\r\n                        \"date\": timestamp,\r\n                        \"fromBubbleJid\": null,\r\n                        \"fromBubbleUserJid\": null,\r\n                        \"event\": null,\r\n                        \"eventJid\": null,\r\n                        \"originalMessageReplaced\": null,\r\n                        \"attention\": undefined,\r\n                        subject\r\n                    };\r\n                    if (stanza.attrs.type === TYPE_GROUPCHAT) {\r\n                        data.fromBubbleJid = fromBubbleJid;\r\n                        data.fromBubbleUserJid = fromBubbleUserJid;\r\n                        data.fromJid = XMPPUtils_1.XMPPUTils.getXMPPUtils().getRoomJIDFromFullJID(stanza.attrs.from);\r\n                        if (event) {\r\n                            data.event = event;\r\n                            data.eventJid = eventJid;\r\n                            data.isEvent = true;\r\n                        }\r\n                        if (attention) {\r\n                            data.attention = attention;\r\n                        }\r\n                    }\r\n                    let outgoingMessage = that.conversationService._contacts.isUserContactJid(fromJid);\r\n                    let conversationId = outgoingMessage ? data.toJid : (stanza.attrs.type === TYPE_GROUPCHAT ? fromBubbleJid : data.fromJid);\r\n                    if (replaceMessageId) {\r\n                        //data.replaceMessageId = replaceMessageId;\r\n                        let conversation = that.conversationService.getConversationById(conversationId);\r\n                        if (conversation) {\r\n                            data.originalMessageReplaced = conversation.getMessageById(replaceMessageId);\r\n                        }\r\n                        else {\r\n                            that.logger.log(\"warn\", LOG_ID + \"(onChatMessageReceived) This is a replace msg but no conversation found for the original msg id. So store an empty msg to avoid the lost of information.\", replaceMessageId);\r\n                            data.originalMessageReplaced = {};\r\n                            data.originalMessageReplaced.id = replaceMessageId;\r\n                        }\r\n                        data.originalMessageReplaced.replacedByMessage = data;\r\n                    }\r\n                    else {\r\n                        if (!hasATextMessage) {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(_onMessageReceived) with no message text, so ignore it! hasATextMessage : \", hasATextMessage);\r\n                            return;\r\n                        }\r\n                        else {\r\n                            that.logger.log(\"internal\", LOG_ID + \"(_onMessageReceived) with message : \", data, \", hasATextMessage : \", hasATextMessage);\r\n                        }\r\n                    }\r\n                    this._onMessageReceived(conversationId, data);\r\n                }\r\n                else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onChatMessageReceived) We are the sender, so ignore it.\");\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onChatMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onChatMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this._onMessageReceived = (conversationId, data) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(_onMessageReceived) _entering_ : \", conversationId, data);\r\n                let conversation = that.conversationService.getConversationById(conversationId);\r\n                if (!conversation) {\r\n                    let cs = this.conversationService;\r\n                    let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId) : cs.getOrCreateOneToOneConversation(conversationId);\r\n                    createPromise.then((conv) => {\r\n                        data.conversation = conv;\r\n                        data.conversation.addMessage(data);\r\n                        /*if (data.conversation.messages.length === 0 || !data.conversation.messages.find((elmt) => { if (elmt.id === data.id) { return elmt; } })) {\r\n                            data.conversation.messages.push(data);\r\n                        } // */\r\n                        this.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\r\n                        that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\r\n                    });\r\n                }\r\n                else {\r\n                    data.conversation = conversation;\r\n                    data.conversation.addMessage(data);\r\n                    /*if (data.conversation.messages.length === 0 || !data.conversation.messages.find((elmt) => { if (elmt.id === data.id) { return elmt; } })) {\r\n                        data.conversation.messages.push(data);\r\n                    } // */\r\n                    this.eventEmitter.emit(\"evt_internal_onmessagereceived\", data);\r\n                    that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(_onMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(_onMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onRoomAdminMessageReceived = (msg, stanza) => {\r\n        };\r\n        this.onFileMessageReceived = (msg, stanza) => {\r\n        };\r\n        this.onWebRTCMessageReceived = (msg, stanza) => {\r\n            // No treatment, dedicated to Call Log later\r\n        };\r\n        this.onManagementMessageReceived = (msg, stanza) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onManagementMessageReceived) _entering_ : \", msg, stanza);\r\n                let children = stanza.children;\r\n                children.forEach(function (node) {\r\n                    switch (node.getName()) {\r\n                        case \"room\":\r\n                            that.onRoomManagementMessageReceived(node);\r\n                            break;\r\n                        case \"usersettings\":\r\n                            that.onUserSettingsManagementMessageReceived(node);\r\n                            break;\r\n                        case \"userinvite\":\r\n                            that.onUserInviteManagementMessageReceived(node);\r\n                            break;\r\n                        case \"group\":\r\n                            that.onGroupManagementMessageReceived(node);\r\n                            break;\r\n                        case \"conversation\":\r\n                            that.onConversationManagementMessageReceived(node);\r\n                            break;\r\n                        case \"mute\":\r\n                            that.onMuteManagementMessageReceived(node);\r\n                            break;\r\n                        case \"unmute\":\r\n                            that.onUnmuteManagementMessageReceived(node);\r\n                            break;\r\n                        case \"file\":\r\n                            that.onFileManagementMessageReceived(node);\r\n                            break;\r\n                        case \"thumbnail\":\r\n                            that.onThumbnailManagementMessageReceived(node);\r\n                            break;\r\n                        case \"channel-subscription\":\r\n                        case \"channel\":\r\n                            //treated in channelEventHandler::onFavoriteManagementMessageReceived(node);\r\n                            break;\r\n                        case \"favorite\":\r\n                            // treated in favoriteEventHandler\r\n                            break;\r\n                        default:\r\n                            that.logger.log(\"error\", LOG_ID + \"(onManagementMessageReceived) unmanaged management message node \" + node.getName());\r\n                            break;\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onRoomManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onRoomManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    // Affiliation changed (my own or for a member)\r\n                    if (node.attrs.status) {\r\n                        if (node.attrs.userjid === XMPPUtils_1.XMPPUTils.getXMPPUtils().getBareJIDFromFullJID(that.fullJid)) {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble management received for own.\");\r\n                            that.eventEmitter.emit(\"evt_internal_ownaffiliationchanged\", {\r\n                                \"bubbleId\": node.attrs.roomid,\r\n                                \"bubbleJid\": node.attrs.roomjid,\r\n                                \"userJid\": node.attrs.userjid,\r\n                                \"status\": node.attrs.status,\r\n                            });\r\n                        }\r\n                        else {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble affiliation received\");\r\n                            that.eventEmitter.emit(\"evt_internal_affiliationchanged\", {\r\n                                \"bubbleId\": node.attrs.roomid,\r\n                                \"bubbleJid\": node.attrs.roomjid,\r\n                                \"userJid\": node.attrs.userjid,\r\n                                \"status\": node.attrs.status,\r\n                            });\r\n                        }\r\n                    }\r\n                    // Custom data changed\r\n                    else if (node.attrs.customData) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble custom-data changed\");\r\n                        that.eventEmitter.emit(\"evt_internal_customdatachanged\", {\r\n                            \"bubbleId\": node.attrs.roomid,\r\n                            \"bubbleJid\": node.attrs.roomjid,\r\n                            \"customData\": node.attrs.customData\r\n                        });\r\n                    }\r\n                    // Topic changed\r\n                    if (node.attrs.topic) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble topic changed\");\r\n                        that.eventEmitter.emit(\"evt_internal_topicchanged\", {\r\n                            \"bubbleId\": node.attrs.roomid,\r\n                            \"bubbleJid\": node.attrs.roomjid,\r\n                            \"topic\": node.attrs.topic\r\n                        });\r\n                    } // Topic changed\r\n                    if (node.attrs.privilege) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble privilege changed\");\r\n                        that.eventEmitter.emit(\"evt_internal_privilegechanged\", {\r\n                            \"bubbleId\": node.attrs.roomid,\r\n                            \"bubbleJid\": node.attrs.roomjid,\r\n                            \"userjid\": node.attrs.userjid,\r\n                            \"privilege\": node.attrs.privilege\r\n                        });\r\n                    }\r\n                    // Name changed\r\n                    if (node.attrs.name) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble name changed\");\r\n                        that.eventEmitter.emit(\"evt_internal_namechanged\", {\r\n                            \"bubbleId\": node.attrs.roomid,\r\n                            \"bubbleJid\": node.attrs.roomjid,\r\n                            \"name\": node.attrs.name\r\n                        });\r\n                    }\r\n                    let lastAvatarUpdateDate = node.attrs.lastAvatarUpdateDate;\r\n                    let avatarElem = node.find(\"avatar\");\r\n                    let avatarType = null;\r\n                    if (avatarElem.length > 0) {\r\n                        if (avatarElem.attr(\"action\") === \"delete\") {\r\n                            avatarType = \"delete\";\r\n                        }\r\n                        else {\r\n                            avatarType = \"update\";\r\n                        }\r\n                    }\r\n                    if (lastAvatarUpdateDate || avatarType) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onRoomManagementMessageReceived) bubble avatar changed\");\r\n                        that.eventEmitter.emit(\"evt_internal_bubbleavatarchanged\", { \"bubbleId\": node.attrs.roomid });\r\n                        /*service.getServerRoom(room.dbId)\r\n                            .then(function(roomToUpdate) {\r\n                                roomToUpdate.updateAvatarInfo();\r\n                                $rootScope.$broadcast(service.ROOM_AVATAR_UPDATE_EVENT, room);\r\n                            }); // */\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onRoomManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onRoomManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onUserSettingsManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"debug\", LOG_ID + \"(onUserSettingsManagementMessageReceived) _entering_\");\r\n                that.logger.log(\"internal\", LOG_ID + \"(onUserSettingsManagementMessageReceived) _entering_\", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    switch (node.attrs.action) {\r\n                        case \"update\":\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onUserSettingsManagementMessageReceived) usersettings updated\");\r\n                            that.eventEmitter.emit(\"evt_internal_usersettingschanged\");\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onUserSettingsManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onUserSettingsManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onUserInviteManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) _entering_\");\r\n                that.logger.log(\"internal\", LOG_ID + \"(onUserInviteManagementMessageReceived) _entering_\", node);\r\n                /*\r\n                // Know the treatment is done in invitationEventHandler\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) xmlns configuration, treat action : \");\r\n                    switch (node.attrs.action) {\r\n                        case \"create\":\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite received\");\r\n                                that.eventEmitter.emit(\"evt_internal_userinvitemngtreceived\", {invitationId: node.attrs.id});\r\n                            break;\r\n                        case \"update\":\r\n                            if (node.attrs.type === \"sent\" && node.attrs.status === \"canceled\") {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite canceled\");\r\n                                that.eventEmitter.emit(\"evt_internal_userinvitecanceled\", {invitationId: node.attrs.id});\r\n                            } else if (node.attrs.type === \"sent\" && node.attrs.status === \"accepted\") {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) user invite accepted\");\r\n                                that.eventEmitter.emit(\"evt_internal_userinviteaccepted\", {invitationId: node.attrs.id});\r\n                            }\r\n                            break;\r\n                        default:\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) action not reconized, so default switch used to do nothing.\");\r\n                            break;\r\n                    }\r\n                } else {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onUserInviteManagementMessageReceived) not xmlns configuration, ignore it : \", node.attrs.xmlns);\r\n                }\r\n                // */\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onUserInviteManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onUserInviteManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onGroupManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onGroupManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    let action = node.attrs.action;\r\n                    let scope = node.attrs.scope;\r\n                    if (action === \"create\" && scope === \"group\") {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group created\");\r\n                        that.eventEmitter.emit(\"evt_internal_hdle_groupcreated\", { \"groupId\": node.attrs.id });\r\n                    }\r\n                    else if (action === \"create\" && scope === \"user\" && node.attrs.userId) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) user added in group\");\r\n                        that.eventEmitter.emit(\"evt_internal_hdle_useraddedingroup\", {\r\n                            \"groupId\": node.attrs.id,\r\n                            \"userId\": node.attrs.userId\r\n                        });\r\n                    }\r\n                    else if (action === \"delete\" && scope === \"group\") {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group deleted\");\r\n                        that.eventEmitter.emit(\"evt_internal_hdle_groupdeleted\", { \"groupId\": node.attrs.id });\r\n                    }\r\n                    else if (action === \"delete\" && scope === \"user\" && node.attrs.userId) {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) user removed from group\");\r\n                        that.eventEmitter.emit(\"evt_internal_hdle_userremovedfromgroup\", {\r\n                            \"groupId\": node.attrs.id,\r\n                            \"userId\": node.attrs.userId\r\n                        });\r\n                    }\r\n                    else if (action === \"update\" && scope === \"group\") {\r\n                        if (node.attrs.name || node.attrs.comment || node.attrs.isFavorite) {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onGroupManagementMessageReceived) group updated\");\r\n                            that.eventEmitter.emit(\"evt_internal_hdle_groupupdated\", { \"groupId\": node.attrs.id });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onGroupManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onGroupManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onConversationManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onConversationManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    let conversationId = node.attrs.id;\r\n                    let conversation = this.conversationService.getConversationById(conversationId);\r\n                    let action = node.attrs.action;\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) action : \" + action + \"\");\r\n                    that.logger.log(\"internal\", LOG_ID + \"(onConversationManagementMessageReceived) action : \" + action + \", for conversation : \", conversation);\r\n                    if (conversation) {\r\n                        switch (action) {\r\n                            case \"create\":\r\n                                //                                conversation.dbId = node.getAttribute(\"id\");\r\n                                conversation.dbId = conversationId;\r\n                                conversation.lastModification = new Date(node.find(\"lastMessageDate\").text());\r\n                                conversation.missedCounter = parseInt(node.find(\"unreadMessageNumber\").text(), 10) || 0;\r\n                                conversation.isFavorite = (node.find(\"isFavorite\").text() === \"true\");\r\n                                //this.conversationService.orderConversations();\r\n                                //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\");\r\n                                // Send conversations update event\r\n                                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                                break;\r\n                            case \"delete\":\r\n                                this.conversationService.removeConversation(conversation);\r\n                                break;\r\n                            case \"update\":\r\n                                conversation.isFavorite = (node.find(\"isFavorite\").text() === \"true\");\r\n                                //this.conversationService.orderConversations();\r\n                                // Send conversations update event\r\n                                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                                //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\");\r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) conversation not know in cache action : \", action);\r\n                        if (action === \"create\") {\r\n                            let convId = node.find(\"peer\").text();\r\n                            let peerId = node.find(\"peerId\").text();\r\n                            let convDbId = node.attrs.id;\r\n                            let lastModification = new Date(node.find(\"lastMessageDate\").text());\r\n                            let lastMessageText = node.find(\"lastMessageText\").text();\r\n                            let lastMessageSender = node.find(\"lastMessageSender\").text();\r\n                            let missedIMCounter = parseInt(node.find(\"unreadMessageNumber\").text(), 10) || 0;\r\n                            let muted = node.find(\"mute\").text() === \"true\";\r\n                            let isFavorite = node.find(\"isFavorite\").text() === \"true\";\r\n                            let type = node.find(\"type\").text();\r\n                            let conversationGetter = null;\r\n                            if (type === \"user\") {\r\n                                conversationGetter = this.conversationService.getOrCreateOneToOneConversation(convId);\r\n                            }\r\n                            else {\r\n                                let bubbleId = convId;\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) create, find conversation, bubbleId : \" + bubbleId + \", convDbId : \", convDbId, \", peerId : \", peerId);\r\n                                // conversationGetter = this.conversationService.getConversationByBubbleId(convId);\r\n                                conversationGetter = this.conversationService.getBubbleConversation(bubbleId, peerId, lastModification, lastMessageText, missedIMCounter, null, muted, new Date(), lastMessageSender);\r\n                            }\r\n                            if (!conversationGetter) {\r\n                                return;\r\n                            }\r\n                            conversationGetter.then(function (conv) {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) update conversation (\" + conv.id + \")\");\r\n                                conv.dbId = convDbId;\r\n                                conv.lastModification = lastModification ? new Date(lastModification) : undefined;\r\n                                conv.lastMessageText = lastMessageText;\r\n                                conv.lastMessageSender = lastMessageSender;\r\n                                conv.muted = muted;\r\n                                conv.isFavorite = isFavorite;\r\n                                conv.preload = true;\r\n                                conv.missedCounter = missedIMCounter;\r\n                                // Send conversations update event\r\n                                that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\r\n                                //$rootScope.$broadcast(\"ON_CONVERSATIONS_UPDATED_EVENT\", conv);\r\n                            });\r\n                        }\r\n                        if (action === \"delete\") {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) conversation not know in cache deleted : \", conversationId);\r\n                            let conversationUnknown = new Conversation_1.Conversation(conversationId);\r\n                            if (conversationUnknown) {\r\n                                that.conversationService.removeConversation(conversationUnknown);\r\n                            }\r\n                        }\r\n                    }\r\n                    // Handle mute/unmute room\r\n                    if (node.find(\"mute\") || node.find(\"unmute\")) {\r\n                        let muteElem = node.find(\"mute\");\r\n                        let mute = false;\r\n                        if (muteElem.length) {\r\n                            if (muteElem.text().length) {\r\n                                mute = (muteElem.text() === \"true\");\r\n                            }\r\n                            else {\r\n                                mute = true;\r\n                            }\r\n                        }\r\n                        let conversationDbId = node.find(\"mute\").attrs.conversation || node.find(\"unmute\").attrs.conversation;\r\n                        let conversation = this.conversationService.getConversationByDbId(conversationDbId);\r\n                        if (conversation) {\r\n                            that.logger.log(\"debug\", LOG_ID + \"(onConversationManagementMessageReceived) : mute is changed to \" + mute);\r\n                            conversation.muted = mute;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onConversationManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onConversationManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onMuteManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onMuteManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onMuteManagementMessageReceived) conversation muted\");\r\n                    let conversationId = node.attrs.conversation;\r\n                    let conversation = that.conversationService.getConversationById(conversationId);\r\n                    if (!conversation) {\r\n                        let cs = this.conversationService;\r\n                        let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined) : cs.getOrCreateOneToOneConversation(conversationId);\r\n                        createPromise.then((conv) => {\r\n                            that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\r\n                        });\r\n                    }\r\n                    else {\r\n                        that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onMuteManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onMuteManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onUnmuteManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onUnmuteManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(onUnmuteManagementMessageReceived) conversation unmuted\");\r\n                    let conversationId = node.attrs.conversation;\r\n                    let conversation = that.conversationService.getConversationById(conversationId);\r\n                    if (!conversation) {\r\n                        let cs = this.conversationService;\r\n                        let createPromise = conversationId.startsWith(\"room_\") ? cs.getBubbleConversation(conversationId, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined) : cs.getOrCreateOneToOneConversation(conversationId);\r\n                        createPromise.then((conv) => {\r\n                            that.eventEmitter.emit(\"evt_internal_conversationupdated\", conv);\r\n                        });\r\n                    }\r\n                    else {\r\n                        that.eventEmitter.emit(\"evt_internal_conversationupdated\", conversation);\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onUnmuteManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onUnmuteManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onFileManagementMessageReceived = (node) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onFileManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    let updateConsumption = false;\r\n                    switch (node.attrs.action) {\r\n                        case \"create\":\r\n                            {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file created\");\r\n                                let fileNode = node.children[0];\r\n                                let fileid = fileNode.children[0];\r\n                                //.getText() ||  \"\";\r\n                                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\r\n                                if (!fileDescriptor) {\r\n                                    updateConsumption = true;\r\n                                }\r\n                                yield that.fileStorageService.retrieveAndStoreOneFileDescriptor(fileid, true).then(function (fileDesc) {\r\n                                    that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) fileDescriptor retrieved\");\r\n                                    if (!fileDesc.previewBlob) {\r\n                                        that.fileServerService.getBlobThumbnailFromFileDescriptor(fileDesc)\r\n                                            .then(function (blob) {\r\n                                            fileDesc.previewBlob = blob;\r\n                                        });\r\n                                    }\r\n                                });\r\n                                that.eventEmitter.emit(\"evt_internal_filecreated\", { 'fileid': fileid });\r\n                            }\r\n                            break;\r\n                        case \"update\":\r\n                            {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file updated\");\r\n                                let fileNode = node.children[0];\r\n                                let fileid = fileNode.children[0];\r\n                                //.getText() ||  \"\";\r\n                                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\r\n                                if (!fileDescriptor) {\r\n                                    updateConsumption = true;\r\n                                }\r\n                                yield that.fileStorageService.retrieveAndStoreOneFileDescriptor(fileid, true).then(function (fileDesc) {\r\n                                    that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) fileDescriptor retrieved\");\r\n                                    if (!fileDesc.previewBlob) {\r\n                                        that.fileServerService.getBlobThumbnailFromFileDescriptor(fileDesc)\r\n                                            .then(function (blob) {\r\n                                            fileDesc.previewBlob = blob;\r\n                                        });\r\n                                    }\r\n                                });\r\n                                that.eventEmitter.emit(\"evt_internal_fileupdated\", { 'fileid': fileid });\r\n                            }\r\n                            break;\r\n                        case \"delete\":\r\n                            {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onFileManagementMessageReceived) file deleted\");\r\n                                let fileNode = node.children[0];\r\n                                let fileid = fileNode.children[0];\r\n                                //.getText() ||  \"\";\r\n                                let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileid);\r\n                                if (fileDescriptor) {\r\n                                    //check if we've deleted one of our own files\r\n                                    if (fileDescriptor.ownerId === that.userId && fileDescriptor.state !== \"deleted\") {\r\n                                        updateConsumption = true;\r\n                                    }\r\n                                    this.fileStorageService.deleteFileDescriptorFromCache(fileid, true);\r\n                                }\r\n                                that.eventEmitter.emit(\"evt_internal_filedeleted\", { 'fileid': fileid });\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    if (updateConsumption) {\r\n                        this.fileStorageService.retrieveUserConsumption();\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onFileManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onFileManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        });\r\n        this.onThumbnailManagementMessageReceived = (node) => {\r\n            try {\r\n                that.logger.log(\"internal\", LOG_ID + \"(onThumbnailManagementMessageReceived) _entering_ : \", node);\r\n                if (node.attrs.xmlns === \"jabber:iq:configuration\") {\r\n                    switch (node.attrs.action) {\r\n                        case \"create\":\r\n                            {\r\n                                that.logger.log(\"debug\", LOG_ID + \"(onThumbnailManagementMessageReceived) file created\");\r\n                                let url = node.getChild('url') ? node.getChild('url').children[0] : '';\r\n                                //let fileId = fileNode.children[0];\r\n                                //.getText() ||  \"\";\r\n                                let mime = node.getChild('mime') ? node.getChild('mime').children[0] : '';\r\n                                let filename = node.getChild('filename') ? node.getChild('filename').children[0] : '';\r\n                                let size = node.getChild('size') ? node.getChild('size').children[0] : '';\r\n                                let md5sum = node.getChild('md5sum') ? node.getChild('md5sum').children[0] : '';\r\n                                let fileid = node.getChild('fileid') ? node.getChild('fileid').children[0] : '';\r\n                                that.eventEmitter.emit(\"evt_internal_thumbnailcreated\", {\r\n                                    'url': url,\r\n                                    'mime': mime,\r\n                                    'filename': filename,\r\n                                    'size': size,\r\n                                    'md5sum': md5sum,\r\n                                    'fileid': fileid\r\n                                });\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onThumbnailManagementMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onThumbnailManagementMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.onReceiptMessageReceived = (msg, stanza) => {\r\n        };\r\n        this.onErrorMessageReceived = (msg, stanza) => {\r\n            try {\r\n                if (stanza.getChild('no-store') != undefined) {\r\n                    that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) The 'to' of the message can not received the message\");\r\n                    let err = {\r\n                        \"id\": stanza.attrs.id,\r\n                        \"body\": stanza.getChild('body').text(),\r\n                        \"subject\": stanza.getChild('subject').text()\r\n                    };\r\n                    that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) no-store message setted...\");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) failed to send : \", err);\r\n                    that.eventEmitter.emit(\"evt_internal_onsendmessagefailed\", err);\r\n                }\r\n                else {\r\n                    that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) something goes wrong...\");\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) something goes wrong... : \", msg, util.inspect(stanza));\r\n                    that.eventEmitter.emit(\"evt_internal_xmpperror\", msg);\r\n                }\r\n            }\r\n            catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(onErrorMessageReceived) CATCH Error !!! \");\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(onErrorMessageReceived) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n        this.findAttrs = () => {\r\n        };\r\n        /*\r\n        this.findChildren = (element) => {\r\n            try {\r\n                that.logger.log(\"debug\", LOG_ID + \"(findChildren) _entering_\");\r\n                that.logger.log(\"internal\", LOG_ID + \"(findChildren) _entering_\", element);\r\n                that.logger.log(\"error\", LOG_ID + \"(findChildren) findChildren element : \", element, \" name : \", element.getName());\r\n                let json = {};\r\n                //let result = null;\r\n                let children = element.children;\r\n                if (children.length > 0) {\r\n                    json[element.getName()] = {};\r\n                    let childrenJson = json[element.getName()];\r\n                    children.forEach((elemt) => {\r\n                        // @ts-ignore\r\n                        if (typeof elemt.children === Array) {\r\n                            that.logger.log(\"error\", LOG_ID + \"(findChildren)  children.forEach Array : \", element, \", elemt : \", elemt);\r\n                            childrenJson[elemt.getName()] = elemt.children[0];\r\n                        }\r\n                        that.logger.log(\"error\", LOG_ID + \"(findChildren)  children.forEach element : \", element, \", elemt : \", elemt);\r\n                        childrenJson[elemt.getName()] = this.findChildren(elemt);\r\n                    });\r\n                    return json;\r\n                } else {\r\n                    that.logger.log(\"error\", LOG_ID + \"(findChildren)  No children element : \", element);\r\n                    return element.getText();\r\n                }\r\n                //return result;\r\n            } catch (err) {\r\n                that.logger.log(\"error\", LOG_ID + \"(findChildren) CATCH Error !!! : \", err);\r\n            }\r\n        };\r\n\r\n         */\r\n        this.onCloseMessageReceived = (msg, stanza) => {\r\n        };\r\n    }\r\n};\r\nConversationEventHandler = __decorate([\r\n    Utils_1.logEntryExit(LOG_ID)\r\n], ConversationEventHandler);\r\nexports.ConversationEventHandler = ConversationEventHandler;\r\nmodule.exports.ConversationEventHandler = ConversationEventHandler;\r\n//# sourceMappingURL=conversationEventHandler.js.map"]},"metadata":{},"sourceType":"script"}