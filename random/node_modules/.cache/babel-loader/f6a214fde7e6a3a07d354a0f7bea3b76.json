{"ast":null,"code":"'use strict';\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst config_1 = require(\"../../config/config\"); //import Element from \"ltx\";\n\n\nconst XMPPService_1 = require(\"../../connection/XMPPService\");\n/*\r\n\r\nconst Client = require('./lib/Client')\r\nconst {xml, jid} = require('@xmpp/client-core')\r\n\r\nmodule.exports.Client = Client\r\nmodule.exports.xml = xml\r\nmodule.exports.jid = jid\r\n\r\n */\n//let client = require(\"@xmpp/client\").client;\n\n\nlet client = require(\"./XmppClientWrapper\").client;\n\nlet XmppQueue = require(\"./XmppQueue\");\n\nlet utils = require(\"../Utils\");\n\nconst _sasl = require('@xmpp/sasl');\n\nconst _middleware = require('@xmpp/middleware');\n\nconst _streamFeatures = require('@xmpp/stream-features');\n\nconst plain = require('@xmpp/sasl-plain');\n\nconst xml = require(\"@xmpp/xml\");\n\nconst Element = require('ltx').Element;\n\nlet LOG_ID = 'XMPPCLIENT';\n\nclass XmppClient {\n  constructor(...args) {\n    this.socketClosed = false; //super(...args);\n\n    const {\n      username,\n      password\n    } = args[0];\n    let that = this;\n    this.options = [...args];\n    this.restartConnectEnabled = true;\n    this.client = client(...args);\n    this.nbMessagesSentThisHour = 0;\n    this.timeBetweenReset = 1000 * 60 * 60; // */\n\n    this.iqGetEventWaiting = {};\n\n    this.onIqErrorReceived = (msg, stanza) => {\n      //let children = stanza.children;\n      let iqId = stanza.attrs.id;\n      let errorMsg = stanza.getChild(\"error\") ? stanza.getChild(\"error\").getChild(\"text\").getText() || \"\" : \"\";\n      that.logger.log(\"warn\", LOG_ID + \"(XmmpClient) onIqErrorReceived received iq result - 'stanza id '\", iqId, msg, errorMsg); // reject and delete the waiting iq.\n\n      if (typeof that.iqGetEventWaiting[iqId] === \"function\") {\n        that.iqGetEventWaiting[iqId](stanza);\n      } else {\n        delete that.iqGetEventWaiting[iqId];\n      }\n    };\n\n    this.onIqResultReceived = (msg, stanza) => {\n      //let children = stanza.children;\n      let iqId = stanza.attrs.id;\n      that.logger.log(\"warn\", LOG_ID + \"(XmmpClient) onIqResultReceived received iq result - 'stanza id '\", iqId);\n\n      if (that.iqGetEventWaiting[iqId]) {\n        // The result iq correspond to a stored promise from our request, so resolve it to allow sendIq to get back a result.\n        if (typeof that.iqGetEventWaiting[iqId] === \"function\") {\n          that.iqGetEventWaiting[iqId](stanza);\n        } else {\n          delete that.iqGetEventWaiting[iqId];\n        }\n      } else {}\n      /*            children.forEach((node) => {\r\n                      switch (node.getName()) {\r\n                          case \"query\":\r\n                              that._onIqGetQueryReceived(stanza, node);\r\n                              break;\r\n                          case \"pbxagentstatus\":\r\n                              // The treatment is in telephonyEventHandler\r\n                              //that._onIqGetPbxAgentStatusReceived(stanza, node);\r\n                              break;\r\n                          case \"default\":\r\n                              that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) not managed - 'stanza'\", node.getName());\r\n                              break;\r\n                          default:\r\n                              that\r\n                                  .logger\r\n                                  .log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) child not managed for iq - 'stanza'\", node.getName());\r\n                      }\r\n                  });\r\n                  if (stanza.attrs.id === \"enable_xmpp_carbon\") {\r\n                      that.eventEmitter.emit(\"rainbow_oncarbonactivated\");\r\n                  } */\n\n    };\n  }\n\n  init(_logger, _timeBetweenXmppRequests, _storeMessages, _rateLimitPerHour, _messagesDataStore) {\n    let that = this;\n    that.logger = _logger;\n    that.xmppQueue = XmppQueue.getXmppQueue(_logger);\n    that.timeBetweenXmppRequests = _timeBetweenXmppRequests ? _timeBetweenXmppRequests : 20;\n    that.storeMessages = _storeMessages;\n    that.rateLimitPerHour = _rateLimitPerHour;\n    that.messagesDataStore = _messagesDataStore;\n    that.lastTimeReset = new Date();\n\n    if (that.messagesDataStore) {\n      switch (that.messagesDataStore) {\n        case config_1.DataStoreType.NoStore:\n          {\n            that.storeMessages = false;\n          }\n          break;\n\n        case config_1.DataStoreType.NoPermanentStore:\n          {\n            that.storeMessages = false;\n          }\n          break;\n\n        case config_1.DataStoreType.StoreTwinSide:\n          {\n            that.storeMessages = true;\n          }\n          break;\n\n        case config_1.DataStoreType.UsestoreMessagesField:\n          {\n            that.messagesDataStore = config_1.DataStoreType.NoStore;\n          }\n          break;\n\n        default:\n          {\n            that.messagesDataStore = config_1.DataStoreType.NoPermanentStore;\n          }\n          break;\n      }\n    } else {\n      that.messagesDataStore = config_1.DataStoreType.NoPermanentStore;\n    }\n\n    that.on('open', () => {\n      that.logger.log(\"debug\", LOG_ID + \"(event) open\");\n      that.socketClosed = false;\n    });\n    /*this.client.websocket.on('message', () => {\r\n        that.socketClosed = true;\r\n    }); // */\n\n    that.on('error', () => {\n      that.logger.log(\"debug\", LOG_ID + \"(event) error\");\n      that.socketClosed = true;\n    });\n    that.on('close', () => {\n      that.logger.log(\"debug\", LOG_ID + \"(event) close\");\n      that.socketClosed = true;\n    });\n    setInterval(that.resetnbMessagesSentThisHour.bind(this), that.timeBetweenReset);\n  }\n\n  resetnbMessagesSentThisHour() {\n    let that = this;\n    that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) _entering_\");\n    that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) before reset, that.nbMessagesSentThisHour : \", that.nbMessagesSentThisHour);\n    that.nbMessagesSentThisHour = 0;\n    that.lastTimeReset = new Date();\n    that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) _exiting_\");\n  }\n\n  send(...args) {\n    let that = this;\n    that.logger.log(\"debug\", LOG_ID + \"(send) _entering_\");\n    return new Promise(resolve => {\n      let prom = this.xmppQueue.addPromise(new Promise((resolve2, reject2) => {\n        /*\r\n        if (args && args[0]) {\r\n            that.logger.log(\"internal\", LOG_ID + \"(send) stanza to send \", that.logger.colors.gray(args[0].toString()));\r\n        } else {\r\n            that.logger.log(\"error\", LOG_ID + \"(send) stanza to send is empty\");\r\n        } // */\n        //that.logger.log(\"debug\", LOG_ID + \"(send) this.client.websocket : \", this.client.Socket);\n        if (that.socketClosed) {\n          that.logger.log(\"debug\", LOG_ID + \"(send) Error the socket is close, so do not send data on it. this.client.websocket : \", this.client.Socket);\n          return Promise.reject(\"Error the socket is close, so do not send data on it.\");\n        }\n\n        let stanza = args[0];\n\n        if (that.storeMessages == false && stanza && typeof stanza === \"object\" && stanza.name == \"message\") {\n          // if (that.storeMessages == false && stanza && typeof stanza === \"object\" && stanza.name == \"message\") {\n          // that.logger.log(\"info\", LOG_ID + \"(send) will add <no-store /> to stanza.\");\n          // that.logger.log(\"internal\", LOG_ID + \"(send) will add <no-store /> to stanza : \", stanza);\n          //that.logger.log(\"debug\", LOG_ID + \"(send) original stanza : \", stanza);\n          // <no-copy xmlns=\"urn:xmpp:hints\"/>\n          //   <no-store xmlns=\"urn:xmpp:hints\"/>\n\n          /*  stanza.append(xml(\"no-copy\", {\r\n                \"xmlns\": NameSpacesLabels.HintsNameSpace\r\n            }));\r\n            // */\n          //let nostoreTag=\"no-store\";\n          let nostoreTag = that.messagesDataStore;\n          stanza.append(xml(nostoreTag, {\n            \"xmlns\": XMPPService_1.NameSpacesLabels.HintsNameSpace\n          })); // */\n          //that.logger.log(\"internal\", LOG_ID + \"(send) no-store stanza : \", stanza);\n        } // test the rate-limit\n\n\n        if (this.nbMessagesSentThisHour > that.rateLimitPerHour) {\n          let timeWhenRateLimitPerHourHappens = new Date().getTime();\n          let timeToWaitBeforeNextMessageAvabilityMs = that.timeBetweenReset - (timeWhenRateLimitPerHourHappens - that.lastTimeReset.getTime());\n          let error = {\n            \"errorCode\": -1,\n            \"timeWhenRateLimitPerHourHappens\": timeWhenRateLimitPerHourHappens,\n            \"nbMessagesSentThisHour\": this.nbMessagesSentThisHour,\n            \"rateLimitPerHour\": that.rateLimitPerHour,\n            \"timeToWaitBeforeNextMessageAvabilityMs\": timeToWaitBeforeNextMessageAvabilityMs,\n            \"label\": \"error number of sent messages is over the rate limit.\",\n            \"sendArgs\": args\n          };\n          that.logger.log(\"internalerror\", LOG_ID + \"(send) error number of sent messages is over the rate limit : \", error);\n          return reject2(error);\n        }\n\n        return this.client.send(...args).then(() => {\n          that.nbMessagesSentThisHour++;\n          resolve2();\n        }).catch(err => __awaiter(this, void 0, void 0, function* () {\n          that.logger.log(\"debug\", LOG_ID + \"(send) _catch error_ at super.send\", err); //that.logger.log(\"debug\", LOG_ID + \"(send) restart the xmpp client\");\n\n          return reject2(err);\n          /*\r\n          this.client.restart().finally(() => {\r\n              reject2(err);\r\n          });\r\n          // */\n        }));\n      })).then(() => {\n        that.logger.log(\"debug\", LOG_ID + \"(send) sent\");\n      }).catch(errr => {\n        that.logger.log(\"error\", LOG_ID + \"(send) error in send promise : \", errr);\n        that.logger.log(\"internalerror\", LOG_ID + \"(send) error in send promise : \", errr);\n        throw errr;\n      }); // Wait a few time between requests to avoid burst with lot of it.\n\n      utils.setTimeoutPromised(that.timeBetweenXmppRequests).then(() => {\n        //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\n        resolve(prom);\n      });\n      /*\r\n      // Wait a few time between requests to avoid burst with lot of it.\r\n      setTimeout(() => {\r\n          //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n          resolve(prom);\r\n      }, that.timeBetweenXmppRequests);\r\n      // */\n    }).then(promiseToreturn => {\n      that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise\");\n      return promiseToreturn;\n    }).catch(err => __awaiter(this, void 0, void 0, function* () {\n      that.logger.log(\"debug\", LOG_ID + \"(send) catch an error during sending! \", err); // if the error is the exceed of maximum message by a time laps then do not reconnecte\n\n      if (err && err.errorCode === -1) {\n        //return Promise.resolve();\n        throw err; //return ;\n      }\n\n      that.logger.log(\"debug\", LOG_ID + \"(send) restart the xmpp client\");\n      yield that.restartConnect().then(res => {\n        that.logger.log(\"debug\", LOG_ID + \"(send) restartConnect result : \", res);\n      }).catch(errr => {\n        that.logger.log(\"debug\", LOG_ID + \"(send) restartConnect catch : \", errr);\n      });\n      /*\r\n      .then(() => {\r\n          that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise with a throw error : \", err);\r\n          throw  err;\r\n      });\r\n      // */\n\n      /*\r\n      this.client.restart().finally(() => {\r\n          that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise with a throw error\");\r\n          throw  err;\r\n      }); */\n    }));\n  }\n\n  sendIq(...args) {\n    let that = this;\n    that.logger.log(\"debug\", LOG_ID + \"(send) _entering_\");\n    return new Promise(resolve => {\n      if (args.length > 0) {\n        let prom = this.xmppQueue.addPromise(this.client.send(...args).catch(err => {\n          that.logger.log(\"debug\", LOG_ID + \"(send) _catch error_ at super.send\", err);\n        })).then(() => {\n          that.logger.log(\"debug\", LOG_ID + \"(send) sent\");\n        }); // callback to be called when the IQ Get result event is received from server.\n\n        function cb(result) {\n          // Wait a few time between requests to avoid burst with lot of it.\n          setTimeout(() => {\n            //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\n            resolve(prom.then(() => {\n              return result;\n            }));\n          }, that.timeBetweenXmppRequests);\n        }\n\n        let idId = args[0].attrs.id; // Store the promise to be resolved\n\n        this.iqGetEventWaiting[idId] = cb;\n        /* // Wait a few time between requests to avoid burst with lot of it.\r\n        setTimeout(()=> {\r\n            //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n            resolve(prom);\r\n        }, that.timeBetweenXmppRequests); // */\n      } else {\n        resolve(Promise.resolve());\n      }\n    }).then(promiseToreturn => {\n      that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise\");\n      return promiseToreturn;\n    });\n  }\n  /*handle(evt, cb) {\r\n      this.client.entity.handle(evt,  cb);\r\n  } // */\n\n\n  on(evt, cb) {\n    this.client.entity.on(evt, cb);\n  }\n\n  get sasl() {\n    return this.client.sasl;\n  }\n\n  setgetMechanism(cb) {//this.client.sasl.findMechanism = cb;\n    //this.client.mechanisms = [\"PLAIN\"];\n  }\n\n  get reconnect() {\n    return this.client.reconnect;\n  }\n  /**\r\n   * @description\r\n   *  Do not use this method to reconnect. Use the @xmpp/reconnect pluging else (with the method XmppClient::reconnect).\r\n   *\r\n   * @returns {Promise<any>}\r\n   */\n\n\n  restartConnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let that = this;\n      that.logger.log(\"debug\", LOG_ID + \"(restartConnect) _entering_\");\n\n      if (this.restartConnectEnabled) {\n        //let result = await that.client.disconnect(5000);\n        //that.logger.log(\"debug\", LOG_ID + \"(restartConnect) disconnect result : \", result);\n        //return that.client.open(that.options);\n        yield that.client._reset();\n        yield that.client.start();\n      } else {\n        return Promise.resolve(\"restartReconnect is disabled\");\n      }\n    });\n  }\n\n  start(...args) {\n    this.restartConnectEnabled = true;\n    return this.client.start(...args);\n  }\n\n  stop(...args) {\n    this.restartConnectEnabled = false;\n    return this.client.stop(...args);\n  }\n\n}\n\nfunction getXmppClient(...args) {\n  let xmppClient = new XmppClient(...args);\n  Object.assign(xmppClient, client());\n} // *************************************\n// Increase Element Behaviour\n// *************************************\n// Find elements of child by name\n// If none is found then an empty Element is return (to allow call of methods like text...)\n// If only one is found then return it, but with a length value to 1\n// If severals are found then return an Array with them\n\n\nElement.prototype.find = function (name) {\n  let result = new Element();\n  result.length = 0;\n\n  if (this instanceof Element && (this.getName ? this.getName() : this.name) == name) {\n    result = this;\n    result.length = 1;\n    return result;\n  }\n\n  let children = this.getChildrenByFilter(element => {\n    let isInstanceOfElement = element instanceof Element;\n    let elmtName = element.getName ? element.getName() : element.name;\n    let isTheNameSearched = name === elmtName;\n    return isInstanceOfElement && isTheNameSearched;\n  }, true);\n\n  if (children.length === 1) {\n    result = children[0];\n    result.length = 1;\n  } else if (children.length > 1) {\n    result = children;\n  }\n\n  return result;\n}; // Shortcut to getText\n\n\nElement.prototype.text = function () {\n  return this.getText();\n}; // Shortcut to attrs\n\n\nElement.prototype.attr = function (attrName) {\n  return this.attrs[attrName];\n};\n\nmodule.exports.getXmppClient = getXmppClient;\nmodule.exports.XmppClient = XmppClient;","map":{"version":3,"sources":["../../../src/lib/common/XmppQueue/XmppClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst config_1 = require(\"../../config/config\");\r\n//import Element from \"ltx\";\r\nconst XMPPService_1 = require(\"../../connection/XMPPService\");\r\n/*\r\n\r\nconst Client = require('./lib/Client')\r\nconst {xml, jid} = require('@xmpp/client-core')\r\n\r\nmodule.exports.Client = Client\r\nmodule.exports.xml = xml\r\nmodule.exports.jid = jid\r\n\r\n */\r\n//let client = require(\"@xmpp/client\").client;\r\nlet client = require(\"./XmppClientWrapper\").client;\r\nlet XmppQueue = require(\"./XmppQueue\");\r\nlet utils = require(\"../Utils\");\r\nconst _sasl = require('@xmpp/sasl');\r\nconst _middleware = require('@xmpp/middleware');\r\nconst _streamFeatures = require('@xmpp/stream-features');\r\nconst plain = require('@xmpp/sasl-plain');\r\nconst xml = require(\"@xmpp/xml\");\r\nconst Element = require('ltx').Element;\r\nlet LOG_ID = 'XMPPCLIENT';\r\nclass XmppClient {\r\n    constructor(...args) {\r\n        this.socketClosed = false;\r\n        //super(...args);\r\n        const { username, password } = args[0];\r\n        let that = this;\r\n        this.options = [...args];\r\n        this.restartConnectEnabled = true;\r\n        this.client = client(...args);\r\n        this.nbMessagesSentThisHour = 0;\r\n        this.timeBetweenReset = 1000 * 60 * 60; // */\r\n        this.iqGetEventWaiting = {};\r\n        this.onIqErrorReceived = (msg, stanza) => {\r\n            //let children = stanza.children;\r\n            let iqId = stanza.attrs.id;\r\n            let errorMsg = stanza.getChild(\"error\") ? stanza.getChild(\"error\").getChild(\"text\").getText() || \"\" : \"\";\r\n            that.logger.log(\"warn\", LOG_ID + \"(XmmpClient) onIqErrorReceived received iq result - 'stanza id '\", iqId, msg, errorMsg);\r\n            // reject and delete the waiting iq.\r\n            if (typeof that.iqGetEventWaiting[iqId] === \"function\") {\r\n                that.iqGetEventWaiting[iqId](stanza);\r\n            }\r\n            else {\r\n                delete that.iqGetEventWaiting[iqId];\r\n            }\r\n        };\r\n        this.onIqResultReceived = (msg, stanza) => {\r\n            //let children = stanza.children;\r\n            let iqId = stanza.attrs.id;\r\n            that.logger.log(\"warn\", LOG_ID + \"(XmmpClient) onIqResultReceived received iq result - 'stanza id '\", iqId);\r\n            if (that.iqGetEventWaiting[iqId]) {\r\n                // The result iq correspond to a stored promise from our request, so resolve it to allow sendIq to get back a result.\r\n                if (typeof that.iqGetEventWaiting[iqId] === \"function\") {\r\n                    that.iqGetEventWaiting[iqId](stanza);\r\n                }\r\n                else {\r\n                    delete that.iqGetEventWaiting[iqId];\r\n                }\r\n            }\r\n            else {\r\n            }\r\n            /*            children.forEach((node) => {\r\n                            switch (node.getName()) {\r\n                                case \"query\":\r\n                                    that._onIqGetQueryReceived(stanza, node);\r\n                                    break;\r\n                                case \"pbxagentstatus\":\r\n                                    // The treatment is in telephonyEventHandler\r\n                                    //that._onIqGetPbxAgentStatusReceived(stanza, node);\r\n                                    break;\r\n                                case \"default\":\r\n                                    that.logger.log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) not managed - 'stanza'\", node.getName());\r\n                                    break;\r\n                                default:\r\n                                    that\r\n                                        .logger\r\n                                        .log(\"warn\", LOG_ID + \"(handleXMPPConnection, onIqResultReceived) child not managed for iq - 'stanza'\", node.getName());\r\n                            }\r\n                        });\r\n                        if (stanza.attrs.id === \"enable_xmpp_carbon\") {\r\n                            that.eventEmitter.emit(\"rainbow_oncarbonactivated\");\r\n                        } */\r\n        };\r\n    }\r\n    init(_logger, _timeBetweenXmppRequests, _storeMessages, _rateLimitPerHour, _messagesDataStore) {\r\n        let that = this;\r\n        that.logger = _logger;\r\n        that.xmppQueue = XmppQueue.getXmppQueue(_logger);\r\n        that.timeBetweenXmppRequests = _timeBetweenXmppRequests ? _timeBetweenXmppRequests : 20;\r\n        that.storeMessages = _storeMessages;\r\n        that.rateLimitPerHour = _rateLimitPerHour;\r\n        that.messagesDataStore = _messagesDataStore;\r\n        that.lastTimeReset = new Date();\r\n        if (that.messagesDataStore) {\r\n            switch (that.messagesDataStore) {\r\n                case config_1.DataStoreType.NoStore:\r\n                    {\r\n                        that.storeMessages = false;\r\n                    }\r\n                    break;\r\n                case config_1.DataStoreType.NoPermanentStore:\r\n                    {\r\n                        that.storeMessages = false;\r\n                    }\r\n                    break;\r\n                case config_1.DataStoreType.StoreTwinSide:\r\n                    {\r\n                        that.storeMessages = true;\r\n                    }\r\n                    break;\r\n                case config_1.DataStoreType.UsestoreMessagesField:\r\n                    {\r\n                        that.messagesDataStore = config_1.DataStoreType.NoStore;\r\n                    }\r\n                    break;\r\n                default:\r\n                    {\r\n                        that.messagesDataStore = config_1.DataStoreType.NoPermanentStore;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            that.messagesDataStore = config_1.DataStoreType.NoPermanentStore;\r\n        }\r\n        that.on('open', () => {\r\n            that.logger.log(\"debug\", LOG_ID + \"(event) open\");\r\n            that.socketClosed = false;\r\n        });\r\n        /*this.client.websocket.on('message', () => {\r\n            that.socketClosed = true;\r\n        }); // */\r\n        that.on('error', () => {\r\n            that.logger.log(\"debug\", LOG_ID + \"(event) error\");\r\n            that.socketClosed = true;\r\n        });\r\n        that.on('close', () => {\r\n            that.logger.log(\"debug\", LOG_ID + \"(event) close\");\r\n            that.socketClosed = true;\r\n        });\r\n        setInterval(that.resetnbMessagesSentThisHour.bind(this), that.timeBetweenReset);\r\n    }\r\n    resetnbMessagesSentThisHour() {\r\n        let that = this;\r\n        that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) _entering_\");\r\n        that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) before reset, that.nbMessagesSentThisHour : \", that.nbMessagesSentThisHour);\r\n        that.nbMessagesSentThisHour = 0;\r\n        that.lastTimeReset = new Date();\r\n        that.logger.log(\"debug\", LOG_ID + \"(resetnbMessagesSentThisHour) _exiting_\");\r\n    }\r\n    send(...args) {\r\n        let that = this;\r\n        that.logger.log(\"debug\", LOG_ID + \"(send) _entering_\");\r\n        return new Promise((resolve) => {\r\n            let prom = this.xmppQueue.addPromise(new Promise((resolve2, reject2) => {\r\n                /*\r\n                if (args && args[0]) {\r\n                    that.logger.log(\"internal\", LOG_ID + \"(send) stanza to send \", that.logger.colors.gray(args[0].toString()));\r\n                } else {\r\n                    that.logger.log(\"error\", LOG_ID + \"(send) stanza to send is empty\");\r\n                } // */\r\n                //that.logger.log(\"debug\", LOG_ID + \"(send) this.client.websocket : \", this.client.Socket);\r\n                if (that.socketClosed) {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(send) Error the socket is close, so do not send data on it. this.client.websocket : \", this.client.Socket);\r\n                    return Promise.reject(\"Error the socket is close, so do not send data on it.\");\r\n                }\r\n                let stanza = args[0];\r\n                if (that.storeMessages == false && stanza && typeof stanza === \"object\" && stanza.name == \"message\") {\r\n                    // if (that.storeMessages == false && stanza && typeof stanza === \"object\" && stanza.name == \"message\") {\r\n                    // that.logger.log(\"info\", LOG_ID + \"(send) will add <no-store /> to stanza.\");\r\n                    // that.logger.log(\"internal\", LOG_ID + \"(send) will add <no-store /> to stanza : \", stanza);\r\n                    //that.logger.log(\"debug\", LOG_ID + \"(send) original stanza : \", stanza);\r\n                    // <no-copy xmlns=\"urn:xmpp:hints\"/>\r\n                    //   <no-store xmlns=\"urn:xmpp:hints\"/>\r\n                    /*  stanza.append(xml(\"no-copy\", {\r\n                          \"xmlns\": NameSpacesLabels.HintsNameSpace\r\n                      }));\r\n                      // */\r\n                    //let nostoreTag=\"no-store\";\r\n                    let nostoreTag = that.messagesDataStore;\r\n                    stanza.append(xml(nostoreTag, {\r\n                        \"xmlns\": XMPPService_1.NameSpacesLabels.HintsNameSpace\r\n                    }));\r\n                    // */\r\n                    //that.logger.log(\"internal\", LOG_ID + \"(send) no-store stanza : \", stanza);\r\n                }\r\n                // test the rate-limit\r\n                if (this.nbMessagesSentThisHour > that.rateLimitPerHour) {\r\n                    let timeWhenRateLimitPerHourHappens = new Date().getTime();\r\n                    let timeToWaitBeforeNextMessageAvabilityMs = that.timeBetweenReset - (timeWhenRateLimitPerHourHappens - that.lastTimeReset.getTime());\r\n                    let error = {\r\n                        \"errorCode\": -1,\r\n                        \"timeWhenRateLimitPerHourHappens\": timeWhenRateLimitPerHourHappens,\r\n                        \"nbMessagesSentThisHour\": this.nbMessagesSentThisHour,\r\n                        \"rateLimitPerHour\": that.rateLimitPerHour,\r\n                        \"timeToWaitBeforeNextMessageAvabilityMs\": timeToWaitBeforeNextMessageAvabilityMs,\r\n                        \"label\": \"error number of sent messages is over the rate limit.\",\r\n                        \"sendArgs\": args\r\n                    };\r\n                    that.logger.log(\"internalerror\", LOG_ID + \"(send) error number of sent messages is over the rate limit : \", error);\r\n                    return reject2(error);\r\n                }\r\n                return this.client.send(...args).then(() => {\r\n                    that.nbMessagesSentThisHour++;\r\n                    resolve2();\r\n                }).catch((err) => __awaiter(this, void 0, void 0, function* () {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(send) _catch error_ at super.send\", err);\r\n                    //that.logger.log(\"debug\", LOG_ID + \"(send) restart the xmpp client\");\r\n                    return reject2(err);\r\n                    /*\r\n                    this.client.restart().finally(() => {\r\n                        reject2(err);\r\n                    });\r\n                    // */\r\n                }));\r\n            })).then(() => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(send) sent\");\r\n            }).catch((errr) => {\r\n                that.logger.log(\"error\", LOG_ID + \"(send) error in send promise : \", errr);\r\n                that.logger.log(\"internalerror\", LOG_ID + \"(send) error in send promise : \", errr);\r\n                throw errr;\r\n            });\r\n            // Wait a few time between requests to avoid burst with lot of it.\r\n            utils.setTimeoutPromised(that.timeBetweenXmppRequests).then(() => {\r\n                //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n                resolve(prom);\r\n            });\r\n            /*\r\n            // Wait a few time between requests to avoid burst with lot of it.\r\n            setTimeout(() => {\r\n                //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n                resolve(prom);\r\n            }, that.timeBetweenXmppRequests);\r\n            // */\r\n        }).then((promiseToreturn) => {\r\n            that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise\");\r\n            return promiseToreturn;\r\n        }).catch((err) => __awaiter(this, void 0, void 0, function* () {\r\n            that.logger.log(\"debug\", LOG_ID + \"(send) catch an error during sending! \", err);\r\n            // if the error is the exceed of maximum message by a time laps then do not reconnecte\r\n            if (err && err.errorCode === -1) {\r\n                //return Promise.resolve();\r\n                throw err;\r\n                //return ;\r\n            }\r\n            that.logger.log(\"debug\", LOG_ID + \"(send) restart the xmpp client\");\r\n            yield that.restartConnect().then((res) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(send) restartConnect result : \", res);\r\n            }).catch((errr) => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(send) restartConnect catch : \", errr);\r\n            });\r\n            /*\r\n            .then(() => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise with a throw error : \", err);\r\n                throw  err;\r\n            });\r\n            // */\r\n            /*\r\n            this.client.restart().finally(() => {\r\n                that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise with a throw error\");\r\n                throw  err;\r\n            }); */\r\n        }));\r\n    }\r\n    sendIq(...args) {\r\n        let that = this;\r\n        that.logger.log(\"debug\", LOG_ID + \"(send) _entering_\");\r\n        return new Promise((resolve) => {\r\n            if (args.length > 0) {\r\n                let prom = this.xmppQueue.addPromise(this.client.send(...args).catch((err) => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(send) _catch error_ at super.send\", err);\r\n                })).then(() => {\r\n                    that.logger.log(\"debug\", LOG_ID + \"(send) sent\");\r\n                });\r\n                // callback to be called when the IQ Get result event is received from server.\r\n                function cb(result) {\r\n                    // Wait a few time between requests to avoid burst with lot of it.\r\n                    setTimeout(() => {\r\n                        //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n                        resolve(prom.then(() => { return result; }));\r\n                    }, that.timeBetweenXmppRequests);\r\n                }\r\n                let idId = args[0].attrs.id;\r\n                // Store the promise to be resolved\r\n                this.iqGetEventWaiting[idId] = cb;\r\n                /* // Wait a few time between requests to avoid burst with lot of it.\r\n                setTimeout(()=> {\r\n                    //that.logger.log(\"debug\", LOG_ID + \"(send) setTimeout resolve\");\r\n                    resolve(prom);\r\n                }, that.timeBetweenXmppRequests); // */\r\n            }\r\n            else {\r\n                resolve(Promise.resolve());\r\n            }\r\n        }).then((promiseToreturn) => {\r\n            that.logger.log(\"debug\", LOG_ID + \"(send) _exiting_ return promise\");\r\n            return promiseToreturn;\r\n        });\r\n    }\r\n    /*handle(evt, cb) {\r\n        this.client.entity.handle(evt,  cb);\r\n    } // */\r\n    on(evt, cb) {\r\n        this.client.entity.on(evt, cb);\r\n    }\r\n    get sasl() {\r\n        return this.client.sasl;\r\n    }\r\n    setgetMechanism(cb) {\r\n        //this.client.sasl.findMechanism = cb;\r\n        //this.client.mechanisms = [\"PLAIN\"];\r\n    }\r\n    get reconnect() {\r\n        return this.client.reconnect;\r\n    }\r\n    /**\r\n     * @description\r\n     *  Do not use this method to reconnect. Use the @xmpp/reconnect pluging else (with the method XmppClient::reconnect).\r\n     *\r\n     * @returns {Promise<any>}\r\n     */\r\n    restartConnect() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let that = this;\r\n            that.logger.log(\"debug\", LOG_ID + \"(restartConnect) _entering_\");\r\n            if (this.restartConnectEnabled) {\r\n                //let result = await that.client.disconnect(5000);\r\n                //that.logger.log(\"debug\", LOG_ID + \"(restartConnect) disconnect result : \", result);\r\n                //return that.client.open(that.options);\r\n                yield that.client._reset();\r\n                yield that.client.start();\r\n            }\r\n            else {\r\n                return Promise.resolve(\"restartReconnect is disabled\");\r\n            }\r\n        });\r\n    }\r\n    start(...args) {\r\n        this.restartConnectEnabled = true;\r\n        return this.client.start(...args);\r\n    }\r\n    stop(...args) {\r\n        this.restartConnectEnabled = false;\r\n        return this.client.stop(...args);\r\n    }\r\n}\r\nfunction getXmppClient(...args) {\r\n    let xmppClient = new XmppClient(...args);\r\n    Object.assign(xmppClient, client());\r\n}\r\n// *************************************\r\n// Increase Element Behaviour\r\n// *************************************\r\n// Find elements of child by name\r\n// If none is found then an empty Element is return (to allow call of methods like text...)\r\n// If only one is found then return it, but with a length value to 1\r\n// If severals are found then return an Array with them\r\nElement.prototype.find = function (name) {\r\n    let result = new Element();\r\n    result.length = 0;\r\n    if (this instanceof Element && (this.getName ? this.getName() : this.name) == name) {\r\n        result = this;\r\n        result.length = 1;\r\n        return result;\r\n    }\r\n    let children = this.getChildrenByFilter((element) => {\r\n        let isInstanceOfElement = element instanceof Element;\r\n        let elmtName = element.getName ? element.getName() : element.name;\r\n        let isTheNameSearched = name === elmtName;\r\n        return isInstanceOfElement && isTheNameSearched;\r\n    }, true);\r\n    if (children.length === 1) {\r\n        result = children[0];\r\n        result.length = 1;\r\n    }\r\n    else if (children.length > 1) {\r\n        result = children;\r\n    }\r\n    return result;\r\n};\r\n// Shortcut to getText\r\nElement.prototype.text = function () {\r\n    return this.getText();\r\n};\r\n// Shortcut to attrs\r\nElement.prototype.attr = function (attrName) {\r\n    return this.attrs[attrName];\r\n};\r\nmodule.exports.getXmppClient = getXmppClient;\r\nmodule.exports.XmppClient = XmppClient;\r\n//# sourceMappingURL=XmppClient.js.map"]},"metadata":{},"sourceType":"script"}